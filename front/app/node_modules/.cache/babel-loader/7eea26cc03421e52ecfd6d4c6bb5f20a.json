{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar asyncLib = require(\"neo-async\");\n\nvar _require = require(\"tapable\"),\n    SyncHook = _require.SyncHook,\n    MultiHook = _require.MultiHook;\n\nvar ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\n\nvar MultiStats = require(\"./MultiStats\");\n\nvar MultiWatching = require(\"./MultiWatching\");\n\nvar ArrayQueue = require(\"./util/ArrayQueue\");\n/** @template T @typedef {import(\"tapable\").AsyncSeriesHook<T>} AsyncSeriesHook<T> */\n\n/** @template T @template R @typedef {import(\"tapable\").SyncBailHook<T, R>} SyncBailHook<T, R> */\n\n/** @typedef {import(\"../declarations/WebpackOptions\").WatchOptions} WatchOptions */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./Stats\")} Stats */\n\n/** @typedef {import(\"./Watching\")} Watching */\n\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n\n/** @typedef {import(\"./util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n\n/** @typedef {import(\"./util/fs\").WatchFileSystem} WatchFileSystem */\n\n/**\n * @template T\n * @callback Callback\n * @param {(Error | null)=} err\n * @param {T=} result\n */\n\n/**\n * @callback RunWithDependenciesHandler\n * @param {Compiler} compiler\n * @param {Callback<MultiStats>} callback\n */\n\n/**\n * @typedef {Object} MultiCompilerOptions\n * @property {number=} parallelism how many Compilers are allows to run at the same time in parallel\n */\n\n\nmodule.exports = /*#__PURE__*/function () {\n  /**\n   * @param {Compiler[] | Record<string, Compiler>} compilers child compilers\n   * @param {MultiCompilerOptions} options options\n   */\n  function MultiCompiler(compilers, options) {\n    var _this = this;\n\n    _classCallCheck(this, MultiCompiler);\n\n    if (!Array.isArray(compilers)) {\n      compilers = Object.keys(compilers).map(function (name) {\n        compilers[name].name = name;\n        return compilers[name];\n      });\n    }\n\n    this.hooks = Object.freeze({\n      /** @type {SyncHook<[MultiStats]>} */\n      done: new SyncHook([\"stats\"]),\n\n      /** @type {MultiHook<SyncHook<[string | null, number]>>} */\n      invalid: new MultiHook(compilers.map(function (c) {\n        return c.hooks.invalid;\n      })),\n\n      /** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n      run: new MultiHook(compilers.map(function (c) {\n        return c.hooks.run;\n      })),\n\n      /** @type {SyncHook<[]>} */\n      watchClose: new SyncHook([]),\n\n      /** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n      watchRun: new MultiHook(compilers.map(function (c) {\n        return c.hooks.watchRun;\n      })),\n\n      /** @type {MultiHook<SyncBailHook<[string, string, any[]], true>>} */\n      infrastructureLog: new MultiHook(compilers.map(function (c) {\n        return c.hooks.infrastructureLog;\n      }))\n    });\n    this.compilers = compilers;\n    /** @type {MultiCompilerOptions} */\n\n    this._options = {\n      parallelism: options.parallelism || Infinity\n    };\n    /** @type {WeakMap<Compiler, string[]>} */\n\n    this.dependencies = new WeakMap();\n    this.running = false;\n    /** @type {Stats[]} */\n\n    var compilerStats = this.compilers.map(function () {\n      return null;\n    });\n    var doneCompilers = 0;\n\n    var _loop = function _loop(index) {\n      var compiler = _this.compilers[index];\n      var compilerIndex = index;\n      var compilerDone = false;\n      compiler.hooks.done.tap(\"MultiCompiler\", function (stats) {\n        if (!compilerDone) {\n          compilerDone = true;\n          doneCompilers++;\n        }\n\n        compilerStats[compilerIndex] = stats;\n\n        if (doneCompilers === _this.compilers.length) {\n          _this.hooks.done.call(new MultiStats(compilerStats));\n        }\n      });\n      compiler.hooks.invalid.tap(\"MultiCompiler\", function () {\n        if (compilerDone) {\n          compilerDone = false;\n          doneCompilers--;\n        }\n      });\n    };\n\n    for (var index = 0; index < this.compilers.length; index++) {\n      _loop(index);\n    }\n  }\n\n  _createClass(MultiCompiler, [{\n    key: \"options\",\n    get: function get() {\n      return Object.assign(this.compilers.map(function (c) {\n        return c.options;\n      }), this._options);\n    }\n  }, {\n    key: \"outputPath\",\n    get: function get() {\n      var commonPath = this.compilers[0].outputPath;\n\n      var _iterator = _createForOfIteratorHelper(this.compilers),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var compiler = _step.value;\n\n          while (compiler.outputPath.indexOf(commonPath) !== 0 && /[/\\\\]/.test(commonPath)) {\n            commonPath = commonPath.replace(/[/\\\\][^/\\\\]*$/, \"\");\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (!commonPath && this.compilers[0].outputPath[0] === \"/\") return \"/\";\n      return commonPath;\n    }\n  }, {\n    key: \"inputFileSystem\",\n    get: function get() {\n      throw new Error(\"Cannot read inputFileSystem of a MultiCompiler\");\n    },\n    set:\n    /**\n     * @param {InputFileSystem} value the new input file system\n     */\n    function set(value) {\n      var _iterator2 = _createForOfIteratorHelper(this.compilers),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var compiler = _step2.value;\n          compiler.inputFileSystem = value;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    /**\n     * @param {OutputFileSystem} value the new output file system\n     */\n\n  }, {\n    key: \"outputFileSystem\",\n    get: function get() {\n      throw new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n    },\n    set: function set(value) {\n      var _iterator3 = _createForOfIteratorHelper(this.compilers),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var compiler = _step3.value;\n          compiler.outputFileSystem = value;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n    /**\n     * @param {WatchFileSystem} value the new watch file system\n     */\n\n  }, {\n    key: \"watchFileSystem\",\n    get: function get() {\n      throw new Error(\"Cannot read watchFileSystem of a MultiCompiler\");\n    },\n    set: function set(value) {\n      var _iterator4 = _createForOfIteratorHelper(this.compilers),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var compiler = _step4.value;\n          compiler.watchFileSystem = value;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n    /**\n     * @param {IntermediateFileSystem} value the new intermediate file system\n     */\n\n  }, {\n    key: \"intermediateFileSystem\",\n    get: function get() {\n      throw new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n    },\n    set: function set(value) {\n      var _iterator5 = _createForOfIteratorHelper(this.compilers),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var compiler = _step5.value;\n          compiler.intermediateFileSystem = value;\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  }, {\n    key: \"getInfrastructureLogger\",\n    value: function getInfrastructureLogger(name) {\n      return this.compilers[0].getInfrastructureLogger(name);\n    }\n    /**\n     * @param {Compiler} compiler the child compiler\n     * @param {string[]} dependencies its dependencies\n     * @returns {void}\n     */\n\n  }, {\n    key: \"setDependencies\",\n    value: function setDependencies(compiler, dependencies) {\n      this.dependencies.set(compiler, dependencies);\n    }\n    /**\n     * @param {Callback<MultiStats>} callback signals when the validation is complete\n     * @returns {boolean} true if the dependencies are valid\n     */\n\n  }, {\n    key: \"validateDependencies\",\n    value: function validateDependencies(callback) {\n      var _this2 = this;\n\n      /** @type {Set<{source: Compiler, target: Compiler}>} */\n      var edges = new Set();\n      /** @type {string[]} */\n\n      var missing = [];\n\n      var targetFound = function targetFound(compiler) {\n        var _iterator6 = _createForOfIteratorHelper(edges),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var edge = _step6.value;\n\n            if (edge.target === compiler) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n\n        return false;\n      };\n\n      var sortEdges = function sortEdges(e1, e2) {\n        return e1.source.name.localeCompare(e2.source.name) || e1.target.name.localeCompare(e2.target.name);\n      };\n\n      var _iterator7 = _createForOfIteratorHelper(this.compilers),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var source = _step7.value;\n          var dependencies = this.dependencies.get(source);\n\n          if (dependencies) {\n            var _iterator9 = _createForOfIteratorHelper(dependencies),\n                _step9;\n\n            try {\n              var _loop2 = function _loop2() {\n                var dep = _step9.value;\n\n                var target = _this2.compilers.find(function (c) {\n                  return c.name === dep;\n                });\n\n                if (!target) {\n                  missing.push(dep);\n                } else {\n                  edges.add({\n                    source: source,\n                    target: target\n                  });\n                }\n              };\n\n              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                _loop2();\n              }\n            } catch (err) {\n              _iterator9.e(err);\n            } finally {\n              _iterator9.f();\n            }\n          }\n        }\n        /** @type {string[]} */\n\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      var errors = missing.map(function (m) {\n        return \"Compiler dependency `\".concat(m, \"` not found.\");\n      });\n      var stack = this.compilers.filter(function (c) {\n        return !targetFound(c);\n      });\n\n      while (stack.length > 0) {\n        var current = stack.pop();\n\n        var _iterator8 = _createForOfIteratorHelper(edges),\n            _step8;\n\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var edge = _step8.value;\n\n            if (edge.source === current) {\n              edges.delete(edge);\n              var target = edge.target;\n\n              if (!targetFound(target)) {\n                stack.push(target);\n              }\n            }\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n      }\n\n      if (edges.size > 0) {\n        /** @type {string[]} */\n        var lines = Array.from(edges).sort(sortEdges).map(function (edge) {\n          return \"\".concat(edge.source.name, \" -> \").concat(edge.target.name);\n        });\n        lines.unshift(\"Circular dependency found in compiler dependencies.\");\n        errors.unshift(lines.join(\"\\n\"));\n      }\n\n      if (errors.length > 0) {\n        var message = errors.join(\"\\n\");\n        callback(new Error(message));\n        return false;\n      }\n\n      return true;\n    } // TODO webpack 6 remove\n\n    /**\n     * @deprecated This method should have been private\n     * @param {Compiler[]} compilers the child compilers\n     * @param {RunWithDependenciesHandler} fn a handler to run for each compiler\n     * @param {Callback<MultiStats>} callback the compiler's handler\n     * @returns {void}\n     */\n\n  }, {\n    key: \"runWithDependencies\",\n    value: function runWithDependencies(compilers, fn, callback) {\n      var _this3 = this;\n\n      var fulfilledNames = new Set();\n      var remainingCompilers = compilers;\n\n      var isDependencyFulfilled = function isDependencyFulfilled(d) {\n        return fulfilledNames.has(d);\n      };\n\n      var getReadyCompilers = function getReadyCompilers() {\n        var readyCompilers = [];\n        var list = remainingCompilers;\n        remainingCompilers = [];\n\n        var _iterator10 = _createForOfIteratorHelper(list),\n            _step10;\n\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var c = _step10.value;\n\n            var dependencies = _this3.dependencies.get(c);\n\n            var ready = !dependencies || dependencies.every(isDependencyFulfilled);\n\n            if (ready) {\n              readyCompilers.push(c);\n            } else {\n              remainingCompilers.push(c);\n            }\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n\n        return readyCompilers;\n      };\n\n      var runCompilers = function runCompilers(callback) {\n        if (remainingCompilers.length === 0) return callback();\n        asyncLib.map(getReadyCompilers(), function (compiler, callback) {\n          fn(compiler, function (err) {\n            if (err) return callback(err);\n            fulfilledNames.add(compiler.name);\n            runCompilers(callback);\n          });\n        }, callback);\n      };\n\n      runCompilers(callback);\n    }\n    /**\n     * @template SetupResult\n     * @param {function(Compiler, number, Callback<Stats>, function(): boolean, function(): void, function(): void): SetupResult} setup setup a single compiler\n     * @param {function(Compiler, SetupResult, Callback<Stats>): void} run run/continue a single compiler\n     * @param {Callback<MultiStats>} callback callback when all compilers are done, result includes Stats of all changed compilers\n     * @returns {SetupResult[]} result of setup\n     */\n\n  }, {\n    key: \"_runGraph\",\n    value: function _runGraph(setup, run, callback) {\n      /** @typedef {{ compiler: Compiler, setupResult: SetupResult, result: Stats, state: \"pending\" | \"blocked\" | \"queued\" | \"starting\" | \"running\" | \"running-outdated\" | \"done\", children: Node[], parents: Node[] }} Node */\n      // State transitions for nodes:\n      // -> blocked (initial)\n      // blocked -> starting [running++] (when all parents done)\n      // queued -> starting [running++] (when processing the queue)\n      // starting -> running (when run has been called)\n      // running -> done [running--] (when compilation is done)\n      // done -> pending (when invalidated from file change)\n      // pending -> blocked [add to queue] (when invalidated from aggregated changes)\n      // done -> blocked [add to queue] (when invalidated, from parent invalidation)\n      // running -> running-outdated (when invalidated, either from change or parent invalidation)\n      // running-outdated -> blocked [running--] (when compilation is done)\n\n      /** @type {Node[]} */\n      var nodes = this.compilers.map(function (compiler) {\n        return {\n          compiler: compiler,\n          setupResult: undefined,\n          result: undefined,\n          state: \"blocked\",\n          children: [],\n          parents: []\n        };\n      });\n      /** @type {Map<string, Node>} */\n\n      var compilerToNode = new Map();\n\n      var _iterator11 = _createForOfIteratorHelper(nodes),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var node = _step11.value;\n          compilerToNode.set(node.compiler.name, node);\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n\n      var _iterator12 = _createForOfIteratorHelper(nodes),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var _node2 = _step12.value;\n          var dependencies = this.dependencies.get(_node2.compiler);\n          if (!dependencies) continue;\n\n          var _iterator18 = _createForOfIteratorHelper(dependencies),\n              _step18;\n\n          try {\n            for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n              var dep = _step18.value;\n              var parent = compilerToNode.get(dep);\n\n              _node2.parents.push(parent);\n\n              parent.children.push(_node2);\n            }\n          } catch (err) {\n            _iterator18.e(err);\n          } finally {\n            _iterator18.f();\n          }\n        }\n        /** @type {ArrayQueue<Node>} */\n\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n\n      var queue = new ArrayQueue();\n\n      var _iterator13 = _createForOfIteratorHelper(nodes),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var _node3 = _step13.value;\n\n          if (_node3.parents.length === 0) {\n            _node3.state = \"queued\";\n            queue.enqueue(_node3);\n          }\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n\n      var errored = false;\n      var running = 0;\n      var parallelism = this._options.parallelism;\n      /**\n       * @param {Node} node node\n       * @param {Error=} err error\n       * @param {Stats=} stats result\n       * @returns {void}\n       */\n\n      var nodeDone = function nodeDone(node, err, stats) {\n        if (errored) return;\n\n        if (err) {\n          errored = true;\n          return asyncLib.each(nodes, function (node, callback) {\n            if (node.compiler.watching) {\n              node.compiler.watching.close(callback);\n            } else {\n              callback();\n            }\n          }, function () {\n            return callback(err);\n          });\n        }\n\n        node.result = stats;\n        running--;\n\n        if (node.state === \"running\") {\n          node.state = \"done\";\n\n          var _iterator14 = _createForOfIteratorHelper(node.children),\n              _step14;\n\n          try {\n            for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n              var child = _step14.value;\n              if (child.state === \"blocked\") queue.enqueue(child);\n            }\n          } catch (err) {\n            _iterator14.e(err);\n          } finally {\n            _iterator14.f();\n          }\n        } else if (node.state === \"running-outdated\") {\n          node.state = \"blocked\";\n          queue.enqueue(node);\n        }\n\n        processQueue();\n      };\n      /**\n       * @param {Node} node node\n       * @returns {void}\n       */\n\n\n      var nodeInvalidFromParent = function nodeInvalidFromParent(node) {\n        if (node.state === \"done\") {\n          node.state = \"blocked\";\n        } else if (node.state === \"running\") {\n          node.state = \"running-outdated\";\n        }\n\n        var _iterator15 = _createForOfIteratorHelper(node.children),\n            _step15;\n\n        try {\n          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n            var child = _step15.value;\n            nodeInvalidFromParent(child);\n          }\n        } catch (err) {\n          _iterator15.e(err);\n        } finally {\n          _iterator15.f();\n        }\n      };\n      /**\n       * @param {Node} node node\n       * @returns {void}\n       */\n\n\n      var nodeInvalid = function nodeInvalid(node) {\n        if (node.state === \"done\") {\n          node.state = \"pending\";\n        } else if (node.state === \"running\") {\n          node.state = \"running-outdated\";\n        }\n\n        var _iterator16 = _createForOfIteratorHelper(node.children),\n            _step16;\n\n        try {\n          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n            var child = _step16.value;\n            nodeInvalidFromParent(child);\n          }\n        } catch (err) {\n          _iterator16.e(err);\n        } finally {\n          _iterator16.f();\n        }\n      };\n      /**\n       * @param {Node} node node\n       * @returns {void}\n       */\n\n\n      var nodeChange = function nodeChange(node) {\n        nodeInvalid(node);\n\n        if (node.state === \"pending\") {\n          node.state = \"blocked\";\n        }\n\n        if (node.state === \"blocked\") {\n          queue.enqueue(node);\n          processQueue();\n        }\n      };\n\n      var setupResults = [];\n      nodes.forEach(function (node, i) {\n        setupResults.push(node.setupResult = setup(node.compiler, i, nodeDone.bind(null, node), function () {\n          return node.state !== \"starting\" && node.state !== \"running\";\n        }, function () {\n          return nodeChange(node);\n        }, function () {\n          return nodeInvalid(node);\n        }));\n      });\n      var processing = true;\n\n      var processQueue = function processQueue() {\n        if (processing) return;\n        processing = true;\n        process.nextTick(processQueueWorker);\n      };\n\n      var processQueueWorker = function processQueueWorker() {\n        while (running < parallelism && queue.length > 0 && !errored) {\n          var node = queue.dequeue();\n\n          if (node.state === \"queued\" || node.state === \"blocked\" && node.parents.every(function (p) {\n            return p.state === \"done\";\n          })) {\n            running++;\n            node.state = \"starting\";\n            run(node.compiler, node.setupResult, nodeDone.bind(null, node));\n            node.state = \"running\";\n          }\n        }\n\n        processing = false;\n\n        if (!errored && running === 0 && nodes.every(function (node) {\n          return node.state === \"done\";\n        })) {\n          var stats = [];\n\n          var _iterator17 = _createForOfIteratorHelper(nodes),\n              _step17;\n\n          try {\n            for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n              var _node = _step17.value;\n              var result = _node.result;\n\n              if (result) {\n                _node.result = undefined;\n                stats.push(result);\n              }\n            }\n          } catch (err) {\n            _iterator17.e(err);\n          } finally {\n            _iterator17.f();\n          }\n\n          if (stats.length > 0) {\n            callback(null, new MultiStats(stats));\n          }\n        }\n      };\n\n      processQueueWorker();\n      return setupResults;\n    }\n    /**\n     * @param {WatchOptions|WatchOptions[]} watchOptions the watcher's options\n     * @param {Callback<MultiStats>} handler signals when the call finishes\n     * @returns {MultiWatching} a compiler watcher\n     */\n\n  }, {\n    key: \"watch\",\n    value: function watch(watchOptions, handler) {\n      if (this.running) {\n        return handler(new ConcurrentCompilationError());\n      }\n\n      this.running = true;\n\n      if (this.validateDependencies(handler)) {\n        var watchings = this._runGraph(function (compiler, idx, callback, isBlocked, setChanged, setInvalid) {\n          var watching = compiler.watch(Array.isArray(watchOptions) ? watchOptions[idx] : watchOptions, callback);\n\n          if (watching) {\n            watching._onInvalid = setInvalid;\n            watching._onChange = setChanged;\n            watching._isBlocked = isBlocked;\n          }\n\n          return watching;\n        }, function (compiler, watching, callback) {\n          if (compiler.watching !== watching) return;\n          if (!watching.running) watching.invalidate();\n        }, handler);\n\n        return new MultiWatching(watchings, this);\n      }\n\n      return new MultiWatching([], this);\n    }\n    /**\n     * @param {Callback<MultiStats>} callback signals when the call finishes\n     * @returns {void}\n     */\n\n  }, {\n    key: \"run\",\n    value: function run(callback) {\n      var _this4 = this;\n\n      if (this.running) {\n        return callback(new ConcurrentCompilationError());\n      }\n\n      this.running = true;\n\n      if (this.validateDependencies(callback)) {\n        this._runGraph(function () {}, function (compiler, setupResult, callback) {\n          return compiler.run(callback);\n        }, function (err, stats) {\n          _this4.running = false;\n\n          if (callback !== undefined) {\n            return callback(err, stats);\n          }\n        });\n      }\n    }\n  }, {\n    key: \"purgeInputFileSystem\",\n    value: function purgeInputFileSystem() {\n      var _iterator19 = _createForOfIteratorHelper(this.compilers),\n          _step19;\n\n      try {\n        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n          var compiler = _step19.value;\n\n          if (compiler.inputFileSystem && compiler.inputFileSystem.purge) {\n            compiler.inputFileSystem.purge();\n          }\n        }\n      } catch (err) {\n        _iterator19.e(err);\n      } finally {\n        _iterator19.f();\n      }\n    }\n    /**\n     * @param {Callback<void>} callback signals when the compiler closes\n     * @returns {void}\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(callback) {\n      asyncLib.each(this.compilers, function (compiler, callback) {\n        compiler.close(callback);\n      }, callback);\n    }\n  }]);\n\n  return MultiCompiler;\n}();","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/MultiCompiler.js"],"names":["asyncLib","require","SyncHook","MultiHook","ConcurrentCompilationError","MultiStats","MultiWatching","ArrayQueue","module","exports","compilers","options","Array","isArray","Object","keys","map","name","hooks","freeze","done","invalid","c","run","watchClose","watchRun","infrastructureLog","_options","parallelism","Infinity","dependencies","WeakMap","running","compilerStats","doneCompilers","index","compiler","compilerIndex","compilerDone","tap","stats","length","call","assign","commonPath","outputPath","indexOf","test","replace","Error","value","inputFileSystem","outputFileSystem","watchFileSystem","intermediateFileSystem","getInfrastructureLogger","set","callback","edges","Set","missing","targetFound","edge","target","sortEdges","e1","e2","source","localeCompare","get","dep","find","push","add","errors","m","stack","filter","current","pop","delete","size","lines","from","sort","unshift","join","message","fn","fulfilledNames","remainingCompilers","isDependencyFulfilled","d","has","getReadyCompilers","readyCompilers","list","ready","every","runCompilers","err","setup","nodes","setupResult","undefined","result","state","children","parents","compilerToNode","Map","node","parent","queue","enqueue","errored","nodeDone","each","watching","close","child","processQueue","nodeInvalidFromParent","nodeInvalid","nodeChange","setupResults","forEach","i","bind","processing","process","nextTick","processQueueWorker","dequeue","p","watchOptions","handler","validateDependencies","watchings","_runGraph","idx","isBlocked","setChanged","setInvalid","watch","_onInvalid","_onChange","_isBlocked","invalidate","purge"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst { SyncHook, MultiHook } = require(\"tapable\");\n\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\nconst MultiStats = require(\"./MultiStats\");\nconst MultiWatching = require(\"./MultiWatching\");\nconst ArrayQueue = require(\"./util/ArrayQueue\");\n\n/** @template T @typedef {import(\"tapable\").AsyncSeriesHook<T>} AsyncSeriesHook<T> */\n/** @template T @template R @typedef {import(\"tapable\").SyncBailHook<T, R>} SyncBailHook<T, R> */\n/** @typedef {import(\"../declarations/WebpackOptions\").WatchOptions} WatchOptions */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Stats\")} Stats */\n/** @typedef {import(\"./Watching\")} Watching */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n/** @typedef {import(\"./util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n/** @typedef {import(\"./util/fs\").WatchFileSystem} WatchFileSystem */\n\n/**\n * @template T\n * @callback Callback\n * @param {(Error | null)=} err\n * @param {T=} result\n */\n\n/**\n * @callback RunWithDependenciesHandler\n * @param {Compiler} compiler\n * @param {Callback<MultiStats>} callback\n */\n\n/**\n * @typedef {Object} MultiCompilerOptions\n * @property {number=} parallelism how many Compilers are allows to run at the same time in parallel\n */\n\nmodule.exports = class MultiCompiler {\n\t/**\n\t * @param {Compiler[] | Record<string, Compiler>} compilers child compilers\n\t * @param {MultiCompilerOptions} options options\n\t */\n\tconstructor(compilers, options) {\n\t\tif (!Array.isArray(compilers)) {\n\t\t\tcompilers = Object.keys(compilers).map(name => {\n\t\t\t\tcompilers[name].name = name;\n\t\t\t\treturn compilers[name];\n\t\t\t});\n\t\t}\n\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {SyncHook<[MultiStats]>} */\n\t\t\tdone: new SyncHook([\"stats\"]),\n\t\t\t/** @type {MultiHook<SyncHook<[string | null, number]>>} */\n\t\t\tinvalid: new MultiHook(compilers.map(c => c.hooks.invalid)),\n\t\t\t/** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n\t\t\trun: new MultiHook(compilers.map(c => c.hooks.run)),\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\twatchClose: new SyncHook([]),\n\t\t\t/** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n\t\t\twatchRun: new MultiHook(compilers.map(c => c.hooks.watchRun)),\n\t\t\t/** @type {MultiHook<SyncBailHook<[string, string, any[]], true>>} */\n\t\t\tinfrastructureLog: new MultiHook(\n\t\t\t\tcompilers.map(c => c.hooks.infrastructureLog)\n\t\t\t)\n\t\t});\n\t\tthis.compilers = compilers;\n\t\t/** @type {MultiCompilerOptions} */\n\t\tthis._options = {\n\t\t\tparallelism: options.parallelism || Infinity\n\t\t};\n\t\t/** @type {WeakMap<Compiler, string[]>} */\n\t\tthis.dependencies = new WeakMap();\n\t\tthis.running = false;\n\n\t\t/** @type {Stats[]} */\n\t\tconst compilerStats = this.compilers.map(() => null);\n\t\tlet doneCompilers = 0;\n\t\tfor (let index = 0; index < this.compilers.length; index++) {\n\t\t\tconst compiler = this.compilers[index];\n\t\t\tconst compilerIndex = index;\n\t\t\tlet compilerDone = false;\n\t\t\tcompiler.hooks.done.tap(\"MultiCompiler\", stats => {\n\t\t\t\tif (!compilerDone) {\n\t\t\t\t\tcompilerDone = true;\n\t\t\t\t\tdoneCompilers++;\n\t\t\t\t}\n\t\t\t\tcompilerStats[compilerIndex] = stats;\n\t\t\t\tif (doneCompilers === this.compilers.length) {\n\t\t\t\t\tthis.hooks.done.call(new MultiStats(compilerStats));\n\t\t\t\t}\n\t\t\t});\n\t\t\tcompiler.hooks.invalid.tap(\"MultiCompiler\", () => {\n\t\t\t\tif (compilerDone) {\n\t\t\t\t\tcompilerDone = false;\n\t\t\t\t\tdoneCompilers--;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tget options() {\n\t\treturn Object.assign(\n\t\t\tthis.compilers.map(c => c.options),\n\t\t\tthis._options\n\t\t);\n\t}\n\n\tget outputPath() {\n\t\tlet commonPath = this.compilers[0].outputPath;\n\t\tfor (const compiler of this.compilers) {\n\t\t\twhile (\n\t\t\t\tcompiler.outputPath.indexOf(commonPath) !== 0 &&\n\t\t\t\t/[/\\\\]/.test(commonPath)\n\t\t\t) {\n\t\t\t\tcommonPath = commonPath.replace(/[/\\\\][^/\\\\]*$/, \"\");\n\t\t\t}\n\t\t}\n\n\t\tif (!commonPath && this.compilers[0].outputPath[0] === \"/\") return \"/\";\n\t\treturn commonPath;\n\t}\n\n\tget inputFileSystem() {\n\t\tthrow new Error(\"Cannot read inputFileSystem of a MultiCompiler\");\n\t}\n\n\tget outputFileSystem() {\n\t\tthrow new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n\t}\n\n\tget watchFileSystem() {\n\t\tthrow new Error(\"Cannot read watchFileSystem of a MultiCompiler\");\n\t}\n\n\tget intermediateFileSystem() {\n\t\tthrow new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n\t}\n\n\t/**\n\t * @param {InputFileSystem} value the new input file system\n\t */\n\tset inputFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.inputFileSystem = value;\n\t\t}\n\t}\n\n\t/**\n\t * @param {OutputFileSystem} value the new output file system\n\t */\n\tset outputFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.outputFileSystem = value;\n\t\t}\n\t}\n\n\t/**\n\t * @param {WatchFileSystem} value the new watch file system\n\t */\n\tset watchFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.watchFileSystem = value;\n\t\t}\n\t}\n\n\t/**\n\t * @param {IntermediateFileSystem} value the new intermediate file system\n\t */\n\tset intermediateFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.intermediateFileSystem = value;\n\t\t}\n\t}\n\n\tgetInfrastructureLogger(name) {\n\t\treturn this.compilers[0].getInfrastructureLogger(name);\n\t}\n\n\t/**\n\t * @param {Compiler} compiler the child compiler\n\t * @param {string[]} dependencies its dependencies\n\t * @returns {void}\n\t */\n\tsetDependencies(compiler, dependencies) {\n\t\tthis.dependencies.set(compiler, dependencies);\n\t}\n\n\t/**\n\t * @param {Callback<MultiStats>} callback signals when the validation is complete\n\t * @returns {boolean} true if the dependencies are valid\n\t */\n\tvalidateDependencies(callback) {\n\t\t/** @type {Set<{source: Compiler, target: Compiler}>} */\n\t\tconst edges = new Set();\n\t\t/** @type {string[]} */\n\t\tconst missing = [];\n\t\tconst targetFound = compiler => {\n\t\t\tfor (const edge of edges) {\n\t\t\t\tif (edge.target === compiler) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tconst sortEdges = (e1, e2) => {\n\t\t\treturn (\n\t\t\t\te1.source.name.localeCompare(e2.source.name) ||\n\t\t\t\te1.target.name.localeCompare(e2.target.name)\n\t\t\t);\n\t\t};\n\t\tfor (const source of this.compilers) {\n\t\t\tconst dependencies = this.dependencies.get(source);\n\t\t\tif (dependencies) {\n\t\t\t\tfor (const dep of dependencies) {\n\t\t\t\t\tconst target = this.compilers.find(c => c.name === dep);\n\t\t\t\t\tif (!target) {\n\t\t\t\t\t\tmissing.push(dep);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tedges.add({\n\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\ttarget\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/** @type {string[]} */\n\t\tconst errors = missing.map(m => `Compiler dependency \\`${m}\\` not found.`);\n\t\tconst stack = this.compilers.filter(c => !targetFound(c));\n\t\twhile (stack.length > 0) {\n\t\t\tconst current = stack.pop();\n\t\t\tfor (const edge of edges) {\n\t\t\t\tif (edge.source === current) {\n\t\t\t\t\tedges.delete(edge);\n\t\t\t\t\tconst target = edge.target;\n\t\t\t\t\tif (!targetFound(target)) {\n\t\t\t\t\t\tstack.push(target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (edges.size > 0) {\n\t\t\t/** @type {string[]} */\n\t\t\tconst lines = Array.from(edges)\n\t\t\t\t.sort(sortEdges)\n\t\t\t\t.map(edge => `${edge.source.name} -> ${edge.target.name}`);\n\t\t\tlines.unshift(\"Circular dependency found in compiler dependencies.\");\n\t\t\terrors.unshift(lines.join(\"\\n\"));\n\t\t}\n\t\tif (errors.length > 0) {\n\t\t\tconst message = errors.join(\"\\n\");\n\t\t\tcallback(new Error(message));\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t// TODO webpack 6 remove\n\t/**\n\t * @deprecated This method should have been private\n\t * @param {Compiler[]} compilers the child compilers\n\t * @param {RunWithDependenciesHandler} fn a handler to run for each compiler\n\t * @param {Callback<MultiStats>} callback the compiler's handler\n\t * @returns {void}\n\t */\n\trunWithDependencies(compilers, fn, callback) {\n\t\tconst fulfilledNames = new Set();\n\t\tlet remainingCompilers = compilers;\n\t\tconst isDependencyFulfilled = d => fulfilledNames.has(d);\n\t\tconst getReadyCompilers = () => {\n\t\t\tlet readyCompilers = [];\n\t\t\tlet list = remainingCompilers;\n\t\t\tremainingCompilers = [];\n\t\t\tfor (const c of list) {\n\t\t\t\tconst dependencies = this.dependencies.get(c);\n\t\t\t\tconst ready =\n\t\t\t\t\t!dependencies || dependencies.every(isDependencyFulfilled);\n\t\t\t\tif (ready) {\n\t\t\t\t\treadyCompilers.push(c);\n\t\t\t\t} else {\n\t\t\t\t\tremainingCompilers.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn readyCompilers;\n\t\t};\n\t\tconst runCompilers = callback => {\n\t\t\tif (remainingCompilers.length === 0) return callback();\n\t\t\tasyncLib.map(\n\t\t\t\tgetReadyCompilers(),\n\t\t\t\t(compiler, callback) => {\n\t\t\t\t\tfn(compiler, err => {\n\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\tfulfilledNames.add(compiler.name);\n\t\t\t\t\t\trunCompilers(callback);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tcallback\n\t\t\t);\n\t\t};\n\t\trunCompilers(callback);\n\t}\n\n\t/**\n\t * @template SetupResult\n\t * @param {function(Compiler, number, Callback<Stats>, function(): boolean, function(): void, function(): void): SetupResult} setup setup a single compiler\n\t * @param {function(Compiler, SetupResult, Callback<Stats>): void} run run/continue a single compiler\n\t * @param {Callback<MultiStats>} callback callback when all compilers are done, result includes Stats of all changed compilers\n\t * @returns {SetupResult[]} result of setup\n\t */\n\t_runGraph(setup, run, callback) {\n\t\t/** @typedef {{ compiler: Compiler, setupResult: SetupResult, result: Stats, state: \"pending\" | \"blocked\" | \"queued\" | \"starting\" | \"running\" | \"running-outdated\" | \"done\", children: Node[], parents: Node[] }} Node */\n\n\t\t// State transitions for nodes:\n\t\t// -> blocked (initial)\n\t\t// blocked -> starting [running++] (when all parents done)\n\t\t// queued -> starting [running++] (when processing the queue)\n\t\t// starting -> running (when run has been called)\n\t\t// running -> done [running--] (when compilation is done)\n\t\t// done -> pending (when invalidated from file change)\n\t\t// pending -> blocked [add to queue] (when invalidated from aggregated changes)\n\t\t// done -> blocked [add to queue] (when invalidated, from parent invalidation)\n\t\t// running -> running-outdated (when invalidated, either from change or parent invalidation)\n\t\t// running-outdated -> blocked [running--] (when compilation is done)\n\n\t\t/** @type {Node[]} */\n\t\tconst nodes = this.compilers.map(compiler => ({\n\t\t\tcompiler,\n\t\t\tsetupResult: undefined,\n\t\t\tresult: undefined,\n\t\t\tstate: \"blocked\",\n\t\t\tchildren: [],\n\t\t\tparents: []\n\t\t}));\n\t\t/** @type {Map<string, Node>} */\n\t\tconst compilerToNode = new Map();\n\t\tfor (const node of nodes) compilerToNode.set(node.compiler.name, node);\n\t\tfor (const node of nodes) {\n\t\t\tconst dependencies = this.dependencies.get(node.compiler);\n\t\t\tif (!dependencies) continue;\n\t\t\tfor (const dep of dependencies) {\n\t\t\t\tconst parent = compilerToNode.get(dep);\n\t\t\t\tnode.parents.push(parent);\n\t\t\t\tparent.children.push(node);\n\t\t\t}\n\t\t}\n\t\t/** @type {ArrayQueue<Node>} */\n\t\tconst queue = new ArrayQueue();\n\t\tfor (const node of nodes) {\n\t\t\tif (node.parents.length === 0) {\n\t\t\t\tnode.state = \"queued\";\n\t\t\t\tqueue.enqueue(node);\n\t\t\t}\n\t\t}\n\t\tlet errored = false;\n\t\tlet running = 0;\n\t\tconst parallelism = this._options.parallelism;\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @param {Error=} err error\n\t\t * @param {Stats=} stats result\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeDone = (node, err, stats) => {\n\t\t\tif (errored) return;\n\t\t\tif (err) {\n\t\t\t\terrored = true;\n\t\t\t\treturn asyncLib.each(\n\t\t\t\t\tnodes,\n\t\t\t\t\t(node, callback) => {\n\t\t\t\t\t\tif (node.compiler.watching) {\n\t\t\t\t\t\t\tnode.compiler.watching.close(callback);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t() => callback(err)\n\t\t\t\t);\n\t\t\t}\n\t\t\tnode.result = stats;\n\t\t\trunning--;\n\t\t\tif (node.state === \"running\") {\n\t\t\t\tnode.state = \"done\";\n\t\t\t\tfor (const child of node.children) {\n\t\t\t\t\tif (child.state === \"blocked\") queue.enqueue(child);\n\t\t\t\t}\n\t\t\t} else if (node.state === \"running-outdated\") {\n\t\t\t\tnode.state = \"blocked\";\n\t\t\t\tqueue.enqueue(node);\n\t\t\t}\n\t\t\tprocessQueue();\n\t\t};\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeInvalidFromParent = node => {\n\t\t\tif (node.state === \"done\") {\n\t\t\t\tnode.state = \"blocked\";\n\t\t\t} else if (node.state === \"running\") {\n\t\t\t\tnode.state = \"running-outdated\";\n\t\t\t}\n\t\t\tfor (const child of node.children) {\n\t\t\t\tnodeInvalidFromParent(child);\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeInvalid = node => {\n\t\t\tif (node.state === \"done\") {\n\t\t\t\tnode.state = \"pending\";\n\t\t\t} else if (node.state === \"running\") {\n\t\t\t\tnode.state = \"running-outdated\";\n\t\t\t}\n\t\t\tfor (const child of node.children) {\n\t\t\t\tnodeInvalidFromParent(child);\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeChange = node => {\n\t\t\tnodeInvalid(node);\n\t\t\tif (node.state === \"pending\") {\n\t\t\t\tnode.state = \"blocked\";\n\t\t\t}\n\t\t\tif (node.state === \"blocked\") {\n\t\t\t\tqueue.enqueue(node);\n\t\t\t\tprocessQueue();\n\t\t\t}\n\t\t};\n\n\t\tconst setupResults = [];\n\t\tnodes.forEach((node, i) => {\n\t\t\tsetupResults.push(\n\t\t\t\t(node.setupResult = setup(\n\t\t\t\t\tnode.compiler,\n\t\t\t\t\ti,\n\t\t\t\t\tnodeDone.bind(null, node),\n\t\t\t\t\t() => node.state !== \"starting\" && node.state !== \"running\",\n\t\t\t\t\t() => nodeChange(node),\n\t\t\t\t\t() => nodeInvalid(node)\n\t\t\t\t))\n\t\t\t);\n\t\t});\n\t\tlet processing = true;\n\t\tconst processQueue = () => {\n\t\t\tif (processing) return;\n\t\t\tprocessing = true;\n\t\t\tprocess.nextTick(processQueueWorker);\n\t\t};\n\t\tconst processQueueWorker = () => {\n\t\t\twhile (running < parallelism && queue.length > 0 && !errored) {\n\t\t\t\tconst node = queue.dequeue();\n\t\t\t\tif (\n\t\t\t\t\tnode.state === \"queued\" ||\n\t\t\t\t\t(node.state === \"blocked\" &&\n\t\t\t\t\t\tnode.parents.every(p => p.state === \"done\"))\n\t\t\t\t) {\n\t\t\t\t\trunning++;\n\t\t\t\t\tnode.state = \"starting\";\n\t\t\t\t\trun(node.compiler, node.setupResult, nodeDone.bind(null, node));\n\t\t\t\t\tnode.state = \"running\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tprocessing = false;\n\t\t\tif (\n\t\t\t\t!errored &&\n\t\t\t\trunning === 0 &&\n\t\t\t\tnodes.every(node => node.state === \"done\")\n\t\t\t) {\n\t\t\t\tconst stats = [];\n\t\t\t\tfor (const node of nodes) {\n\t\t\t\t\tconst result = node.result;\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tnode.result = undefined;\n\t\t\t\t\t\tstats.push(result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (stats.length > 0) {\n\t\t\t\t\tcallback(null, new MultiStats(stats));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tprocessQueueWorker();\n\t\treturn setupResults;\n\t}\n\n\t/**\n\t * @param {WatchOptions|WatchOptions[]} watchOptions the watcher's options\n\t * @param {Callback<MultiStats>} handler signals when the call finishes\n\t * @returns {MultiWatching} a compiler watcher\n\t */\n\twatch(watchOptions, handler) {\n\t\tif (this.running) {\n\t\t\treturn handler(new ConcurrentCompilationError());\n\t\t}\n\t\tthis.running = true;\n\n\t\tif (this.validateDependencies(handler)) {\n\t\t\tconst watchings = this._runGraph(\n\t\t\t\t(compiler, idx, callback, isBlocked, setChanged, setInvalid) => {\n\t\t\t\t\tconst watching = compiler.watch(\n\t\t\t\t\t\tArray.isArray(watchOptions) ? watchOptions[idx] : watchOptions,\n\t\t\t\t\t\tcallback\n\t\t\t\t\t);\n\t\t\t\t\tif (watching) {\n\t\t\t\t\t\twatching._onInvalid = setInvalid;\n\t\t\t\t\t\twatching._onChange = setChanged;\n\t\t\t\t\t\twatching._isBlocked = isBlocked;\n\t\t\t\t\t}\n\t\t\t\t\treturn watching;\n\t\t\t\t},\n\t\t\t\t(compiler, watching, callback) => {\n\t\t\t\t\tif (compiler.watching !== watching) return;\n\t\t\t\t\tif (!watching.running) watching.invalidate();\n\t\t\t\t},\n\t\t\t\thandler\n\t\t\t);\n\t\t\treturn new MultiWatching(watchings, this);\n\t\t}\n\n\t\treturn new MultiWatching([], this);\n\t}\n\n\t/**\n\t * @param {Callback<MultiStats>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\trun(callback) {\n\t\tif (this.running) {\n\t\t\treturn callback(new ConcurrentCompilationError());\n\t\t}\n\t\tthis.running = true;\n\n\t\tif (this.validateDependencies(callback)) {\n\t\t\tthis._runGraph(\n\t\t\t\t() => {},\n\t\t\t\t(compiler, setupResult, callback) => compiler.run(callback),\n\t\t\t\t(err, stats) => {\n\t\t\t\t\tthis.running = false;\n\n\t\t\t\t\tif (callback !== undefined) {\n\t\t\t\t\t\treturn callback(err, stats);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n\n\tpurgeInputFileSystem() {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tif (compiler.inputFileSystem && compiler.inputFileSystem.purge) {\n\t\t\t\tcompiler.inputFileSystem.purge();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the compiler closes\n\t * @returns {void}\n\t */\n\tclose(callback) {\n\t\tasyncLib.each(\n\t\t\tthis.compilers,\n\t\t\t(compiler, callback) => {\n\t\t\t\tcompiler.close(callback);\n\t\t\t},\n\t\t\tcallback\n\t\t);\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}