{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar _slicedToArray = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _asyncToGenerator = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _require = require(\"tapable\"),\n    SyncBailHook = _require.SyncBailHook;\n\nvar _require2 = require(\"webpack-sources\"),\n    RawSource = _require2.RawSource,\n    CachedSource = _require2.CachedSource,\n    CompatSource = _require2.CompatSource;\n\nvar Compilation = require(\"../Compilation\");\n\nvar WebpackError = require(\"../WebpackError\");\n\nvar _require3 = require(\"../util/comparators\"),\n    compareSelect = _require3.compareSelect,\n    compareStrings = _require3.compareStrings;\n\nvar createHash = require(\"../util/createHash\");\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n\nvar EMPTY_SET = new Set();\n\nvar addToList = function addToList(itemOrItems, list) {\n  if (Array.isArray(itemOrItems)) {\n    var _iterator = _createForOfIteratorHelper(itemOrItems),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var item = _step.value;\n        list.add(item);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } else if (itemOrItems) {\n    list.add(itemOrItems);\n  }\n};\n/**\n * @template T\n * @param {T[]} input list\n * @param {function(T): Buffer} fn map function\n * @returns {Buffer[]} buffers without duplicates\n */\n\n\nvar mapAndDeduplicateBuffers = function mapAndDeduplicateBuffers(input, fn) {\n  // Buffer.equals compares size first so this should be efficient enough\n  // If it becomes a performance problem we can use a map and group by size\n  // instead of looping over all assets.\n  var result = [];\n\n  var _iterator2 = _createForOfIteratorHelper(input),\n      _step2;\n\n  try {\n    outer: for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var value = _step2.value;\n      var buf = fn(value);\n\n      var _iterator3 = _createForOfIteratorHelper(result),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var other = _step3.value;\n          if (buf.equals(other)) continue outer;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      result.push(buf);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return result;\n};\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\n\n\nvar quoteMeta = function quoteMeta(str) {\n  return str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\nvar cachedSourceMap = new WeakMap();\n\nvar toCachedSource = function toCachedSource(source) {\n  if (source instanceof CachedSource) {\n    return source;\n  }\n\n  var entry = cachedSourceMap.get(source);\n  if (entry !== undefined) return entry;\n  var newSource = new CachedSource(CompatSource.from(source));\n  cachedSourceMap.set(source, newSource);\n  return newSource;\n};\n/**\n * @typedef {Object} AssetInfoForRealContentHash\n * @property {string} name\n * @property {AssetInfo} info\n * @property {Source} source\n * @property {RawSource | undefined} newSource\n * @property {RawSource | undefined} newSourceWithoutOwn\n * @property {string} content\n * @property {Set<string>} ownHashes\n * @property {Promise} contentComputePromise\n * @property {Promise} contentComputeWithoutOwnPromise\n * @property {Set<string>} referencedHashes\n * @property {Set<string>} hashes\n */\n\n/**\n * @typedef {Object} CompilationHooks\n * @property {SyncBailHook<[Buffer[], string], string>} updateHash\n */\n\n/** @type {WeakMap<Compilation, CompilationHooks>} */\n\n\nvar compilationHooksMap = new WeakMap();\n\nvar RealContentHashPlugin = /*#__PURE__*/function () {\n  function RealContentHashPlugin(_ref) {\n    var hashFunction = _ref.hashFunction,\n        hashDigest = _ref.hashDigest;\n\n    _classCallCheck(this, RealContentHashPlugin);\n\n    this._hashFunction = hashFunction;\n    this._hashDigest = hashDigest;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  _createClass(RealContentHashPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var _this = this;\n\n      compiler.hooks.compilation.tap(\"RealContentHashPlugin\", function (compilation) {\n        var cacheAnalyse = compilation.getCache(\"RealContentHashPlugin|analyse\");\n        var cacheGenerate = compilation.getCache(\"RealContentHashPlugin|generate\");\n        var hooks = RealContentHashPlugin.getCompilationHooks(compilation);\n        compilation.hooks.processAssets.tapPromise({\n          name: \"RealContentHashPlugin\",\n          stage: Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH\n        }, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n          var assets, assetsWithInfo, hashToAssets, _iterator4, _step4, _step4$value, source, info, name, cachedSource, content, hashes, data, _iterator11, _step11, hash, list, hashRegExp, getDependencies, hashInfo, hashesInOrder, _iterator9, _step9, _loop, _ret, hashToNewHash, getEtag, computeNewContent, computeNewContentWithoutOwn, comparator, _iterator10, _step10, _loop2;\n\n          return _regeneratorRuntime.wrap(function _callee5$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  assets = compilation.getAssets();\n                  /** @type {AssetInfoForRealContentHash[]} */\n\n                  assetsWithInfo = [];\n                  hashToAssets = new Map();\n                  _iterator4 = _createForOfIteratorHelper(assets);\n\n                  try {\n                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                      _step4$value = _step4.value, source = _step4$value.source, info = _step4$value.info, name = _step4$value.name;\n                      cachedSource = toCachedSource(source);\n                      content = cachedSource.source();\n                      /** @type {Set<string>} */\n\n                      hashes = new Set();\n                      addToList(info.contenthash, hashes);\n                      data = {\n                        name: name,\n                        info: info,\n                        source: cachedSource,\n\n                        /** @type {RawSource | undefined} */\n                        newSource: undefined,\n\n                        /** @type {RawSource | undefined} */\n                        newSourceWithoutOwn: undefined,\n                        content: content,\n\n                        /** @type {Set<string>} */\n                        ownHashes: undefined,\n                        contentComputePromise: undefined,\n                        contentComputeWithoutOwnPromise: undefined,\n\n                        /** @type {Set<string>} */\n                        referencedHashes: undefined,\n                        hashes: hashes\n                      };\n                      assetsWithInfo.push(data);\n                      _iterator11 = _createForOfIteratorHelper(hashes);\n\n                      try {\n                        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                          hash = _step11.value;\n                          list = hashToAssets.get(hash);\n\n                          if (list === undefined) {\n                            hashToAssets.set(hash, [data]);\n                          } else {\n                            list.push(data);\n                          }\n                        }\n                      } catch (err) {\n                        _iterator11.e(err);\n                      } finally {\n                        _iterator11.f();\n                      }\n                    }\n                  } catch (err) {\n                    _iterator4.e(err);\n                  } finally {\n                    _iterator4.f();\n                  }\n\n                  if (!(hashToAssets.size === 0)) {\n                    _context6.next = 7;\n                    break;\n                  }\n\n                  return _context6.abrupt(\"return\");\n\n                case 7:\n                  hashRegExp = new RegExp(Array.from(hashToAssets.keys(), quoteMeta).join(\"|\"), \"g\");\n                  _context6.next = 10;\n                  return Promise.all(assetsWithInfo.map( /*#__PURE__*/function () {\n                    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(asset) {\n                      var name, source, content, hashes, etag, _yield$cacheAnalyse$p, _yield$cacheAnalyse$p2;\n\n                      return _regeneratorRuntime.wrap(function _callee$(_context) {\n                        while (1) {\n                          switch (_context.prev = _context.next) {\n                            case 0:\n                              name = asset.name, source = asset.source, content = asset.content, hashes = asset.hashes;\n\n                              if (!Buffer.isBuffer(content)) {\n                                _context.next = 5;\n                                break;\n                              }\n\n                              asset.referencedHashes = EMPTY_SET;\n                              asset.ownHashes = EMPTY_SET;\n                              return _context.abrupt(\"return\");\n\n                            case 5:\n                              etag = cacheAnalyse.mergeEtags(cacheAnalyse.getLazyHashedEtag(source), Array.from(hashes).join(\"|\"));\n                              _context.next = 8;\n                              return cacheAnalyse.providePromise(name, etag, function () {\n                                var referencedHashes = new Set();\n                                var ownHashes = new Set();\n                                var inContent = content.match(hashRegExp);\n\n                                if (inContent) {\n                                  var _iterator5 = _createForOfIteratorHelper(inContent),\n                                      _step5;\n\n                                  try {\n                                    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                                      var hash = _step5.value;\n\n                                      if (hashes.has(hash)) {\n                                        ownHashes.add(hash);\n                                        continue;\n                                      }\n\n                                      referencedHashes.add(hash);\n                                    }\n                                  } catch (err) {\n                                    _iterator5.e(err);\n                                  } finally {\n                                    _iterator5.f();\n                                  }\n                                }\n\n                                return [referencedHashes, ownHashes];\n                              });\n\n                            case 8:\n                              _yield$cacheAnalyse$p = _context.sent;\n                              _yield$cacheAnalyse$p2 = _slicedToArray(_yield$cacheAnalyse$p, 2);\n                              asset.referencedHashes = _yield$cacheAnalyse$p2[0];\n                              asset.ownHashes = _yield$cacheAnalyse$p2[1];\n\n                            case 12:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }\n                      }, _callee);\n                    }));\n\n                    return function (_x) {\n                      return _ref3.apply(this, arguments);\n                    };\n                  }()));\n\n                case 10:\n                  getDependencies = function getDependencies(hash) {\n                    var assets = hashToAssets.get(hash);\n\n                    if (!assets) {\n                      var referencingAssets = assetsWithInfo.filter(function (asset) {\n                        return asset.referencedHashes.has(hash);\n                      });\n                      var err = new WebpackError(\"RealContentHashPlugin\\nSome kind of unexpected caching problem occurred.\\nAn asset was cached with a reference to another asset (\".concat(hash, \") that's not in the compilation anymore.\\nEither the asset was incorrectly cached, or the referenced asset should also be restored from cache.\\nReferenced by:\\n\").concat(referencingAssets.map(function (a) {\n                        var match = new RegExp(\".{0,20}\".concat(quoteMeta(hash), \".{0,20}\")).exec(a.content);\n                        return \" - \".concat(a.name, \": ...\").concat(match ? match[0] : \"???\", \"...\");\n                      }).join(\"\\n\")));\n                      compilation.errors.push(err);\n                      return undefined;\n                    }\n\n                    var hashes = new Set();\n\n                    var _iterator6 = _createForOfIteratorHelper(assets),\n                        _step6;\n\n                    try {\n                      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                        var _step6$value = _step6.value,\n                            referencedHashes = _step6$value.referencedHashes,\n                            ownHashes = _step6$value.ownHashes;\n\n                        if (!ownHashes.has(hash)) {\n                          var _iterator7 = _createForOfIteratorHelper(ownHashes),\n                              _step7;\n\n                          try {\n                            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                              var _hash = _step7.value;\n                              hashes.add(_hash);\n                            }\n                          } catch (err) {\n                            _iterator7.e(err);\n                          } finally {\n                            _iterator7.f();\n                          }\n                        }\n\n                        var _iterator8 = _createForOfIteratorHelper(referencedHashes),\n                            _step8;\n\n                        try {\n                          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                            var _hash2 = _step8.value;\n                            hashes.add(_hash2);\n                          }\n                        } catch (err) {\n                          _iterator8.e(err);\n                        } finally {\n                          _iterator8.f();\n                        }\n                      }\n                    } catch (err) {\n                      _iterator6.e(err);\n                    } finally {\n                      _iterator6.f();\n                    }\n\n                    return hashes;\n                  };\n\n                  hashInfo = function hashInfo(hash) {\n                    var assets = hashToAssets.get(hash);\n                    return \"\".concat(hash, \" (\").concat(Array.from(assets, function (a) {\n                      return a.name;\n                    }), \")\");\n                  };\n\n                  hashesInOrder = new Set();\n                  _iterator9 = _createForOfIteratorHelper(hashToAssets.keys());\n                  _context6.prev = 14;\n\n                  _loop = function _loop() {\n                    var hash = _step9.value;\n\n                    var add = function add(hash, stack) {\n                      var deps = getDependencies(hash);\n                      if (!deps) return;\n                      stack.add(hash);\n\n                      var _iterator12 = _createForOfIteratorHelper(deps),\n                          _step12;\n\n                      try {\n                        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                          var dep = _step12.value;\n                          if (hashesInOrder.has(dep)) continue;\n\n                          if (stack.has(dep)) {\n                            throw new Error(\"Circular hash dependency \".concat(Array.from(stack, hashInfo).join(\" -> \"), \" -> \").concat(hashInfo(dep)));\n                          }\n\n                          add(dep, stack);\n                        }\n                      } catch (err) {\n                        _iterator12.e(err);\n                      } finally {\n                        _iterator12.f();\n                      }\n\n                      hashesInOrder.add(hash);\n                      stack.delete(hash);\n                    };\n\n                    if (hashesInOrder.has(hash)) return \"continue\";\n                    add(hash, new Set());\n                  };\n\n                  _iterator9.s();\n\n                case 17:\n                  if ((_step9 = _iterator9.n()).done) {\n                    _context6.next = 23;\n                    break;\n                  }\n\n                  _ret = _loop();\n\n                  if (!(_ret === \"continue\")) {\n                    _context6.next = 21;\n                    break;\n                  }\n\n                  return _context6.abrupt(\"continue\", 21);\n\n                case 21:\n                  _context6.next = 17;\n                  break;\n\n                case 23:\n                  _context6.next = 28;\n                  break;\n\n                case 25:\n                  _context6.prev = 25;\n                  _context6.t0 = _context6[\"catch\"](14);\n\n                  _iterator9.e(_context6.t0);\n\n                case 28:\n                  _context6.prev = 28;\n\n                  _iterator9.f();\n\n                  return _context6.finish(28);\n\n                case 31:\n                  hashToNewHash = new Map();\n\n                  getEtag = function getEtag(asset) {\n                    return cacheGenerate.mergeEtags(cacheGenerate.getLazyHashedEtag(asset.source), Array.from(asset.referencedHashes, function (hash) {\n                      return hashToNewHash.get(hash);\n                    }).join(\"|\"));\n                  };\n\n                  computeNewContent = function computeNewContent(asset) {\n                    if (asset.contentComputePromise) return asset.contentComputePromise;\n                    return asset.contentComputePromise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n                      var identifier, etag;\n                      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                        while (1) {\n                          switch (_context2.prev = _context2.next) {\n                            case 0:\n                              if (!(asset.ownHashes.size > 0 || Array.from(asset.referencedHashes).some(function (hash) {\n                                return hashToNewHash.get(hash) !== hash;\n                              }))) {\n                                _context2.next = 6;\n                                break;\n                              }\n\n                              identifier = asset.name;\n                              etag = getEtag(asset);\n                              _context2.next = 5;\n                              return cacheGenerate.providePromise(identifier, etag, function () {\n                                var newContent = asset.content.replace(hashRegExp, function (hash) {\n                                  return hashToNewHash.get(hash);\n                                });\n                                return new RawSource(newContent);\n                              });\n\n                            case 5:\n                              asset.newSource = _context2.sent;\n\n                            case 6:\n                            case \"end\":\n                              return _context2.stop();\n                          }\n                        }\n                      }, _callee2);\n                    }))();\n                  };\n\n                  computeNewContentWithoutOwn = function computeNewContentWithoutOwn(asset) {\n                    if (asset.contentComputeWithoutOwnPromise) return asset.contentComputeWithoutOwnPromise;\n                    return asset.contentComputeWithoutOwnPromise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n                      var identifier, etag;\n                      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                        while (1) {\n                          switch (_context3.prev = _context3.next) {\n                            case 0:\n                              if (!(asset.ownHashes.size > 0 || Array.from(asset.referencedHashes).some(function (hash) {\n                                return hashToNewHash.get(hash) !== hash;\n                              }))) {\n                                _context3.next = 6;\n                                break;\n                              }\n\n                              identifier = asset.name + \"|without-own\";\n                              etag = getEtag(asset);\n                              _context3.next = 5;\n                              return cacheGenerate.providePromise(identifier, etag, function () {\n                                var newContent = asset.content.replace(hashRegExp, function (hash) {\n                                  if (asset.ownHashes.has(hash)) {\n                                    return \"\";\n                                  }\n\n                                  return hashToNewHash.get(hash);\n                                });\n                                return new RawSource(newContent);\n                              });\n\n                            case 5:\n                              asset.newSourceWithoutOwn = _context3.sent;\n\n                            case 6:\n                            case \"end\":\n                              return _context3.stop();\n                          }\n                        }\n                      }, _callee3);\n                    }))();\n                  };\n\n                  comparator = compareSelect(function (a) {\n                    return a.name;\n                  }, compareStrings);\n                  _iterator10 = _createForOfIteratorHelper(hashesInOrder);\n                  _context6.prev = 37;\n                  _loop2 = /*#__PURE__*/_regeneratorRuntime.mark(function _loop2() {\n                    var oldHash, assets, hash, assetsContent, newHash, _iterator13, _step13, _content, digest;\n\n                    return _regeneratorRuntime.wrap(function _loop2$(_context5) {\n                      while (1) {\n                        switch (_context5.prev = _context5.next) {\n                          case 0:\n                            oldHash = _step10.value;\n                            assets = hashToAssets.get(oldHash);\n                            assets.sort(comparator);\n                            hash = createHash(_this._hashFunction);\n                            _context5.next = 6;\n                            return Promise.all(assets.map(function (asset) {\n                              return asset.ownHashes.has(oldHash) ? computeNewContentWithoutOwn(asset) : computeNewContent(asset);\n                            }));\n\n                          case 6:\n                            assetsContent = mapAndDeduplicateBuffers(assets, function (asset) {\n                              if (asset.ownHashes.has(oldHash)) {\n                                return asset.newSourceWithoutOwn ? asset.newSourceWithoutOwn.buffer() : asset.source.buffer();\n                              } else {\n                                return asset.newSource ? asset.newSource.buffer() : asset.source.buffer();\n                              }\n                            });\n                            newHash = hooks.updateHash.call(assetsContent, oldHash);\n\n                            if (!newHash) {\n                              _iterator13 = _createForOfIteratorHelper(assetsContent);\n\n                              try {\n                                for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n                                  _content = _step13.value;\n                                  hash.update(_content);\n                                }\n                              } catch (err) {\n                                _iterator13.e(err);\n                              } finally {\n                                _iterator13.f();\n                              }\n\n                              digest = hash.digest(_this._hashDigest);\n                              newHash =\n                              /** @type {string} */\n                              digest.slice(0, oldHash.length);\n                            }\n\n                            hashToNewHash.set(oldHash, newHash);\n\n                          case 10:\n                          case \"end\":\n                            return _context5.stop();\n                        }\n                      }\n                    }, _loop2);\n                  });\n\n                  _iterator10.s();\n\n                case 40:\n                  if ((_step10 = _iterator10.n()).done) {\n                    _context6.next = 44;\n                    break;\n                  }\n\n                  return _context6.delegateYield(_loop2(), \"t1\", 42);\n\n                case 42:\n                  _context6.next = 40;\n                  break;\n\n                case 44:\n                  _context6.next = 49;\n                  break;\n\n                case 46:\n                  _context6.prev = 46;\n                  _context6.t2 = _context6[\"catch\"](37);\n\n                  _iterator10.e(_context6.t2);\n\n                case 49:\n                  _context6.prev = 49;\n\n                  _iterator10.f();\n\n                  return _context6.finish(49);\n\n                case 52:\n                  _context6.next = 54;\n                  return Promise.all(assetsWithInfo.map( /*#__PURE__*/function () {\n                    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(asset) {\n                      var newName, infoUpdate, hash;\n                      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                        while (1) {\n                          switch (_context4.prev = _context4.next) {\n                            case 0:\n                              _context4.next = 2;\n                              return computeNewContent(asset);\n\n                            case 2:\n                              newName = asset.name.replace(hashRegExp, function (hash) {\n                                return hashToNewHash.get(hash);\n                              });\n                              infoUpdate = {};\n                              hash = asset.info.contenthash;\n                              infoUpdate.contenthash = Array.isArray(hash) ? hash.map(function (hash) {\n                                return hashToNewHash.get(hash);\n                              }) : hashToNewHash.get(hash);\n\n                              if (asset.newSource !== undefined) {\n                                compilation.updateAsset(asset.name, asset.newSource, infoUpdate);\n                              } else {\n                                compilation.updateAsset(asset.name, asset.source, infoUpdate);\n                              }\n\n                              if (asset.name !== newName) {\n                                compilation.renameAsset(asset.name, newName);\n                              }\n\n                            case 8:\n                            case \"end\":\n                              return _context4.stop();\n                          }\n                        }\n                      }, _callee4);\n                    }));\n\n                    return function (_x2) {\n                      return _ref6.apply(this, arguments);\n                    };\n                  }()));\n\n                case 54:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }\n          }, _callee5, null, [[14, 25, 28, 31], [37, 46, 49, 52]]);\n        })));\n      });\n    }\n  }], [{\n    key: \"getCompilationHooks\",\n    value:\n    /**\n     * @param {Compilation} compilation the compilation\n     * @returns {CompilationHooks} the attached hooks\n     */\n    function getCompilationHooks(compilation) {\n      if (!(compilation instanceof Compilation)) {\n        throw new TypeError(\"The 'compilation' argument must be an instance of Compilation\");\n      }\n\n      var hooks = compilationHooksMap.get(compilation);\n\n      if (hooks === undefined) {\n        hooks = {\n          updateHash: new SyncBailHook([\"content\", \"oldHash\"])\n        };\n        compilationHooksMap.set(compilation, hooks);\n      }\n\n      return hooks;\n    }\n  }]);\n\n  return RealContentHashPlugin;\n}();\n\nmodule.exports = RealContentHashPlugin;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/optimize/RealContentHashPlugin.js"],"names":["require","SyncBailHook","RawSource","CachedSource","CompatSource","Compilation","WebpackError","compareSelect","compareStrings","createHash","EMPTY_SET","Set","addToList","itemOrItems","list","Array","isArray","item","add","mapAndDeduplicateBuffers","input","fn","result","outer","value","buf","other","equals","push","quoteMeta","str","replace","cachedSourceMap","WeakMap","toCachedSource","source","entry","get","undefined","newSource","from","set","compilationHooksMap","RealContentHashPlugin","hashFunction","hashDigest","_hashFunction","_hashDigest","compiler","hooks","compilation","tap","cacheAnalyse","getCache","cacheGenerate","getCompilationHooks","processAssets","tapPromise","name","stage","PROCESS_ASSETS_STAGE_OPTIMIZE_HASH","assets","getAssets","assetsWithInfo","hashToAssets","Map","info","cachedSource","content","hashes","contenthash","data","newSourceWithoutOwn","ownHashes","contentComputePromise","contentComputeWithoutOwnPromise","referencedHashes","hash","size","hashRegExp","RegExp","keys","join","Promise","all","map","asset","Buffer","isBuffer","etag","mergeEtags","getLazyHashedEtag","providePromise","inContent","match","has","getDependencies","referencingAssets","filter","err","a","exec","errors","hashInfo","hashesInOrder","stack","deps","dep","Error","delete","hashToNewHash","getEtag","computeNewContent","some","identifier","newContent","computeNewContentWithoutOwn","comparator","oldHash","sort","assetsContent","buffer","newHash","updateHash","call","update","digest","slice","length","newName","infoUpdate","updateAsset","renameAsset","TypeError","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { SyncBailHook } = require(\"tapable\");\nconst { RawSource, CachedSource, CompatSource } = require(\"webpack-sources\");\nconst Compilation = require(\"../Compilation\");\nconst WebpackError = require(\"../WebpackError\");\nconst { compareSelect, compareStrings } = require(\"../util/comparators\");\nconst createHash = require(\"../util/createHash\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nconst EMPTY_SET = new Set();\n\nconst addToList = (itemOrItems, list) => {\n\tif (Array.isArray(itemOrItems)) {\n\t\tfor (const item of itemOrItems) {\n\t\t\tlist.add(item);\n\t\t}\n\t} else if (itemOrItems) {\n\t\tlist.add(itemOrItems);\n\t}\n};\n\n/**\n * @template T\n * @param {T[]} input list\n * @param {function(T): Buffer} fn map function\n * @returns {Buffer[]} buffers without duplicates\n */\nconst mapAndDeduplicateBuffers = (input, fn) => {\n\t// Buffer.equals compares size first so this should be efficient enough\n\t// If it becomes a performance problem we can use a map and group by size\n\t// instead of looping over all assets.\n\tconst result = [];\n\touter: for (const value of input) {\n\t\tconst buf = fn(value);\n\t\tfor (const other of result) {\n\t\t\tif (buf.equals(other)) continue outer;\n\t\t}\n\t\tresult.push(buf);\n\t}\n\treturn result;\n};\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nconst quoteMeta = str => {\n\treturn str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\nconst cachedSourceMap = new WeakMap();\n\nconst toCachedSource = source => {\n\tif (source instanceof CachedSource) {\n\t\treturn source;\n\t}\n\tconst entry = cachedSourceMap.get(source);\n\tif (entry !== undefined) return entry;\n\tconst newSource = new CachedSource(CompatSource.from(source));\n\tcachedSourceMap.set(source, newSource);\n\treturn newSource;\n};\n\n/**\n * @typedef {Object} AssetInfoForRealContentHash\n * @property {string} name\n * @property {AssetInfo} info\n * @property {Source} source\n * @property {RawSource | undefined} newSource\n * @property {RawSource | undefined} newSourceWithoutOwn\n * @property {string} content\n * @property {Set<string>} ownHashes\n * @property {Promise} contentComputePromise\n * @property {Promise} contentComputeWithoutOwnPromise\n * @property {Set<string>} referencedHashes\n * @property {Set<string>} hashes\n */\n\n/**\n * @typedef {Object} CompilationHooks\n * @property {SyncBailHook<[Buffer[], string], string>} updateHash\n */\n\n/** @type {WeakMap<Compilation, CompilationHooks>} */\nconst compilationHooksMap = new WeakMap();\n\nclass RealContentHashPlugin {\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @returns {CompilationHooks} the attached hooks\n\t */\n\tstatic getCompilationHooks(compilation) {\n\t\tif (!(compilation instanceof Compilation)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t\"The 'compilation' argument must be an instance of Compilation\"\n\t\t\t);\n\t\t}\n\t\tlet hooks = compilationHooksMap.get(compilation);\n\t\tif (hooks === undefined) {\n\t\t\thooks = {\n\t\t\t\tupdateHash: new SyncBailHook([\"content\", \"oldHash\"])\n\t\t\t};\n\t\t\tcompilationHooksMap.set(compilation, hooks);\n\t\t}\n\t\treturn hooks;\n\t}\n\n\tconstructor({ hashFunction, hashDigest }) {\n\t\tthis._hashFunction = hashFunction;\n\t\tthis._hashDigest = hashDigest;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"RealContentHashPlugin\", compilation => {\n\t\t\tconst cacheAnalyse = compilation.getCache(\n\t\t\t\t\"RealContentHashPlugin|analyse\"\n\t\t\t);\n\t\t\tconst cacheGenerate = compilation.getCache(\n\t\t\t\t\"RealContentHashPlugin|generate\"\n\t\t\t);\n\t\t\tconst hooks = RealContentHashPlugin.getCompilationHooks(compilation);\n\t\t\tcompilation.hooks.processAssets.tapPromise(\n\t\t\t\t{\n\t\t\t\t\tname: \"RealContentHashPlugin\",\n\t\t\t\t\tstage: Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH\n\t\t\t\t},\n\t\t\t\tasync () => {\n\t\t\t\t\tconst assets = compilation.getAssets();\n\t\t\t\t\t/** @type {AssetInfoForRealContentHash[]} */\n\t\t\t\t\tconst assetsWithInfo = [];\n\t\t\t\t\tconst hashToAssets = new Map();\n\t\t\t\t\tfor (const { source, info, name } of assets) {\n\t\t\t\t\t\tconst cachedSource = toCachedSource(source);\n\t\t\t\t\t\tconst content = cachedSource.source();\n\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\tconst hashes = new Set();\n\t\t\t\t\t\taddToList(info.contenthash, hashes);\n\t\t\t\t\t\tconst data = {\n\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\tsource: cachedSource,\n\t\t\t\t\t\t\t/** @type {RawSource | undefined} */\n\t\t\t\t\t\t\tnewSource: undefined,\n\t\t\t\t\t\t\t/** @type {RawSource | undefined} */\n\t\t\t\t\t\t\tnewSourceWithoutOwn: undefined,\n\t\t\t\t\t\t\tcontent,\n\t\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\t\townHashes: undefined,\n\t\t\t\t\t\t\tcontentComputePromise: undefined,\n\t\t\t\t\t\t\tcontentComputeWithoutOwnPromise: undefined,\n\t\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\t\treferencedHashes: undefined,\n\t\t\t\t\t\t\thashes\n\t\t\t\t\t\t};\n\t\t\t\t\t\tassetsWithInfo.push(data);\n\t\t\t\t\t\tfor (const hash of hashes) {\n\t\t\t\t\t\t\tconst list = hashToAssets.get(hash);\n\t\t\t\t\t\t\tif (list === undefined) {\n\t\t\t\t\t\t\t\thashToAssets.set(hash, [data]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlist.push(data);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (hashToAssets.size === 0) return;\n\t\t\t\t\tconst hashRegExp = new RegExp(\n\t\t\t\t\t\tArray.from(hashToAssets.keys(), quoteMeta).join(\"|\"),\n\t\t\t\t\t\t\"g\"\n\t\t\t\t\t);\n\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\tassetsWithInfo.map(async asset => {\n\t\t\t\t\t\t\tconst { name, source, content, hashes } = asset;\n\t\t\t\t\t\t\tif (Buffer.isBuffer(content)) {\n\t\t\t\t\t\t\t\tasset.referencedHashes = EMPTY_SET;\n\t\t\t\t\t\t\t\tasset.ownHashes = EMPTY_SET;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst etag = cacheAnalyse.mergeEtags(\n\t\t\t\t\t\t\t\tcacheAnalyse.getLazyHashedEtag(source),\n\t\t\t\t\t\t\t\tArray.from(hashes).join(\"|\")\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t[asset.referencedHashes, asset.ownHashes] =\n\t\t\t\t\t\t\t\tawait cacheAnalyse.providePromise(name, etag, () => {\n\t\t\t\t\t\t\t\t\tconst referencedHashes = new Set();\n\t\t\t\t\t\t\t\t\tlet ownHashes = new Set();\n\t\t\t\t\t\t\t\t\tconst inContent = content.match(hashRegExp);\n\t\t\t\t\t\t\t\t\tif (inContent) {\n\t\t\t\t\t\t\t\t\t\tfor (const hash of inContent) {\n\t\t\t\t\t\t\t\t\t\t\tif (hashes.has(hash)) {\n\t\t\t\t\t\t\t\t\t\t\t\townHashes.add(hash);\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treferencedHashes.add(hash);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn [referencedHashes, ownHashes];\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t\tconst getDependencies = hash => {\n\t\t\t\t\t\tconst assets = hashToAssets.get(hash);\n\t\t\t\t\t\tif (!assets) {\n\t\t\t\t\t\t\tconst referencingAssets = assetsWithInfo.filter(asset =>\n\t\t\t\t\t\t\t\tasset.referencedHashes.has(hash)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst err = new WebpackError(`RealContentHashPlugin\nSome kind of unexpected caching problem occurred.\nAn asset was cached with a reference to another asset (${hash}) that's not in the compilation anymore.\nEither the asset was incorrectly cached, or the referenced asset should also be restored from cache.\nReferenced by:\n${referencingAssets\n\t.map(a => {\n\t\tconst match = new RegExp(`.{0,20}${quoteMeta(hash)}.{0,20}`).exec(\n\t\t\ta.content\n\t\t);\n\t\treturn ` - ${a.name}: ...${match ? match[0] : \"???\"}...`;\n\t})\n\t.join(\"\\n\")}`);\n\t\t\t\t\t\t\tcompilation.errors.push(err);\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst hashes = new Set();\n\t\t\t\t\t\tfor (const { referencedHashes, ownHashes } of assets) {\n\t\t\t\t\t\t\tif (!ownHashes.has(hash)) {\n\t\t\t\t\t\t\t\tfor (const hash of ownHashes) {\n\t\t\t\t\t\t\t\t\thashes.add(hash);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const hash of referencedHashes) {\n\t\t\t\t\t\t\t\thashes.add(hash);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn hashes;\n\t\t\t\t\t};\n\t\t\t\t\tconst hashInfo = hash => {\n\t\t\t\t\t\tconst assets = hashToAssets.get(hash);\n\t\t\t\t\t\treturn `${hash} (${Array.from(assets, a => a.name)})`;\n\t\t\t\t\t};\n\t\t\t\t\tconst hashesInOrder = new Set();\n\t\t\t\t\tfor (const hash of hashToAssets.keys()) {\n\t\t\t\t\t\tconst add = (hash, stack) => {\n\t\t\t\t\t\t\tconst deps = getDependencies(hash);\n\t\t\t\t\t\t\tif (!deps) return;\n\t\t\t\t\t\t\tstack.add(hash);\n\t\t\t\t\t\t\tfor (const dep of deps) {\n\t\t\t\t\t\t\t\tif (hashesInOrder.has(dep)) continue;\n\t\t\t\t\t\t\t\tif (stack.has(dep)) {\n\t\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\t`Circular hash dependency ${Array.from(\n\t\t\t\t\t\t\t\t\t\t\tstack,\n\t\t\t\t\t\t\t\t\t\t\thashInfo\n\t\t\t\t\t\t\t\t\t\t).join(\" -> \")} -> ${hashInfo(dep)}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tadd(dep, stack);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thashesInOrder.add(hash);\n\t\t\t\t\t\t\tstack.delete(hash);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (hashesInOrder.has(hash)) continue;\n\t\t\t\t\t\tadd(hash, new Set());\n\t\t\t\t\t}\n\t\t\t\t\tconst hashToNewHash = new Map();\n\t\t\t\t\tconst getEtag = asset =>\n\t\t\t\t\t\tcacheGenerate.mergeEtags(\n\t\t\t\t\t\t\tcacheGenerate.getLazyHashedEtag(asset.source),\n\t\t\t\t\t\t\tArray.from(asset.referencedHashes, hash =>\n\t\t\t\t\t\t\t\thashToNewHash.get(hash)\n\t\t\t\t\t\t\t).join(\"|\")\n\t\t\t\t\t\t);\n\t\t\t\t\tconst computeNewContent = asset => {\n\t\t\t\t\t\tif (asset.contentComputePromise) return asset.contentComputePromise;\n\t\t\t\t\t\treturn (asset.contentComputePromise = (async () => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tasset.ownHashes.size > 0 ||\n\t\t\t\t\t\t\t\tArray.from(asset.referencedHashes).some(\n\t\t\t\t\t\t\t\t\thash => hashToNewHash.get(hash) !== hash\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst identifier = asset.name;\n\t\t\t\t\t\t\t\tconst etag = getEtag(asset);\n\t\t\t\t\t\t\t\tasset.newSource = await cacheGenerate.providePromise(\n\t\t\t\t\t\t\t\t\tidentifier,\n\t\t\t\t\t\t\t\t\tetag,\n\t\t\t\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t\t\t\tconst newContent = asset.content.replace(hashRegExp, hash =>\n\t\t\t\t\t\t\t\t\t\t\thashToNewHash.get(hash)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\treturn new RawSource(newContent);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})());\n\t\t\t\t\t};\n\t\t\t\t\tconst computeNewContentWithoutOwn = asset => {\n\t\t\t\t\t\tif (asset.contentComputeWithoutOwnPromise)\n\t\t\t\t\t\t\treturn asset.contentComputeWithoutOwnPromise;\n\t\t\t\t\t\treturn (asset.contentComputeWithoutOwnPromise = (async () => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tasset.ownHashes.size > 0 ||\n\t\t\t\t\t\t\t\tArray.from(asset.referencedHashes).some(\n\t\t\t\t\t\t\t\t\thash => hashToNewHash.get(hash) !== hash\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst identifier = asset.name + \"|without-own\";\n\t\t\t\t\t\t\t\tconst etag = getEtag(asset);\n\t\t\t\t\t\t\t\tasset.newSourceWithoutOwn = await cacheGenerate.providePromise(\n\t\t\t\t\t\t\t\t\tidentifier,\n\t\t\t\t\t\t\t\t\tetag,\n\t\t\t\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t\t\t\tconst newContent = asset.content.replace(\n\t\t\t\t\t\t\t\t\t\t\thashRegExp,\n\t\t\t\t\t\t\t\t\t\t\thash => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (asset.ownHashes.has(hash)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\treturn hashToNewHash.get(hash);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\treturn new RawSource(newContent);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})());\n\t\t\t\t\t};\n\t\t\t\t\tconst comparator = compareSelect(a => a.name, compareStrings);\n\t\t\t\t\tfor (const oldHash of hashesInOrder) {\n\t\t\t\t\t\tconst assets = hashToAssets.get(oldHash);\n\t\t\t\t\t\tassets.sort(comparator);\n\t\t\t\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\t\tassets.map(asset =>\n\t\t\t\t\t\t\t\tasset.ownHashes.has(oldHash)\n\t\t\t\t\t\t\t\t\t? computeNewContentWithoutOwn(asset)\n\t\t\t\t\t\t\t\t\t: computeNewContent(asset)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst assetsContent = mapAndDeduplicateBuffers(assets, asset => {\n\t\t\t\t\t\t\tif (asset.ownHashes.has(oldHash)) {\n\t\t\t\t\t\t\t\treturn asset.newSourceWithoutOwn\n\t\t\t\t\t\t\t\t\t? asset.newSourceWithoutOwn.buffer()\n\t\t\t\t\t\t\t\t\t: asset.source.buffer();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn asset.newSource\n\t\t\t\t\t\t\t\t\t? asset.newSource.buffer()\n\t\t\t\t\t\t\t\t\t: asset.source.buffer();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tlet newHash = hooks.updateHash.call(assetsContent, oldHash);\n\t\t\t\t\t\tif (!newHash) {\n\t\t\t\t\t\t\tfor (const content of assetsContent) {\n\t\t\t\t\t\t\t\thash.update(content);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst digest = hash.digest(this._hashDigest);\n\t\t\t\t\t\t\tnewHash = /** @type {string} */ (digest.slice(0, oldHash.length));\n\t\t\t\t\t\t}\n\t\t\t\t\t\thashToNewHash.set(oldHash, newHash);\n\t\t\t\t\t}\n\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\tassetsWithInfo.map(async asset => {\n\t\t\t\t\t\t\tawait computeNewContent(asset);\n\t\t\t\t\t\t\tconst newName = asset.name.replace(hashRegExp, hash =>\n\t\t\t\t\t\t\t\thashToNewHash.get(hash)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tconst infoUpdate = {};\n\t\t\t\t\t\t\tconst hash = asset.info.contenthash;\n\t\t\t\t\t\t\tinfoUpdate.contenthash = Array.isArray(hash)\n\t\t\t\t\t\t\t\t? hash.map(hash => hashToNewHash.get(hash))\n\t\t\t\t\t\t\t\t: hashToNewHash.get(hash);\n\n\t\t\t\t\t\t\tif (asset.newSource !== undefined) {\n\t\t\t\t\t\t\t\tcompilation.updateAsset(\n\t\t\t\t\t\t\t\t\tasset.name,\n\t\t\t\t\t\t\t\t\tasset.newSource,\n\t\t\t\t\t\t\t\t\tinfoUpdate\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcompilation.updateAsset(asset.name, asset.source, infoUpdate);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (asset.name !== newName) {\n\t\t\t\t\t\t\t\tcompilation.renameAsset(asset.name, newName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = RealContentHashPlugin;\n"]},"metadata":{},"sourceType":"script"}