{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _slicedToArray = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _objectSpread = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _require = require(\"../util/comparators\"),\n    compareModulesByPreOrderIndexOrIdentifier = _require.compareModulesByPreOrderIndexOrIdentifier;\n\nvar createSchemaValidation = require(\"../util/create-schema-validation\");\n\nvar createHash = require(\"../util/createHash\");\n\nvar _require2 = require(\"./IdHelpers\"),\n    getUsedModuleIdsAndModules = _require2.getUsedModuleIdsAndModules,\n    getFullModuleName = _require2.getFullModuleName;\n/** @typedef {import(\"../../declarations/plugins/HashedModuleIdsPlugin\").HashedModuleIdsPluginOptions} HashedModuleIdsPluginOptions */\n\n\nvar validate = createSchemaValidation(require(\"../../schemas/plugins/HashedModuleIdsPlugin.check.js\"), function () {\n  return require(\"../../schemas/plugins/HashedModuleIdsPlugin.json\");\n}, {\n  name: \"Hashed Module Ids Plugin\",\n  baseDataPath: \"options\"\n});\n\nvar HashedModuleIdsPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {HashedModuleIdsPluginOptions=} options options object\n   */\n  function HashedModuleIdsPlugin() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, HashedModuleIdsPlugin);\n\n    validate(options);\n    /** @type {HashedModuleIdsPluginOptions} */\n\n    this.options = _objectSpread({\n      context: null,\n      hashFunction: \"md4\",\n      hashDigest: \"base64\",\n      hashDigestLength: 4\n    }, options);\n  }\n\n  _createClass(HashedModuleIdsPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var _this = this;\n\n      var options = this.options;\n      compiler.hooks.compilation.tap(\"HashedModuleIdsPlugin\", function (compilation) {\n        compilation.hooks.moduleIds.tap(\"HashedModuleIdsPlugin\", function () {\n          var chunkGraph = compilation.chunkGraph;\n          var context = _this.options.context ? _this.options.context : compiler.context;\n\n          var _getUsedModuleIdsAndM = getUsedModuleIdsAndModules(compilation),\n              _getUsedModuleIdsAndM2 = _slicedToArray(_getUsedModuleIdsAndM, 2),\n              usedIds = _getUsedModuleIdsAndM2[0],\n              modules = _getUsedModuleIdsAndM2[1];\n\n          var modulesInNaturalOrder = modules.sort(compareModulesByPreOrderIndexOrIdentifier(compilation.moduleGraph));\n\n          var _iterator = _createForOfIteratorHelper(modulesInNaturalOrder),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _module = _step.value;\n              var ident = getFullModuleName(_module, context, compiler.root);\n              var hash = createHash(options.hashFunction);\n              hash.update(ident || \"\");\n              var hashId =\n              /** @type {string} */\n              hash.digest(options.hashDigest);\n              var len = options.hashDigestLength;\n\n              while (usedIds.has(hashId.substr(0, len))) {\n                len++;\n              }\n\n              var moduleId = hashId.substr(0, len);\n              chunkGraph.setModuleId(_module, moduleId);\n              usedIds.add(moduleId);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        });\n      });\n    }\n  }]);\n\n  return HashedModuleIdsPlugin;\n}();\n\nmodule.exports = HashedModuleIdsPlugin;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/ids/HashedModuleIdsPlugin.js"],"names":["require","compareModulesByPreOrderIndexOrIdentifier","createSchemaValidation","createHash","getUsedModuleIdsAndModules","getFullModuleName","validate","name","baseDataPath","HashedModuleIdsPlugin","options","context","hashFunction","hashDigest","hashDigestLength","compiler","hooks","compilation","tap","moduleIds","chunkGraph","usedIds","modules","modulesInNaturalOrder","sort","moduleGraph","module","ident","root","hash","update","hashId","digest","len","has","substr","moduleId","setModuleId","add","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n\tcompareModulesByPreOrderIndexOrIdentifier\n} = require(\"../util/comparators\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst createHash = require(\"../util/createHash\");\nconst {\n\tgetUsedModuleIdsAndModules,\n\tgetFullModuleName\n} = require(\"./IdHelpers\");\n\n/** @typedef {import(\"../../declarations/plugins/HashedModuleIdsPlugin\").HashedModuleIdsPluginOptions} HashedModuleIdsPluginOptions */\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/HashedModuleIdsPlugin.check.js\"),\n\t() => require(\"../../schemas/plugins/HashedModuleIdsPlugin.json\"),\n\t{\n\t\tname: \"Hashed Module Ids Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\nclass HashedModuleIdsPlugin {\n\t/**\n\t * @param {HashedModuleIdsPluginOptions=} options options object\n\t */\n\tconstructor(options = {}) {\n\t\tvalidate(options);\n\n\t\t/** @type {HashedModuleIdsPluginOptions} */\n\t\tthis.options = {\n\t\t\tcontext: null,\n\t\t\thashFunction: \"md4\",\n\t\t\thashDigest: \"base64\",\n\t\t\thashDigestLength: 4,\n\t\t\t...options\n\t\t};\n\t}\n\n\tapply(compiler) {\n\t\tconst options = this.options;\n\t\tcompiler.hooks.compilation.tap(\"HashedModuleIdsPlugin\", compilation => {\n\t\t\tcompilation.hooks.moduleIds.tap(\"HashedModuleIdsPlugin\", () => {\n\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\tconst context = this.options.context\n\t\t\t\t\t? this.options.context\n\t\t\t\t\t: compiler.context;\n\n\t\t\t\tconst [usedIds, modules] = getUsedModuleIdsAndModules(compilation);\n\t\t\t\tconst modulesInNaturalOrder = modules.sort(\n\t\t\t\t\tcompareModulesByPreOrderIndexOrIdentifier(compilation.moduleGraph)\n\t\t\t\t);\n\t\t\t\tfor (const module of modulesInNaturalOrder) {\n\t\t\t\t\tconst ident = getFullModuleName(module, context, compiler.root);\n\t\t\t\t\tconst hash = createHash(options.hashFunction);\n\t\t\t\t\thash.update(ident || \"\");\n\t\t\t\t\tconst hashId = /** @type {string} */ (\n\t\t\t\t\t\thash.digest(options.hashDigest)\n\t\t\t\t\t);\n\t\t\t\t\tlet len = options.hashDigestLength;\n\t\t\t\t\twhile (usedIds.has(hashId.substr(0, len))) len++;\n\t\t\t\t\tconst moduleId = hashId.substr(0, len);\n\t\t\t\t\tchunkGraph.setModuleId(module, moduleId);\n\t\t\t\t\tusedIds.add(moduleId);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n\nmodule.exports = HashedModuleIdsPlugin;\n"]},"metadata":{},"sourceType":"script"}