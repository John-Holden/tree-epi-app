{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar Hash = require(\"./Hash\");\n\nvar BULK_SIZE = 2000; // We are using an object instead of a Map as this will stay static during the runtime\n// so access to it can be optimized by v8\n\nvar digestCaches = {};\n\nvar BulkUpdateDecorator = /*#__PURE__*/function (_Hash) {\n  _inherits(BulkUpdateDecorator, _Hash);\n\n  var _super = _createSuper(BulkUpdateDecorator);\n\n  /**\n   * @param {Hash | function(): Hash} hashOrFactory function to create a hash\n   * @param {string=} hashKey key for caching\n   */\n  function BulkUpdateDecorator(hashOrFactory, hashKey) {\n    var _this;\n\n    _classCallCheck(this, BulkUpdateDecorator);\n\n    _this = _super.call(this);\n    _this.hashKey = hashKey;\n\n    if (typeof hashOrFactory === \"function\") {\n      _this.hashFactory = hashOrFactory;\n      _this.hash = undefined;\n    } else {\n      _this.hashFactory = undefined;\n      _this.hash = hashOrFactory;\n    }\n\n    _this.buffer = \"\";\n    return _this;\n  }\n  /**\n   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n   * @param {string|Buffer} data data\n   * @param {string=} inputEncoding data encoding\n   * @returns {this} updated hash\n   */\n\n\n  _createClass(BulkUpdateDecorator, [{\n    key: \"update\",\n    value: function update(data, inputEncoding) {\n      if (inputEncoding !== undefined || typeof data !== \"string\" || data.length > BULK_SIZE) {\n        if (this.hash === undefined) this.hash = this.hashFactory();\n\n        if (this.buffer.length > 0) {\n          this.hash.update(this.buffer);\n          this.buffer = \"\";\n        }\n\n        this.hash.update(data, inputEncoding);\n      } else {\n        this.buffer += data;\n\n        if (this.buffer.length > BULK_SIZE) {\n          if (this.hash === undefined) this.hash = this.hashFactory();\n          this.hash.update(this.buffer);\n          this.buffer = \"\";\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n     * @param {string=} encoding encoding of the return value\n     * @returns {string|Buffer} digest\n     */\n\n  }, {\n    key: \"digest\",\n    value: function digest(encoding) {\n      var digestCache;\n      var buffer = this.buffer;\n\n      if (this.hash === undefined) {\n        // short data for hash, we can use caching\n        var cacheKey = \"\".concat(this.hashKey, \"-\").concat(encoding);\n        digestCache = digestCaches[cacheKey];\n\n        if (digestCache === undefined) {\n          digestCache = digestCaches[cacheKey] = new Map();\n        }\n\n        var cacheEntry = digestCache.get(buffer);\n        if (cacheEntry !== undefined) return cacheEntry;\n        this.hash = this.hashFactory();\n      }\n\n      if (buffer.length > 0) {\n        this.hash.update(buffer);\n      }\n\n      var digestResult = this.hash.digest(encoding);\n      var result = typeof digestResult === \"string\" ? digestResult : digestResult.toString();\n\n      if (digestCache !== undefined) {\n        digestCache.set(buffer, result);\n      }\n\n      return result;\n    }\n  }]);\n\n  return BulkUpdateDecorator;\n}(Hash);\n/* istanbul ignore next */\n\n\nvar DebugHash = /*#__PURE__*/function (_Hash2) {\n  _inherits(DebugHash, _Hash2);\n\n  var _super2 = _createSuper(DebugHash);\n\n  function DebugHash() {\n    var _this2;\n\n    _classCallCheck(this, DebugHash);\n\n    _this2 = _super2.call(this);\n    _this2.string = \"\";\n    return _this2;\n  }\n  /**\n   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n   * @param {string|Buffer} data data\n   * @param {string=} inputEncoding data encoding\n   * @returns {this} updated hash\n   */\n\n\n  _createClass(DebugHash, [{\n    key: \"update\",\n    value: function update(data, inputEncoding) {\n      if (typeof data !== \"string\") data = data.toString(\"utf-8\");\n\n      if (data.startsWith(\"debug-digest-\")) {\n        data = Buffer.from(data.slice(\"debug-digest-\".length), \"hex\").toString();\n      }\n\n      this.string += \"[\".concat(data, \"](\").concat(new Error().stack.split(\"\\n\", 3)[2], \")\\n\");\n      return this;\n    }\n    /**\n     * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n     * @param {string=} encoding encoding of the return value\n     * @returns {string|Buffer} digest\n     */\n\n  }, {\n    key: \"digest\",\n    value: function digest(encoding) {\n      return \"debug-digest-\" + Buffer.from(this.string).toString(\"hex\");\n    }\n  }]);\n\n  return DebugHash;\n}(Hash);\n\nvar crypto = undefined;\nvar createXXHash64 = undefined;\nvar createMd4 = undefined;\nvar BatchedHash = undefined;\n/**\n * Creates a hash by name or function\n * @param {string | typeof Hash} algorithm the algorithm name or a constructor creating a hash\n * @returns {Hash} the hash\n */\n\nmodule.exports = function (algorithm) {\n  if (typeof algorithm === \"function\") {\n    return new BulkUpdateDecorator(function () {\n      return new algorithm();\n    });\n  }\n\n  switch (algorithm) {\n    // TODO add non-cryptographic algorithm here\n    case \"debug\":\n      return new DebugHash();\n\n    case \"xxhash64\":\n      if (createXXHash64 === undefined) {\n        createXXHash64 = require(\"./hash/xxhash64\");\n\n        if (BatchedHash === undefined) {\n          BatchedHash = require(\"./hash/BatchedHash\");\n        }\n      }\n\n      return new BatchedHash(createXXHash64());\n\n    case \"md4\":\n      if (createMd4 === undefined) {\n        createMd4 = require(\"./hash/md4\");\n\n        if (BatchedHash === undefined) {\n          BatchedHash = require(\"./hash/BatchedHash\");\n        }\n      }\n\n      return new BatchedHash(createMd4());\n\n    case \"native-md4\":\n      if (crypto === undefined) crypto = require(\"crypto\");\n      return new BulkUpdateDecorator(function () {\n        return crypto.createHash(\"md4\");\n      }, \"md4\");\n\n    default:\n      if (crypto === undefined) crypto = require(\"crypto\");\n      return new BulkUpdateDecorator(function () {\n        return crypto.createHash(algorithm);\n      }, algorithm);\n  }\n};","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/util/createHash.js"],"names":["Hash","require","BULK_SIZE","digestCaches","BulkUpdateDecorator","hashOrFactory","hashKey","hashFactory","hash","undefined","buffer","data","inputEncoding","length","update","encoding","digestCache","cacheKey","Map","cacheEntry","get","digestResult","digest","result","toString","set","DebugHash","string","startsWith","Buffer","from","slice","Error","stack","split","crypto","createXXHash64","createMd4","BatchedHash","module","exports","algorithm","createHash"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Hash = require(\"./Hash\");\n\nconst BULK_SIZE = 2000;\n\n// We are using an object instead of a Map as this will stay static during the runtime\n// so access to it can be optimized by v8\nconst digestCaches = {};\n\nclass BulkUpdateDecorator extends Hash {\n\t/**\n\t * @param {Hash | function(): Hash} hashOrFactory function to create a hash\n\t * @param {string=} hashKey key for caching\n\t */\n\tconstructor(hashOrFactory, hashKey) {\n\t\tsuper();\n\t\tthis.hashKey = hashKey;\n\t\tif (typeof hashOrFactory === \"function\") {\n\t\t\tthis.hashFactory = hashOrFactory;\n\t\t\tthis.hash = undefined;\n\t\t} else {\n\t\t\tthis.hashFactory = undefined;\n\t\t\tthis.hash = hashOrFactory;\n\t\t}\n\t\tthis.buffer = \"\";\n\t}\n\n\t/**\n\t * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n\t * @param {string|Buffer} data data\n\t * @param {string=} inputEncoding data encoding\n\t * @returns {this} updated hash\n\t */\n\tupdate(data, inputEncoding) {\n\t\tif (\n\t\t\tinputEncoding !== undefined ||\n\t\t\ttypeof data !== \"string\" ||\n\t\t\tdata.length > BULK_SIZE\n\t\t) {\n\t\t\tif (this.hash === undefined) this.hash = this.hashFactory();\n\t\t\tif (this.buffer.length > 0) {\n\t\t\t\tthis.hash.update(this.buffer);\n\t\t\t\tthis.buffer = \"\";\n\t\t\t}\n\t\t\tthis.hash.update(data, inputEncoding);\n\t\t} else {\n\t\t\tthis.buffer += data;\n\t\t\tif (this.buffer.length > BULK_SIZE) {\n\t\t\t\tif (this.hash === undefined) this.hash = this.hashFactory();\n\t\t\t\tthis.hash.update(this.buffer);\n\t\t\t\tthis.buffer = \"\";\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n\t * @param {string=} encoding encoding of the return value\n\t * @returns {string|Buffer} digest\n\t */\n\tdigest(encoding) {\n\t\tlet digestCache;\n\t\tconst buffer = this.buffer;\n\t\tif (this.hash === undefined) {\n\t\t\t// short data for hash, we can use caching\n\t\t\tconst cacheKey = `${this.hashKey}-${encoding}`;\n\t\t\tdigestCache = digestCaches[cacheKey];\n\t\t\tif (digestCache === undefined) {\n\t\t\t\tdigestCache = digestCaches[cacheKey] = new Map();\n\t\t\t}\n\t\t\tconst cacheEntry = digestCache.get(buffer);\n\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\tthis.hash = this.hashFactory();\n\t\t}\n\t\tif (buffer.length > 0) {\n\t\t\tthis.hash.update(buffer);\n\t\t}\n\t\tconst digestResult = this.hash.digest(encoding);\n\t\tconst result =\n\t\t\ttypeof digestResult === \"string\" ? digestResult : digestResult.toString();\n\t\tif (digestCache !== undefined) {\n\t\t\tdigestCache.set(buffer, result);\n\t\t}\n\t\treturn result;\n\t}\n}\n\n/* istanbul ignore next */\nclass DebugHash extends Hash {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.string = \"\";\n\t}\n\n\t/**\n\t * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n\t * @param {string|Buffer} data data\n\t * @param {string=} inputEncoding data encoding\n\t * @returns {this} updated hash\n\t */\n\tupdate(data, inputEncoding) {\n\t\tif (typeof data !== \"string\") data = data.toString(\"utf-8\");\n\t\tif (data.startsWith(\"debug-digest-\")) {\n\t\t\tdata = Buffer.from(data.slice(\"debug-digest-\".length), \"hex\").toString();\n\t\t}\n\t\tthis.string += `[${data}](${new Error().stack.split(\"\\n\", 3)[2]})\\n`;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n\t * @param {string=} encoding encoding of the return value\n\t * @returns {string|Buffer} digest\n\t */\n\tdigest(encoding) {\n\t\treturn \"debug-digest-\" + Buffer.from(this.string).toString(\"hex\");\n\t}\n}\n\nlet crypto = undefined;\nlet createXXHash64 = undefined;\nlet createMd4 = undefined;\nlet BatchedHash = undefined;\n\n/**\n * Creates a hash by name or function\n * @param {string | typeof Hash} algorithm the algorithm name or a constructor creating a hash\n * @returns {Hash} the hash\n */\nmodule.exports = algorithm => {\n\tif (typeof algorithm === \"function\") {\n\t\treturn new BulkUpdateDecorator(() => new algorithm());\n\t}\n\tswitch (algorithm) {\n\t\t// TODO add non-cryptographic algorithm here\n\t\tcase \"debug\":\n\t\t\treturn new DebugHash();\n\t\tcase \"xxhash64\":\n\t\t\tif (createXXHash64 === undefined) {\n\t\t\t\tcreateXXHash64 = require(\"./hash/xxhash64\");\n\t\t\t\tif (BatchedHash === undefined) {\n\t\t\t\t\tBatchedHash = require(\"./hash/BatchedHash\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new BatchedHash(createXXHash64());\n\t\tcase \"md4\":\n\t\t\tif (createMd4 === undefined) {\n\t\t\t\tcreateMd4 = require(\"./hash/md4\");\n\t\t\t\tif (BatchedHash === undefined) {\n\t\t\t\t\tBatchedHash = require(\"./hash/BatchedHash\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new BatchedHash(createMd4());\n\t\tcase \"native-md4\":\n\t\t\tif (crypto === undefined) crypto = require(\"crypto\");\n\t\t\treturn new BulkUpdateDecorator(() => crypto.createHash(\"md4\"), \"md4\");\n\t\tdefault:\n\t\t\tif (crypto === undefined) crypto = require(\"crypto\");\n\t\t\treturn new BulkUpdateDecorator(\n\t\t\t\t() => crypto.createHash(algorithm),\n\t\t\t\talgorithm\n\t\t\t);\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}