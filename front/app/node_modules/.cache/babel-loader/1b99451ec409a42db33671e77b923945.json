{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _toConsumableArray = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _objectSpread = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar asyncLib = require(\"neo-async\");\n\nvar _require = require(\"tapable\"),\n    AsyncSeriesWaterfallHook = _require.AsyncSeriesWaterfallHook,\n    SyncWaterfallHook = _require.SyncWaterfallHook;\n\nvar ContextModule = require(\"./ContextModule\");\n\nvar ModuleFactory = require(\"./ModuleFactory\");\n\nvar ContextElementDependency = require(\"./dependencies/ContextElementDependency\");\n\nvar LazySet = require(\"./util/LazySet\");\n\nvar _require2 = require(\"./util/cleverMerge\"),\n    cachedSetProperty = _require2.cachedSetProperty;\n\nvar _require3 = require(\"./util/deprecation\"),\n    createFakeHook = _require3.createFakeHook;\n\nvar _require4 = require(\"./util/fs\"),\n    join = _require4.join;\n/** @typedef {import(\"./ContextModule\").ContextModuleOptions} ContextModuleOptions */\n\n/** @typedef {import(\"./ContextModule\").ResolveDependenciesCallback} ResolveDependenciesCallback */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryCreateData} ModuleFactoryCreateData */\n\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryResult} ModuleFactoryResult */\n\n/** @typedef {import(\"./ResolverFactory\")} ResolverFactory */\n\n/** @typedef {import(\"./dependencies/ContextDependency\")} ContextDependency */\n\n/** @template T @typedef {import(\"./util/deprecation\").FakeHook<T>} FakeHook<T> */\n\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n\n\nvar EMPTY_RESOLVE_OPTIONS = {};\n\nmodule.exports = /*#__PURE__*/function (_ModuleFactory) {\n  _inherits(ContextModuleFactory, _ModuleFactory);\n\n  var _super = _createSuper(ContextModuleFactory);\n\n  /**\n   * @param {ResolverFactory} resolverFactory resolverFactory\n   */\n  function ContextModuleFactory(resolverFactory) {\n    var _this;\n\n    _classCallCheck(this, ContextModuleFactory);\n\n    _this = _super.call(this);\n    /** @type {AsyncSeriesWaterfallHook<[TODO[], ContextModuleOptions]>} */\n\n    var alternativeRequests = new AsyncSeriesWaterfallHook([\"modules\", \"options\"]);\n    _this.hooks = Object.freeze({\n      /** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n      beforeResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\n      /** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n      afterResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\n      /** @type {SyncWaterfallHook<[string[]]>} */\n      contextModuleFiles: new SyncWaterfallHook([\"files\"]),\n\n      /** @type {FakeHook<Pick<AsyncSeriesWaterfallHook<[TODO[]]>, \"tap\" | \"tapAsync\" | \"tapPromise\" | \"name\">>} */\n      alternatives: createFakeHook({\n        name: \"alternatives\",\n\n        /** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"intercept\"]} */\n        intercept: function intercept(interceptor) {\n          throw new Error(\"Intercepting fake hook ContextModuleFactory.hooks.alternatives is not possible, use ContextModuleFactory.hooks.alternativeRequests instead\");\n        },\n\n        /** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tap\"]} */\n        tap: function tap(options, fn) {\n          alternativeRequests.tap(options, fn);\n        },\n\n        /** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tapAsync\"]} */\n        tapAsync: function tapAsync(options, fn) {\n          alternativeRequests.tapAsync(options, function (items, _options, callback) {\n            return fn(items, callback);\n          });\n        },\n\n        /** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tapPromise\"]} */\n        tapPromise: function tapPromise(options, fn) {\n          alternativeRequests.tapPromise(options, fn);\n        }\n      }, \"ContextModuleFactory.hooks.alternatives has deprecated in favor of ContextModuleFactory.hooks.alternativeRequests with an additional options argument.\", \"DEP_WEBPACK_CONTEXT_MODULE_FACTORY_ALTERNATIVES\"),\n      alternativeRequests: alternativeRequests\n    });\n    _this.resolverFactory = resolverFactory;\n    return _this;\n  }\n  /**\n   * @param {ModuleFactoryCreateData} data data object\n   * @param {function(Error=, ModuleFactoryResult=): void} callback callback\n   * @returns {void}\n   */\n\n\n  _createClass(ContextModuleFactory, [{\n    key: \"create\",\n    value: function create(data, callback) {\n      var _this2 = this;\n\n      var context = data.context;\n      var dependencies = data.dependencies;\n      var resolveOptions = data.resolveOptions;\n      var dependency =\n      /** @type {ContextDependency} */\n      dependencies[0];\n      var fileDependencies = new LazySet();\n      var missingDependencies = new LazySet();\n      var contextDependencies = new LazySet();\n      this.hooks.beforeResolve.callAsync(_objectSpread({\n        context: context,\n        dependencies: dependencies,\n        resolveOptions: resolveOptions,\n        fileDependencies: fileDependencies,\n        missingDependencies: missingDependencies,\n        contextDependencies: contextDependencies\n      }, dependency.options), function (err, beforeResolveResult) {\n        if (err) {\n          return callback(err, {\n            fileDependencies: fileDependencies,\n            missingDependencies: missingDependencies,\n            contextDependencies: contextDependencies\n          });\n        } // Ignored\n\n\n        if (!beforeResolveResult) {\n          return callback(null, {\n            fileDependencies: fileDependencies,\n            missingDependencies: missingDependencies,\n            contextDependencies: contextDependencies\n          });\n        }\n\n        var context = beforeResolveResult.context;\n        var request = beforeResolveResult.request;\n        var resolveOptions = beforeResolveResult.resolveOptions;\n        var loaders,\n            resource,\n            loadersPrefix = \"\";\n        var idx = request.lastIndexOf(\"!\");\n\n        if (idx >= 0) {\n          var loadersRequest = request.substr(0, idx + 1);\n          var i;\n\n          for (i = 0; i < loadersRequest.length && loadersRequest[i] === \"!\"; i++) {\n            loadersPrefix += \"!\";\n          }\n\n          loadersRequest = loadersRequest.substr(i).replace(/!+$/, \"\").replace(/!!+/g, \"!\");\n\n          if (loadersRequest === \"\") {\n            loaders = [];\n          } else {\n            loaders = loadersRequest.split(\"!\");\n          }\n\n          resource = request.substr(idx + 1);\n        } else {\n          loaders = [];\n          resource = request;\n        }\n\n        var contextResolver = _this2.resolverFactory.get(\"context\", dependencies.length > 0 ? cachedSetProperty(resolveOptions || EMPTY_RESOLVE_OPTIONS, \"dependencyType\", dependencies[0].category) : resolveOptions);\n\n        var loaderResolver = _this2.resolverFactory.get(\"loader\");\n\n        asyncLib.parallel([function (callback) {\n          contextResolver.resolve({}, context, resource, {\n            fileDependencies: fileDependencies,\n            missingDependencies: missingDependencies,\n            contextDependencies: contextDependencies\n          }, function (err, result) {\n            if (err) return callback(err);\n            callback(null, result);\n          });\n        }, function (callback) {\n          asyncLib.map(loaders, function (loader, callback) {\n            loaderResolver.resolve({}, context, loader, {\n              fileDependencies: fileDependencies,\n              missingDependencies: missingDependencies,\n              contextDependencies: contextDependencies\n            }, function (err, result) {\n              if (err) return callback(err);\n              callback(null, result);\n            });\n          }, callback);\n        }], function (err, result) {\n          if (err) {\n            return callback(err, {\n              fileDependencies: fileDependencies,\n              missingDependencies: missingDependencies,\n              contextDependencies: contextDependencies\n            });\n          }\n\n          _this2.hooks.afterResolve.callAsync(_objectSpread({\n            addon: loadersPrefix + result[1].join(\"!\") + (result[1].length > 0 ? \"!\" : \"\"),\n            resource: result[0],\n            resolveDependencies: _this2.resolveDependencies.bind(_this2)\n          }, beforeResolveResult), function (err, result) {\n            if (err) {\n              return callback(err, {\n                fileDependencies: fileDependencies,\n                missingDependencies: missingDependencies,\n                contextDependencies: contextDependencies\n              });\n            } // Ignored\n\n\n            if (!result) {\n              return callback(null, {\n                fileDependencies: fileDependencies,\n                missingDependencies: missingDependencies,\n                contextDependencies: contextDependencies\n              });\n            }\n\n            return callback(null, {\n              module: new ContextModule(result.resolveDependencies, result),\n              fileDependencies: fileDependencies,\n              missingDependencies: missingDependencies,\n              contextDependencies: contextDependencies\n            });\n          });\n        });\n      });\n    }\n    /**\n     * @param {InputFileSystem} fs file system\n     * @param {ContextModuleOptions} options options\n     * @param {ResolveDependenciesCallback} callback callback function\n     * @returns {void}\n     */\n\n  }, {\n    key: \"resolveDependencies\",\n    value: function resolveDependencies(fs, options, callback) {\n      var _this3 = this;\n\n      var cmf = this;\n      var resource = options.resource,\n          resourceQuery = options.resourceQuery,\n          resourceFragment = options.resourceFragment,\n          recursive = options.recursive,\n          regExp = options.regExp,\n          include = options.include,\n          exclude = options.exclude,\n          referencedExports = options.referencedExports,\n          category = options.category,\n          typePrefix = options.typePrefix;\n      if (!regExp || !resource) return callback(null, []);\n\n      var addDirectoryChecked = function addDirectoryChecked(directory, visited, callback) {\n        fs.realpath(directory, function (err, realPath) {\n          if (err) return callback(err);\n          if (visited.has(realPath)) return callback(null, []);\n          var recursionStack;\n          addDirectory(directory, function (dir, callback) {\n            if (recursionStack === undefined) {\n              recursionStack = new Set(visited);\n              recursionStack.add(realPath);\n            }\n\n            addDirectoryChecked(dir, recursionStack, callback);\n          }, callback);\n        });\n      };\n\n      var addDirectory = function addDirectory(directory, addSubDirectory, callback) {\n        fs.readdir(directory, function (err, files) {\n          if (err) return callback(err);\n          var processedFiles = cmf.hooks.contextModuleFiles.call(\n          /** @type {string[]} */\n          files.map(function (file) {\n            return file.normalize(\"NFC\");\n          }));\n          if (!processedFiles || processedFiles.length === 0) return callback(null, []);\n          asyncLib.map(processedFiles.filter(function (p) {\n            return p.indexOf(\".\") !== 0;\n          }), function (segment, callback) {\n            var subResource = join(fs, directory, segment);\n\n            if (!exclude || !subResource.match(exclude)) {\n              fs.stat(subResource, function (err, stat) {\n                if (err) {\n                  if (err.code === \"ENOENT\") {\n                    // ENOENT is ok here because the file may have been deleted between\n                    // the readdir and stat calls.\n                    return callback();\n                  } else {\n                    return callback(err);\n                  }\n                }\n\n                if (stat.isDirectory()) {\n                  if (!recursive) return callback();\n                  addSubDirectory(subResource, callback);\n                } else if (stat.isFile() && (!include || subResource.match(include))) {\n                  var obj = {\n                    context: resource,\n                    request: \".\" + subResource.substr(resource.length).replace(/\\\\/g, \"/\")\n                  };\n\n                  _this3.hooks.alternativeRequests.callAsync([obj], options, function (err, alternatives) {\n                    if (err) return callback(err);\n                    alternatives = alternatives.filter(function (obj) {\n                      return regExp.test(obj.request);\n                    }).map(function (obj) {\n                      var dep = new ContextElementDependency(obj.request + resourceQuery + resourceFragment, obj.request, typePrefix, category, referencedExports);\n                      dep.optional = true;\n                      return dep;\n                    });\n                    callback(null, alternatives);\n                  });\n                } else {\n                  callback();\n                }\n              });\n            } else {\n              callback();\n            }\n          }, function (err, result) {\n            if (err) return callback(err);\n            if (!result) return callback(null, []);\n            var flattenedResult = [];\n\n            var _iterator = _createForOfIteratorHelper(result),\n                _step;\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var item = _step.value;\n                if (item) flattenedResult.push.apply(flattenedResult, _toConsumableArray(item));\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n\n            callback(null, flattenedResult);\n          });\n        });\n      };\n\n      if (typeof fs.realpath === \"function\") {\n        addDirectoryChecked(resource, new Set(), callback);\n      } else {\n        var addSubDirectory = function addSubDirectory(dir, callback) {\n          return addDirectory(dir, addSubDirectory, callback);\n        };\n\n        addDirectory(resource, addSubDirectory, callback);\n      }\n    }\n  }]);\n\n  return ContextModuleFactory;\n}(ModuleFactory);","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/ContextModuleFactory.js"],"names":["asyncLib","require","AsyncSeriesWaterfallHook","SyncWaterfallHook","ContextModule","ModuleFactory","ContextElementDependency","LazySet","cachedSetProperty","createFakeHook","join","EMPTY_RESOLVE_OPTIONS","module","exports","resolverFactory","alternativeRequests","hooks","Object","freeze","beforeResolve","afterResolve","contextModuleFiles","alternatives","name","intercept","interceptor","Error","tap","options","fn","tapAsync","items","_options","callback","tapPromise","data","context","dependencies","resolveOptions","dependency","fileDependencies","missingDependencies","contextDependencies","callAsync","err","beforeResolveResult","request","loaders","resource","loadersPrefix","idx","lastIndexOf","loadersRequest","substr","i","length","replace","split","contextResolver","get","category","loaderResolver","parallel","resolve","result","map","loader","addon","resolveDependencies","bind","fs","cmf","resourceQuery","resourceFragment","recursive","regExp","include","exclude","referencedExports","typePrefix","addDirectoryChecked","directory","visited","realpath","realPath","has","recursionStack","addDirectory","dir","undefined","Set","add","addSubDirectory","readdir","files","processedFiles","call","file","normalize","filter","p","indexOf","segment","subResource","match","stat","code","isDirectory","isFile","obj","test","dep","optional","flattenedResult","item","push"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst { AsyncSeriesWaterfallHook, SyncWaterfallHook } = require(\"tapable\");\nconst ContextModule = require(\"./ContextModule\");\nconst ModuleFactory = require(\"./ModuleFactory\");\nconst ContextElementDependency = require(\"./dependencies/ContextElementDependency\");\nconst LazySet = require(\"./util/LazySet\");\nconst { cachedSetProperty } = require(\"./util/cleverMerge\");\nconst { createFakeHook } = require(\"./util/deprecation\");\nconst { join } = require(\"./util/fs\");\n\n/** @typedef {import(\"./ContextModule\").ContextModuleOptions} ContextModuleOptions */\n/** @typedef {import(\"./ContextModule\").ResolveDependenciesCallback} ResolveDependenciesCallback */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryCreateData} ModuleFactoryCreateData */\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryResult} ModuleFactoryResult */\n/** @typedef {import(\"./ResolverFactory\")} ResolverFactory */\n/** @typedef {import(\"./dependencies/ContextDependency\")} ContextDependency */\n/** @template T @typedef {import(\"./util/deprecation\").FakeHook<T>} FakeHook<T> */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n\nconst EMPTY_RESOLVE_OPTIONS = {};\n\nmodule.exports = class ContextModuleFactory extends ModuleFactory {\n\t/**\n\t * @param {ResolverFactory} resolverFactory resolverFactory\n\t */\n\tconstructor(resolverFactory) {\n\t\tsuper();\n\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[], ContextModuleOptions]>} */\n\t\tconst alternativeRequests = new AsyncSeriesWaterfallHook([\n\t\t\t\"modules\",\n\t\t\t\"options\"\n\t\t]);\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n\t\t\tbeforeResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n\t\t\tafterResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\t\t\t/** @type {SyncWaterfallHook<[string[]]>} */\n\t\t\tcontextModuleFiles: new SyncWaterfallHook([\"files\"]),\n\t\t\t/** @type {FakeHook<Pick<AsyncSeriesWaterfallHook<[TODO[]]>, \"tap\" | \"tapAsync\" | \"tapPromise\" | \"name\">>} */\n\t\t\talternatives: createFakeHook(\n\t\t\t\t{\n\t\t\t\t\tname: \"alternatives\",\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"intercept\"]} */\n\t\t\t\t\tintercept: interceptor => {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\"Intercepting fake hook ContextModuleFactory.hooks.alternatives is not possible, use ContextModuleFactory.hooks.alternativeRequests instead\"\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tap\"]} */\n\t\t\t\t\ttap: (options, fn) => {\n\t\t\t\t\t\talternativeRequests.tap(options, fn);\n\t\t\t\t\t},\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tapAsync\"]} */\n\t\t\t\t\ttapAsync: (options, fn) => {\n\t\t\t\t\t\talternativeRequests.tapAsync(options, (items, _options, callback) =>\n\t\t\t\t\t\t\tfn(items, callback)\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tapPromise\"]} */\n\t\t\t\t\ttapPromise: (options, fn) => {\n\t\t\t\t\t\talternativeRequests.tapPromise(options, fn);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"ContextModuleFactory.hooks.alternatives has deprecated in favor of ContextModuleFactory.hooks.alternativeRequests with an additional options argument.\",\n\t\t\t\t\"DEP_WEBPACK_CONTEXT_MODULE_FACTORY_ALTERNATIVES\"\n\t\t\t),\n\t\t\talternativeRequests\n\t\t});\n\t\tthis.resolverFactory = resolverFactory;\n\t}\n\n\t/**\n\t * @param {ModuleFactoryCreateData} data data object\n\t * @param {function(Error=, ModuleFactoryResult=): void} callback callback\n\t * @returns {void}\n\t */\n\tcreate(data, callback) {\n\t\tconst context = data.context;\n\t\tconst dependencies = data.dependencies;\n\t\tconst resolveOptions = data.resolveOptions;\n\t\tconst dependency = /** @type {ContextDependency} */ (dependencies[0]);\n\t\tconst fileDependencies = new LazySet();\n\t\tconst missingDependencies = new LazySet();\n\t\tconst contextDependencies = new LazySet();\n\t\tthis.hooks.beforeResolve.callAsync(\n\t\t\t{\n\t\t\t\tcontext: context,\n\t\t\t\tdependencies: dependencies,\n\t\t\t\tresolveOptions,\n\t\t\t\tfileDependencies,\n\t\t\t\tmissingDependencies,\n\t\t\t\tcontextDependencies,\n\t\t\t\t...dependency.options\n\t\t\t},\n\t\t\t(err, beforeResolveResult) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err, {\n\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Ignored\n\t\t\t\tif (!beforeResolveResult) {\n\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst context = beforeResolveResult.context;\n\t\t\t\tconst request = beforeResolveResult.request;\n\t\t\t\tconst resolveOptions = beforeResolveResult.resolveOptions;\n\n\t\t\t\tlet loaders,\n\t\t\t\t\tresource,\n\t\t\t\t\tloadersPrefix = \"\";\n\t\t\t\tconst idx = request.lastIndexOf(\"!\");\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tlet loadersRequest = request.substr(0, idx + 1);\n\t\t\t\t\tlet i;\n\t\t\t\t\tfor (\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\ti < loadersRequest.length && loadersRequest[i] === \"!\";\n\t\t\t\t\t\ti++\n\t\t\t\t\t) {\n\t\t\t\t\t\tloadersPrefix += \"!\";\n\t\t\t\t\t}\n\t\t\t\t\tloadersRequest = loadersRequest\n\t\t\t\t\t\t.substr(i)\n\t\t\t\t\t\t.replace(/!+$/, \"\")\n\t\t\t\t\t\t.replace(/!!+/g, \"!\");\n\t\t\t\t\tif (loadersRequest === \"\") {\n\t\t\t\t\t\tloaders = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tloaders = loadersRequest.split(\"!\");\n\t\t\t\t\t}\n\t\t\t\t\tresource = request.substr(idx + 1);\n\t\t\t\t} else {\n\t\t\t\t\tloaders = [];\n\t\t\t\t\tresource = request;\n\t\t\t\t}\n\n\t\t\t\tconst contextResolver = this.resolverFactory.get(\n\t\t\t\t\t\"context\",\n\t\t\t\t\tdependencies.length > 0\n\t\t\t\t\t\t? cachedSetProperty(\n\t\t\t\t\t\t\t\tresolveOptions || EMPTY_RESOLVE_OPTIONS,\n\t\t\t\t\t\t\t\t\"dependencyType\",\n\t\t\t\t\t\t\t\tdependencies[0].category\n\t\t\t\t\t\t  )\n\t\t\t\t\t\t: resolveOptions\n\t\t\t\t);\n\t\t\t\tconst loaderResolver = this.resolverFactory.get(\"loader\");\n\n\t\t\t\tasyncLib.parallel(\n\t\t\t\t\t[\n\t\t\t\t\t\tcallback => {\n\t\t\t\t\t\t\tcontextResolver.resolve(\n\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\tresource,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcallback => {\n\t\t\t\t\t\t\tasyncLib.map(\n\t\t\t\t\t\t\t\tloaders,\n\t\t\t\t\t\t\t\t(loader, callback) => {\n\t\t\t\t\t\t\t\t\tloaderResolver.resolve(\n\t\t\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\t\t\tloader,\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treturn callback(err, {\n\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.hooks.afterResolve.callAsync(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\taddon:\n\t\t\t\t\t\t\t\t\tloadersPrefix +\n\t\t\t\t\t\t\t\t\tresult[1].join(\"!\") +\n\t\t\t\t\t\t\t\t\t(result[1].length > 0 ? \"!\" : \"\"),\n\t\t\t\t\t\t\t\tresource: result[0],\n\t\t\t\t\t\t\t\tresolveDependencies: this.resolveDependencies.bind(this),\n\t\t\t\t\t\t\t\t...beforeResolveResult\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treturn callback(err, {\n\t\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Ignored\n\t\t\t\t\t\t\t\tif (!result) {\n\t\t\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\t\tmodule: new ContextModule(result.resolveDependencies, result),\n\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {InputFileSystem} fs file system\n\t * @param {ContextModuleOptions} options options\n\t * @param {ResolveDependenciesCallback} callback callback function\n\t * @returns {void}\n\t */\n\tresolveDependencies(fs, options, callback) {\n\t\tconst cmf = this;\n\t\tconst {\n\t\t\tresource,\n\t\t\tresourceQuery,\n\t\t\tresourceFragment,\n\t\t\trecursive,\n\t\t\tregExp,\n\t\t\tinclude,\n\t\t\texclude,\n\t\t\treferencedExports,\n\t\t\tcategory,\n\t\t\ttypePrefix\n\t\t} = options;\n\t\tif (!regExp || !resource) return callback(null, []);\n\n\t\tconst addDirectoryChecked = (directory, visited, callback) => {\n\t\t\tfs.realpath(directory, (err, realPath) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tif (visited.has(realPath)) return callback(null, []);\n\t\t\t\tlet recursionStack;\n\t\t\t\taddDirectory(\n\t\t\t\t\tdirectory,\n\t\t\t\t\t(dir, callback) => {\n\t\t\t\t\t\tif (recursionStack === undefined) {\n\t\t\t\t\t\t\trecursionStack = new Set(visited);\n\t\t\t\t\t\t\trecursionStack.add(realPath);\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddDirectoryChecked(dir, recursionStack, callback);\n\t\t\t\t\t},\n\t\t\t\t\tcallback\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\tconst addDirectory = (directory, addSubDirectory, callback) => {\n\t\t\tfs.readdir(directory, (err, files) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tconst processedFiles = cmf.hooks.contextModuleFiles.call(\n\t\t\t\t\t/** @type {string[]} */ (files).map(file => file.normalize(\"NFC\"))\n\t\t\t\t);\n\t\t\t\tif (!processedFiles || processedFiles.length === 0)\n\t\t\t\t\treturn callback(null, []);\n\t\t\t\tasyncLib.map(\n\t\t\t\t\tprocessedFiles.filter(p => p.indexOf(\".\") !== 0),\n\t\t\t\t\t(segment, callback) => {\n\t\t\t\t\t\tconst subResource = join(fs, directory, segment);\n\n\t\t\t\t\t\tif (!exclude || !subResource.match(exclude)) {\n\t\t\t\t\t\t\tfs.stat(subResource, (err, stat) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\t\t\t\t\t\t\t// ENOENT is ok here because the file may have been deleted between\n\t\t\t\t\t\t\t\t\t\t// the readdir and stat calls.\n\t\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\t\t\t\t\tif (!recursive) return callback();\n\t\t\t\t\t\t\t\t\taddSubDirectory(subResource, callback);\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tstat.isFile() &&\n\t\t\t\t\t\t\t\t\t(!include || subResource.match(include))\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\t\t\t\tcontext: resource,\n\t\t\t\t\t\t\t\t\t\trequest:\n\t\t\t\t\t\t\t\t\t\t\t\".\" +\n\t\t\t\t\t\t\t\t\t\t\tsubResource.substr(resource.length).replace(/\\\\/g, \"/\")\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tthis.hooks.alternativeRequests.callAsync(\n\t\t\t\t\t\t\t\t\t\t[obj],\n\t\t\t\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\t\t\t\t(err, alternatives) => {\n\t\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\t\talternatives = alternatives\n\t\t\t\t\t\t\t\t\t\t\t\t.filter(obj => regExp.test(obj.request))\n\t\t\t\t\t\t\t\t\t\t\t\t.map(obj => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new ContextElementDependency(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tobj.request + resourceQuery + resourceFragment,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tobj.request,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttypePrefix,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcategory,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treferencedExports\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\tdep.optional = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn dep;\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\tcallback(null, alternatives);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\tif (!result) return callback(null, []);\n\n\t\t\t\t\t\tconst flattenedResult = [];\n\n\t\t\t\t\t\tfor (const item of result) {\n\t\t\t\t\t\t\tif (item) flattenedResult.push(...item);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcallback(null, flattenedResult);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\tif (typeof fs.realpath === \"function\") {\n\t\t\taddDirectoryChecked(resource, new Set(), callback);\n\t\t} else {\n\t\t\tconst addSubDirectory = (dir, callback) =>\n\t\t\t\taddDirectory(dir, addSubDirectory, callback);\n\t\t\taddDirectory(resource, addSubDirectory, callback);\n\t\t}\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}