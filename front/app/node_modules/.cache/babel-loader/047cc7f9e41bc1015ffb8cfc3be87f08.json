{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _slicedToArray = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _require = require(\"..\"),\n    WebpackError = _require.WebpackError;\n\nvar _require2 = require(\"./IdHelpers\"),\n    getUsedModuleIdsAndModules = _require2.getUsedModuleIdsAndModules;\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Module\")} Module */\n\n\nvar plugin = \"SyncModuleIdsPlugin\";\n\nvar SyncModuleIdsPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {Object} options options\n   * @param {string} options.path path to file\n   * @param {string=} options.context context for module names\n   * @param {function(Module): boolean} options.test selector for modules\n   * @param {\"read\" | \"create\" | \"merge\" | \"update\"=} options.mode operation mode (defaults to merge)\n   */\n  function SyncModuleIdsPlugin(_ref) {\n    var path = _ref.path,\n        context = _ref.context,\n        test = _ref.test,\n        mode = _ref.mode;\n\n    _classCallCheck(this, SyncModuleIdsPlugin);\n\n    this._path = path;\n    this._context = context;\n\n    this._test = test || function () {\n      return true;\n    };\n\n    var readAndWrite = !mode || mode === \"merge\" || mode === \"update\";\n    this._read = readAndWrite || mode === \"read\";\n    this._write = readAndWrite || mode === \"create\";\n    this._prune = mode === \"update\";\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  _createClass(SyncModuleIdsPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var _this = this;\n\n      /** @type {Map<string, string | number>} */\n      var data;\n      var dataChanged = false;\n\n      if (this._read) {\n        compiler.hooks.readRecords.tapAsync(plugin, function (callback) {\n          var fs = compiler.intermediateFileSystem;\n          fs.readFile(_this._path, function (err, buffer) {\n            if (err) {\n              if (err.code !== \"ENOENT\") {\n                return callback(err);\n              }\n\n              return callback();\n            }\n\n            var json = JSON.parse(buffer.toString());\n            data = new Map();\n\n            for (var _i = 0, _Object$keys = Object.keys(json); _i < _Object$keys.length; _i++) {\n              var key = _Object$keys[_i];\n              data.set(key, json[key]);\n            }\n\n            dataChanged = false;\n            return callback();\n          });\n        });\n      }\n\n      if (this._write) {\n        compiler.hooks.emitRecords.tapAsync(plugin, function (callback) {\n          if (!data || !dataChanged) return callback();\n          var json = {};\n          var sorted = Array.from(data).sort(function (_ref2, _ref3) {\n            var _ref4 = _slicedToArray(_ref2, 1),\n                a = _ref4[0];\n\n            var _ref5 = _slicedToArray(_ref3, 1),\n                b = _ref5[0];\n\n            return a < b ? -1 : 1;\n          });\n\n          var _iterator = _createForOfIteratorHelper(sorted),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _step$value = _slicedToArray(_step.value, 2),\n                  key = _step$value[0],\n                  value = _step$value[1];\n\n              json[key] = value;\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          var fs = compiler.intermediateFileSystem;\n          fs.writeFile(_this._path, JSON.stringify(json), callback);\n        });\n      }\n\n      compiler.hooks.thisCompilation.tap(plugin, function (compilation) {\n        var associatedObjectForCache = compiler.root;\n        var context = _this._context || compiler.context;\n\n        if (_this._read) {\n          compilation.hooks.reviveModules.tap(plugin, function (_1, _2) {\n            if (!data) return;\n            var chunkGraph = compilation.chunkGraph;\n\n            var _getUsedModuleIdsAndM = getUsedModuleIdsAndModules(compilation, _this._test),\n                _getUsedModuleIdsAndM2 = _slicedToArray(_getUsedModuleIdsAndM, 2),\n                usedIds = _getUsedModuleIdsAndM2[0],\n                modules = _getUsedModuleIdsAndM2[1];\n\n            var _iterator2 = _createForOfIteratorHelper(modules),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var _module = _step2.value;\n\n                var name = _module.libIdent({\n                  context: context,\n                  associatedObjectForCache: associatedObjectForCache\n                });\n\n                if (!name) continue;\n                var id = data.get(name);\n                var idAsString = \"\".concat(id);\n\n                if (usedIds.has(idAsString)) {\n                  var err = new WebpackError(\"SyncModuleIdsPlugin: Unable to restore id '\".concat(id, \"' from '\").concat(_this._path, \"' as it's already used.\"));\n                  err.module = _module;\n                  compilation.errors.push(err);\n                }\n\n                chunkGraph.setModuleId(_module, id);\n                usedIds.add(idAsString);\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          });\n        }\n\n        if (_this._write) {\n          compilation.hooks.recordModules.tap(plugin, function (modules) {\n            var chunkGraph = compilation.chunkGraph;\n            var oldData = data;\n\n            if (!oldData) {\n              oldData = data = new Map();\n            } else if (_this._prune) {\n              data = new Map();\n            }\n\n            var _iterator3 = _createForOfIteratorHelper(modules),\n                _step3;\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var _module2 = _step3.value;\n\n                if (_this._test(_module2)) {\n                  var name = _module2.libIdent({\n                    context: context,\n                    associatedObjectForCache: associatedObjectForCache\n                  });\n\n                  if (!name) continue;\n                  var id = chunkGraph.getModuleId(_module2);\n                  if (id === null) continue;\n                  var oldId = oldData.get(name);\n\n                  if (oldId !== id) {\n                    dataChanged = true;\n                  } else if (data === oldData) {\n                    continue;\n                  }\n\n                  data.set(name, id);\n                }\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n\n            if (data.size !== oldData.size) dataChanged = true;\n          });\n        }\n      });\n    }\n  }]);\n\n  return SyncModuleIdsPlugin;\n}();\n\nmodule.exports = SyncModuleIdsPlugin;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/ids/SyncModuleIdsPlugin.js"],"names":["require","WebpackError","getUsedModuleIdsAndModules","plugin","SyncModuleIdsPlugin","path","context","test","mode","_path","_context","_test","readAndWrite","_read","_write","_prune","compiler","data","dataChanged","hooks","readRecords","tapAsync","callback","fs","intermediateFileSystem","readFile","err","buffer","code","json","JSON","parse","toString","Map","Object","keys","key","set","emitRecords","sorted","Array","from","sort","a","b","value","writeFile","stringify","thisCompilation","tap","compilation","associatedObjectForCache","root","reviveModules","_1","_2","chunkGraph","usedIds","modules","module","name","libIdent","id","get","idAsString","has","errors","push","setModuleId","add","recordModules","oldData","getModuleId","oldId","size","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { WebpackError } = require(\"..\");\nconst { getUsedModuleIdsAndModules } = require(\"./IdHelpers\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\nconst plugin = \"SyncModuleIdsPlugin\";\n\nclass SyncModuleIdsPlugin {\n\t/**\n\t * @param {Object} options options\n\t * @param {string} options.path path to file\n\t * @param {string=} options.context context for module names\n\t * @param {function(Module): boolean} options.test selector for modules\n\t * @param {\"read\" | \"create\" | \"merge\" | \"update\"=} options.mode operation mode (defaults to merge)\n\t */\n\tconstructor({ path, context, test, mode }) {\n\t\tthis._path = path;\n\t\tthis._context = context;\n\t\tthis._test = test || (() => true);\n\t\tconst readAndWrite = !mode || mode === \"merge\" || mode === \"update\";\n\t\tthis._read = readAndWrite || mode === \"read\";\n\t\tthis._write = readAndWrite || mode === \"create\";\n\t\tthis._prune = mode === \"update\";\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\t/** @type {Map<string, string | number>} */\n\t\tlet data;\n\t\tlet dataChanged = false;\n\t\tif (this._read) {\n\t\t\tcompiler.hooks.readRecords.tapAsync(plugin, callback => {\n\t\t\t\tconst fs = compiler.intermediateFileSystem;\n\t\t\t\tfs.readFile(this._path, (err, buffer) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tif (err.code !== \"ENOENT\") {\n\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn callback();\n\t\t\t\t\t}\n\t\t\t\t\tconst json = JSON.parse(buffer.toString());\n\t\t\t\t\tdata = new Map();\n\t\t\t\t\tfor (const key of Object.keys(json)) {\n\t\t\t\t\t\tdata.set(key, json[key]);\n\t\t\t\t\t}\n\t\t\t\t\tdataChanged = false;\n\t\t\t\t\treturn callback();\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\tif (this._write) {\n\t\t\tcompiler.hooks.emitRecords.tapAsync(plugin, callback => {\n\t\t\t\tif (!data || !dataChanged) return callback();\n\t\t\t\tconst json = {};\n\t\t\t\tconst sorted = Array.from(data).sort(([a], [b]) => (a < b ? -1 : 1));\n\t\t\t\tfor (const [key, value] of sorted) {\n\t\t\t\t\tjson[key] = value;\n\t\t\t\t}\n\t\t\t\tconst fs = compiler.intermediateFileSystem;\n\t\t\t\tfs.writeFile(this._path, JSON.stringify(json), callback);\n\t\t\t});\n\t\t}\n\t\tcompiler.hooks.thisCompilation.tap(plugin, compilation => {\n\t\t\tconst associatedObjectForCache = compiler.root;\n\t\t\tconst context = this._context || compiler.context;\n\t\t\tif (this._read) {\n\t\t\t\tcompilation.hooks.reviveModules.tap(plugin, (_1, _2) => {\n\t\t\t\t\tif (!data) return;\n\t\t\t\t\tconst { chunkGraph } = compilation;\n\t\t\t\t\tconst [usedIds, modules] = getUsedModuleIdsAndModules(\n\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\tthis._test\n\t\t\t\t\t);\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\tconst name = module.libIdent({\n\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\tassociatedObjectForCache\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (!name) continue;\n\t\t\t\t\t\tconst id = data.get(name);\n\t\t\t\t\t\tconst idAsString = `${id}`;\n\t\t\t\t\t\tif (usedIds.has(idAsString)) {\n\t\t\t\t\t\t\tconst err = new WebpackError(\n\t\t\t\t\t\t\t\t`SyncModuleIdsPlugin: Unable to restore id '${id}' from '${this._path}' as it's already used.`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\terr.module = module;\n\t\t\t\t\t\t\tcompilation.errors.push(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchunkGraph.setModuleId(module, id);\n\t\t\t\t\t\tusedIds.add(idAsString);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (this._write) {\n\t\t\t\tcompilation.hooks.recordModules.tap(plugin, modules => {\n\t\t\t\t\tconst { chunkGraph } = compilation;\n\t\t\t\t\tlet oldData = data;\n\t\t\t\t\tif (!oldData) {\n\t\t\t\t\t\toldData = data = new Map();\n\t\t\t\t\t} else if (this._prune) {\n\t\t\t\t\t\tdata = new Map();\n\t\t\t\t\t}\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\tif (this._test(module)) {\n\t\t\t\t\t\t\tconst name = module.libIdent({\n\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\tassociatedObjectForCache\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif (!name) continue;\n\t\t\t\t\t\t\tconst id = chunkGraph.getModuleId(module);\n\t\t\t\t\t\t\tif (id === null) continue;\n\t\t\t\t\t\t\tconst oldId = oldData.get(name);\n\t\t\t\t\t\t\tif (oldId !== id) {\n\t\t\t\t\t\t\t\tdataChanged = true;\n\t\t\t\t\t\t\t} else if (data === oldData) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdata.set(name, id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (data.size !== oldData.size) dataChanged = true;\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n}\n\nmodule.exports = SyncModuleIdsPlugin;\n"]},"metadata":{},"sourceType":"script"}