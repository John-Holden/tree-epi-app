{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\"use strict\";\n\nvar _objectSpread = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _require = require(\"chrome-trace-event\"),\n    Tracer = _require.Tracer;\n\nvar createSchemaValidation = require(\"../util/create-schema-validation\");\n\nvar _require2 = require(\"../util/fs\"),\n    dirname = _require2.dirname,\n    mkdirpSync = _require2.mkdirpSync;\n/** @typedef {import(\"../../declarations/plugins/debug/ProfilingPlugin\").ProfilingPluginOptions} ProfilingPluginOptions */\n\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\n\nvar validate = createSchemaValidation(require(\"../../schemas/plugins/debug/ProfilingPlugin.check.js\"), function () {\n  return require(\"../../schemas/plugins/debug/ProfilingPlugin.json\");\n}, {\n  name: \"Profiling Plugin\",\n  baseDataPath: \"options\"\n});\nvar inspector = undefined;\n\ntry {\n  // eslint-disable-next-line node/no-unsupported-features/node-builtins\n  inspector = require(\"inspector\");\n} catch (e) {\n  console.log(\"Unable to CPU profile in < node 8.0\");\n}\n\nvar Profiler = /*#__PURE__*/function () {\n  function Profiler(inspector) {\n    _classCallCheck(this, Profiler);\n\n    this.session = undefined;\n    this.inspector = inspector;\n    this._startTime = 0;\n  }\n\n  _createClass(Profiler, [{\n    key: \"hasSession\",\n    value: function hasSession() {\n      return this.session !== undefined;\n    }\n  }, {\n    key: \"startProfiling\",\n    value: function startProfiling() {\n      if (this.inspector === undefined) {\n        return Promise.resolve();\n      }\n\n      try {\n        this.session = new inspector.Session();\n        this.session.connect();\n      } catch (_) {\n        this.session = undefined;\n        return Promise.resolve();\n      }\n\n      var hrtime = process.hrtime();\n      this._startTime = hrtime[0] * 1000000 + Math.round(hrtime[1] / 1000);\n      return Promise.all([this.sendCommand(\"Profiler.setSamplingInterval\", {\n        interval: 100\n      }), this.sendCommand(\"Profiler.enable\"), this.sendCommand(\"Profiler.start\")]);\n    }\n  }, {\n    key: \"sendCommand\",\n    value: function sendCommand(method, params) {\n      var _this = this;\n\n      if (this.hasSession()) {\n        return new Promise(function (res, rej) {\n          return _this.session.post(method, params, function (err, params) {\n            if (err !== null) {\n              rej(err);\n            } else {\n              res(params);\n            }\n          });\n        });\n      } else {\n        return Promise.resolve();\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.hasSession()) {\n        this.session.disconnect();\n      }\n\n      return Promise.resolve();\n    }\n  }, {\n    key: \"stopProfiling\",\n    value: function stopProfiling() {\n      var _this2 = this;\n\n      return this.sendCommand(\"Profiler.stop\").then(function (_ref) {\n        var profile = _ref.profile;\n        var hrtime = process.hrtime();\n        var endTime = hrtime[0] * 1000000 + Math.round(hrtime[1] / 1000);\n\n        if (profile.startTime < _this2._startTime || profile.endTime > endTime) {\n          // In some cases timestamps mismatch and we need to adjust them\n          // Both process.hrtime and the inspector timestamps claim to be relative\n          // to a unknown point in time. But they do not guarantee that this is the\n          // same point in time.\n          var duration = profile.endTime - profile.startTime;\n          var ownDuration = endTime - _this2._startTime;\n          var untracked = Math.max(0, ownDuration - duration);\n          profile.startTime = _this2._startTime + untracked / 2;\n          profile.endTime = endTime - untracked / 2;\n        }\n\n        return {\n          profile: profile\n        };\n      });\n    }\n  }]);\n\n  return Profiler;\n}();\n/**\n * an object that wraps Tracer and Profiler with a counter\n * @typedef {Object} Trace\n * @property {Tracer} trace instance of Tracer\n * @property {number} counter Counter\n * @property {Profiler} profiler instance of Profiler\n * @property {Function} end the end function\n */\n\n/**\n * @param {IntermediateFileSystem} fs filesystem used for output\n * @param {string} outputPath The location where to write the log.\n * @returns {Trace} The trace object\n */\n\n\nvar createTrace = function createTrace(fs, outputPath) {\n  var trace = new Tracer();\n  var profiler = new Profiler(inspector);\n\n  if (/\\/|\\\\/.test(outputPath)) {\n    var dirPath = dirname(fs, outputPath);\n    mkdirpSync(fs, dirPath);\n  }\n\n  var fsStream = fs.createWriteStream(outputPath);\n  var counter = 0;\n  trace.pipe(fsStream); // These are critical events that need to be inserted so that tools like\n  // chrome dev tools can load the profile.\n\n  trace.instantEvent({\n    name: \"TracingStartedInPage\",\n    id: ++counter,\n    cat: [\"disabled-by-default-devtools.timeline\"],\n    args: {\n      data: {\n        sessionId: \"-1\",\n        page: \"0xfff\",\n        frames: [{\n          frame: \"0xfff\",\n          url: \"webpack\",\n          name: \"\"\n        }]\n      }\n    }\n  });\n  trace.instantEvent({\n    name: \"TracingStartedInBrowser\",\n    id: ++counter,\n    cat: [\"disabled-by-default-devtools.timeline\"],\n    args: {\n      data: {\n        sessionId: \"-1\"\n      }\n    }\n  });\n  return {\n    trace: trace,\n    counter: counter,\n    profiler: profiler,\n    end: function end(callback) {\n      trace.push(\"]\"); // Wait until the write stream finishes.\n\n      fsStream.on(\"close\", function () {\n        callback();\n      }); // Tear down the readable trace stream.\n\n      trace.push(null);\n    }\n  };\n};\n\nvar pluginName = \"ProfilingPlugin\";\n\nvar ProfilingPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {ProfilingPluginOptions=} options options object\n   */\n  function ProfilingPlugin() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, ProfilingPlugin);\n\n    validate(options);\n    this.outputPath = options.outputPath || \"events.json\";\n  }\n\n  _createClass(ProfilingPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var tracer = createTrace(compiler.intermediateFileSystem, this.outputPath);\n      tracer.profiler.startProfiling(); // Compiler Hooks\n\n      Object.keys(compiler.hooks).forEach(function (hookName) {\n        var hook = compiler.hooks[hookName];\n\n        if (hook) {\n          hook.intercept(makeInterceptorFor(\"Compiler\", tracer)(hookName));\n        }\n      });\n      Object.keys(compiler.resolverFactory.hooks).forEach(function (hookName) {\n        var hook = compiler.resolverFactory.hooks[hookName];\n\n        if (hook) {\n          hook.intercept(makeInterceptorFor(\"Resolver\", tracer)(hookName));\n        }\n      });\n      compiler.hooks.compilation.tap(pluginName, function (compilation, _ref2) {\n        var normalModuleFactory = _ref2.normalModuleFactory,\n            contextModuleFactory = _ref2.contextModuleFactory;\n        interceptAllHooksFor(compilation, tracer, \"Compilation\");\n        interceptAllHooksFor(normalModuleFactory, tracer, \"Normal Module Factory\");\n        interceptAllHooksFor(contextModuleFactory, tracer, \"Context Module Factory\");\n        interceptAllParserHooks(normalModuleFactory, tracer);\n        interceptAllJavascriptModulesPluginHooks(compilation, tracer);\n      }); // We need to write out the CPU profile when we are all done.\n\n      compiler.hooks.done.tapAsync({\n        name: pluginName,\n        stage: Infinity\n      }, function (stats, callback) {\n        if (compiler.watchMode) return callback();\n        tracer.profiler.stopProfiling().then(function (parsedResults) {\n          if (parsedResults === undefined) {\n            tracer.profiler.destroy();\n            tracer.end(callback);\n            return;\n          }\n\n          var cpuStartTime = parsedResults.profile.startTime;\n          var cpuEndTime = parsedResults.profile.endTime;\n          tracer.trace.completeEvent({\n            name: \"TaskQueueManager::ProcessTaskFromWorkQueue\",\n            id: ++tracer.counter,\n            cat: [\"toplevel\"],\n            ts: cpuStartTime,\n            args: {\n              src_file: \"../../ipc/ipc_moji_bootstrap.cc\",\n              src_func: \"Accept\"\n            }\n          });\n          tracer.trace.completeEvent({\n            name: \"EvaluateScript\",\n            id: ++tracer.counter,\n            cat: [\"devtools.timeline\"],\n            ts: cpuStartTime,\n            dur: cpuEndTime - cpuStartTime,\n            args: {\n              data: {\n                url: \"webpack\",\n                lineNumber: 1,\n                columnNumber: 1,\n                frame: \"0xFFF\"\n              }\n            }\n          });\n          tracer.trace.instantEvent({\n            name: \"CpuProfile\",\n            id: ++tracer.counter,\n            cat: [\"disabled-by-default-devtools.timeline\"],\n            ts: cpuEndTime,\n            args: {\n              data: {\n                cpuProfile: parsedResults.profile\n              }\n            }\n          });\n          tracer.profiler.destroy();\n          tracer.end(callback);\n        });\n      });\n    }\n  }]);\n\n  return ProfilingPlugin;\n}();\n\nvar interceptAllHooksFor = function interceptAllHooksFor(instance, tracer, logLabel) {\n  if (Reflect.has(instance, \"hooks\")) {\n    Object.keys(instance.hooks).forEach(function (hookName) {\n      var hook = instance.hooks[hookName];\n\n      if (hook && !hook._fakeHook) {\n        hook.intercept(makeInterceptorFor(logLabel, tracer)(hookName));\n      }\n    });\n  }\n};\n\nvar interceptAllParserHooks = function interceptAllParserHooks(moduleFactory, tracer) {\n  var moduleTypes = [\"javascript/auto\", \"javascript/dynamic\", \"javascript/esm\", \"json\", \"webassembly/async\", \"webassembly/sync\"];\n  moduleTypes.forEach(function (moduleType) {\n    moduleFactory.hooks.parser.for(moduleType).tap(\"ProfilingPlugin\", function (parser, parserOpts) {\n      interceptAllHooksFor(parser, tracer, \"Parser\");\n    });\n  });\n};\n\nvar interceptAllJavascriptModulesPluginHooks = function interceptAllJavascriptModulesPluginHooks(compilation, tracer) {\n  interceptAllHooksFor({\n    hooks: require(\"../javascript/JavascriptModulesPlugin\").getCompilationHooks(compilation)\n  }, tracer, \"JavascriptModulesPlugin\");\n};\n\nvar makeInterceptorFor = function makeInterceptorFor(instance, tracer) {\n  return function (hookName) {\n    return {\n      register: function register(tapInfo) {\n        var name = tapInfo.name,\n            type = tapInfo.type,\n            fn = tapInfo.fn;\n        var newFn = // Don't tap our own hooks to ensure stream can close cleanly\n        name === pluginName ? fn : makeNewProfiledTapFn(hookName, tracer, {\n          name: name,\n          type: type,\n          fn: fn\n        });\n        return _objectSpread(_objectSpread({}, tapInfo), {}, {\n          fn: newFn\n        });\n      }\n    };\n  };\n}; // TODO improve typing\n\n/** @typedef {(...args: TODO[]) => void | Promise<TODO>} PluginFunction */\n\n/**\n * @param {string} hookName Name of the hook to profile.\n * @param {Trace} tracer The trace object.\n * @param {object} options Options for the profiled fn.\n * @param {string} options.name Plugin name\n * @param {string} options.type Plugin type (sync | async | promise)\n * @param {PluginFunction} options.fn Plugin function\n * @returns {PluginFunction} Chainable hooked function.\n */\n\n\nvar makeNewProfiledTapFn = function makeNewProfiledTapFn(hookName, tracer, _ref3) {\n  var name = _ref3.name,\n      type = _ref3.type,\n      fn = _ref3.fn;\n  var defaultCategory = [\"blink.user_timing\"];\n\n  switch (type) {\n    case \"promise\":\n      return function () {\n        var id = ++tracer.counter;\n        tracer.trace.begin({\n          name: name,\n          id: id,\n          cat: defaultCategory\n        });\n        var promise =\n        /** @type {Promise<*>} */\n        fn.apply(void 0, arguments);\n        return promise.then(function (r) {\n          tracer.trace.end({\n            name: name,\n            id: id,\n            cat: defaultCategory\n          });\n          return r;\n        });\n      };\n\n    case \"async\":\n      return function () {\n        var id = ++tracer.counter;\n        tracer.trace.begin({\n          name: name,\n          id: id,\n          cat: defaultCategory\n        });\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        var callback = args.pop();\n        fn.apply(void 0, args.concat([function () {\n          tracer.trace.end({\n            name: name,\n            id: id,\n            cat: defaultCategory\n          });\n          callback.apply(void 0, arguments);\n        }]));\n      };\n\n    case \"sync\":\n      return function () {\n        var id = ++tracer.counter; // Do not instrument ourself due to the CPU\n        // profile needing to be the last event in the trace.\n\n        if (name === pluginName) {\n          return fn.apply(void 0, arguments);\n        }\n\n        tracer.trace.begin({\n          name: name,\n          id: id,\n          cat: defaultCategory\n        });\n        var r;\n\n        try {\n          r = fn.apply(void 0, arguments);\n        } catch (error) {\n          tracer.trace.end({\n            name: name,\n            id: id,\n            cat: defaultCategory\n          });\n          throw error;\n        }\n\n        tracer.trace.end({\n          name: name,\n          id: id,\n          cat: defaultCategory\n        });\n        return r;\n      };\n\n    default:\n      break;\n  }\n};\n\nmodule.exports = ProfilingPlugin;\nmodule.exports.Profiler = Profiler;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/debug/ProfilingPlugin.js"],"names":["require","Tracer","createSchemaValidation","dirname","mkdirpSync","validate","name","baseDataPath","inspector","undefined","e","console","log","Profiler","session","_startTime","Promise","resolve","Session","connect","_","hrtime","process","Math","round","all","sendCommand","interval","method","params","hasSession","res","rej","post","err","disconnect","then","profile","endTime","startTime","duration","ownDuration","untracked","max","createTrace","fs","outputPath","trace","profiler","test","dirPath","fsStream","createWriteStream","counter","pipe","instantEvent","id","cat","args","data","sessionId","page","frames","frame","url","end","callback","push","on","pluginName","ProfilingPlugin","options","compiler","tracer","intermediateFileSystem","startProfiling","Object","keys","hooks","forEach","hookName","hook","intercept","makeInterceptorFor","resolverFactory","compilation","tap","normalModuleFactory","contextModuleFactory","interceptAllHooksFor","interceptAllParserHooks","interceptAllJavascriptModulesPluginHooks","done","tapAsync","stage","Infinity","stats","watchMode","stopProfiling","parsedResults","destroy","cpuStartTime","cpuEndTime","completeEvent","ts","src_file","src_func","dur","lineNumber","columnNumber","cpuProfile","instance","logLabel","Reflect","has","_fakeHook","moduleFactory","moduleTypes","moduleType","parser","for","parserOpts","getCompilationHooks","register","tapInfo","type","fn","newFn","makeNewProfiledTapFn","defaultCategory","begin","promise","r","pop","error","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst { Tracer } = require(\"chrome-trace-event\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst { dirname, mkdirpSync } = require(\"../util/fs\");\n\n/** @typedef {import(\"../../declarations/plugins/debug/ProfilingPlugin\").ProfilingPluginOptions} ProfilingPluginOptions */\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/debug/ProfilingPlugin.check.js\"),\n\t() => require(\"../../schemas/plugins/debug/ProfilingPlugin.json\"),\n\t{\n\t\tname: \"Profiling Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\nlet inspector = undefined;\n\ntry {\n\t// eslint-disable-next-line node/no-unsupported-features/node-builtins\n\tinspector = require(\"inspector\");\n} catch (e) {\n\tconsole.log(\"Unable to CPU profile in < node 8.0\");\n}\n\nclass Profiler {\n\tconstructor(inspector) {\n\t\tthis.session = undefined;\n\t\tthis.inspector = inspector;\n\t\tthis._startTime = 0;\n\t}\n\n\thasSession() {\n\t\treturn this.session !== undefined;\n\t}\n\n\tstartProfiling() {\n\t\tif (this.inspector === undefined) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\ttry {\n\t\t\tthis.session = new inspector.Session();\n\t\t\tthis.session.connect();\n\t\t} catch (_) {\n\t\t\tthis.session = undefined;\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tconst hrtime = process.hrtime();\n\t\tthis._startTime = hrtime[0] * 1000000 + Math.round(hrtime[1] / 1000);\n\n\t\treturn Promise.all([\n\t\t\tthis.sendCommand(\"Profiler.setSamplingInterval\", {\n\t\t\t\tinterval: 100\n\t\t\t}),\n\t\t\tthis.sendCommand(\"Profiler.enable\"),\n\t\t\tthis.sendCommand(\"Profiler.start\")\n\t\t]);\n\t}\n\n\tsendCommand(method, params) {\n\t\tif (this.hasSession()) {\n\t\t\treturn new Promise((res, rej) => {\n\t\t\t\treturn this.session.post(method, params, (err, params) => {\n\t\t\t\t\tif (err !== null) {\n\t\t\t\t\t\trej(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres(params);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tif (this.hasSession()) {\n\t\t\tthis.session.disconnect();\n\t\t}\n\n\t\treturn Promise.resolve();\n\t}\n\n\tstopProfiling() {\n\t\treturn this.sendCommand(\"Profiler.stop\").then(({ profile }) => {\n\t\t\tconst hrtime = process.hrtime();\n\t\t\tconst endTime = hrtime[0] * 1000000 + Math.round(hrtime[1] / 1000);\n\t\t\tif (profile.startTime < this._startTime || profile.endTime > endTime) {\n\t\t\t\t// In some cases timestamps mismatch and we need to adjust them\n\t\t\t\t// Both process.hrtime and the inspector timestamps claim to be relative\n\t\t\t\t// to a unknown point in time. But they do not guarantee that this is the\n\t\t\t\t// same point in time.\n\t\t\t\tconst duration = profile.endTime - profile.startTime;\n\t\t\t\tconst ownDuration = endTime - this._startTime;\n\t\t\t\tconst untracked = Math.max(0, ownDuration - duration);\n\t\t\t\tprofile.startTime = this._startTime + untracked / 2;\n\t\t\t\tprofile.endTime = endTime - untracked / 2;\n\t\t\t}\n\t\t\treturn { profile };\n\t\t});\n\t}\n}\n\n/**\n * an object that wraps Tracer and Profiler with a counter\n * @typedef {Object} Trace\n * @property {Tracer} trace instance of Tracer\n * @property {number} counter Counter\n * @property {Profiler} profiler instance of Profiler\n * @property {Function} end the end function\n */\n\n/**\n * @param {IntermediateFileSystem} fs filesystem used for output\n * @param {string} outputPath The location where to write the log.\n * @returns {Trace} The trace object\n */\nconst createTrace = (fs, outputPath) => {\n\tconst trace = new Tracer();\n\tconst profiler = new Profiler(inspector);\n\tif (/\\/|\\\\/.test(outputPath)) {\n\t\tconst dirPath = dirname(fs, outputPath);\n\t\tmkdirpSync(fs, dirPath);\n\t}\n\tconst fsStream = fs.createWriteStream(outputPath);\n\n\tlet counter = 0;\n\n\ttrace.pipe(fsStream);\n\t// These are critical events that need to be inserted so that tools like\n\t// chrome dev tools can load the profile.\n\ttrace.instantEvent({\n\t\tname: \"TracingStartedInPage\",\n\t\tid: ++counter,\n\t\tcat: [\"disabled-by-default-devtools.timeline\"],\n\t\targs: {\n\t\t\tdata: {\n\t\t\t\tsessionId: \"-1\",\n\t\t\t\tpage: \"0xfff\",\n\t\t\t\tframes: [\n\t\t\t\t\t{\n\t\t\t\t\t\tframe: \"0xfff\",\n\t\t\t\t\t\turl: \"webpack\",\n\t\t\t\t\t\tname: \"\"\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t}\n\t});\n\n\ttrace.instantEvent({\n\t\tname: \"TracingStartedInBrowser\",\n\t\tid: ++counter,\n\t\tcat: [\"disabled-by-default-devtools.timeline\"],\n\t\targs: {\n\t\t\tdata: {\n\t\t\t\tsessionId: \"-1\"\n\t\t\t}\n\t\t}\n\t});\n\n\treturn {\n\t\ttrace,\n\t\tcounter,\n\t\tprofiler,\n\t\tend: callback => {\n\t\t\ttrace.push(\"]\");\n\t\t\t// Wait until the write stream finishes.\n\t\t\tfsStream.on(\"close\", () => {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t\t// Tear down the readable trace stream.\n\t\t\ttrace.push(null);\n\t\t}\n\t};\n};\n\nconst pluginName = \"ProfilingPlugin\";\n\nclass ProfilingPlugin {\n\t/**\n\t * @param {ProfilingPluginOptions=} options options object\n\t */\n\tconstructor(options = {}) {\n\t\tvalidate(options);\n\t\tthis.outputPath = options.outputPath || \"events.json\";\n\t}\n\n\tapply(compiler) {\n\t\tconst tracer = createTrace(\n\t\t\tcompiler.intermediateFileSystem,\n\t\t\tthis.outputPath\n\t\t);\n\t\ttracer.profiler.startProfiling();\n\n\t\t// Compiler Hooks\n\t\tObject.keys(compiler.hooks).forEach(hookName => {\n\t\t\tconst hook = compiler.hooks[hookName];\n\t\t\tif (hook) {\n\t\t\t\thook.intercept(makeInterceptorFor(\"Compiler\", tracer)(hookName));\n\t\t\t}\n\t\t});\n\n\t\tObject.keys(compiler.resolverFactory.hooks).forEach(hookName => {\n\t\t\tconst hook = compiler.resolverFactory.hooks[hookName];\n\t\t\tif (hook) {\n\t\t\t\thook.intercept(makeInterceptorFor(\"Resolver\", tracer)(hookName));\n\t\t\t}\n\t\t});\n\n\t\tcompiler.hooks.compilation.tap(\n\t\t\tpluginName,\n\t\t\t(compilation, { normalModuleFactory, contextModuleFactory }) => {\n\t\t\t\tinterceptAllHooksFor(compilation, tracer, \"Compilation\");\n\t\t\t\tinterceptAllHooksFor(\n\t\t\t\t\tnormalModuleFactory,\n\t\t\t\t\ttracer,\n\t\t\t\t\t\"Normal Module Factory\"\n\t\t\t\t);\n\t\t\t\tinterceptAllHooksFor(\n\t\t\t\t\tcontextModuleFactory,\n\t\t\t\t\ttracer,\n\t\t\t\t\t\"Context Module Factory\"\n\t\t\t\t);\n\t\t\t\tinterceptAllParserHooks(normalModuleFactory, tracer);\n\t\t\t\tinterceptAllJavascriptModulesPluginHooks(compilation, tracer);\n\t\t\t}\n\t\t);\n\n\t\t// We need to write out the CPU profile when we are all done.\n\t\tcompiler.hooks.done.tapAsync(\n\t\t\t{\n\t\t\t\tname: pluginName,\n\t\t\t\tstage: Infinity\n\t\t\t},\n\t\t\t(stats, callback) => {\n\t\t\t\tif (compiler.watchMode) return callback();\n\t\t\t\ttracer.profiler.stopProfiling().then(parsedResults => {\n\t\t\t\t\tif (parsedResults === undefined) {\n\t\t\t\t\t\ttracer.profiler.destroy();\n\t\t\t\t\t\ttracer.end(callback);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cpuStartTime = parsedResults.profile.startTime;\n\t\t\t\t\tconst cpuEndTime = parsedResults.profile.endTime;\n\n\t\t\t\t\ttracer.trace.completeEvent({\n\t\t\t\t\t\tname: \"TaskQueueManager::ProcessTaskFromWorkQueue\",\n\t\t\t\t\t\tid: ++tracer.counter,\n\t\t\t\t\t\tcat: [\"toplevel\"],\n\t\t\t\t\t\tts: cpuStartTime,\n\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\tsrc_file: \"../../ipc/ipc_moji_bootstrap.cc\",\n\t\t\t\t\t\t\tsrc_func: \"Accept\"\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\ttracer.trace.completeEvent({\n\t\t\t\t\t\tname: \"EvaluateScript\",\n\t\t\t\t\t\tid: ++tracer.counter,\n\t\t\t\t\t\tcat: [\"devtools.timeline\"],\n\t\t\t\t\t\tts: cpuStartTime,\n\t\t\t\t\t\tdur: cpuEndTime - cpuStartTime,\n\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\turl: \"webpack\",\n\t\t\t\t\t\t\t\tlineNumber: 1,\n\t\t\t\t\t\t\t\tcolumnNumber: 1,\n\t\t\t\t\t\t\t\tframe: \"0xFFF\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\ttracer.trace.instantEvent({\n\t\t\t\t\t\tname: \"CpuProfile\",\n\t\t\t\t\t\tid: ++tracer.counter,\n\t\t\t\t\t\tcat: [\"disabled-by-default-devtools.timeline\"],\n\t\t\t\t\t\tts: cpuEndTime,\n\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\tcpuProfile: parsedResults.profile\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\ttracer.profiler.destroy();\n\t\t\t\t\ttracer.end(callback);\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t}\n}\n\nconst interceptAllHooksFor = (instance, tracer, logLabel) => {\n\tif (Reflect.has(instance, \"hooks\")) {\n\t\tObject.keys(instance.hooks).forEach(hookName => {\n\t\t\tconst hook = instance.hooks[hookName];\n\t\t\tif (hook && !hook._fakeHook) {\n\t\t\t\thook.intercept(makeInterceptorFor(logLabel, tracer)(hookName));\n\t\t\t}\n\t\t});\n\t}\n};\n\nconst interceptAllParserHooks = (moduleFactory, tracer) => {\n\tconst moduleTypes = [\n\t\t\"javascript/auto\",\n\t\t\"javascript/dynamic\",\n\t\t\"javascript/esm\",\n\t\t\"json\",\n\t\t\"webassembly/async\",\n\t\t\"webassembly/sync\"\n\t];\n\n\tmoduleTypes.forEach(moduleType => {\n\t\tmoduleFactory.hooks.parser\n\t\t\t.for(moduleType)\n\t\t\t.tap(\"ProfilingPlugin\", (parser, parserOpts) => {\n\t\t\t\tinterceptAllHooksFor(parser, tracer, \"Parser\");\n\t\t\t});\n\t});\n};\n\nconst interceptAllJavascriptModulesPluginHooks = (compilation, tracer) => {\n\tinterceptAllHooksFor(\n\t\t{\n\t\t\thooks:\n\t\t\t\trequire(\"../javascript/JavascriptModulesPlugin\").getCompilationHooks(\n\t\t\t\t\tcompilation\n\t\t\t\t)\n\t\t},\n\t\ttracer,\n\t\t\"JavascriptModulesPlugin\"\n\t);\n};\n\nconst makeInterceptorFor = (instance, tracer) => hookName => ({\n\tregister: tapInfo => {\n\t\tconst { name, type, fn } = tapInfo;\n\t\tconst newFn =\n\t\t\t// Don't tap our own hooks to ensure stream can close cleanly\n\t\t\tname === pluginName\n\t\t\t\t? fn\n\t\t\t\t: makeNewProfiledTapFn(hookName, tracer, {\n\t\t\t\t\t\tname,\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\tfn\n\t\t\t\t  });\n\t\treturn {\n\t\t\t...tapInfo,\n\t\t\tfn: newFn\n\t\t};\n\t}\n});\n\n// TODO improve typing\n/** @typedef {(...args: TODO[]) => void | Promise<TODO>} PluginFunction */\n\n/**\n * @param {string} hookName Name of the hook to profile.\n * @param {Trace} tracer The trace object.\n * @param {object} options Options for the profiled fn.\n * @param {string} options.name Plugin name\n * @param {string} options.type Plugin type (sync | async | promise)\n * @param {PluginFunction} options.fn Plugin function\n * @returns {PluginFunction} Chainable hooked function.\n */\nconst makeNewProfiledTapFn = (hookName, tracer, { name, type, fn }) => {\n\tconst defaultCategory = [\"blink.user_timing\"];\n\n\tswitch (type) {\n\t\tcase \"promise\":\n\t\t\treturn (...args) => {\n\t\t\t\tconst id = ++tracer.counter;\n\t\t\t\ttracer.trace.begin({\n\t\t\t\t\tname,\n\t\t\t\t\tid,\n\t\t\t\t\tcat: defaultCategory\n\t\t\t\t});\n\t\t\t\tconst promise = /** @type {Promise<*>} */ (fn(...args));\n\t\t\t\treturn promise.then(r => {\n\t\t\t\t\ttracer.trace.end({\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tcat: defaultCategory\n\t\t\t\t\t});\n\t\t\t\t\treturn r;\n\t\t\t\t});\n\t\t\t};\n\t\tcase \"async\":\n\t\t\treturn (...args) => {\n\t\t\t\tconst id = ++tracer.counter;\n\t\t\t\ttracer.trace.begin({\n\t\t\t\t\tname,\n\t\t\t\t\tid,\n\t\t\t\t\tcat: defaultCategory\n\t\t\t\t});\n\t\t\t\tconst callback = args.pop();\n\t\t\t\tfn(...args, (...r) => {\n\t\t\t\t\ttracer.trace.end({\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tcat: defaultCategory\n\t\t\t\t\t});\n\t\t\t\t\tcallback(...r);\n\t\t\t\t});\n\t\t\t};\n\t\tcase \"sync\":\n\t\t\treturn (...args) => {\n\t\t\t\tconst id = ++tracer.counter;\n\t\t\t\t// Do not instrument ourself due to the CPU\n\t\t\t\t// profile needing to be the last event in the trace.\n\t\t\t\tif (name === pluginName) {\n\t\t\t\t\treturn fn(...args);\n\t\t\t\t}\n\n\t\t\t\ttracer.trace.begin({\n\t\t\t\t\tname,\n\t\t\t\t\tid,\n\t\t\t\t\tcat: defaultCategory\n\t\t\t\t});\n\t\t\t\tlet r;\n\t\t\t\ttry {\n\t\t\t\t\tr = fn(...args);\n\t\t\t\t} catch (error) {\n\t\t\t\t\ttracer.trace.end({\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tcat: defaultCategory\n\t\t\t\t\t});\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t\ttracer.trace.end({\n\t\t\t\t\tname,\n\t\t\t\t\tid,\n\t\t\t\t\tcat: defaultCategory\n\t\t\t\t});\n\t\t\t\treturn r;\n\t\t\t};\n\t\tdefault:\n\t\t\tbreak;\n\t}\n};\n\nmodule.exports = ProfilingPlugin;\nmodule.exports.Profiler = Profiler;\n"]},"metadata":{},"sourceType":"script"}