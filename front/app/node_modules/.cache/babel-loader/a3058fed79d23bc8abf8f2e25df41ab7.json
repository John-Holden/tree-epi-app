{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Sergey Melyukov @smelukov\n*/\n\"use strict\";\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _slicedToArray = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _require = require(\"../ExportsInfo\"),\n    UsageState = _require.UsageState;\n/** @typedef {import(\"estree\").Node} AnyNode */\n\n/** @typedef {import(\"../Dependency\")} Dependency */\n\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n\n/** @typedef {import(\"../ModuleGraphConnection\").ConnectionState} ConnectionState */\n\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @typedef {Map<TopLevelSymbol | null, Set<string | TopLevelSymbol> | true>} InnerGraph */\n\n/** @typedef {function(boolean | Set<string> | undefined): void} UsageCallback */\n\n/**\n * @typedef {Object} StateObject\n * @property {InnerGraph} innerGraph\n * @property {TopLevelSymbol=} currentTopLevelSymbol\n * @property {Map<TopLevelSymbol, Set<UsageCallback>>} usageCallbackMap\n */\n\n/** @typedef {false|StateObject} State */\n\n/** @type {WeakMap<ParserState, State>} */\n\n\nvar parserStateMap = new WeakMap();\nvar topLevelSymbolTag = Symbol(\"top level symbol\");\n/**\n * @param {ParserState} parserState parser state\n * @returns {State} state\n */\n\nfunction getState(parserState) {\n  return parserStateMap.get(parserState);\n}\n/**\n * @param {ParserState} parserState parser state\n * @returns {void}\n */\n\n\nexports.bailout = function (parserState) {\n  parserStateMap.set(parserState, false);\n};\n/**\n * @param {ParserState} parserState parser state\n * @returns {void}\n */\n\n\nexports.enable = function (parserState) {\n  var state = parserStateMap.get(parserState);\n\n  if (state === false) {\n    return;\n  }\n\n  parserStateMap.set(parserState, {\n    innerGraph: new Map(),\n    currentTopLevelSymbol: undefined,\n    usageCallbackMap: new Map()\n  });\n};\n/**\n * @param {ParserState} parserState parser state\n * @returns {boolean} true, when enabled\n */\n\n\nexports.isEnabled = function (parserState) {\n  var state = parserStateMap.get(parserState);\n  return !!state;\n};\n/**\n * @param {ParserState} state parser state\n * @param {TopLevelSymbol | null} symbol the symbol, or null for all symbols\n * @param {string | TopLevelSymbol | true} usage usage data\n * @returns {void}\n */\n\n\nexports.addUsage = function (state, symbol, usage) {\n  var innerGraphState = getState(state);\n\n  if (innerGraphState) {\n    var innerGraph = innerGraphState.innerGraph;\n    var info = innerGraph.get(symbol);\n\n    if (usage === true) {\n      innerGraph.set(symbol, true);\n    } else if (info === undefined) {\n      innerGraph.set(symbol, new Set([usage]));\n    } else if (info !== true) {\n      info.add(usage);\n    }\n  }\n};\n/**\n * @param {JavascriptParser} parser the parser\n * @param {string} name name of variable\n * @param {string | TopLevelSymbol | true} usage usage data\n * @returns {void}\n */\n\n\nexports.addVariableUsage = function (parser, name, usage) {\n  var symbol =\n  /** @type {TopLevelSymbol} */\n  parser.getTagData(name, topLevelSymbolTag) || exports.tagTopLevelSymbol(parser, name);\n\n  if (symbol) {\n    exports.addUsage(parser.state, symbol, usage);\n  }\n};\n/**\n * @param {ParserState} state parser state\n * @returns {void}\n */\n\n\nexports.inferDependencyUsage = function (state) {\n  var innerGraphState = getState(state);\n\n  if (!innerGraphState) {\n    return;\n  }\n\n  var innerGraph = innerGraphState.innerGraph,\n      usageCallbackMap = innerGraphState.usageCallbackMap;\n  var processed = new Map(); // flatten graph to terminal nodes (string, undefined or true)\n\n  var nonTerminal = new Set(innerGraph.keys());\n\n  while (nonTerminal.size > 0) {\n    var _iterator = _createForOfIteratorHelper(nonTerminal),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var key = _step.value;\n\n        /** @type {Set<string|TopLevelSymbol> | true} */\n        var newSet = new Set();\n        var isTerminal = true;\n        var value = innerGraph.get(key);\n        var alreadyProcessed = processed.get(key);\n\n        if (alreadyProcessed === undefined) {\n          alreadyProcessed = new Set();\n          processed.set(key, alreadyProcessed);\n        }\n\n        if (value !== true && value !== undefined) {\n          var _iterator2 = _createForOfIteratorHelper(value),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var item = _step2.value;\n              alreadyProcessed.add(item);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          var _iterator3 = _createForOfIteratorHelper(value),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _item = _step3.value;\n\n              if (typeof _item === \"string\") {\n                newSet.add(_item);\n              } else {\n                var itemValue = innerGraph.get(_item);\n\n                if (itemValue === true) {\n                  newSet = true;\n                  break;\n                }\n\n                if (itemValue !== undefined) {\n                  var _iterator4 = _createForOfIteratorHelper(itemValue),\n                      _step4;\n\n                  try {\n                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                      var i = _step4.value;\n                      if (i === key) continue;\n                      if (alreadyProcessed.has(i)) continue;\n                      newSet.add(i);\n\n                      if (typeof i !== \"string\") {\n                        isTerminal = false;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator4.e(err);\n                  } finally {\n                    _iterator4.f();\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n\n          if (newSet === true) {\n            innerGraph.set(key, true);\n          } else if (newSet.size === 0) {\n            innerGraph.set(key, undefined);\n          } else {\n            innerGraph.set(key, newSet);\n          }\n        }\n\n        if (isTerminal) {\n          nonTerminal.delete(key); // For the global key, merge with all other keys\n\n          if (key === null) {\n            var globalValue = innerGraph.get(null);\n\n            if (globalValue) {\n              var _iterator5 = _createForOfIteratorHelper(innerGraph),\n                  _step5;\n\n              try {\n                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                  var _step5$value = _slicedToArray(_step5.value, 2),\n                      _key = _step5$value[0],\n                      _value = _step5$value[1];\n\n                  if (_key !== null && _value !== true) {\n                    if (globalValue === true) {\n                      innerGraph.set(_key, true);\n                    } else {\n                      var _newSet = new Set(_value);\n\n                      var _iterator6 = _createForOfIteratorHelper(globalValue),\n                          _step6;\n\n                      try {\n                        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                          var _item2 = _step6.value;\n\n                          _newSet.add(_item2);\n                        }\n                      } catch (err) {\n                        _iterator6.e(err);\n                      } finally {\n                        _iterator6.f();\n                      }\n\n                      innerGraph.set(_key, _newSet);\n                    }\n                  }\n                }\n              } catch (err) {\n                _iterator5.e(err);\n              } finally {\n                _iterator5.f();\n              }\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  /** @type {Map<Dependency, true | Set<string>>} */\n\n\n  var _iterator7 = _createForOfIteratorHelper(usageCallbackMap),\n      _step7;\n\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var _step7$value = _slicedToArray(_step7.value, 2),\n          symbol = _step7$value[0],\n          callbacks = _step7$value[1];\n\n      var usage =\n      /** @type {true | Set<string> | undefined} */\n      innerGraph.get(symbol);\n\n      var _iterator8 = _createForOfIteratorHelper(callbacks),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var callback = _step8.value;\n          callback(usage === undefined ? false : usage);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n};\n/**\n * @param {ParserState} state parser state\n * @param {UsageCallback} onUsageCallback on usage callback\n */\n\n\nexports.onUsage = function (state, onUsageCallback) {\n  var innerGraphState = getState(state);\n\n  if (innerGraphState) {\n    var usageCallbackMap = innerGraphState.usageCallbackMap,\n        currentTopLevelSymbol = innerGraphState.currentTopLevelSymbol;\n\n    if (currentTopLevelSymbol) {\n      var callbacks = usageCallbackMap.get(currentTopLevelSymbol);\n\n      if (callbacks === undefined) {\n        callbacks = new Set();\n        usageCallbackMap.set(currentTopLevelSymbol, callbacks);\n      }\n\n      callbacks.add(onUsageCallback);\n    } else {\n      onUsageCallback(true);\n    }\n  } else {\n    onUsageCallback(undefined);\n  }\n};\n/**\n * @param {ParserState} state parser state\n * @param {TopLevelSymbol} symbol the symbol\n */\n\n\nexports.setTopLevelSymbol = function (state, symbol) {\n  var innerGraphState = getState(state);\n\n  if (innerGraphState) {\n    innerGraphState.currentTopLevelSymbol = symbol;\n  }\n};\n/**\n * @param {ParserState} state parser state\n * @returns {TopLevelSymbol|void} usage data\n */\n\n\nexports.getTopLevelSymbol = function (state) {\n  var innerGraphState = getState(state);\n\n  if (innerGraphState) {\n    return innerGraphState.currentTopLevelSymbol;\n  }\n};\n/**\n * @param {JavascriptParser} parser parser\n * @param {string} name name of variable\n * @returns {TopLevelSymbol} symbol\n */\n\n\nexports.tagTopLevelSymbol = function (parser, name) {\n  var innerGraphState = getState(parser.state);\n  if (!innerGraphState) return;\n  parser.defineVariable(name);\n  var existingTag =\n  /** @type {TopLevelSymbol} */\n  parser.getTagData(name, topLevelSymbolTag);\n\n  if (existingTag) {\n    return existingTag;\n  }\n\n  var fn = new TopLevelSymbol(name);\n  parser.tagVariable(name, topLevelSymbolTag, fn);\n  return fn;\n};\n/**\n * @param {Dependency} dependency the dependency\n * @param {Set<string> | boolean} usedByExports usedByExports info\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @param {RuntimeSpec} runtime runtime\n * @returns {boolean} false, when unused. Otherwise true\n */\n\n\nexports.isDependencyUsedByExports = function (dependency, usedByExports, moduleGraph, runtime) {\n  if (usedByExports === false) return false;\n\n  if (usedByExports !== true && usedByExports !== undefined) {\n    var selfModule = moduleGraph.getParentModule(dependency);\n    var exportsInfo = moduleGraph.getExportsInfo(selfModule);\n    var used = false;\n\n    var _iterator9 = _createForOfIteratorHelper(usedByExports),\n        _step9;\n\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var exportName = _step9.value;\n        if (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused) used = true;\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n\n    if (!used) return false;\n  }\n\n  return true;\n};\n/**\n * @param {Dependency} dependency the dependency\n * @param {Set<string> | boolean} usedByExports usedByExports info\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @returns {null | false | function(ModuleGraphConnection, RuntimeSpec): ConnectionState} function to determine if the connection is active\n */\n\n\nexports.getDependencyUsedByExportsCondition = function (dependency, usedByExports, moduleGraph) {\n  if (usedByExports === false) return false;\n\n  if (usedByExports !== true && usedByExports !== undefined) {\n    var selfModule = moduleGraph.getParentModule(dependency);\n    var exportsInfo = moduleGraph.getExportsInfo(selfModule);\n    return function (connections, runtime) {\n      var _iterator10 = _createForOfIteratorHelper(usedByExports),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var exportName = _step10.value;\n          if (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused) return true;\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      return false;\n    };\n  }\n\n  return null;\n};\n\nvar TopLevelSymbol = /*#__PURE__*/_createClass(\n/**\n * @param {string} name name of the variable\n */\nfunction TopLevelSymbol(name) {\n  _classCallCheck(this, TopLevelSymbol);\n\n  this.name = name;\n});\n\nexports.TopLevelSymbol = TopLevelSymbol;\nexports.topLevelSymbolTag = topLevelSymbolTag;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/optimize/InnerGraph.js"],"names":["require","UsageState","parserStateMap","WeakMap","topLevelSymbolTag","Symbol","getState","parserState","get","exports","bailout","set","enable","state","innerGraph","Map","currentTopLevelSymbol","undefined","usageCallbackMap","isEnabled","addUsage","symbol","usage","innerGraphState","info","Set","add","addVariableUsage","parser","name","getTagData","tagTopLevelSymbol","inferDependencyUsage","processed","nonTerminal","keys","size","key","newSet","isTerminal","value","alreadyProcessed","item","itemValue","i","has","delete","globalValue","callbacks","callback","onUsage","onUsageCallback","setTopLevelSymbol","getTopLevelSymbol","defineVariable","existingTag","fn","TopLevelSymbol","tagVariable","isDependencyUsedByExports","dependency","usedByExports","moduleGraph","runtime","selfModule","getParentModule","exportsInfo","getExportsInfo","used","exportName","getUsed","Unused","getDependencyUsedByExportsCondition","connections"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Sergey Melyukov @smelukov\n*/\n\n\"use strict\";\n\nconst { UsageState } = require(\"../ExportsInfo\");\n\n/** @typedef {import(\"estree\").Node} AnyNode */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n/** @typedef {import(\"../ModuleGraphConnection\").ConnectionState} ConnectionState */\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @typedef {Map<TopLevelSymbol | null, Set<string | TopLevelSymbol> | true>} InnerGraph */\n/** @typedef {function(boolean | Set<string> | undefined): void} UsageCallback */\n\n/**\n * @typedef {Object} StateObject\n * @property {InnerGraph} innerGraph\n * @property {TopLevelSymbol=} currentTopLevelSymbol\n * @property {Map<TopLevelSymbol, Set<UsageCallback>>} usageCallbackMap\n */\n\n/** @typedef {false|StateObject} State */\n\n/** @type {WeakMap<ParserState, State>} */\nconst parserStateMap = new WeakMap();\nconst topLevelSymbolTag = Symbol(\"top level symbol\");\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {State} state\n */\nfunction getState(parserState) {\n\treturn parserStateMap.get(parserState);\n}\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {void}\n */\nexports.bailout = parserState => {\n\tparserStateMap.set(parserState, false);\n};\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {void}\n */\nexports.enable = parserState => {\n\tconst state = parserStateMap.get(parserState);\n\tif (state === false) {\n\t\treturn;\n\t}\n\tparserStateMap.set(parserState, {\n\t\tinnerGraph: new Map(),\n\t\tcurrentTopLevelSymbol: undefined,\n\t\tusageCallbackMap: new Map()\n\t});\n};\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {boolean} true, when enabled\n */\nexports.isEnabled = parserState => {\n\tconst state = parserStateMap.get(parserState);\n\treturn !!state;\n};\n\n/**\n * @param {ParserState} state parser state\n * @param {TopLevelSymbol | null} symbol the symbol, or null for all symbols\n * @param {string | TopLevelSymbol | true} usage usage data\n * @returns {void}\n */\nexports.addUsage = (state, symbol, usage) => {\n\tconst innerGraphState = getState(state);\n\n\tif (innerGraphState) {\n\t\tconst { innerGraph } = innerGraphState;\n\t\tconst info = innerGraph.get(symbol);\n\t\tif (usage === true) {\n\t\t\tinnerGraph.set(symbol, true);\n\t\t} else if (info === undefined) {\n\t\t\tinnerGraph.set(symbol, new Set([usage]));\n\t\t} else if (info !== true) {\n\t\t\tinfo.add(usage);\n\t\t}\n\t}\n};\n\n/**\n * @param {JavascriptParser} parser the parser\n * @param {string} name name of variable\n * @param {string | TopLevelSymbol | true} usage usage data\n * @returns {void}\n */\nexports.addVariableUsage = (parser, name, usage) => {\n\tconst symbol =\n\t\t/** @type {TopLevelSymbol} */ (\n\t\t\tparser.getTagData(name, topLevelSymbolTag)\n\t\t) || exports.tagTopLevelSymbol(parser, name);\n\tif (symbol) {\n\t\texports.addUsage(parser.state, symbol, usage);\n\t}\n};\n\n/**\n * @param {ParserState} state parser state\n * @returns {void}\n */\nexports.inferDependencyUsage = state => {\n\tconst innerGraphState = getState(state);\n\n\tif (!innerGraphState) {\n\t\treturn;\n\t}\n\n\tconst { innerGraph, usageCallbackMap } = innerGraphState;\n\tconst processed = new Map();\n\t// flatten graph to terminal nodes (string, undefined or true)\n\tconst nonTerminal = new Set(innerGraph.keys());\n\twhile (nonTerminal.size > 0) {\n\t\tfor (const key of nonTerminal) {\n\t\t\t/** @type {Set<string|TopLevelSymbol> | true} */\n\t\t\tlet newSet = new Set();\n\t\t\tlet isTerminal = true;\n\t\t\tconst value = innerGraph.get(key);\n\t\t\tlet alreadyProcessed = processed.get(key);\n\t\t\tif (alreadyProcessed === undefined) {\n\t\t\t\talreadyProcessed = new Set();\n\t\t\t\tprocessed.set(key, alreadyProcessed);\n\t\t\t}\n\t\t\tif (value !== true && value !== undefined) {\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\talreadyProcessed.add(item);\n\t\t\t\t}\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\tif (typeof item === \"string\") {\n\t\t\t\t\t\tnewSet.add(item);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst itemValue = innerGraph.get(item);\n\t\t\t\t\t\tif (itemValue === true) {\n\t\t\t\t\t\t\tnewSet = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (itemValue !== undefined) {\n\t\t\t\t\t\t\tfor (const i of itemValue) {\n\t\t\t\t\t\t\t\tif (i === key) continue;\n\t\t\t\t\t\t\t\tif (alreadyProcessed.has(i)) continue;\n\t\t\t\t\t\t\t\tnewSet.add(i);\n\t\t\t\t\t\t\t\tif (typeof i !== \"string\") {\n\t\t\t\t\t\t\t\t\tisTerminal = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (newSet === true) {\n\t\t\t\t\tinnerGraph.set(key, true);\n\t\t\t\t} else if (newSet.size === 0) {\n\t\t\t\t\tinnerGraph.set(key, undefined);\n\t\t\t\t} else {\n\t\t\t\t\tinnerGraph.set(key, newSet);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isTerminal) {\n\t\t\t\tnonTerminal.delete(key);\n\n\t\t\t\t// For the global key, merge with all other keys\n\t\t\t\tif (key === null) {\n\t\t\t\t\tconst globalValue = innerGraph.get(null);\n\t\t\t\t\tif (globalValue) {\n\t\t\t\t\t\tfor (const [key, value] of innerGraph) {\n\t\t\t\t\t\t\tif (key !== null && value !== true) {\n\t\t\t\t\t\t\t\tif (globalValue === true) {\n\t\t\t\t\t\t\t\t\tinnerGraph.set(key, true);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst newSet = new Set(value);\n\t\t\t\t\t\t\t\t\tfor (const item of globalValue) {\n\t\t\t\t\t\t\t\t\t\tnewSet.add(item);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tinnerGraph.set(key, newSet);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @type {Map<Dependency, true | Set<string>>} */\n\tfor (const [symbol, callbacks] of usageCallbackMap) {\n\t\tconst usage = /** @type {true | Set<string> | undefined} */ (\n\t\t\tinnerGraph.get(symbol)\n\t\t);\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback(usage === undefined ? false : usage);\n\t\t}\n\t}\n};\n\n/**\n * @param {ParserState} state parser state\n * @param {UsageCallback} onUsageCallback on usage callback\n */\nexports.onUsage = (state, onUsageCallback) => {\n\tconst innerGraphState = getState(state);\n\n\tif (innerGraphState) {\n\t\tconst { usageCallbackMap, currentTopLevelSymbol } = innerGraphState;\n\t\tif (currentTopLevelSymbol) {\n\t\t\tlet callbacks = usageCallbackMap.get(currentTopLevelSymbol);\n\n\t\t\tif (callbacks === undefined) {\n\t\t\t\tcallbacks = new Set();\n\t\t\t\tusageCallbackMap.set(currentTopLevelSymbol, callbacks);\n\t\t\t}\n\n\t\t\tcallbacks.add(onUsageCallback);\n\t\t} else {\n\t\t\tonUsageCallback(true);\n\t\t}\n\t} else {\n\t\tonUsageCallback(undefined);\n\t}\n};\n\n/**\n * @param {ParserState} state parser state\n * @param {TopLevelSymbol} symbol the symbol\n */\nexports.setTopLevelSymbol = (state, symbol) => {\n\tconst innerGraphState = getState(state);\n\n\tif (innerGraphState) {\n\t\tinnerGraphState.currentTopLevelSymbol = symbol;\n\t}\n};\n\n/**\n * @param {ParserState} state parser state\n * @returns {TopLevelSymbol|void} usage data\n */\nexports.getTopLevelSymbol = state => {\n\tconst innerGraphState = getState(state);\n\n\tif (innerGraphState) {\n\t\treturn innerGraphState.currentTopLevelSymbol;\n\t}\n};\n\n/**\n * @param {JavascriptParser} parser parser\n * @param {string} name name of variable\n * @returns {TopLevelSymbol} symbol\n */\nexports.tagTopLevelSymbol = (parser, name) => {\n\tconst innerGraphState = getState(parser.state);\n\tif (!innerGraphState) return;\n\n\tparser.defineVariable(name);\n\n\tconst existingTag = /** @type {TopLevelSymbol} */ (\n\t\tparser.getTagData(name, topLevelSymbolTag)\n\t);\n\tif (existingTag) {\n\t\treturn existingTag;\n\t}\n\n\tconst fn = new TopLevelSymbol(name);\n\tparser.tagVariable(name, topLevelSymbolTag, fn);\n\treturn fn;\n};\n\n/**\n * @param {Dependency} dependency the dependency\n * @param {Set<string> | boolean} usedByExports usedByExports info\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @param {RuntimeSpec} runtime runtime\n * @returns {boolean} false, when unused. Otherwise true\n */\nexports.isDependencyUsedByExports = (\n\tdependency,\n\tusedByExports,\n\tmoduleGraph,\n\truntime\n) => {\n\tif (usedByExports === false) return false;\n\tif (usedByExports !== true && usedByExports !== undefined) {\n\t\tconst selfModule = moduleGraph.getParentModule(dependency);\n\t\tconst exportsInfo = moduleGraph.getExportsInfo(selfModule);\n\t\tlet used = false;\n\t\tfor (const exportName of usedByExports) {\n\t\t\tif (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused)\n\t\t\t\tused = true;\n\t\t}\n\t\tif (!used) return false;\n\t}\n\treturn true;\n};\n\n/**\n * @param {Dependency} dependency the dependency\n * @param {Set<string> | boolean} usedByExports usedByExports info\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @returns {null | false | function(ModuleGraphConnection, RuntimeSpec): ConnectionState} function to determine if the connection is active\n */\nexports.getDependencyUsedByExportsCondition = (\n\tdependency,\n\tusedByExports,\n\tmoduleGraph\n) => {\n\tif (usedByExports === false) return false;\n\tif (usedByExports !== true && usedByExports !== undefined) {\n\t\tconst selfModule = moduleGraph.getParentModule(dependency);\n\t\tconst exportsInfo = moduleGraph.getExportsInfo(selfModule);\n\t\treturn (connections, runtime) => {\n\t\t\tfor (const exportName of usedByExports) {\n\t\t\t\tif (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t}\n\treturn null;\n};\n\nclass TopLevelSymbol {\n\t/**\n\t * @param {string} name name of the variable\n\t */\n\tconstructor(name) {\n\t\tthis.name = name;\n\t}\n}\n\nexports.TopLevelSymbol = TopLevelSymbol;\nexports.topLevelSymbolTag = topLevelSymbolTag;\n"]},"metadata":{},"sourceType":"script"}