{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/** @template T @typedef {(string | Record<string, string | string[] | T>)[] | Record<string, string | string[] | T>} ContainerOptionsFormat */\n\n/**\n * @template T\n * @template N\n * @param {ContainerOptionsFormat<T>} options options passed by the user\n * @param {function(string | string[], string) : N} normalizeSimple normalize a simple item\n * @param {function(T, string) : N} normalizeOptions normalize a complex item\n * @param {function(string, N): void} fn processing function\n * @returns {void}\n */\n\nvar _slicedToArray = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar process = function process(options, normalizeSimple, normalizeOptions, fn) {\n  var array = function array(items) {\n    var _iterator = _createForOfIteratorHelper(items),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var item = _step.value;\n\n        if (typeof item === \"string\") {\n          fn(item, normalizeSimple(item, item));\n        } else if (item && typeof item === \"object\") {\n          object(item);\n        } else {\n          throw new Error(\"Unexpected options format\");\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  };\n\n  var object = function object(obj) {\n    for (var _i = 0, _Object$entries = Object.entries(obj); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          key = _Object$entries$_i[0],\n          value = _Object$entries$_i[1];\n\n      if (typeof value === \"string\" || Array.isArray(value)) {\n        fn(key, normalizeSimple(value, key));\n      } else {\n        fn(key, normalizeOptions(value, key));\n      }\n    }\n  };\n\n  if (!options) {\n    return;\n  } else if (Array.isArray(options)) {\n    array(options);\n  } else if (typeof options === \"object\") {\n    object(options);\n  } else {\n    throw new Error(\"Unexpected options format\");\n  }\n};\n/**\n * @template T\n * @template R\n * @param {ContainerOptionsFormat<T>} options options passed by the user\n * @param {function(string | string[], string) : R} normalizeSimple normalize a simple item\n * @param {function(T, string) : R} normalizeOptions normalize a complex item\n * @returns {[string, R][]} parsed options\n */\n\n\nvar parseOptions = function parseOptions(options, normalizeSimple, normalizeOptions) {\n  /** @type {[string, R][]} */\n  var items = [];\n  process(options, normalizeSimple, normalizeOptions, function (key, value) {\n    items.push([key, value]);\n  });\n  return items;\n};\n/**\n * @template T\n * @param {string} scope scope name\n * @param {ContainerOptionsFormat<T>} options options passed by the user\n * @returns {Record<string, string | string[] | T>} options to spread or pass\n */\n\n\nvar scope = function scope(_scope, options) {\n  /** @type {Record<string, string | string[] | T>} */\n  var obj = {};\n  process(options, function (item) {\n    return (\n      /** @type {string | string[] | T} */\n      item\n    );\n  }, function (item) {\n    return (\n      /** @type {string | string[] | T} */\n      item\n    );\n  }, function (key, value) {\n    obj[key.startsWith(\"./\") ? \"\".concat(_scope).concat(key.slice(1)) : \"\".concat(_scope, \"/\").concat(key)] = value;\n  });\n  return obj;\n};\n\nexports.parseOptions = parseOptions;\nexports.scope = scope;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/container/options.js"],"names":["process","options","normalizeSimple","normalizeOptions","fn","array","items","item","object","Error","obj","Object","entries","key","value","Array","isArray","parseOptions","push","scope","startsWith","slice","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AACA,IAAMA,OAAO,GAAG,SAAVA,OAAU,CAACC,OAAD,EAAUC,eAAV,EAA2BC,gBAA3B,EAA6CC,EAA7C,EAAoD;AACnE,MAAMC,KAAK,GAAG,SAARA,KAAQ,CAAAC,KAAK,EAAI;AAAA,+CACHA,KADG;AAAA;;AAAA;AACtB,0DAA0B;AAAA,YAAfC,IAAe;;AACzB,YAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC7BH,UAAAA,EAAE,CAACG,IAAD,EAAOL,eAAe,CAACK,IAAD,EAAOA,IAAP,CAAtB,CAAF;AACA,SAFD,MAEO,IAAIA,IAAI,IAAI,OAAOA,IAAP,KAAgB,QAA5B,EAAsC;AAC5CC,UAAAA,MAAM,CAACD,IAAD,CAAN;AACA,SAFM,MAEA;AACN,gBAAM,IAAIE,KAAJ,CAAU,2BAAV,CAAN;AACA;AACD;AATqB;AAAA;AAAA;AAAA;AAAA;AAUtB,GAVD;;AAWA,MAAMD,MAAM,GAAG,SAATA,MAAS,CAAAE,GAAG,EAAI;AACrB,uCAA2BC,MAAM,CAACC,OAAP,CAAeF,GAAf,CAA3B,qCAAgD;AAA3C;AAAA,UAAOG,GAAP;AAAA,UAAYC,KAAZ;;AACJ,UAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BC,KAAK,CAACC,OAAN,CAAcF,KAAd,CAAjC,EAAuD;AACtDV,QAAAA,EAAE,CAACS,GAAD,EAAMX,eAAe,CAACY,KAAD,EAAQD,GAAR,CAArB,CAAF;AACA,OAFD,MAEO;AACNT,QAAAA,EAAE,CAACS,GAAD,EAAMV,gBAAgB,CAACW,KAAD,EAAQD,GAAR,CAAtB,CAAF;AACA;AACD;AACD,GARD;;AASA,MAAI,CAACZ,OAAL,EAAc;AACb;AACA,GAFD,MAEO,IAAIc,KAAK,CAACC,OAAN,CAAcf,OAAd,CAAJ,EAA4B;AAClCI,IAAAA,KAAK,CAACJ,OAAD,CAAL;AACA,GAFM,MAEA,IAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AACvCO,IAAAA,MAAM,CAACP,OAAD,CAAN;AACA,GAFM,MAEA;AACN,UAAM,IAAIQ,KAAJ,CAAU,2BAAV,CAAN;AACA;AACD,CA9BD;AAgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMQ,YAAY,GAAG,SAAfA,YAAe,CAAChB,OAAD,EAAUC,eAAV,EAA2BC,gBAA3B,EAAgD;AACpE;AACA,MAAMG,KAAK,GAAG,EAAd;AACAN,EAAAA,OAAO,CAACC,OAAD,EAAUC,eAAV,EAA2BC,gBAA3B,EAA6C,UAACU,GAAD,EAAMC,KAAN,EAAgB;AACnER,IAAAA,KAAK,CAACY,IAAN,CAAW,CAACL,GAAD,EAAMC,KAAN,CAAX;AACA,GAFM,CAAP;AAGA,SAAOR,KAAP;AACA,CAPD;AASA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMa,KAAK,GAAG,eAACA,MAAD,EAAQlB,OAAR,EAAoB;AACjC;AACA,MAAMS,GAAG,GAAG,EAAZ;AACAV,EAAAA,OAAO,CACNC,OADM,EAEN,UAAAM,IAAI;AAAA;AAAI;AAAsCA,MAAAA;AAA1C;AAAA,GAFE,EAGN,UAAAA,IAAI;AAAA;AAAI;AAAsCA,MAAAA;AAA1C;AAAA,GAHE,EAIN,UAACM,GAAD,EAAMC,KAAN,EAAgB;AACfJ,IAAAA,GAAG,CACFG,GAAG,CAACO,UAAJ,CAAe,IAAf,cAA0BD,MAA1B,SAAkCN,GAAG,CAACQ,KAAJ,CAAU,CAAV,CAAlC,cAAsDF,MAAtD,cAA+DN,GAA/D,CADE,CAAH,GAEIC,KAFJ;AAGA,GARK,CAAP;AAUA,SAAOJ,GAAP;AACA,CAdD;;AAgBAY,OAAO,CAACL,YAAR,GAAuBA,YAAvB;AACAK,OAAO,CAACH,KAAR,GAAgBA,KAAhB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @template T @typedef {(string | Record<string, string | string[] | T>)[] | Record<string, string | string[] | T>} ContainerOptionsFormat */\n\n/**\n * @template T\n * @template N\n * @param {ContainerOptionsFormat<T>} options options passed by the user\n * @param {function(string | string[], string) : N} normalizeSimple normalize a simple item\n * @param {function(T, string) : N} normalizeOptions normalize a complex item\n * @param {function(string, N): void} fn processing function\n * @returns {void}\n */\nconst process = (options, normalizeSimple, normalizeOptions, fn) => {\n\tconst array = items => {\n\t\tfor (const item of items) {\n\t\t\tif (typeof item === \"string\") {\n\t\t\t\tfn(item, normalizeSimple(item, item));\n\t\t\t} else if (item && typeof item === \"object\") {\n\t\t\t\tobject(item);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Unexpected options format\");\n\t\t\t}\n\t\t}\n\t};\n\tconst object = obj => {\n\t\tfor (const [key, value] of Object.entries(obj)) {\n\t\t\tif (typeof value === \"string\" || Array.isArray(value)) {\n\t\t\t\tfn(key, normalizeSimple(value, key));\n\t\t\t} else {\n\t\t\t\tfn(key, normalizeOptions(value, key));\n\t\t\t}\n\t\t}\n\t};\n\tif (!options) {\n\t\treturn;\n\t} else if (Array.isArray(options)) {\n\t\tarray(options);\n\t} else if (typeof options === \"object\") {\n\t\tobject(options);\n\t} else {\n\t\tthrow new Error(\"Unexpected options format\");\n\t}\n};\n\n/**\n * @template T\n * @template R\n * @param {ContainerOptionsFormat<T>} options options passed by the user\n * @param {function(string | string[], string) : R} normalizeSimple normalize a simple item\n * @param {function(T, string) : R} normalizeOptions normalize a complex item\n * @returns {[string, R][]} parsed options\n */\nconst parseOptions = (options, normalizeSimple, normalizeOptions) => {\n\t/** @type {[string, R][]} */\n\tconst items = [];\n\tprocess(options, normalizeSimple, normalizeOptions, (key, value) => {\n\t\titems.push([key, value]);\n\t});\n\treturn items;\n};\n\n/**\n * @template T\n * @param {string} scope scope name\n * @param {ContainerOptionsFormat<T>} options options passed by the user\n * @returns {Record<string, string | string[] | T>} options to spread or pass\n */\nconst scope = (scope, options) => {\n\t/** @type {Record<string, string | string[] | T>} */\n\tconst obj = {};\n\tprocess(\n\t\toptions,\n\t\titem => /** @type {string | string[] | T} */ (item),\n\t\titem => /** @type {string | string[] | T} */ (item),\n\t\t(key, value) => {\n\t\t\tobj[\n\t\t\t\tkey.startsWith(\"./\") ? `${scope}${key.slice(1)}` : `${scope}/${key}`\n\t\t\t] = value;\n\t\t}\n\t);\n\treturn obj;\n};\n\nexports.parseOptions = parseOptions;\nexports.scope = scope;\n"]},"metadata":{},"sourceType":"script"}