{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _objectSpread = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar asyncLib = require(\"neo-async\");\n\nvar _require = require(\"webpack-sources\"),\n    ConcatSource = _require.ConcatSource,\n    RawSource = _require.RawSource;\n\nvar Compilation = require(\"./Compilation\");\n\nvar ModuleFilenameHelpers = require(\"./ModuleFilenameHelpers\");\n\nvar ProgressPlugin = require(\"./ProgressPlugin\");\n\nvar SourceMapDevToolModuleOptionsPlugin = require(\"./SourceMapDevToolModuleOptionsPlugin\");\n\nvar createSchemaValidation = require(\"./util/create-schema-validation\");\n\nvar createHash = require(\"./util/createHash\");\n\nvar _require2 = require(\"./util/fs\"),\n    relative = _require2.relative,\n    dirname = _require2.dirname;\n\nvar _require3 = require(\"./util/identifier\"),\n    makePathsAbsolute = _require3.makePathsAbsolute;\n/** @typedef {import(\"webpack-sources\").MapOptions} MapOptions */\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../declarations/plugins/SourceMapDevToolPlugin\").SourceMapDevToolPluginOptions} SourceMapDevToolPluginOptions */\n\n/** @typedef {import(\"./Cache\").Etag} Etag */\n\n/** @typedef {import(\"./CacheFacade\").ItemCacheFacade} ItemCacheFacade */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./NormalModule\").SourceMap} SourceMap */\n\n/** @typedef {import(\"./util/Hash\")} Hash */\n\n\nvar validate = createSchemaValidation(require(\"../schemas/plugins/SourceMapDevToolPlugin.check.js\"), function () {\n  return require(\"../schemas/plugins/SourceMapDevToolPlugin.json\");\n}, {\n  name: \"SourceMap DevTool Plugin\",\n  baseDataPath: \"options\"\n});\n/**\n * @typedef {object} SourceMapTask\n * @property {Source} asset\n * @property {AssetInfo} assetInfo\n * @property {(string | Module)[]} modules\n * @property {string} source\n * @property {string} file\n * @property {SourceMap} sourceMap\n * @property {ItemCacheFacade} cacheItem cache item\n */\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\n\nvar quoteMeta = function quoteMeta(str) {\n  return str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n/**\n * Creating {@link SourceMapTask} for given file\n * @param {string} file current compiled file\n * @param {Source} asset the asset\n * @param {AssetInfo} assetInfo the asset info\n * @param {MapOptions} options source map options\n * @param {Compilation} compilation compilation instance\n * @param {ItemCacheFacade} cacheItem cache item\n * @returns {SourceMapTask | undefined} created task instance or `undefined`\n */\n\n\nvar getTaskForFile = function getTaskForFile(file, asset, assetInfo, options, compilation, cacheItem) {\n  var source;\n  /** @type {SourceMap} */\n\n  var sourceMap;\n  /**\n   * Check if asset can build source map\n   */\n\n  if (asset.sourceAndMap) {\n    var sourceAndMap = asset.sourceAndMap(options);\n    sourceMap =\n    /** @type {SourceMap} */\n    sourceAndMap.map;\n    source = sourceAndMap.source;\n  } else {\n    sourceMap =\n    /** @type {SourceMap} */\n    asset.map(options);\n    source = asset.source();\n  }\n\n  if (!sourceMap || typeof source !== \"string\") return;\n  var context = compilation.options.context;\n  var root = compilation.compiler.root;\n  var cachedAbsolutify = makePathsAbsolute.bindContextCache(context, root);\n  var modules = sourceMap.sources.map(function (source) {\n    if (!source.startsWith(\"webpack://\")) return source;\n    source = cachedAbsolutify(source.slice(10));\n    var module = compilation.findModule(source);\n    return module || source;\n  });\n  return {\n    file: file,\n    asset: asset,\n    source: source,\n    assetInfo: assetInfo,\n    sourceMap: sourceMap,\n    modules: modules,\n    cacheItem: cacheItem\n  };\n};\n\nvar SourceMapDevToolPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {SourceMapDevToolPluginOptions} [options] options object\n   * @throws {Error} throws error, if got more than 1 arguments\n   */\n  function SourceMapDevToolPlugin() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, SourceMapDevToolPlugin);\n\n    validate(options);\n    /** @type {string | false} */\n\n    this.sourceMapFilename = options.filename;\n    /** @type {string | false} */\n\n    this.sourceMappingURLComment = options.append === false ? false : options.append || \"\\n//# source\" + \"MappingURL=[url]\";\n    /** @type {string | Function} */\n\n    this.moduleFilenameTemplate = options.moduleFilenameTemplate || \"webpack://[namespace]/[resourcePath]\";\n    /** @type {string | Function} */\n\n    this.fallbackModuleFilenameTemplate = options.fallbackModuleFilenameTemplate || \"webpack://[namespace]/[resourcePath]?[hash]\";\n    /** @type {string} */\n\n    this.namespace = options.namespace || \"\";\n    /** @type {SourceMapDevToolPluginOptions} */\n\n    this.options = options;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler compiler instance\n   * @returns {void}\n   */\n\n\n  _createClass(SourceMapDevToolPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var outputFs = compiler.outputFileSystem;\n      var sourceMapFilename = this.sourceMapFilename;\n      var sourceMappingURLComment = this.sourceMappingURLComment;\n      var moduleFilenameTemplate = this.moduleFilenameTemplate;\n      var namespace = this.namespace;\n      var fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;\n      var requestShortener = compiler.requestShortener;\n      var options = this.options;\n      options.test = options.test || /\\.((c|m)?js|css)($|\\?)/i;\n      var matchObject = ModuleFilenameHelpers.matchObject.bind(undefined, options);\n      compiler.hooks.compilation.tap(\"SourceMapDevToolPlugin\", function (compilation) {\n        new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);\n        compilation.hooks.processAssets.tapAsync({\n          name: \"SourceMapDevToolPlugin\",\n          stage: Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING,\n          additionalAssets: true\n        }, function (assets, callback) {\n          var chunkGraph = compilation.chunkGraph;\n          var cache = compilation.getCache(\"SourceMapDevToolPlugin\");\n          /** @type {Map<string | Module, string>} */\n\n          var moduleToSourceNameMapping = new Map();\n          /**\n           * @type {Function}\n           * @returns {void}\n           */\n\n          var reportProgress = ProgressPlugin.getReporter(compilation.compiler) || function () {};\n          /** @type {Map<string, Chunk>} */\n\n\n          var fileToChunk = new Map();\n\n          var _iterator = _createForOfIteratorHelper(compilation.chunks),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var chunk = _step.value;\n\n              var _iterator2 = _createForOfIteratorHelper(chunk.files),\n                  _step2;\n\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var _file = _step2.value;\n                  fileToChunk.set(_file, chunk);\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n\n              var _iterator3 = _createForOfIteratorHelper(chunk.auxiliaryFiles),\n                  _step3;\n\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  var _file2 = _step3.value;\n                  fileToChunk.set(_file2, chunk);\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n            }\n            /** @type {string[]} */\n\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          var files = [];\n\n          for (var _i = 0, _Object$keys = Object.keys(assets); _i < _Object$keys.length; _i++) {\n            var file = _Object$keys[_i];\n\n            if (matchObject(file)) {\n              files.push(file);\n            }\n          }\n\n          reportProgress(0.0);\n          /** @type {SourceMapTask[]} */\n\n          var tasks = [];\n          var fileIndex = 0;\n          asyncLib.each(files, function (file, callback) {\n            var asset = compilation.getAsset(file);\n\n            if (asset.info.related && asset.info.related.sourceMap) {\n              fileIndex++;\n              return callback();\n            }\n\n            var cacheItem = cache.getItemCache(file, cache.mergeEtags(cache.getLazyHashedEtag(asset.source), namespace));\n            cacheItem.get(function (err, cacheEntry) {\n              if (err) {\n                return callback(err);\n              }\n              /**\n               * If presented in cache, reassigns assets. Cache assets already have source maps.\n               */\n\n\n              if (cacheEntry) {\n                var _assets = cacheEntry.assets,\n                    assetsInfo = cacheEntry.assetsInfo;\n\n                for (var _i2 = 0, _Object$keys2 = Object.keys(_assets); _i2 < _Object$keys2.length; _i2++) {\n                  var cachedFile = _Object$keys2[_i2];\n\n                  if (cachedFile === file) {\n                    compilation.updateAsset(cachedFile, _assets[cachedFile], assetsInfo[cachedFile]);\n                  } else {\n                    compilation.emitAsset(cachedFile, _assets[cachedFile], assetsInfo[cachedFile]);\n                  }\n                  /**\n                   * Add file to chunk, if not presented there\n                   */\n\n\n                  if (cachedFile !== file) {\n                    var chunk = fileToChunk.get(file);\n                    if (chunk !== undefined) chunk.auxiliaryFiles.add(cachedFile);\n                  }\n                }\n\n                reportProgress(0.5 * ++fileIndex / files.length, file, \"restored cached SourceMap\");\n                return callback();\n              }\n\n              reportProgress(0.5 * fileIndex / files.length, file, \"generate SourceMap\");\n              /** @type {SourceMapTask | undefined} */\n\n              var task = getTaskForFile(file, asset.source, asset.info, {\n                module: options.module,\n                columns: options.columns\n              }, compilation, cacheItem);\n\n              if (task) {\n                var modules = task.modules;\n\n                for (var idx = 0; idx < modules.length; idx++) {\n                  var _module = modules[idx];\n\n                  if (!moduleToSourceNameMapping.get(_module)) {\n                    moduleToSourceNameMapping.set(_module, ModuleFilenameHelpers.createFilename(_module, {\n                      moduleFilenameTemplate: moduleFilenameTemplate,\n                      namespace: namespace\n                    }, {\n                      requestShortener: requestShortener,\n                      chunkGraph: chunkGraph,\n                      hashFunction: compilation.outputOptions.hashFunction\n                    }));\n                  }\n                }\n\n                tasks.push(task);\n              }\n\n              reportProgress(0.5 * ++fileIndex / files.length, file, \"generated SourceMap\");\n              callback();\n            });\n          }, function (err) {\n            if (err) {\n              return callback(err);\n            }\n\n            reportProgress(0.5, \"resolve sources\");\n            /** @type {Set<string>} */\n\n            var usedNamesSet = new Set(moduleToSourceNameMapping.values());\n            /** @type {Set<string>} */\n\n            var conflictDetectionSet = new Set();\n            /**\n             * all modules in defined order (longest identifier first)\n             * @type {Array<string | Module>}\n             */\n\n            var allModules = Array.from(moduleToSourceNameMapping.keys()).sort(function (a, b) {\n              var ai = typeof a === \"string\" ? a : a.identifier();\n              var bi = typeof b === \"string\" ? b : b.identifier();\n              return ai.length - bi.length;\n            }); // find modules with conflicting source names\n\n            for (var idx = 0; idx < allModules.length; idx++) {\n              var _module2 = allModules[idx];\n              var sourceName = moduleToSourceNameMapping.get(_module2);\n              var hasName = conflictDetectionSet.has(sourceName);\n\n              if (!hasName) {\n                conflictDetectionSet.add(sourceName);\n                continue;\n              } // try the fallback name first\n\n\n              sourceName = ModuleFilenameHelpers.createFilename(_module2, {\n                moduleFilenameTemplate: fallbackModuleFilenameTemplate,\n                namespace: namespace\n              }, {\n                requestShortener: requestShortener,\n                chunkGraph: chunkGraph,\n                hashFunction: compilation.outputOptions.hashFunction\n              });\n              hasName = usedNamesSet.has(sourceName);\n\n              if (!hasName) {\n                moduleToSourceNameMapping.set(_module2, sourceName);\n                usedNamesSet.add(sourceName);\n                continue;\n              } // otherwise just append stars until we have a valid name\n\n\n              while (hasName) {\n                sourceName += \"*\";\n                hasName = usedNamesSet.has(sourceName);\n              }\n\n              moduleToSourceNameMapping.set(_module2, sourceName);\n              usedNamesSet.add(sourceName);\n            }\n\n            var taskIndex = 0;\n            asyncLib.each(tasks, function (task, callback) {\n              var assets = Object.create(null);\n              var assetsInfo = Object.create(null);\n              var file = task.file;\n              var chunk = fileToChunk.get(file);\n              var sourceMap = task.sourceMap;\n              var source = task.source;\n              var modules = task.modules;\n              reportProgress(0.5 + 0.5 * taskIndex / tasks.length, file, \"attach SourceMap\");\n              var moduleFilenames = modules.map(function (m) {\n                return moduleToSourceNameMapping.get(m);\n              });\n              sourceMap.sources = moduleFilenames;\n\n              if (options.noSources) {\n                sourceMap.sourcesContent = undefined;\n              }\n\n              sourceMap.sourceRoot = options.sourceRoot || \"\";\n              sourceMap.file = file;\n              var usesContentHash = sourceMapFilename && /\\[contenthash(:\\w+)?\\]/.test(sourceMapFilename); // If SourceMap and asset uses contenthash, avoid a circular dependency by hiding hash in `file`\n\n              if (usesContentHash && task.assetInfo.contenthash) {\n                var contenthash = task.assetInfo.contenthash;\n                var pattern;\n\n                if (Array.isArray(contenthash)) {\n                  pattern = contenthash.map(quoteMeta).join(\"|\");\n                } else {\n                  pattern = quoteMeta(contenthash);\n                }\n\n                sourceMap.file = sourceMap.file.replace(new RegExp(pattern, \"g\"), function (m) {\n                  return \"x\".repeat(m.length);\n                });\n              }\n              /** @type {string | false} */\n\n\n              var currentSourceMappingURLComment = sourceMappingURLComment;\n\n              if (currentSourceMappingURLComment !== false && /\\.css($|\\?)/i.test(file)) {\n                currentSourceMappingURLComment = currentSourceMappingURLComment.replace(/^\\n\\/\\/(.*)$/, \"\\n/*$1*/\");\n              }\n\n              var sourceMapString = JSON.stringify(sourceMap);\n\n              if (sourceMapFilename) {\n                var filename = file;\n                var sourceMapContentHash = usesContentHash &&\n                /** @type {string} */\n                createHash(compilation.outputOptions.hashFunction).update(sourceMapString).digest(\"hex\");\n                var pathParams = {\n                  chunk: chunk,\n                  filename: options.fileContext ? relative(outputFs, \"/\".concat(options.fileContext), \"/\".concat(filename)) : filename,\n                  contentHash: sourceMapContentHash\n                };\n\n                var _compilation$getPathW = compilation.getPathWithInfo(sourceMapFilename, pathParams),\n                    sourceMapFile = _compilation$getPathW.path,\n                    sourceMapInfo = _compilation$getPathW.info;\n\n                var sourceMapUrl = options.publicPath ? options.publicPath + sourceMapFile : relative(outputFs, dirname(outputFs, \"/\".concat(file)), \"/\".concat(sourceMapFile));\n                /** @type {Source} */\n\n                var asset = new RawSource(source);\n\n                if (currentSourceMappingURLComment !== false) {\n                  // Add source map url to compilation asset, if currentSourceMappingURLComment is set\n                  asset = new ConcatSource(asset, compilation.getPath(currentSourceMappingURLComment, Object.assign({\n                    url: sourceMapUrl\n                  }, pathParams)));\n                }\n\n                var assetInfo = {\n                  related: {\n                    sourceMap: sourceMapFile\n                  }\n                };\n                assets[file] = asset;\n                assetsInfo[file] = assetInfo;\n                compilation.updateAsset(file, asset, assetInfo); // Add source map file to compilation assets and chunk files\n\n                var sourceMapAsset = new RawSource(sourceMapString);\n\n                var sourceMapAssetInfo = _objectSpread(_objectSpread({}, sourceMapInfo), {}, {\n                  development: true\n                });\n\n                assets[sourceMapFile] = sourceMapAsset;\n                assetsInfo[sourceMapFile] = sourceMapAssetInfo;\n                compilation.emitAsset(sourceMapFile, sourceMapAsset, sourceMapAssetInfo);\n                if (chunk !== undefined) chunk.auxiliaryFiles.add(sourceMapFile);\n              } else {\n                if (currentSourceMappingURLComment === false) {\n                  throw new Error(\"SourceMapDevToolPlugin: append can't be false when no filename is provided\");\n                }\n                /**\n                 * Add source map as data url to asset\n                 */\n\n\n                var _asset = new ConcatSource(new RawSource(source), currentSourceMappingURLComment.replace(/\\[map\\]/g, function () {\n                  return sourceMapString;\n                }).replace(/\\[url\\]/g, function () {\n                  return \"data:application/json;charset=utf-8;base64,\".concat(Buffer.from(sourceMapString, \"utf-8\").toString(\"base64\"));\n                }));\n\n                assets[file] = _asset;\n                assetsInfo[file] = undefined;\n                compilation.updateAsset(file, _asset);\n              }\n\n              task.cacheItem.store({\n                assets: assets,\n                assetsInfo: assetsInfo\n              }, function (err) {\n                reportProgress(0.5 + 0.5 * ++taskIndex / tasks.length, task.file, \"attached SourceMap\");\n\n                if (err) {\n                  return callback(err);\n                }\n\n                callback();\n              });\n            }, function (err) {\n              reportProgress(1.0);\n              callback(err);\n            });\n          });\n        });\n      });\n    }\n  }]);\n\n  return SourceMapDevToolPlugin;\n}();\n\nmodule.exports = SourceMapDevToolPlugin;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/SourceMapDevToolPlugin.js"],"names":["asyncLib","require","ConcatSource","RawSource","Compilation","ModuleFilenameHelpers","ProgressPlugin","SourceMapDevToolModuleOptionsPlugin","createSchemaValidation","createHash","relative","dirname","makePathsAbsolute","validate","name","baseDataPath","quoteMeta","str","replace","getTaskForFile","file","asset","assetInfo","options","compilation","cacheItem","source","sourceMap","sourceAndMap","map","context","root","compiler","cachedAbsolutify","bindContextCache","modules","sources","startsWith","slice","module","findModule","SourceMapDevToolPlugin","sourceMapFilename","filename","sourceMappingURLComment","append","moduleFilenameTemplate","fallbackModuleFilenameTemplate","namespace","outputFs","outputFileSystem","requestShortener","test","matchObject","bind","undefined","hooks","tap","apply","processAssets","tapAsync","stage","PROCESS_ASSETS_STAGE_DEV_TOOLING","additionalAssets","assets","callback","chunkGraph","cache","getCache","moduleToSourceNameMapping","Map","reportProgress","getReporter","fileToChunk","chunks","chunk","files","set","auxiliaryFiles","Object","keys","push","tasks","fileIndex","each","getAsset","info","related","getItemCache","mergeEtags","getLazyHashedEtag","get","err","cacheEntry","assetsInfo","cachedFile","updateAsset","emitAsset","add","length","task","columns","idx","createFilename","hashFunction","outputOptions","usedNamesSet","Set","values","conflictDetectionSet","allModules","Array","from","sort","a","b","ai","identifier","bi","sourceName","hasName","has","taskIndex","create","moduleFilenames","m","noSources","sourcesContent","sourceRoot","usesContentHash","contenthash","pattern","isArray","join","RegExp","repeat","currentSourceMappingURLComment","sourceMapString","JSON","stringify","sourceMapContentHash","update","digest","pathParams","fileContext","contentHash","getPathWithInfo","sourceMapFile","path","sourceMapInfo","sourceMapUrl","publicPath","getPath","assign","url","sourceMapAsset","sourceMapAssetInfo","development","Error","Buffer","toString","store","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst { ConcatSource, RawSource } = require(\"webpack-sources\");\nconst Compilation = require(\"./Compilation\");\nconst ModuleFilenameHelpers = require(\"./ModuleFilenameHelpers\");\nconst ProgressPlugin = require(\"./ProgressPlugin\");\nconst SourceMapDevToolModuleOptionsPlugin = require(\"./SourceMapDevToolModuleOptionsPlugin\");\nconst createSchemaValidation = require(\"./util/create-schema-validation\");\nconst createHash = require(\"./util/createHash\");\nconst { relative, dirname } = require(\"./util/fs\");\nconst { makePathsAbsolute } = require(\"./util/identifier\");\n\n/** @typedef {import(\"webpack-sources\").MapOptions} MapOptions */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../declarations/plugins/SourceMapDevToolPlugin\").SourceMapDevToolPluginOptions} SourceMapDevToolPluginOptions */\n/** @typedef {import(\"./Cache\").Etag} Etag */\n/** @typedef {import(\"./CacheFacade\").ItemCacheFacade} ItemCacheFacade */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./NormalModule\").SourceMap} SourceMap */\n/** @typedef {import(\"./util/Hash\")} Hash */\n\nconst validate = createSchemaValidation(\n\trequire(\"../schemas/plugins/SourceMapDevToolPlugin.check.js\"),\n\t() => require(\"../schemas/plugins/SourceMapDevToolPlugin.json\"),\n\t{\n\t\tname: \"SourceMap DevTool Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n/**\n * @typedef {object} SourceMapTask\n * @property {Source} asset\n * @property {AssetInfo} assetInfo\n * @property {(string | Module)[]} modules\n * @property {string} source\n * @property {string} file\n * @property {SourceMap} sourceMap\n * @property {ItemCacheFacade} cacheItem cache item\n */\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nconst quoteMeta = str => {\n\treturn str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\n/**\n * Creating {@link SourceMapTask} for given file\n * @param {string} file current compiled file\n * @param {Source} asset the asset\n * @param {AssetInfo} assetInfo the asset info\n * @param {MapOptions} options source map options\n * @param {Compilation} compilation compilation instance\n * @param {ItemCacheFacade} cacheItem cache item\n * @returns {SourceMapTask | undefined} created task instance or `undefined`\n */\nconst getTaskForFile = (\n\tfile,\n\tasset,\n\tassetInfo,\n\toptions,\n\tcompilation,\n\tcacheItem\n) => {\n\tlet source;\n\t/** @type {SourceMap} */\n\tlet sourceMap;\n\t/**\n\t * Check if asset can build source map\n\t */\n\tif (asset.sourceAndMap) {\n\t\tconst sourceAndMap = asset.sourceAndMap(options);\n\t\tsourceMap = /** @type {SourceMap} */ (sourceAndMap.map);\n\t\tsource = sourceAndMap.source;\n\t} else {\n\t\tsourceMap = /** @type {SourceMap} */ (asset.map(options));\n\t\tsource = asset.source();\n\t}\n\tif (!sourceMap || typeof source !== \"string\") return;\n\tconst context = compilation.options.context;\n\tconst root = compilation.compiler.root;\n\tconst cachedAbsolutify = makePathsAbsolute.bindContextCache(context, root);\n\tconst modules = sourceMap.sources.map(source => {\n\t\tif (!source.startsWith(\"webpack://\")) return source;\n\t\tsource = cachedAbsolutify(source.slice(10));\n\t\tconst module = compilation.findModule(source);\n\t\treturn module || source;\n\t});\n\n\treturn {\n\t\tfile,\n\t\tasset,\n\t\tsource,\n\t\tassetInfo,\n\t\tsourceMap,\n\t\tmodules,\n\t\tcacheItem\n\t};\n};\n\nclass SourceMapDevToolPlugin {\n\t/**\n\t * @param {SourceMapDevToolPluginOptions} [options] options object\n\t * @throws {Error} throws error, if got more than 1 arguments\n\t */\n\tconstructor(options = {}) {\n\t\tvalidate(options);\n\n\t\t/** @type {string | false} */\n\t\tthis.sourceMapFilename = options.filename;\n\t\t/** @type {string | false} */\n\t\tthis.sourceMappingURLComment =\n\t\t\toptions.append === false\n\t\t\t\t? false\n\t\t\t\t: options.append || \"\\n//# source\" + \"MappingURL=[url]\";\n\t\t/** @type {string | Function} */\n\t\tthis.moduleFilenameTemplate =\n\t\t\toptions.moduleFilenameTemplate || \"webpack://[namespace]/[resourcePath]\";\n\t\t/** @type {string | Function} */\n\t\tthis.fallbackModuleFilenameTemplate =\n\t\t\toptions.fallbackModuleFilenameTemplate ||\n\t\t\t\"webpack://[namespace]/[resourcePath]?[hash]\";\n\t\t/** @type {string} */\n\t\tthis.namespace = options.namespace || \"\";\n\t\t/** @type {SourceMapDevToolPluginOptions} */\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst outputFs = compiler.outputFileSystem;\n\t\tconst sourceMapFilename = this.sourceMapFilename;\n\t\tconst sourceMappingURLComment = this.sourceMappingURLComment;\n\t\tconst moduleFilenameTemplate = this.moduleFilenameTemplate;\n\t\tconst namespace = this.namespace;\n\t\tconst fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;\n\t\tconst requestShortener = compiler.requestShortener;\n\t\tconst options = this.options;\n\t\toptions.test = options.test || /\\.((c|m)?js|css)($|\\?)/i;\n\n\t\tconst matchObject = ModuleFilenameHelpers.matchObject.bind(\n\t\t\tundefined,\n\t\t\toptions\n\t\t);\n\n\t\tcompiler.hooks.compilation.tap(\"SourceMapDevToolPlugin\", compilation => {\n\t\t\tnew SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);\n\n\t\t\tcompilation.hooks.processAssets.tapAsync(\n\t\t\t\t{\n\t\t\t\t\tname: \"SourceMapDevToolPlugin\",\n\t\t\t\t\tstage: Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING,\n\t\t\t\t\tadditionalAssets: true\n\t\t\t\t},\n\t\t\t\t(assets, callback) => {\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\tconst cache = compilation.getCache(\"SourceMapDevToolPlugin\");\n\t\t\t\t\t/** @type {Map<string | Module, string>} */\n\t\t\t\t\tconst moduleToSourceNameMapping = new Map();\n\t\t\t\t\t/**\n\t\t\t\t\t * @type {Function}\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst reportProgress =\n\t\t\t\t\t\tProgressPlugin.getReporter(compilation.compiler) || (() => {});\n\n\t\t\t\t\t/** @type {Map<string, Chunk>} */\n\t\t\t\t\tconst fileToChunk = new Map();\n\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\tfor (const file of chunk.files) {\n\t\t\t\t\t\t\tfileToChunk.set(file, chunk);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const file of chunk.auxiliaryFiles) {\n\t\t\t\t\t\t\tfileToChunk.set(file, chunk);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/** @type {string[]} */\n\t\t\t\t\tconst files = [];\n\t\t\t\t\tfor (const file of Object.keys(assets)) {\n\t\t\t\t\t\tif (matchObject(file)) {\n\t\t\t\t\t\t\tfiles.push(file);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treportProgress(0.0);\n\t\t\t\t\t/** @type {SourceMapTask[]} */\n\t\t\t\t\tconst tasks = [];\n\t\t\t\t\tlet fileIndex = 0;\n\n\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\tfiles,\n\t\t\t\t\t\t(file, callback) => {\n\t\t\t\t\t\t\tconst asset = compilation.getAsset(file);\n\t\t\t\t\t\t\tif (asset.info.related && asset.info.related.sourceMap) {\n\t\t\t\t\t\t\t\tfileIndex++;\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst cacheItem = cache.getItemCache(\n\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\tcache.mergeEtags(\n\t\t\t\t\t\t\t\t\tcache.getLazyHashedEtag(asset.source),\n\t\t\t\t\t\t\t\t\tnamespace\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tcacheItem.get((err, cacheEntry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * If presented in cache, reassigns assets. Cache assets already have source maps.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tif (cacheEntry) {\n\t\t\t\t\t\t\t\t\tconst { assets, assetsInfo } = cacheEntry;\n\t\t\t\t\t\t\t\t\tfor (const cachedFile of Object.keys(assets)) {\n\t\t\t\t\t\t\t\t\t\tif (cachedFile === file) {\n\t\t\t\t\t\t\t\t\t\t\tcompilation.updateAsset(\n\t\t\t\t\t\t\t\t\t\t\t\tcachedFile,\n\t\t\t\t\t\t\t\t\t\t\t\tassets[cachedFile],\n\t\t\t\t\t\t\t\t\t\t\t\tassetsInfo[cachedFile]\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tcompilation.emitAsset(\n\t\t\t\t\t\t\t\t\t\t\t\tcachedFile,\n\t\t\t\t\t\t\t\t\t\t\t\tassets[cachedFile],\n\t\t\t\t\t\t\t\t\t\t\t\tassetsInfo[cachedFile]\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t\t * Add file to chunk, if not presented there\n\t\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\t\tif (cachedFile !== file) {\n\t\t\t\t\t\t\t\t\t\t\tconst chunk = fileToChunk.get(file);\n\t\t\t\t\t\t\t\t\t\t\tif (chunk !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\tchunk.auxiliaryFiles.add(cachedFile);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t(0.5 * ++fileIndex) / files.length,\n\t\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t\t\"restored cached SourceMap\"\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t(0.5 * fileIndex) / files.length,\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t\"generate SourceMap\"\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t/** @type {SourceMapTask | undefined} */\n\t\t\t\t\t\t\t\tconst task = getTaskForFile(\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\tasset.source,\n\t\t\t\t\t\t\t\t\tasset.info,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmodule: options.module,\n\t\t\t\t\t\t\t\t\t\tcolumns: options.columns\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\t\t\tcacheItem\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif (task) {\n\t\t\t\t\t\t\t\t\tconst modules = task.modules;\n\n\t\t\t\t\t\t\t\t\tfor (let idx = 0; idx < modules.length; idx++) {\n\t\t\t\t\t\t\t\t\t\tconst module = modules[idx];\n\t\t\t\t\t\t\t\t\t\tif (!moduleToSourceNameMapping.get(module)) {\n\t\t\t\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.set(\n\t\t\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\t\t\tModuleFilenameHelpers.createFilename(\n\t\t\t\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleFilenameTemplate: moduleFilenameTemplate,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnamespace: namespace\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trequestShortener,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thashFunction: compilation.outputOptions.hashFunction\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttasks.push(task);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t(0.5 * ++fileIndex) / files.length,\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t\"generated SourceMap\"\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treportProgress(0.5, \"resolve sources\");\n\t\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\t\tconst usedNamesSet = new Set(moduleToSourceNameMapping.values());\n\t\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\t\tconst conflictDetectionSet = new Set();\n\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * all modules in defined order (longest identifier first)\n\t\t\t\t\t\t\t * @type {Array<string | Module>}\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst allModules = Array.from(\n\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.keys()\n\t\t\t\t\t\t\t).sort((a, b) => {\n\t\t\t\t\t\t\t\tconst ai = typeof a === \"string\" ? a : a.identifier();\n\t\t\t\t\t\t\t\tconst bi = typeof b === \"string\" ? b : b.identifier();\n\t\t\t\t\t\t\t\treturn ai.length - bi.length;\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// find modules with conflicting source names\n\t\t\t\t\t\t\tfor (let idx = 0; idx < allModules.length; idx++) {\n\t\t\t\t\t\t\t\tconst module = allModules[idx];\n\t\t\t\t\t\t\t\tlet sourceName = moduleToSourceNameMapping.get(module);\n\t\t\t\t\t\t\t\tlet hasName = conflictDetectionSet.has(sourceName);\n\t\t\t\t\t\t\t\tif (!hasName) {\n\t\t\t\t\t\t\t\t\tconflictDetectionSet.add(sourceName);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// try the fallback name first\n\t\t\t\t\t\t\t\tsourceName = ModuleFilenameHelpers.createFilename(\n\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmoduleFilenameTemplate: fallbackModuleFilenameTemplate,\n\t\t\t\t\t\t\t\t\t\tnamespace: namespace\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\trequestShortener,\n\t\t\t\t\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\t\t\t\t\thashFunction: compilation.outputOptions.hashFunction\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\thasName = usedNamesSet.has(sourceName);\n\t\t\t\t\t\t\t\tif (!hasName) {\n\t\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.set(module, sourceName);\n\t\t\t\t\t\t\t\t\tusedNamesSet.add(sourceName);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// otherwise just append stars until we have a valid name\n\t\t\t\t\t\t\t\twhile (hasName) {\n\t\t\t\t\t\t\t\t\tsourceName += \"*\";\n\t\t\t\t\t\t\t\t\thasName = usedNamesSet.has(sourceName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.set(module, sourceName);\n\t\t\t\t\t\t\t\tusedNamesSet.add(sourceName);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlet taskIndex = 0;\n\n\t\t\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\t\t\ttasks,\n\t\t\t\t\t\t\t\t(task, callback) => {\n\t\t\t\t\t\t\t\t\tconst assets = Object.create(null);\n\t\t\t\t\t\t\t\t\tconst assetsInfo = Object.create(null);\n\t\t\t\t\t\t\t\t\tconst file = task.file;\n\t\t\t\t\t\t\t\t\tconst chunk = fileToChunk.get(file);\n\t\t\t\t\t\t\t\t\tconst sourceMap = task.sourceMap;\n\t\t\t\t\t\t\t\t\tconst source = task.source;\n\t\t\t\t\t\t\t\t\tconst modules = task.modules;\n\n\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t0.5 + (0.5 * taskIndex) / tasks.length,\n\t\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t\t\"attach SourceMap\"\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tconst moduleFilenames = modules.map(m =>\n\t\t\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.get(m)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tsourceMap.sources = moduleFilenames;\n\t\t\t\t\t\t\t\t\tif (options.noSources) {\n\t\t\t\t\t\t\t\t\t\tsourceMap.sourcesContent = undefined;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tsourceMap.sourceRoot = options.sourceRoot || \"\";\n\t\t\t\t\t\t\t\t\tsourceMap.file = file;\n\t\t\t\t\t\t\t\t\tconst usesContentHash =\n\t\t\t\t\t\t\t\t\t\tsourceMapFilename &&\n\t\t\t\t\t\t\t\t\t\t/\\[contenthash(:\\w+)?\\]/.test(sourceMapFilename);\n\n\t\t\t\t\t\t\t\t\t// If SourceMap and asset uses contenthash, avoid a circular dependency by hiding hash in `file`\n\t\t\t\t\t\t\t\t\tif (usesContentHash && task.assetInfo.contenthash) {\n\t\t\t\t\t\t\t\t\t\tconst contenthash = task.assetInfo.contenthash;\n\t\t\t\t\t\t\t\t\t\tlet pattern;\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(contenthash)) {\n\t\t\t\t\t\t\t\t\t\t\tpattern = contenthash.map(quoteMeta).join(\"|\");\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tpattern = quoteMeta(contenthash);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tsourceMap.file = sourceMap.file.replace(\n\t\t\t\t\t\t\t\t\t\t\tnew RegExp(pattern, \"g\"),\n\t\t\t\t\t\t\t\t\t\t\tm => \"x\".repeat(m.length)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t/** @type {string | false} */\n\t\t\t\t\t\t\t\t\tlet currentSourceMappingURLComment = sourceMappingURLComment;\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment !== false &&\n\t\t\t\t\t\t\t\t\t\t/\\.css($|\\?)/i.test(file)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment =\n\t\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment.replace(\n\t\t\t\t\t\t\t\t\t\t\t\t/^\\n\\/\\/(.*)$/,\n\t\t\t\t\t\t\t\t\t\t\t\t\"\\n/*$1*/\"\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst sourceMapString = JSON.stringify(sourceMap);\n\t\t\t\t\t\t\t\t\tif (sourceMapFilename) {\n\t\t\t\t\t\t\t\t\t\tlet filename = file;\n\t\t\t\t\t\t\t\t\t\tconst sourceMapContentHash =\n\t\t\t\t\t\t\t\t\t\t\tusesContentHash &&\n\t\t\t\t\t\t\t\t\t\t\t/** @type {string} */ (\n\t\t\t\t\t\t\t\t\t\t\t\tcreateHash(compilation.outputOptions.hashFunction)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.update(sourceMapString)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.digest(\"hex\")\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tconst pathParams = {\n\t\t\t\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\t\t\t\tfilename: options.fileContext\n\t\t\t\t\t\t\t\t\t\t\t\t? relative(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\toutputFs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`/${options.fileContext}`,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`/${filename}`\n\t\t\t\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t\t\t\t: filename,\n\t\t\t\t\t\t\t\t\t\t\tcontentHash: sourceMapContentHash\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tconst { path: sourceMapFile, info: sourceMapInfo } =\n\t\t\t\t\t\t\t\t\t\t\tcompilation.getPathWithInfo(\n\t\t\t\t\t\t\t\t\t\t\t\tsourceMapFilename,\n\t\t\t\t\t\t\t\t\t\t\t\tpathParams\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tconst sourceMapUrl = options.publicPath\n\t\t\t\t\t\t\t\t\t\t\t? options.publicPath + sourceMapFile\n\t\t\t\t\t\t\t\t\t\t\t: relative(\n\t\t\t\t\t\t\t\t\t\t\t\t\toutputFs,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdirname(outputFs, `/${file}`),\n\t\t\t\t\t\t\t\t\t\t\t\t\t`/${sourceMapFile}`\n\t\t\t\t\t\t\t\t\t\t\t  );\n\t\t\t\t\t\t\t\t\t\t/** @type {Source} */\n\t\t\t\t\t\t\t\t\t\tlet asset = new RawSource(source);\n\t\t\t\t\t\t\t\t\t\tif (currentSourceMappingURLComment !== false) {\n\t\t\t\t\t\t\t\t\t\t\t// Add source map url to compilation asset, if currentSourceMappingURLComment is set\n\t\t\t\t\t\t\t\t\t\t\tasset = new ConcatSource(\n\t\t\t\t\t\t\t\t\t\t\t\tasset,\n\t\t\t\t\t\t\t\t\t\t\t\tcompilation.getPath(\n\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment,\n\t\t\t\t\t\t\t\t\t\t\t\t\tObject.assign({ url: sourceMapUrl }, pathParams)\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst assetInfo = {\n\t\t\t\t\t\t\t\t\t\t\trelated: { sourceMap: sourceMapFile }\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tassets[file] = asset;\n\t\t\t\t\t\t\t\t\t\tassetsInfo[file] = assetInfo;\n\t\t\t\t\t\t\t\t\t\tcompilation.updateAsset(file, asset, assetInfo);\n\t\t\t\t\t\t\t\t\t\t// Add source map file to compilation assets and chunk files\n\t\t\t\t\t\t\t\t\t\tconst sourceMapAsset = new RawSource(sourceMapString);\n\t\t\t\t\t\t\t\t\t\tconst sourceMapAssetInfo = {\n\t\t\t\t\t\t\t\t\t\t\t...sourceMapInfo,\n\t\t\t\t\t\t\t\t\t\t\tdevelopment: true\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tassets[sourceMapFile] = sourceMapAsset;\n\t\t\t\t\t\t\t\t\t\tassetsInfo[sourceMapFile] = sourceMapAssetInfo;\n\t\t\t\t\t\t\t\t\t\tcompilation.emitAsset(\n\t\t\t\t\t\t\t\t\t\t\tsourceMapFile,\n\t\t\t\t\t\t\t\t\t\t\tsourceMapAsset,\n\t\t\t\t\t\t\t\t\t\t\tsourceMapAssetInfo\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tif (chunk !== undefined)\n\t\t\t\t\t\t\t\t\t\t\tchunk.auxiliaryFiles.add(sourceMapFile);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif (currentSourceMappingURLComment === false) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\"SourceMapDevToolPlugin: append can't be false when no filename is provided\"\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t\t * Add source map as data url to asset\n\t\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\t\tconst asset = new ConcatSource(\n\t\t\t\t\t\t\t\t\t\t\tnew RawSource(source),\n\t\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment\n\t\t\t\t\t\t\t\t\t\t\t\t.replace(/\\[map\\]/g, () => sourceMapString)\n\t\t\t\t\t\t\t\t\t\t\t\t.replace(\n\t\t\t\t\t\t\t\t\t\t\t\t\t/\\[url\\]/g,\n\t\t\t\t\t\t\t\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`data:application/json;charset=utf-8;base64,${Buffer.from(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsourceMapString,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"utf-8\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t).toString(\"base64\")}`\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tassets[file] = asset;\n\t\t\t\t\t\t\t\t\t\tassetsInfo[file] = undefined;\n\t\t\t\t\t\t\t\t\t\tcompilation.updateAsset(file, asset);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttask.cacheItem.store({ assets, assetsInfo }, err => {\n\t\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t\t0.5 + (0.5 * ++taskIndex) / tasks.length,\n\t\t\t\t\t\t\t\t\t\t\ttask.file,\n\t\t\t\t\t\t\t\t\t\t\t\"attached SourceMap\"\n\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\treportProgress(1.0);\n\t\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = SourceMapDevToolPlugin;\n"]},"metadata":{},"sourceType":"script"}