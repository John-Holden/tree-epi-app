{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar _asyncToGenerator = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _require = require(\"enhanced-resolve\"),\n    forEachBail = _require.forEachBail;\n\nvar asyncLib = require(\"neo-async\");\n\nvar _getLazyHashedEtag = require(\"./cache/getLazyHashedEtag\");\n\nvar _mergeEtags = require(\"./cache/mergeEtags\");\n/** @typedef {import(\"./Cache\")} Cache */\n\n/** @typedef {import(\"./Cache\").Etag} Etag */\n\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n\n/** @typedef {import(\"./cache/getLazyHashedEtag\").HashableObject} HashableObject */\n\n/** @typedef {typeof import(\"./util/Hash\")} HashConstructor */\n\n/**\n * @template T\n * @callback CallbackCache\n * @param {(WebpackError | null)=} err\n * @param {T=} result\n * @returns {void}\n */\n\n/**\n * @template T\n * @callback CallbackNormalErrorCache\n * @param {(Error | null)=} err\n * @param {T=} result\n * @returns {void}\n */\n\n\nvar MultiItemCache = /*#__PURE__*/function () {\n  /**\n   * @param {ItemCacheFacade[]} items item caches\n   */\n  function MultiItemCache(items) {\n    _classCallCheck(this, MultiItemCache);\n\n    this._items = items;\n    if (items.length === 1) return (\n      /** @type {any} */\n      items[0]\n    );\n  }\n  /**\n   * @template T\n   * @param {CallbackCache<T>} callback signals when the value is retrieved\n   * @returns {void}\n   */\n\n\n  _createClass(MultiItemCache, [{\n    key: \"get\",\n    value: function get(callback) {\n      forEachBail(this._items, function (item, callback) {\n        return item.get(callback);\n      }, callback);\n    }\n    /**\n     * @template T\n     * @returns {Promise<T>} promise with the data\n     */\n\n  }, {\n    key: \"getPromise\",\n    value: function getPromise() {\n      var _this = this;\n\n      var next = function next(i) {\n        return _this._items[i].getPromise().then(function (result) {\n          if (result !== undefined) return result;\n          if (++i < _this._items.length) return next(i);\n        });\n      };\n\n      return next(0);\n    }\n    /**\n     * @template T\n     * @param {T} data the value to store\n     * @param {CallbackCache<void>} callback signals when the value is stored\n     * @returns {void}\n     */\n\n  }, {\n    key: \"store\",\n    value: function store(data, callback) {\n      asyncLib.each(this._items, function (item, callback) {\n        return item.store(data, callback);\n      }, callback);\n    }\n    /**\n     * @template T\n     * @param {T} data the value to store\n     * @returns {Promise<void>} promise signals when the value is stored\n     */\n\n  }, {\n    key: \"storePromise\",\n    value: function storePromise(data) {\n      return Promise.all(this._items.map(function (item) {\n        return item.storePromise(data);\n      })).then(function () {});\n    }\n  }]);\n\n  return MultiItemCache;\n}();\n\nvar ItemCacheFacade = /*#__PURE__*/function () {\n  /**\n   * @param {Cache} cache the root cache\n   * @param {string} name the child cache item name\n   * @param {Etag | null} etag the etag\n   */\n  function ItemCacheFacade(cache, name, etag) {\n    _classCallCheck(this, ItemCacheFacade);\n\n    this._cache = cache;\n    this._name = name;\n    this._etag = etag;\n  }\n  /**\n   * @template T\n   * @param {CallbackCache<T>} callback signals when the value is retrieved\n   * @returns {void}\n   */\n\n\n  _createClass(ItemCacheFacade, [{\n    key: \"get\",\n    value: function get(callback) {\n      this._cache.get(this._name, this._etag, callback);\n    }\n    /**\n     * @template T\n     * @returns {Promise<T>} promise with the data\n     */\n\n  }, {\n    key: \"getPromise\",\n    value: function getPromise() {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this2._cache.get(_this2._name, _this2._etag, function (err, data) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(data);\n          }\n        });\n      });\n    }\n    /**\n     * @template T\n     * @param {T} data the value to store\n     * @param {CallbackCache<void>} callback signals when the value is stored\n     * @returns {void}\n     */\n\n  }, {\n    key: \"store\",\n    value: function store(data, callback) {\n      this._cache.store(this._name, this._etag, data, callback);\n    }\n    /**\n     * @template T\n     * @param {T} data the value to store\n     * @returns {Promise<void>} promise signals when the value is stored\n     */\n\n  }, {\n    key: \"storePromise\",\n    value: function storePromise(data) {\n      var _this3 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this3._cache.store(_this3._name, _this3._etag, data, function (err) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve();\n          }\n        });\n      });\n    }\n    /**\n     * @template T\n     * @param {function(CallbackNormalErrorCache<T>): void} computer function to compute the value if not cached\n     * @param {CallbackNormalErrorCache<T>} callback signals when the value is retrieved\n     * @returns {void}\n     */\n\n  }, {\n    key: \"provide\",\n    value: function provide(computer, callback) {\n      var _this4 = this;\n\n      this.get(function (err, cacheEntry) {\n        if (err) return callback(err);\n        if (cacheEntry !== undefined) return cacheEntry;\n        computer(function (err, result) {\n          if (err) return callback(err);\n\n          _this4.store(result, function (err) {\n            if (err) return callback(err);\n            callback(null, result);\n          });\n        });\n      });\n    }\n    /**\n     * @template T\n     * @param {function(): Promise<T> | T} computer function to compute the value if not cached\n     * @returns {Promise<T>} promise with the data\n     */\n\n  }, {\n    key: \"providePromise\",\n    value: function () {\n      var _providePromise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(computer) {\n        var cacheEntry, result;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.getPromise();\n\n              case 2:\n                cacheEntry = _context.sent;\n\n                if (!(cacheEntry !== undefined)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", cacheEntry);\n\n              case 5:\n                _context.next = 7;\n                return computer();\n\n              case 7:\n                result = _context.sent;\n                _context.next = 10;\n                return this.storePromise(result);\n\n              case 10:\n                return _context.abrupt(\"return\", result);\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function providePromise(_x) {\n        return _providePromise.apply(this, arguments);\n      }\n\n      return providePromise;\n    }()\n  }]);\n\n  return ItemCacheFacade;\n}();\n\nvar CacheFacade = /*#__PURE__*/function () {\n  /**\n   * @param {Cache} cache the root cache\n   * @param {string} name the child cache name\n   * @param {string | HashConstructor} hashFunction the hash function to use\n   */\n  function CacheFacade(cache, name, hashFunction) {\n    _classCallCheck(this, CacheFacade);\n\n    this._cache = cache;\n    this._name = name;\n    this._hashFunction = hashFunction;\n  }\n  /**\n   * @param {string} name the child cache name#\n   * @returns {CacheFacade} child cache\n   */\n\n\n  _createClass(CacheFacade, [{\n    key: \"getChildCache\",\n    value: function getChildCache(name) {\n      return new CacheFacade(this._cache, \"\".concat(this._name, \"|\").concat(name), this._hashFunction);\n    }\n    /**\n     * @param {string} identifier the cache identifier\n     * @param {Etag | null} etag the etag\n     * @returns {ItemCacheFacade} item cache\n     */\n\n  }, {\n    key: \"getItemCache\",\n    value: function getItemCache(identifier, etag) {\n      return new ItemCacheFacade(this._cache, \"\".concat(this._name, \"|\").concat(identifier), etag);\n    }\n    /**\n     * @param {HashableObject} obj an hashable object\n     * @returns {Etag} an etag that is lazy hashed\n     */\n\n  }, {\n    key: \"getLazyHashedEtag\",\n    value: function getLazyHashedEtag(obj) {\n      return _getLazyHashedEtag(obj, this._hashFunction);\n    }\n    /**\n     * @param {Etag} a an etag\n     * @param {Etag} b another etag\n     * @returns {Etag} an etag that represents both\n     */\n\n  }, {\n    key: \"mergeEtags\",\n    value: function mergeEtags(a, b) {\n      return _mergeEtags(a, b);\n    }\n    /**\n     * @template T\n     * @param {string} identifier the cache identifier\n     * @param {Etag | null} etag the etag\n     * @param {CallbackCache<T>} callback signals when the value is retrieved\n     * @returns {void}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(identifier, etag, callback) {\n      this._cache.get(\"\".concat(this._name, \"|\").concat(identifier), etag, callback);\n    }\n    /**\n     * @template T\n     * @param {string} identifier the cache identifier\n     * @param {Etag | null} etag the etag\n     * @returns {Promise<T>} promise with the data\n     */\n\n  }, {\n    key: \"getPromise\",\n    value: function getPromise(identifier, etag) {\n      var _this5 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this5._cache.get(\"\".concat(_this5._name, \"|\").concat(identifier), etag, function (err, data) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(data);\n          }\n        });\n      });\n    }\n    /**\n     * @template T\n     * @param {string} identifier the cache identifier\n     * @param {Etag | null} etag the etag\n     * @param {T} data the value to store\n     * @param {CallbackCache<void>} callback signals when the value is stored\n     * @returns {void}\n     */\n\n  }, {\n    key: \"store\",\n    value: function store(identifier, etag, data, callback) {\n      this._cache.store(\"\".concat(this._name, \"|\").concat(identifier), etag, data, callback);\n    }\n    /**\n     * @template T\n     * @param {string} identifier the cache identifier\n     * @param {Etag | null} etag the etag\n     * @param {T} data the value to store\n     * @returns {Promise<void>} promise signals when the value is stored\n     */\n\n  }, {\n    key: \"storePromise\",\n    value: function storePromise(identifier, etag, data) {\n      var _this6 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this6._cache.store(\"\".concat(_this6._name, \"|\").concat(identifier), etag, data, function (err) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve();\n          }\n        });\n      });\n    }\n    /**\n     * @template T\n     * @param {string} identifier the cache identifier\n     * @param {Etag | null} etag the etag\n     * @param {function(CallbackNormalErrorCache<T>): void} computer function to compute the value if not cached\n     * @param {CallbackNormalErrorCache<T>} callback signals when the value is retrieved\n     * @returns {void}\n     */\n\n  }, {\n    key: \"provide\",\n    value: function provide(identifier, etag, computer, callback) {\n      var _this7 = this;\n\n      this.get(identifier, etag, function (err, cacheEntry) {\n        if (err) return callback(err);\n        if (cacheEntry !== undefined) return cacheEntry;\n        computer(function (err, result) {\n          if (err) return callback(err);\n\n          _this7.store(identifier, etag, result, function (err) {\n            if (err) return callback(err);\n            callback(null, result);\n          });\n        });\n      });\n    }\n    /**\n     * @template T\n     * @param {string} identifier the cache identifier\n     * @param {Etag | null} etag the etag\n     * @param {function(): Promise<T> | T} computer function to compute the value if not cached\n     * @returns {Promise<T>} promise with the data\n     */\n\n  }, {\n    key: \"providePromise\",\n    value: function () {\n      var _providePromise2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(identifier, etag, computer) {\n        var cacheEntry, result;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.getPromise(identifier, etag);\n\n              case 2:\n                cacheEntry = _context2.sent;\n\n                if (!(cacheEntry !== undefined)) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", cacheEntry);\n\n              case 5:\n                _context2.next = 7;\n                return computer();\n\n              case 7:\n                result = _context2.sent;\n                _context2.next = 10;\n                return this.storePromise(identifier, etag, result);\n\n              case 10:\n                return _context2.abrupt(\"return\", result);\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function providePromise(_x2, _x3, _x4) {\n        return _providePromise2.apply(this, arguments);\n      }\n\n      return providePromise;\n    }()\n  }]);\n\n  return CacheFacade;\n}();\n\nmodule.exports = CacheFacade;\nmodule.exports.ItemCacheFacade = ItemCacheFacade;\nmodule.exports.MultiItemCache = MultiItemCache;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/CacheFacade.js"],"names":["require","forEachBail","asyncLib","getLazyHashedEtag","mergeEtags","MultiItemCache","items","_items","length","callback","item","get","next","i","getPromise","then","result","undefined","data","each","store","Promise","all","map","storePromise","ItemCacheFacade","cache","name","etag","_cache","_name","_etag","resolve","reject","err","computer","cacheEntry","CacheFacade","hashFunction","_hashFunction","identifier","obj","a","b","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAEA,eAAwBA,OAAO,CAAC,kBAAD,CAA/B;AAAA,IAAQC,WAAR,YAAQA,WAAR;;AACA,IAAMC,QAAQ,GAAGF,OAAO,CAAC,WAAD,CAAxB;;AACA,IAAMG,kBAAiB,GAAGH,OAAO,CAAC,2BAAD,CAAjC;;AACA,IAAMI,WAAU,GAAGJ,OAAO,CAAC,oBAAD,CAA1B;AAEA;;AACA;;AACA;;AACA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;IAEMK,c;AACL;AACD;AACA;AACC,0BAAYC,KAAZ,EAAmB;AAAA;;AAClB,SAAKC,MAAL,GAAcD,KAAd;AACA,QAAIA,KAAK,CAACE,MAAN,KAAiB,CAArB,EAAwB;AAAO;AAAoBF,MAAAA,KAAK,CAAC,CAAD;AAAhC;AACxB;AAED;AACD;AACA;AACA;AACA;;;;;WACC,aAAIG,QAAJ,EAAc;AACbR,MAAAA,WAAW,CAAC,KAAKM,MAAN,EAAc,UAACG,IAAD,EAAOD,QAAP;AAAA,eAAoBC,IAAI,CAACC,GAAL,CAASF,QAAT,CAApB;AAAA,OAAd,EAAsDA,QAAtD,CAAX;AACA;AAED;AACD;AACA;AACA;;;;WACC,sBAAa;AAAA;;AACZ,UAAMG,IAAI,GAAG,SAAPA,IAAO,CAAAC,CAAC,EAAI;AACjB,eAAO,KAAI,CAACN,MAAL,CAAYM,CAAZ,EAAeC,UAAf,GAA4BC,IAA5B,CAAiC,UAAAC,MAAM,EAAI;AACjD,cAAIA,MAAM,KAAKC,SAAf,EAA0B,OAAOD,MAAP;AAC1B,cAAI,EAAEH,CAAF,GAAM,KAAI,CAACN,MAAL,CAAYC,MAAtB,EAA8B,OAAOI,IAAI,CAACC,CAAD,CAAX;AAC9B,SAHM,CAAP;AAIA,OALD;;AAMA,aAAOD,IAAI,CAAC,CAAD,CAAX;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;WACC,eAAMM,IAAN,EAAYT,QAAZ,EAAsB;AACrBP,MAAAA,QAAQ,CAACiB,IAAT,CACC,KAAKZ,MADN,EAEC,UAACG,IAAD,EAAOD,QAAP;AAAA,eAAoBC,IAAI,CAACU,KAAL,CAAWF,IAAX,EAAiBT,QAAjB,CAApB;AAAA,OAFD,EAGCA,QAHD;AAKA;AAED;AACD;AACA;AACA;AACA;;;;WACC,sBAAaS,IAAb,EAAmB;AAClB,aAAOG,OAAO,CAACC,GAAR,CAAY,KAAKf,MAAL,CAAYgB,GAAZ,CAAgB,UAAAb,IAAI;AAAA,eAAIA,IAAI,CAACc,YAAL,CAAkBN,IAAlB,CAAJ;AAAA,OAApB,CAAZ,EAA8DH,IAA9D,CACN,YAAM,CAAE,CADF,CAAP;AAGA;;;;;;IAGIU,e;AACL;AACD;AACA;AACA;AACA;AACC,2BAAYC,KAAZ,EAAmBC,IAAnB,EAAyBC,IAAzB,EAA+B;AAAA;;AAC9B,SAAKC,MAAL,GAAcH,KAAd;AACA,SAAKI,KAAL,GAAaH,IAAb;AACA,SAAKI,KAAL,GAAaH,IAAb;AACA;AAED;AACD;AACA;AACA;AACA;;;;;WACC,aAAInB,QAAJ,EAAc;AACb,WAAKoB,MAAL,CAAYlB,GAAZ,CAAgB,KAAKmB,KAArB,EAA4B,KAAKC,KAAjC,EAAwCtB,QAAxC;AACA;AAED;AACD;AACA;AACA;;;;WACC,sBAAa;AAAA;;AACZ,aAAO,IAAIY,OAAJ,CAAY,UAACW,OAAD,EAAUC,MAAV,EAAqB;AACvC,QAAA,MAAI,CAACJ,MAAL,CAAYlB,GAAZ,CAAgB,MAAI,CAACmB,KAArB,EAA4B,MAAI,CAACC,KAAjC,EAAwC,UAACG,GAAD,EAAMhB,IAAN,EAAe;AACtD,cAAIgB,GAAJ,EAAS;AACRD,YAAAA,MAAM,CAACC,GAAD,CAAN;AACA,WAFD,MAEO;AACNF,YAAAA,OAAO,CAACd,IAAD,CAAP;AACA;AACD,SAND;AAOA,OARM,CAAP;AASA;AAED;AACD;AACA;AACA;AACA;AACA;;;;WACC,eAAMA,IAAN,EAAYT,QAAZ,EAAsB;AACrB,WAAKoB,MAAL,CAAYT,KAAZ,CAAkB,KAAKU,KAAvB,EAA8B,KAAKC,KAAnC,EAA0Cb,IAA1C,EAAgDT,QAAhD;AACA;AAED;AACD;AACA;AACA;AACA;;;;WACC,sBAAaS,IAAb,EAAmB;AAAA;;AAClB,aAAO,IAAIG,OAAJ,CAAY,UAACW,OAAD,EAAUC,MAAV,EAAqB;AACvC,QAAA,MAAI,CAACJ,MAAL,CAAYT,KAAZ,CAAkB,MAAI,CAACU,KAAvB,EAA8B,MAAI,CAACC,KAAnC,EAA0Cb,IAA1C,EAAgD,UAAAgB,GAAG,EAAI;AACtD,cAAIA,GAAJ,EAAS;AACRD,YAAAA,MAAM,CAACC,GAAD,CAAN;AACA,WAFD,MAEO;AACNF,YAAAA,OAAO;AACP;AACD,SAND;AAOA,OARM,CAAP;AASA;AAED;AACD;AACA;AACA;AACA;AACA;;;;WACC,iBAAQG,QAAR,EAAkB1B,QAAlB,EAA4B;AAAA;;AAC3B,WAAKE,GAAL,CAAS,UAACuB,GAAD,EAAME,UAAN,EAAqB;AAC7B,YAAIF,GAAJ,EAAS,OAAOzB,QAAQ,CAACyB,GAAD,CAAf;AACT,YAAIE,UAAU,KAAKnB,SAAnB,EAA8B,OAAOmB,UAAP;AAC9BD,QAAAA,QAAQ,CAAC,UAACD,GAAD,EAAMlB,MAAN,EAAiB;AACzB,cAAIkB,GAAJ,EAAS,OAAOzB,QAAQ,CAACyB,GAAD,CAAf;;AACT,UAAA,MAAI,CAACd,KAAL,CAAWJ,MAAX,EAAmB,UAAAkB,GAAG,EAAI;AACzB,gBAAIA,GAAJ,EAAS,OAAOzB,QAAQ,CAACyB,GAAD,CAAf;AACTzB,YAAAA,QAAQ,CAAC,IAAD,EAAOO,MAAP,CAAR;AACA,WAHD;AAIA,SANO,CAAR;AAOA,OAVD;AAWA;AAED;AACD;AACA;AACA;AACA;;;;;qFACC,iBAAqBmB,QAArB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAC0B,KAAKrB,UAAL,EAD1B;;AAAA;AACOsB,gBAAAA,UADP;;AAAA,sBAEKA,UAAU,KAAKnB,SAFpB;AAAA;AAAA;AAAA;;AAAA,iDAEsCmB,UAFtC;;AAAA;AAAA;AAAA,uBAGsBD,QAAQ,EAH9B;;AAAA;AAGOnB,gBAAAA,MAHP;AAAA;AAAA,uBAIO,KAAKQ,YAAL,CAAkBR,MAAlB,CAJP;;AAAA;AAAA,iDAKQA,MALR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;;;IASKqB,W;AACL;AACD;AACA;AACA;AACA;AACC,uBAAYX,KAAZ,EAAmBC,IAAnB,EAAyBW,YAAzB,EAAuC;AAAA;;AACtC,SAAKT,MAAL,GAAcH,KAAd;AACA,SAAKI,KAAL,GAAaH,IAAb;AACA,SAAKY,aAAL,GAAqBD,YAArB;AACA;AAED;AACD;AACA;AACA;;;;;WACC,uBAAcX,IAAd,EAAoB;AACnB,aAAO,IAAIU,WAAJ,CACN,KAAKR,MADC,YAEH,KAAKC,KAFF,cAEWH,IAFX,GAGN,KAAKY,aAHC,CAAP;AAKA;AAED;AACD;AACA;AACA;AACA;;;;WACC,sBAAaC,UAAb,EAAyBZ,IAAzB,EAA+B;AAC9B,aAAO,IAAIH,eAAJ,CACN,KAAKI,MADC,YAEH,KAAKC,KAFF,cAEWU,UAFX,GAGNZ,IAHM,CAAP;AAKA;AAED;AACD;AACA;AACA;;;;WACC,2BAAkBa,GAAlB,EAAuB;AACtB,aAAOtC,kBAAiB,CAACsC,GAAD,EAAM,KAAKF,aAAX,CAAxB;AACA;AAED;AACD;AACA;AACA;AACA;;;;WACC,oBAAWG,CAAX,EAAcC,CAAd,EAAiB;AAChB,aAAOvC,WAAU,CAACsC,CAAD,EAAIC,CAAJ,CAAjB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;WACC,aAAIH,UAAJ,EAAgBZ,IAAhB,EAAsBnB,QAAtB,EAAgC;AAC/B,WAAKoB,MAAL,CAAYlB,GAAZ,WAAmB,KAAKmB,KAAxB,cAAiCU,UAAjC,GAA+CZ,IAA/C,EAAqDnB,QAArD;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;WACC,oBAAW+B,UAAX,EAAuBZ,IAAvB,EAA6B;AAAA;;AAC5B,aAAO,IAAIP,OAAJ,CAAY,UAACW,OAAD,EAAUC,MAAV,EAAqB;AACvC,QAAA,MAAI,CAACJ,MAAL,CAAYlB,GAAZ,WAAmB,MAAI,CAACmB,KAAxB,cAAiCU,UAAjC,GAA+CZ,IAA/C,EAAqD,UAACM,GAAD,EAAMhB,IAAN,EAAe;AACnE,cAAIgB,GAAJ,EAAS;AACRD,YAAAA,MAAM,CAACC,GAAD,CAAN;AACA,WAFD,MAEO;AACNF,YAAAA,OAAO,CAACd,IAAD,CAAP;AACA;AACD,SAND;AAOA,OARM,CAAP;AASA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,eAAMsB,UAAN,EAAkBZ,IAAlB,EAAwBV,IAAxB,EAA8BT,QAA9B,EAAwC;AACvC,WAAKoB,MAAL,CAAYT,KAAZ,WAAqB,KAAKU,KAA1B,cAAmCU,UAAnC,GAAiDZ,IAAjD,EAAuDV,IAAvD,EAA6DT,QAA7D;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;WACC,sBAAa+B,UAAb,EAAyBZ,IAAzB,EAA+BV,IAA/B,EAAqC;AAAA;;AACpC,aAAO,IAAIG,OAAJ,CAAY,UAACW,OAAD,EAAUC,MAAV,EAAqB;AACvC,QAAA,MAAI,CAACJ,MAAL,CAAYT,KAAZ,WAAqB,MAAI,CAACU,KAA1B,cAAmCU,UAAnC,GAAiDZ,IAAjD,EAAuDV,IAAvD,EAA6D,UAAAgB,GAAG,EAAI;AACnE,cAAIA,GAAJ,EAAS;AACRD,YAAAA,MAAM,CAACC,GAAD,CAAN;AACA,WAFD,MAEO;AACNF,YAAAA,OAAO;AACP;AACD,SAND;AAOA,OARM,CAAP;AASA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,iBAAQQ,UAAR,EAAoBZ,IAApB,EAA0BO,QAA1B,EAAoC1B,QAApC,EAA8C;AAAA;;AAC7C,WAAKE,GAAL,CAAS6B,UAAT,EAAqBZ,IAArB,EAA2B,UAACM,GAAD,EAAME,UAAN,EAAqB;AAC/C,YAAIF,GAAJ,EAAS,OAAOzB,QAAQ,CAACyB,GAAD,CAAf;AACT,YAAIE,UAAU,KAAKnB,SAAnB,EAA8B,OAAOmB,UAAP;AAC9BD,QAAAA,QAAQ,CAAC,UAACD,GAAD,EAAMlB,MAAN,EAAiB;AACzB,cAAIkB,GAAJ,EAAS,OAAOzB,QAAQ,CAACyB,GAAD,CAAf;;AACT,UAAA,MAAI,CAACd,KAAL,CAAWoB,UAAX,EAAuBZ,IAAvB,EAA6BZ,MAA7B,EAAqC,UAAAkB,GAAG,EAAI;AAC3C,gBAAIA,GAAJ,EAAS,OAAOzB,QAAQ,CAACyB,GAAD,CAAf;AACTzB,YAAAA,QAAQ,CAAC,IAAD,EAAOO,MAAP,CAAR;AACA,WAHD;AAIA,SANO,CAAR;AAOA,OAVD;AAWA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;;sFACC,kBAAqBwB,UAArB,EAAiCZ,IAAjC,EAAuCO,QAAvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAC0B,KAAKrB,UAAL,CAAgB0B,UAAhB,EAA4BZ,IAA5B,CAD1B;;AAAA;AACOQ,gBAAAA,UADP;;AAAA,sBAEKA,UAAU,KAAKnB,SAFpB;AAAA;AAAA;AAAA;;AAAA,kDAEsCmB,UAFtC;;AAAA;AAAA;AAAA,uBAGsBD,QAAQ,EAH9B;;AAAA;AAGOnB,gBAAAA,MAHP;AAAA;AAAA,uBAIO,KAAKQ,YAAL,CAAkBgB,UAAlB,EAA8BZ,IAA9B,EAAoCZ,MAApC,CAJP;;AAAA;AAAA,kDAKQA,MALR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;;;AASD4B,MAAM,CAACC,OAAP,GAAiBR,WAAjB;AACAO,MAAM,CAACC,OAAP,CAAepB,eAAf,GAAiCA,eAAjC;AACAmB,MAAM,CAACC,OAAP,CAAexC,cAAf,GAAgCA,cAAhC","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { forEachBail } = require(\"enhanced-resolve\");\nconst asyncLib = require(\"neo-async\");\nconst getLazyHashedEtag = require(\"./cache/getLazyHashedEtag\");\nconst mergeEtags = require(\"./cache/mergeEtags\");\n\n/** @typedef {import(\"./Cache\")} Cache */\n/** @typedef {import(\"./Cache\").Etag} Etag */\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n/** @typedef {import(\"./cache/getLazyHashedEtag\").HashableObject} HashableObject */\n/** @typedef {typeof import(\"./util/Hash\")} HashConstructor */\n\n/**\n * @template T\n * @callback CallbackCache\n * @param {(WebpackError | null)=} err\n * @param {T=} result\n * @returns {void}\n */\n\n/**\n * @template T\n * @callback CallbackNormalErrorCache\n * @param {(Error | null)=} err\n * @param {T=} result\n * @returns {void}\n */\n\nclass MultiItemCache {\n\t/**\n\t * @param {ItemCacheFacade[]} items item caches\n\t */\n\tconstructor(items) {\n\t\tthis._items = items;\n\t\tif (items.length === 1) return /** @type {any} */ (items[0]);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {CallbackCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tget(callback) {\n\t\tforEachBail(this._items, (item, callback) => item.get(callback), callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tgetPromise() {\n\t\tconst next = i => {\n\t\t\treturn this._items[i].getPromise().then(result => {\n\t\t\t\tif (result !== undefined) return result;\n\t\t\t\tif (++i < this._items.length) return next(i);\n\t\t\t});\n\t\t};\n\t\treturn next(0);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {T} data the value to store\n\t * @param {CallbackCache<void>} callback signals when the value is stored\n\t * @returns {void}\n\t */\n\tstore(data, callback) {\n\t\tasyncLib.each(\n\t\t\tthis._items,\n\t\t\t(item, callback) => item.store(data, callback),\n\t\t\tcallback\n\t\t);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {T} data the value to store\n\t * @returns {Promise<void>} promise signals when the value is stored\n\t */\n\tstorePromise(data) {\n\t\treturn Promise.all(this._items.map(item => item.storePromise(data))).then(\n\t\t\t() => {}\n\t\t);\n\t}\n}\n\nclass ItemCacheFacade {\n\t/**\n\t * @param {Cache} cache the root cache\n\t * @param {string} name the child cache item name\n\t * @param {Etag | null} etag the etag\n\t */\n\tconstructor(cache, name, etag) {\n\t\tthis._cache = cache;\n\t\tthis._name = name;\n\t\tthis._etag = etag;\n\t}\n\n\t/**\n\t * @template T\n\t * @param {CallbackCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tget(callback) {\n\t\tthis._cache.get(this._name, this._etag, callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tgetPromise() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._cache.get(this._name, this._etag, (err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(data);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {T} data the value to store\n\t * @param {CallbackCache<void>} callback signals when the value is stored\n\t * @returns {void}\n\t */\n\tstore(data, callback) {\n\t\tthis._cache.store(this._name, this._etag, data, callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {T} data the value to store\n\t * @returns {Promise<void>} promise signals when the value is stored\n\t */\n\tstorePromise(data) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._cache.store(this._name, this._etag, data, err => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {function(CallbackNormalErrorCache<T>): void} computer function to compute the value if not cached\n\t * @param {CallbackNormalErrorCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tprovide(computer, callback) {\n\t\tthis.get((err, cacheEntry) => {\n\t\t\tif (err) return callback(err);\n\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\tcomputer((err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tthis.store(result, err => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tcallback(null, result);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {function(): Promise<T> | T} computer function to compute the value if not cached\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tasync providePromise(computer) {\n\t\tconst cacheEntry = await this.getPromise();\n\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\tconst result = await computer();\n\t\tawait this.storePromise(result);\n\t\treturn result;\n\t}\n}\n\nclass CacheFacade {\n\t/**\n\t * @param {Cache} cache the root cache\n\t * @param {string} name the child cache name\n\t * @param {string | HashConstructor} hashFunction the hash function to use\n\t */\n\tconstructor(cache, name, hashFunction) {\n\t\tthis._cache = cache;\n\t\tthis._name = name;\n\t\tthis._hashFunction = hashFunction;\n\t}\n\n\t/**\n\t * @param {string} name the child cache name#\n\t * @returns {CacheFacade} child cache\n\t */\n\tgetChildCache(name) {\n\t\treturn new CacheFacade(\n\t\t\tthis._cache,\n\t\t\t`${this._name}|${name}`,\n\t\t\tthis._hashFunction\n\t\t);\n\t}\n\n\t/**\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @returns {ItemCacheFacade} item cache\n\t */\n\tgetItemCache(identifier, etag) {\n\t\treturn new ItemCacheFacade(\n\t\t\tthis._cache,\n\t\t\t`${this._name}|${identifier}`,\n\t\t\tetag\n\t\t);\n\t}\n\n\t/**\n\t * @param {HashableObject} obj an hashable object\n\t * @returns {Etag} an etag that is lazy hashed\n\t */\n\tgetLazyHashedEtag(obj) {\n\t\treturn getLazyHashedEtag(obj, this._hashFunction);\n\t}\n\n\t/**\n\t * @param {Etag} a an etag\n\t * @param {Etag} b another etag\n\t * @returns {Etag} an etag that represents both\n\t */\n\tmergeEtags(a, b) {\n\t\treturn mergeEtags(a, b);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {CallbackCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tget(identifier, etag, callback) {\n\t\tthis._cache.get(`${this._name}|${identifier}`, etag, callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tgetPromise(identifier, etag) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._cache.get(`${this._name}|${identifier}`, etag, (err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(data);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {T} data the value to store\n\t * @param {CallbackCache<void>} callback signals when the value is stored\n\t * @returns {void}\n\t */\n\tstore(identifier, etag, data, callback) {\n\t\tthis._cache.store(`${this._name}|${identifier}`, etag, data, callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {T} data the value to store\n\t * @returns {Promise<void>} promise signals when the value is stored\n\t */\n\tstorePromise(identifier, etag, data) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._cache.store(`${this._name}|${identifier}`, etag, data, err => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {function(CallbackNormalErrorCache<T>): void} computer function to compute the value if not cached\n\t * @param {CallbackNormalErrorCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tprovide(identifier, etag, computer, callback) {\n\t\tthis.get(identifier, etag, (err, cacheEntry) => {\n\t\t\tif (err) return callback(err);\n\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\tcomputer((err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tthis.store(identifier, etag, result, err => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tcallback(null, result);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {function(): Promise<T> | T} computer function to compute the value if not cached\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tasync providePromise(identifier, etag, computer) {\n\t\tconst cacheEntry = await this.getPromise(identifier, etag);\n\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\tconst result = await computer();\n\t\tawait this.storePromise(identifier, etag, result);\n\t\treturn result;\n\t}\n}\n\nmodule.exports = CacheFacade;\nmodule.exports.ItemCacheFacade = ItemCacheFacade;\nmodule.exports.MultiItemCache = MultiItemCache;\n"]},"metadata":{},"sourceType":"script"}