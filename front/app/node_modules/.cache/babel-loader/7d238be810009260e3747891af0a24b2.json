{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _slicedToArray = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _require = require(\"../util/comparators\"),\n    compareModulesByPreOrderIndexOrIdentifier = _require.compareModulesByPreOrderIndexOrIdentifier;\n\nvar createSchemaValidation = require(\"../util/create-schema-validation\");\n\nvar _require2 = require(\"./IdHelpers\"),\n    assignAscendingModuleIds = _require2.assignAscendingModuleIds,\n    getUsedModuleIdsAndModules = _require2.getUsedModuleIdsAndModules;\n/** @typedef {import(\"../../declarations/plugins/ids/OccurrenceModuleIdsPlugin\").OccurrenceModuleIdsPluginOptions} OccurrenceModuleIdsPluginOptions */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n\n\nvar validate = createSchemaValidation(require(\"../../schemas/plugins/ids/OccurrenceModuleIdsPlugin.check.js\"), function () {\n  return require(\"../../schemas/plugins/ids/OccurrenceModuleIdsPlugin.json\");\n}, {\n  name: \"Occurrence Order Module Ids Plugin\",\n  baseDataPath: \"options\"\n});\n\nvar OccurrenceModuleIdsPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {OccurrenceModuleIdsPluginOptions=} options options object\n   */\n  function OccurrenceModuleIdsPlugin() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, OccurrenceModuleIdsPlugin);\n\n    validate(options);\n    this.options = options;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  _createClass(OccurrenceModuleIdsPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var prioritiseInitial = this.options.prioritiseInitial;\n      compiler.hooks.compilation.tap(\"OccurrenceModuleIdsPlugin\", function (compilation) {\n        var moduleGraph = compilation.moduleGraph;\n        compilation.hooks.moduleIds.tap(\"OccurrenceModuleIdsPlugin\", function () {\n          var chunkGraph = compilation.chunkGraph;\n\n          var _getUsedModuleIdsAndM = getUsedModuleIdsAndModules(compilation),\n              _getUsedModuleIdsAndM2 = _slicedToArray(_getUsedModuleIdsAndM, 2),\n              usedIds = _getUsedModuleIdsAndM2[0],\n              modulesInOccurrenceOrder = _getUsedModuleIdsAndM2[1];\n\n          var occursInInitialChunksMap = new Map();\n          var occursInAllChunksMap = new Map();\n          var initialChunkChunkMap = new Map();\n          var entryCountMap = new Map();\n\n          var _iterator = _createForOfIteratorHelper(modulesInOccurrenceOrder),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _m = _step.value;\n              var initial = 0;\n              var entry = 0;\n\n              var _iterator7 = _createForOfIteratorHelper(chunkGraph.getModuleChunksIterable(_m)),\n                  _step7;\n\n              try {\n                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                  var c = _step7.value;\n                  if (c.canBeInitial()) initial++;\n                  if (chunkGraph.isEntryModuleInChunk(_m, c)) entry++;\n                }\n              } catch (err) {\n                _iterator7.e(err);\n              } finally {\n                _iterator7.f();\n              }\n\n              initialChunkChunkMap.set(_m, initial);\n              entryCountMap.set(_m, entry);\n            }\n            /**\n             * @param {Module} module module\n             * @returns {number} count of occurs\n             */\n\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          var countOccursInEntry = function countOccursInEntry(module) {\n            var sum = 0;\n\n            var _iterator2 = _createForOfIteratorHelper(moduleGraph.getIncomingConnectionsByOriginModule(module)),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var _step2$value = _slicedToArray(_step2.value, 2),\n                    originModule = _step2$value[0],\n                    connections = _step2$value[1];\n\n                if (!originModule) continue;\n                if (!connections.some(function (c) {\n                  return c.isTargetActive(undefined);\n                })) continue;\n                sum += initialChunkChunkMap.get(originModule);\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n\n            return sum;\n          };\n          /**\n           * @param {Module} module module\n           * @returns {number} count of occurs\n           */\n\n\n          var countOccurs = function countOccurs(module) {\n            var sum = 0;\n\n            var _iterator3 = _createForOfIteratorHelper(moduleGraph.getIncomingConnectionsByOriginModule(module)),\n                _step3;\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var _step3$value = _slicedToArray(_step3.value, 2),\n                    originModule = _step3$value[0],\n                    connections = _step3$value[1];\n\n                if (!originModule) continue;\n                var chunkModules = chunkGraph.getNumberOfModuleChunks(originModule);\n\n                var _iterator4 = _createForOfIteratorHelper(connections),\n                    _step4;\n\n                try {\n                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                    var c = _step4.value;\n                    if (!c.isTargetActive(undefined)) continue;\n                    if (!c.dependency) continue;\n                    var factor = c.dependency.getNumberOfIdOccurrences();\n                    if (factor === 0) continue;\n                    sum += factor * chunkModules;\n                  }\n                } catch (err) {\n                  _iterator4.e(err);\n                } finally {\n                  _iterator4.f();\n                }\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n\n            return sum;\n          };\n\n          if (prioritiseInitial) {\n            var _iterator5 = _createForOfIteratorHelper(modulesInOccurrenceOrder),\n                _step5;\n\n            try {\n              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                var m = _step5.value;\n                var result = countOccursInEntry(m) + initialChunkChunkMap.get(m) + entryCountMap.get(m);\n                occursInInitialChunksMap.set(m, result);\n              }\n            } catch (err) {\n              _iterator5.e(err);\n            } finally {\n              _iterator5.f();\n            }\n          }\n\n          var _iterator6 = _createForOfIteratorHelper(modulesInOccurrenceOrder),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var _m2 = _step6.value;\n\n              var _result = countOccurs(_m2) + chunkGraph.getNumberOfModuleChunks(_m2) + entryCountMap.get(_m2);\n\n              occursInAllChunksMap.set(_m2, _result);\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n\n          var naturalCompare = compareModulesByPreOrderIndexOrIdentifier(compilation.moduleGraph);\n          modulesInOccurrenceOrder.sort(function (a, b) {\n            if (prioritiseInitial) {\n              var aEntryOccurs = occursInInitialChunksMap.get(a);\n              var bEntryOccurs = occursInInitialChunksMap.get(b);\n              if (aEntryOccurs > bEntryOccurs) return -1;\n              if (aEntryOccurs < bEntryOccurs) return 1;\n            }\n\n            var aOccurs = occursInAllChunksMap.get(a);\n            var bOccurs = occursInAllChunksMap.get(b);\n            if (aOccurs > bOccurs) return -1;\n            if (aOccurs < bOccurs) return 1;\n            return naturalCompare(a, b);\n          });\n          assignAscendingModuleIds(usedIds, modulesInOccurrenceOrder, compilation);\n        });\n      });\n    }\n  }]);\n\n  return OccurrenceModuleIdsPlugin;\n}();\n\nmodule.exports = OccurrenceModuleIdsPlugin;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/ids/OccurrenceModuleIdsPlugin.js"],"names":["require","compareModulesByPreOrderIndexOrIdentifier","createSchemaValidation","assignAscendingModuleIds","getUsedModuleIdsAndModules","validate","name","baseDataPath","OccurrenceModuleIdsPlugin","options","compiler","prioritiseInitial","hooks","compilation","tap","moduleGraph","moduleIds","chunkGraph","usedIds","modulesInOccurrenceOrder","occursInInitialChunksMap","Map","occursInAllChunksMap","initialChunkChunkMap","entryCountMap","m","initial","entry","getModuleChunksIterable","c","canBeInitial","isEntryModuleInChunk","set","countOccursInEntry","module","sum","getIncomingConnectionsByOriginModule","originModule","connections","some","isTargetActive","undefined","get","countOccurs","chunkModules","getNumberOfModuleChunks","dependency","factor","getNumberOfIdOccurrences","result","naturalCompare","sort","a","b","aEntryOccurs","bEntryOccurs","aOccurs","bOccurs","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAEA,eAEIA,OAAO,CAAC,qBAAD,CAFX;AAAA,IACCC,yCADD,YACCA,yCADD;;AAGA,IAAMC,sBAAsB,GAAGF,OAAO,CAAC,kCAAD,CAAtC;;AACA,gBAGIA,OAAO,CAAC,aAAD,CAHX;AAAA,IACCG,wBADD,aACCA,wBADD;AAAA,IAECC,0BAFD,aAECA,0BAFD;AAKA;;AACA;;AACA;;AACA;;;AAEA,IAAMC,QAAQ,GAAGH,sBAAsB,CACtCF,OAAO,CAAC,8DAAD,CAD+B,EAEtC;AAAA,SAAMA,OAAO,CAAC,0DAAD,CAAb;AAAA,CAFsC,EAGtC;AACCM,EAAAA,IAAI,EAAE,oCADP;AAECC,EAAAA,YAAY,EAAE;AAFf,CAHsC,CAAvC;;IASMC,yB;AACL;AACD;AACA;AACC,uCAA0B;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AAAA;;AACzBJ,IAAAA,QAAQ,CAACI,OAAD,CAAR;AACA,SAAKA,OAAL,GAAeA,OAAf;AACA;AAED;AACD;AACA;AACA;AACA;;;;;WACC,eAAMC,QAAN,EAAgB;AACf,UAAMC,iBAAiB,GAAG,KAAKF,OAAL,CAAaE,iBAAvC;AACAD,MAAAA,QAAQ,CAACE,KAAT,CAAeC,WAAf,CAA2BC,GAA3B,CAA+B,2BAA/B,EAA4D,UAAAD,WAAW,EAAI;AAC1E,YAAME,WAAW,GAAGF,WAAW,CAACE,WAAhC;AAEAF,QAAAA,WAAW,CAACD,KAAZ,CAAkBI,SAAlB,CAA4BF,GAA5B,CAAgC,2BAAhC,EAA6D,YAAM;AAClE,cAAMG,UAAU,GAAGJ,WAAW,CAACI,UAA/B;;AAEA,sCACCb,0BAA0B,CAACS,WAAD,CAD3B;AAAA;AAAA,cAAOK,OAAP;AAAA,cAAgBC,wBAAhB;;AAGA,cAAMC,wBAAwB,GAAG,IAAIC,GAAJ,EAAjC;AACA,cAAMC,oBAAoB,GAAG,IAAID,GAAJ,EAA7B;AAEA,cAAME,oBAAoB,GAAG,IAAIF,GAAJ,EAA7B;AACA,cAAMG,aAAa,GAAG,IAAIH,GAAJ,EAAtB;;AAVkE,qDAWlDF,wBAXkD;AAAA;;AAAA;AAWlE,gEAA0C;AAAA,kBAA/BM,EAA+B;AACzC,kBAAIC,OAAO,GAAG,CAAd;AACA,kBAAIC,KAAK,GAAG,CAAZ;;AAFyC,0DAGzBV,UAAU,CAACW,uBAAX,CAAmCH,EAAnC,CAHyB;AAAA;;AAAA;AAGzC,uEAAuD;AAAA,sBAA5CI,CAA4C;AACtD,sBAAIA,CAAC,CAACC,YAAF,EAAJ,EAAsBJ,OAAO;AAC7B,sBAAIT,UAAU,CAACc,oBAAX,CAAgCN,EAAhC,EAAmCI,CAAnC,CAAJ,EAA2CF,KAAK;AAChD;AANwC;AAAA;AAAA;AAAA;AAAA;;AAOzCJ,cAAAA,oBAAoB,CAACS,GAArB,CAAyBP,EAAzB,EAA4BC,OAA5B;AACAF,cAAAA,aAAa,CAACQ,GAAd,CAAkBP,EAAlB,EAAqBE,KAArB;AACA;AAED;AACJ;AACA;AACA;;AAzBsE;AAAA;AAAA;AAAA;AAAA;;AA0BlE,cAAMM,kBAAkB,GAAG,SAArBA,kBAAqB,CAAAC,MAAM,EAAI;AACpC,gBAAIC,GAAG,GAAG,CAAV;;AADoC,wDAK/BpB,WAAW,CAACqB,oCAAZ,CAAiDF,MAAjD,CAL+B;AAAA;;AAAA;AAEpC,qEAG+D;AAAA;AAAA,oBAF9DG,YAE8D;AAAA,oBAD9DC,WAC8D;;AAC9D,oBAAI,CAACD,YAAL,EAAmB;AACnB,oBAAI,CAACC,WAAW,CAACC,IAAZ,CAAiB,UAAAV,CAAC;AAAA,yBAAIA,CAAC,CAACW,cAAF,CAAiBC,SAAjB,CAAJ;AAAA,iBAAlB,CAAL,EAAyD;AACzDN,gBAAAA,GAAG,IAAIZ,oBAAoB,CAACmB,GAArB,CAAyBL,YAAzB,CAAP;AACA;AATmC;AAAA;AAAA;AAAA;AAAA;;AAUpC,mBAAOF,GAAP;AACA,WAXD;AAaA;AACJ;AACA;AACA;;;AACI,cAAMQ,WAAW,GAAG,SAAdA,WAAc,CAAAT,MAAM,EAAI;AAC7B,gBAAIC,GAAG,GAAG,CAAV;;AAD6B,wDAKxBpB,WAAW,CAACqB,oCAAZ,CAAiDF,MAAjD,CALwB;AAAA;;AAAA;AAE7B,qEAG+D;AAAA;AAAA,oBAF9DG,YAE8D;AAAA,oBAD9DC,WAC8D;;AAC9D,oBAAI,CAACD,YAAL,EAAmB;AACnB,oBAAMO,YAAY,GACjB3B,UAAU,CAAC4B,uBAAX,CAAmCR,YAAnC,CADD;;AAF8D,4DAI9CC,WAJ8C;AAAA;;AAAA;AAI9D,yEAA6B;AAAA,wBAAlBT,CAAkB;AAC5B,wBAAI,CAACA,CAAC,CAACW,cAAF,CAAiBC,SAAjB,CAAL,EAAkC;AAClC,wBAAI,CAACZ,CAAC,CAACiB,UAAP,EAAmB;AACnB,wBAAMC,MAAM,GAAGlB,CAAC,CAACiB,UAAF,CAAaE,wBAAb,EAAf;AACA,wBAAID,MAAM,KAAK,CAAf,EAAkB;AAClBZ,oBAAAA,GAAG,IAAIY,MAAM,GAAGH,YAAhB;AACA;AAV6D;AAAA;AAAA;AAAA;AAAA;AAW9D;AAhB4B;AAAA;AAAA;AAAA;AAAA;;AAiB7B,mBAAOT,GAAP;AACA,WAlBD;;AAoBA,cAAIxB,iBAAJ,EAAuB;AAAA,wDACNQ,wBADM;AAAA;;AAAA;AACtB,qEAA0C;AAAA,oBAA/BM,CAA+B;AACzC,oBAAMwB,MAAM,GACXhB,kBAAkB,CAACR,CAAD,CAAlB,GACAF,oBAAoB,CAACmB,GAArB,CAAyBjB,CAAzB,CADA,GAEAD,aAAa,CAACkB,GAAd,CAAkBjB,CAAlB,CAHD;AAIAL,gBAAAA,wBAAwB,CAACY,GAAzB,CAA6BP,CAA7B,EAAgCwB,MAAhC;AACA;AAPqB;AAAA;AAAA;AAAA;AAAA;AAQtB;;AAvEiE,sDAyElD9B,wBAzEkD;AAAA;;AAAA;AAyElE,mEAA0C;AAAA,kBAA/BM,GAA+B;;AACzC,kBAAMwB,OAAM,GACXN,WAAW,CAAClB,GAAD,CAAX,GACAR,UAAU,CAAC4B,uBAAX,CAAmCpB,GAAnC,CADA,GAEAD,aAAa,CAACkB,GAAd,CAAkBjB,GAAlB,CAHD;;AAIAH,cAAAA,oBAAoB,CAACU,GAArB,CAAyBP,GAAzB,EAA4BwB,OAA5B;AACA;AA/EiE;AAAA;AAAA;AAAA;AAAA;;AAiFlE,cAAMC,cAAc,GAAGjD,yCAAyC,CAC/DY,WAAW,CAACE,WADmD,CAAhE;AAIAI,UAAAA,wBAAwB,CAACgC,IAAzB,CAA8B,UAACC,CAAD,EAAIC,CAAJ,EAAU;AACvC,gBAAI1C,iBAAJ,EAAuB;AACtB,kBAAM2C,YAAY,GAAGlC,wBAAwB,CAACsB,GAAzB,CAA6BU,CAA7B,CAArB;AACA,kBAAMG,YAAY,GAAGnC,wBAAwB,CAACsB,GAAzB,CAA6BW,CAA7B,CAArB;AACA,kBAAIC,YAAY,GAAGC,YAAnB,EAAiC,OAAO,CAAC,CAAR;AACjC,kBAAID,YAAY,GAAGC,YAAnB,EAAiC,OAAO,CAAP;AACjC;;AACD,gBAAMC,OAAO,GAAGlC,oBAAoB,CAACoB,GAArB,CAAyBU,CAAzB,CAAhB;AACA,gBAAMK,OAAO,GAAGnC,oBAAoB,CAACoB,GAArB,CAAyBW,CAAzB,CAAhB;AACA,gBAAIG,OAAO,GAAGC,OAAd,EAAuB,OAAO,CAAC,CAAR;AACvB,gBAAID,OAAO,GAAGC,OAAd,EAAuB,OAAO,CAAP;AACvB,mBAAOP,cAAc,CAACE,CAAD,EAAIC,CAAJ,CAArB;AACA,WAZD;AAcAlD,UAAAA,wBAAwB,CACvBe,OADuB,EAEvBC,wBAFuB,EAGvBN,WAHuB,CAAxB;AAKA,SAxGD;AAyGA,OA5GD;AA6GA;;;;;;AAGFqB,MAAM,CAACwB,OAAP,GAAiBlD,yBAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n\tcompareModulesByPreOrderIndexOrIdentifier\n} = require(\"../util/comparators\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst {\n\tassignAscendingModuleIds,\n\tgetUsedModuleIdsAndModules\n} = require(\"./IdHelpers\");\n\n/** @typedef {import(\"../../declarations/plugins/ids/OccurrenceModuleIdsPlugin\").OccurrenceModuleIdsPluginOptions} OccurrenceModuleIdsPluginOptions */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/ids/OccurrenceModuleIdsPlugin.check.js\"),\n\t() => require(\"../../schemas/plugins/ids/OccurrenceModuleIdsPlugin.json\"),\n\t{\n\t\tname: \"Occurrence Order Module Ids Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\nclass OccurrenceModuleIdsPlugin {\n\t/**\n\t * @param {OccurrenceModuleIdsPluginOptions=} options options object\n\t */\n\tconstructor(options = {}) {\n\t\tvalidate(options);\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst prioritiseInitial = this.options.prioritiseInitial;\n\t\tcompiler.hooks.compilation.tap(\"OccurrenceModuleIdsPlugin\", compilation => {\n\t\t\tconst moduleGraph = compilation.moduleGraph;\n\n\t\t\tcompilation.hooks.moduleIds.tap(\"OccurrenceModuleIdsPlugin\", () => {\n\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\n\t\t\t\tconst [usedIds, modulesInOccurrenceOrder] =\n\t\t\t\t\tgetUsedModuleIdsAndModules(compilation);\n\n\t\t\t\tconst occursInInitialChunksMap = new Map();\n\t\t\t\tconst occursInAllChunksMap = new Map();\n\n\t\t\t\tconst initialChunkChunkMap = new Map();\n\t\t\t\tconst entryCountMap = new Map();\n\t\t\t\tfor (const m of modulesInOccurrenceOrder) {\n\t\t\t\t\tlet initial = 0;\n\t\t\t\t\tlet entry = 0;\n\t\t\t\t\tfor (const c of chunkGraph.getModuleChunksIterable(m)) {\n\t\t\t\t\t\tif (c.canBeInitial()) initial++;\n\t\t\t\t\t\tif (chunkGraph.isEntryModuleInChunk(m, c)) entry++;\n\t\t\t\t\t}\n\t\t\t\t\tinitialChunkChunkMap.set(m, initial);\n\t\t\t\t\tentryCountMap.set(m, entry);\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * @param {Module} module module\n\t\t\t\t * @returns {number} count of occurs\n\t\t\t\t */\n\t\t\t\tconst countOccursInEntry = module => {\n\t\t\t\t\tlet sum = 0;\n\t\t\t\t\tfor (const [\n\t\t\t\t\t\toriginModule,\n\t\t\t\t\t\tconnections\n\t\t\t\t\t] of moduleGraph.getIncomingConnectionsByOriginModule(module)) {\n\t\t\t\t\t\tif (!originModule) continue;\n\t\t\t\t\t\tif (!connections.some(c => c.isTargetActive(undefined))) continue;\n\t\t\t\t\t\tsum += initialChunkChunkMap.get(originModule);\n\t\t\t\t\t}\n\t\t\t\t\treturn sum;\n\t\t\t\t};\n\n\t\t\t\t/**\n\t\t\t\t * @param {Module} module module\n\t\t\t\t * @returns {number} count of occurs\n\t\t\t\t */\n\t\t\t\tconst countOccurs = module => {\n\t\t\t\t\tlet sum = 0;\n\t\t\t\t\tfor (const [\n\t\t\t\t\t\toriginModule,\n\t\t\t\t\t\tconnections\n\t\t\t\t\t] of moduleGraph.getIncomingConnectionsByOriginModule(module)) {\n\t\t\t\t\t\tif (!originModule) continue;\n\t\t\t\t\t\tconst chunkModules =\n\t\t\t\t\t\t\tchunkGraph.getNumberOfModuleChunks(originModule);\n\t\t\t\t\t\tfor (const c of connections) {\n\t\t\t\t\t\t\tif (!c.isTargetActive(undefined)) continue;\n\t\t\t\t\t\t\tif (!c.dependency) continue;\n\t\t\t\t\t\t\tconst factor = c.dependency.getNumberOfIdOccurrences();\n\t\t\t\t\t\t\tif (factor === 0) continue;\n\t\t\t\t\t\t\tsum += factor * chunkModules;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn sum;\n\t\t\t\t};\n\n\t\t\t\tif (prioritiseInitial) {\n\t\t\t\t\tfor (const m of modulesInOccurrenceOrder) {\n\t\t\t\t\t\tconst result =\n\t\t\t\t\t\t\tcountOccursInEntry(m) +\n\t\t\t\t\t\t\tinitialChunkChunkMap.get(m) +\n\t\t\t\t\t\t\tentryCountMap.get(m);\n\t\t\t\t\t\toccursInInitialChunksMap.set(m, result);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const m of modulesInOccurrenceOrder) {\n\t\t\t\t\tconst result =\n\t\t\t\t\t\tcountOccurs(m) +\n\t\t\t\t\t\tchunkGraph.getNumberOfModuleChunks(m) +\n\t\t\t\t\t\tentryCountMap.get(m);\n\t\t\t\t\toccursInAllChunksMap.set(m, result);\n\t\t\t\t}\n\n\t\t\t\tconst naturalCompare = compareModulesByPreOrderIndexOrIdentifier(\n\t\t\t\t\tcompilation.moduleGraph\n\t\t\t\t);\n\n\t\t\t\tmodulesInOccurrenceOrder.sort((a, b) => {\n\t\t\t\t\tif (prioritiseInitial) {\n\t\t\t\t\t\tconst aEntryOccurs = occursInInitialChunksMap.get(a);\n\t\t\t\t\t\tconst bEntryOccurs = occursInInitialChunksMap.get(b);\n\t\t\t\t\t\tif (aEntryOccurs > bEntryOccurs) return -1;\n\t\t\t\t\t\tif (aEntryOccurs < bEntryOccurs) return 1;\n\t\t\t\t\t}\n\t\t\t\t\tconst aOccurs = occursInAllChunksMap.get(a);\n\t\t\t\t\tconst bOccurs = occursInAllChunksMap.get(b);\n\t\t\t\t\tif (aOccurs > bOccurs) return -1;\n\t\t\t\t\tif (aOccurs < bOccurs) return 1;\n\t\t\t\t\treturn naturalCompare(a, b);\n\t\t\t\t});\n\n\t\t\t\tassignAscendingModuleIds(\n\t\t\t\t\tusedIds,\n\t\t\t\t\tmodulesInOccurrenceOrder,\n\t\t\t\t\tcompilation\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\t}\n}\n\nmodule.exports = OccurrenceModuleIdsPlugin;\n"]},"metadata":{},"sourceType":"script"}