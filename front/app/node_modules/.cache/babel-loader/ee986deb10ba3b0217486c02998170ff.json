{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar NO_MARKER = 0;\nvar IN_PROGRESS_MARKER = 1;\nvar DONE_MARKER = 2;\nvar DONE_MAYBE_ROOT_CYCLE_MARKER = 3;\nvar DONE_AND_ROOT_MARKER = 4;\n/**\n * @template T\n */\n\nvar Node = /*#__PURE__*/_createClass(\n/**\n * @param {T} item the value of the node\n */\nfunction Node(item) {\n  _classCallCheck(this, Node);\n\n  this.item = item;\n  /** @type {Set<Node<T>>} */\n\n  this.dependencies = new Set();\n  this.marker = NO_MARKER;\n  /** @type {Cycle<T> | undefined} */\n\n  this.cycle = undefined;\n  this.incoming = 0;\n});\n/**\n * @template T\n */\n\n\nvar Cycle = /*#__PURE__*/_createClass(function Cycle() {\n  _classCallCheck(this, Cycle);\n\n  /** @type {Set<Node<T>>} */\n  this.nodes = new Set();\n});\n/**\n * @template T\n * @typedef {Object} StackEntry\n * @property {Node<T>} node\n * @property {Node<T>[]} openEdges\n */\n\n/**\n * @template T\n * @param {Iterable<T>} items list of items\n * @param {function(T): Iterable<T>} getDependencies function to get dependencies of an item (items that are not in list are ignored)\n * @returns {Iterable<T>} graph roots of the items\n */\n\n\nmodule.exports = function (items, getDependencies) {\n  /** @type {Map<T, Node<T>>} */\n  var itemToNode = new Map();\n\n  var _iterator = _createForOfIteratorHelper(items),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      var node = new Node(item);\n      itemToNode.set(item, node);\n    } // early exit when there is only a single item\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (itemToNode.size <= 1) return items; // grab all the dependencies\n\n  var _iterator2 = _createForOfIteratorHelper(itemToNode.values()),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _node = _step2.value;\n\n      var _iterator5 = _createForOfIteratorHelper(getDependencies(_node.item)),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var dep = _step5.value;\n          var depNode = itemToNode.get(dep);\n\n          if (depNode !== undefined) {\n            _node.dependencies.add(depNode);\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    } // Set of current root modules\n    // items will be removed if a new reference to it has been found\n\n    /** @type {Set<Node<T>>} */\n\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  var roots = new Set(); // Set of current cycles without references to it\n  // cycles will be removed if a new reference to it has been found\n  // that is not part of the cycle\n\n  /** @type {Set<Cycle<T>>} */\n\n  var rootCycles = new Set(); // For all non-marked nodes\n\n  var _iterator3 = _createForOfIteratorHelper(itemToNode.values()),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var selectedNode = _step3.value;\n\n      if (selectedNode.marker === NO_MARKER) {\n        // deep-walk all referenced modules\n        // in a non-recursive way\n        // start by entering the selected node\n        selectedNode.marker = IN_PROGRESS_MARKER; // keep a stack to avoid recursive walk\n\n        /** @type {StackEntry<T>[]} */\n\n        var stack = [{\n          node: selectedNode,\n          openEdges: Array.from(selectedNode.dependencies)\n        }]; // process the top item until stack is empty\n\n        while (stack.length > 0) {\n          var topOfStack = stack[stack.length - 1]; // Are there still edges unprocessed in the current node?\n\n          if (topOfStack.openEdges.length > 0) {\n            // Process one dependency\n            var dependency = topOfStack.openEdges.pop();\n\n            switch (dependency.marker) {\n              case NO_MARKER:\n                // dependency has not be visited yet\n                // mark it as in-progress and recurse\n                stack.push({\n                  node: dependency,\n                  openEdges: Array.from(dependency.dependencies)\n                });\n                dependency.marker = IN_PROGRESS_MARKER;\n                break;\n\n              case IN_PROGRESS_MARKER:\n                {\n                  // It's a in-progress cycle\n                  var _cycle = dependency.cycle;\n\n                  if (!_cycle) {\n                    _cycle = new Cycle();\n\n                    _cycle.nodes.add(dependency);\n\n                    dependency.cycle = _cycle;\n                  } // set cycle property for each node in the cycle\n                  // if nodes are already part of a cycle\n                  // we merge the cycles to a shared cycle\n\n\n                  for (var i = stack.length - 1; stack[i].node !== dependency; i--) {\n                    var _node2 = stack[i].node;\n\n                    if (_node2.cycle) {\n                      if (_node2.cycle !== _cycle) {\n                        // merge cycles\n                        var _iterator6 = _createForOfIteratorHelper(_node2.cycle.nodes),\n                            _step6;\n\n                        try {\n                          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                            var cycleNode = _step6.value;\n                            cycleNode.cycle = _cycle;\n\n                            _cycle.nodes.add(cycleNode);\n                          }\n                        } catch (err) {\n                          _iterator6.e(err);\n                        } finally {\n                          _iterator6.f();\n                        }\n                      }\n                    } else {\n                      _node2.cycle = _cycle;\n\n                      _cycle.nodes.add(_node2);\n                    }\n                  } // don't recurse into dependencies\n                  // these are already on the stack\n\n\n                  break;\n                }\n\n              case DONE_AND_ROOT_MARKER:\n                // This node has be visited yet and is currently a root node\n                // But as this is a new reference to the node\n                // it's not really a root\n                // so we have to convert it to a normal node\n                dependency.marker = DONE_MARKER;\n                roots.delete(dependency);\n                break;\n\n              case DONE_MAYBE_ROOT_CYCLE_MARKER:\n                // This node has be visited yet and\n                // is maybe currently part of a completed root cycle\n                // we found a new reference to the cycle\n                // so it's not really a root cycle\n                // remove the cycle from the root cycles\n                // and convert it to a normal node\n                rootCycles.delete(dependency.cycle);\n                dependency.marker = DONE_MARKER;\n                break;\n              // DONE_MARKER: nothing to do, don't recurse into dependencies\n            }\n          } else {\n            // All dependencies of the current node has been visited\n            // we leave the node\n            stack.pop();\n            topOfStack.node.marker = DONE_MARKER;\n          }\n        }\n\n        var cycle = selectedNode.cycle;\n\n        if (cycle) {\n          var _iterator7 = _createForOfIteratorHelper(cycle.nodes),\n              _step7;\n\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var _node3 = _step7.value;\n              _node3.marker = DONE_MAYBE_ROOT_CYCLE_MARKER;\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n\n          rootCycles.add(cycle);\n        } else {\n          selectedNode.marker = DONE_AND_ROOT_MARKER;\n          roots.add(selectedNode);\n        }\n      }\n    } // Extract roots from root cycles\n    // We take the nodes with most incoming edges\n    // inside of the cycle\n\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  var _iterator4 = _createForOfIteratorHelper(rootCycles),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var _cycle2 = _step4.value;\n      var max = 0;\n      /** @type {Set<Node<T>>} */\n\n      var cycleRoots = new Set();\n      var nodes = _cycle2.nodes;\n\n      var _iterator8 = _createForOfIteratorHelper(nodes),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _node4 = _step8.value;\n\n          var _iterator10 = _createForOfIteratorHelper(_node4.dependencies),\n              _step10;\n\n          try {\n            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n              var _dep = _step10.value;\n\n              if (nodes.has(_dep)) {\n                _dep.incoming++;\n                if (_dep.incoming < max) continue;\n\n                if (_dep.incoming > max) {\n                  cycleRoots.clear();\n                  max = _dep.incoming;\n                }\n\n                cycleRoots.add(_dep);\n              }\n            }\n          } catch (err) {\n            _iterator10.e(err);\n          } finally {\n            _iterator10.f();\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      var _iterator9 = _createForOfIteratorHelper(cycleRoots),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var cycleRoot = _step9.value;\n          roots.add(cycleRoot);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    } // When roots were found, return them\n\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  if (roots.size > 0) {\n    return Array.from(roots, function (r) {\n      return r.item;\n    });\n  } else {\n    throw new Error(\"Implementation of findGraphRoots is broken\");\n  }\n};","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/util/findGraphRoots.js"],"names":["NO_MARKER","IN_PROGRESS_MARKER","DONE_MARKER","DONE_MAYBE_ROOT_CYCLE_MARKER","DONE_AND_ROOT_MARKER","Node","item","dependencies","Set","marker","cycle","undefined","incoming","Cycle","nodes","module","exports","items","getDependencies","itemToNode","Map","node","set","size","values","dep","depNode","get","add","roots","rootCycles","selectedNode","stack","openEdges","Array","from","length","topOfStack","dependency","pop","push","i","cycleNode","delete","max","cycleRoots","has","clear","cycleRoot","r","Error"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst NO_MARKER = 0;\nconst IN_PROGRESS_MARKER = 1;\nconst DONE_MARKER = 2;\nconst DONE_MAYBE_ROOT_CYCLE_MARKER = 3;\nconst DONE_AND_ROOT_MARKER = 4;\n\n/**\n * @template T\n */\nclass Node {\n\t/**\n\t * @param {T} item the value of the node\n\t */\n\tconstructor(item) {\n\t\tthis.item = item;\n\t\t/** @type {Set<Node<T>>} */\n\t\tthis.dependencies = new Set();\n\t\tthis.marker = NO_MARKER;\n\t\t/** @type {Cycle<T> | undefined} */\n\t\tthis.cycle = undefined;\n\t\tthis.incoming = 0;\n\t}\n}\n\n/**\n * @template T\n */\nclass Cycle {\n\tconstructor() {\n\t\t/** @type {Set<Node<T>>} */\n\t\tthis.nodes = new Set();\n\t}\n}\n\n/**\n * @template T\n * @typedef {Object} StackEntry\n * @property {Node<T>} node\n * @property {Node<T>[]} openEdges\n */\n\n/**\n * @template T\n * @param {Iterable<T>} items list of items\n * @param {function(T): Iterable<T>} getDependencies function to get dependencies of an item (items that are not in list are ignored)\n * @returns {Iterable<T>} graph roots of the items\n */\nmodule.exports = (items, getDependencies) => {\n\t/** @type {Map<T, Node<T>>} */\n\tconst itemToNode = new Map();\n\tfor (const item of items) {\n\t\tconst node = new Node(item);\n\t\titemToNode.set(item, node);\n\t}\n\n\t// early exit when there is only a single item\n\tif (itemToNode.size <= 1) return items;\n\n\t// grab all the dependencies\n\tfor (const node of itemToNode.values()) {\n\t\tfor (const dep of getDependencies(node.item)) {\n\t\t\tconst depNode = itemToNode.get(dep);\n\t\t\tif (depNode !== undefined) {\n\t\t\t\tnode.dependencies.add(depNode);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set of current root modules\n\t// items will be removed if a new reference to it has been found\n\t/** @type {Set<Node<T>>} */\n\tconst roots = new Set();\n\n\t// Set of current cycles without references to it\n\t// cycles will be removed if a new reference to it has been found\n\t// that is not part of the cycle\n\t/** @type {Set<Cycle<T>>} */\n\tconst rootCycles = new Set();\n\n\t// For all non-marked nodes\n\tfor (const selectedNode of itemToNode.values()) {\n\t\tif (selectedNode.marker === NO_MARKER) {\n\t\t\t// deep-walk all referenced modules\n\t\t\t// in a non-recursive way\n\n\t\t\t// start by entering the selected node\n\t\t\tselectedNode.marker = IN_PROGRESS_MARKER;\n\n\t\t\t// keep a stack to avoid recursive walk\n\t\t\t/** @type {StackEntry<T>[]} */\n\t\t\tconst stack = [\n\t\t\t\t{\n\t\t\t\t\tnode: selectedNode,\n\t\t\t\t\topenEdges: Array.from(selectedNode.dependencies)\n\t\t\t\t}\n\t\t\t];\n\n\t\t\t// process the top item until stack is empty\n\t\t\twhile (stack.length > 0) {\n\t\t\t\tconst topOfStack = stack[stack.length - 1];\n\n\t\t\t\t// Are there still edges unprocessed in the current node?\n\t\t\t\tif (topOfStack.openEdges.length > 0) {\n\t\t\t\t\t// Process one dependency\n\t\t\t\t\tconst dependency = topOfStack.openEdges.pop();\n\t\t\t\t\tswitch (dependency.marker) {\n\t\t\t\t\t\tcase NO_MARKER:\n\t\t\t\t\t\t\t// dependency has not be visited yet\n\t\t\t\t\t\t\t// mark it as in-progress and recurse\n\t\t\t\t\t\t\tstack.push({\n\t\t\t\t\t\t\t\tnode: dependency,\n\t\t\t\t\t\t\t\topenEdges: Array.from(dependency.dependencies)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tdependency.marker = IN_PROGRESS_MARKER;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IN_PROGRESS_MARKER: {\n\t\t\t\t\t\t\t// It's a in-progress cycle\n\t\t\t\t\t\t\tlet cycle = dependency.cycle;\n\t\t\t\t\t\t\tif (!cycle) {\n\t\t\t\t\t\t\t\tcycle = new Cycle();\n\t\t\t\t\t\t\t\tcycle.nodes.add(dependency);\n\t\t\t\t\t\t\t\tdependency.cycle = cycle;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// set cycle property for each node in the cycle\n\t\t\t\t\t\t\t// if nodes are already part of a cycle\n\t\t\t\t\t\t\t// we merge the cycles to a shared cycle\n\t\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\t\tlet i = stack.length - 1;\n\t\t\t\t\t\t\t\tstack[i].node !== dependency;\n\t\t\t\t\t\t\t\ti--\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst node = stack[i].node;\n\t\t\t\t\t\t\t\tif (node.cycle) {\n\t\t\t\t\t\t\t\t\tif (node.cycle !== cycle) {\n\t\t\t\t\t\t\t\t\t\t// merge cycles\n\t\t\t\t\t\t\t\t\t\tfor (const cycleNode of node.cycle.nodes) {\n\t\t\t\t\t\t\t\t\t\t\tcycleNode.cycle = cycle;\n\t\t\t\t\t\t\t\t\t\t\tcycle.nodes.add(cycleNode);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnode.cycle = cycle;\n\t\t\t\t\t\t\t\t\tcycle.nodes.add(node);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// don't recurse into dependencies\n\t\t\t\t\t\t\t// these are already on the stack\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase DONE_AND_ROOT_MARKER:\n\t\t\t\t\t\t\t// This node has be visited yet and is currently a root node\n\t\t\t\t\t\t\t// But as this is a new reference to the node\n\t\t\t\t\t\t\t// it's not really a root\n\t\t\t\t\t\t\t// so we have to convert it to a normal node\n\t\t\t\t\t\t\tdependency.marker = DONE_MARKER;\n\t\t\t\t\t\t\troots.delete(dependency);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase DONE_MAYBE_ROOT_CYCLE_MARKER:\n\t\t\t\t\t\t\t// This node has be visited yet and\n\t\t\t\t\t\t\t// is maybe currently part of a completed root cycle\n\t\t\t\t\t\t\t// we found a new reference to the cycle\n\t\t\t\t\t\t\t// so it's not really a root cycle\n\t\t\t\t\t\t\t// remove the cycle from the root cycles\n\t\t\t\t\t\t\t// and convert it to a normal node\n\t\t\t\t\t\t\trootCycles.delete(dependency.cycle);\n\t\t\t\t\t\t\tdependency.marker = DONE_MARKER;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// DONE_MARKER: nothing to do, don't recurse into dependencies\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// All dependencies of the current node has been visited\n\t\t\t\t\t// we leave the node\n\t\t\t\t\tstack.pop();\n\t\t\t\t\ttopOfStack.node.marker = DONE_MARKER;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst cycle = selectedNode.cycle;\n\t\t\tif (cycle) {\n\t\t\t\tfor (const node of cycle.nodes) {\n\t\t\t\t\tnode.marker = DONE_MAYBE_ROOT_CYCLE_MARKER;\n\t\t\t\t}\n\t\t\t\trootCycles.add(cycle);\n\t\t\t} else {\n\t\t\t\tselectedNode.marker = DONE_AND_ROOT_MARKER;\n\t\t\t\troots.add(selectedNode);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Extract roots from root cycles\n\t// We take the nodes with most incoming edges\n\t// inside of the cycle\n\tfor (const cycle of rootCycles) {\n\t\tlet max = 0;\n\t\t/** @type {Set<Node<T>>} */\n\t\tconst cycleRoots = new Set();\n\t\tconst nodes = cycle.nodes;\n\t\tfor (const node of nodes) {\n\t\t\tfor (const dep of node.dependencies) {\n\t\t\t\tif (nodes.has(dep)) {\n\t\t\t\t\tdep.incoming++;\n\t\t\t\t\tif (dep.incoming < max) continue;\n\t\t\t\t\tif (dep.incoming > max) {\n\t\t\t\t\t\tcycleRoots.clear();\n\t\t\t\t\t\tmax = dep.incoming;\n\t\t\t\t\t}\n\t\t\t\t\tcycleRoots.add(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const cycleRoot of cycleRoots) {\n\t\t\troots.add(cycleRoot);\n\t\t}\n\t}\n\n\t// When roots were found, return them\n\tif (roots.size > 0) {\n\t\treturn Array.from(roots, r => r.item);\n\t} else {\n\t\tthrow new Error(\"Implementation of findGraphRoots is broken\");\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}