{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _objectSpread = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _slicedToArray = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _require = require(\"path\"),\n    extname = _require.extname,\n    basename = _require.basename;\n\nvar _require2 = require(\"url\"),\n    URL = _require2.URL;\n\nvar _require3 = require(\"zlib\"),\n    createGunzip = _require3.createGunzip,\n    createBrotliDecompress = _require3.createBrotliDecompress,\n    createInflate = _require3.createInflate;\n\nvar NormalModule = require(\"../NormalModule\");\n\nvar createSchemaValidation = require(\"../util/create-schema-validation\");\n\nvar createHash = require(\"../util/createHash\");\n\nvar _require4 = require(\"../util/fs\"),\n    mkdirp = _require4.mkdirp,\n    dirname = _require4.dirname,\n    join = _require4.join;\n\nvar memoize = require(\"../util/memoize\");\n/** @typedef {import(\"../../declarations/plugins/schemes/HttpUriPlugin\").HttpUriPluginOptions} HttpUriPluginOptions */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n\nvar getHttp = memoize(function () {\n  return require(\"http\");\n});\nvar getHttps = memoize(function () {\n  return require(\"https\");\n});\n/** @type {(() => void)[] | undefined} */\n\nvar inProgressWrite = undefined;\nvar validate = createSchemaValidation(require(\"../../schemas/plugins/schemes/HttpUriPlugin.check.js\"), function () {\n  return require(\"../../schemas/plugins/schemes/HttpUriPlugin.json\");\n}, {\n  name: \"Http Uri Plugin\",\n  baseDataPath: \"options\"\n});\n\nvar toSafePath = function toSafePath(str) {\n  return str.replace(/^[^a-zA-Z0-9]+|[^a-zA-Z0-9]+$/g, \"\").replace(/[^a-zA-Z0-9._-]+/g, \"_\");\n};\n\nvar computeIntegrity = function computeIntegrity(content) {\n  var hash = createHash(\"sha512\");\n  hash.update(content);\n  var integrity = \"sha512-\" + hash.digest(\"base64\");\n  return integrity;\n};\n\nvar verifyIntegrity = function verifyIntegrity(content, integrity) {\n  if (integrity === \"ignore\") return true;\n  return computeIntegrity(content) === integrity;\n};\n/**\n * @param {string} str input\n * @returns {Record<string, string>} parsed\n */\n\n\nvar parseKeyValuePairs = function parseKeyValuePairs(str) {\n  /** @type {Record<string, string>} */\n  var result = {};\n\n  var _iterator = _createForOfIteratorHelper(str.split(\",\")),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      var i = item.indexOf(\"=\");\n\n      if (i >= 0) {\n        var key = item.slice(0, i).trim();\n        var value = item.slice(i + 1).trim();\n        result[key] = value;\n      } else {\n        var _key = item.trim();\n\n        if (!_key) continue;\n        result[_key] = _key;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return result;\n};\n\nvar parseCacheControl = function parseCacheControl(cacheControl, requestTime) {\n  // When false resource is not stored in cache\n  var storeCache = true; // When false resource is not stored in lockfile cache\n\n  var storeLock = true; // Resource is only revalidated, after that timestamp and when upgrade is chosen\n\n  var validUntil = 0;\n\n  if (cacheControl) {\n    var parsed = parseKeyValuePairs(cacheControl);\n    if (parsed[\"no-cache\"]) storeCache = storeLock = false;\n\n    if (parsed[\"max-age\"] && !isNaN(+parsed[\"max-age\"])) {\n      validUntil = requestTime + +parsed[\"max-age\"] * 1000;\n    }\n\n    if (parsed[\"must-revalidate\"]) validUntil = 0;\n  }\n\n  return {\n    storeLock: storeLock,\n    storeCache: storeCache,\n    validUntil: validUntil\n  };\n};\n/**\n * @typedef {Object} LockfileEntry\n * @property {string} resolved\n * @property {string} integrity\n * @property {string} contentType\n */\n\n\nvar areLockfileEntriesEqual = function areLockfileEntriesEqual(a, b) {\n  return a.resolved === b.resolved && a.integrity === b.integrity && a.contentType === b.contentType;\n};\n\nvar entryToString = function entryToString(entry) {\n  return \"resolved: \".concat(entry.resolved, \", integrity: \").concat(entry.integrity, \", contentType: \").concat(entry.contentType);\n};\n\nvar Lockfile = /*#__PURE__*/function () {\n  function Lockfile() {\n    _classCallCheck(this, Lockfile);\n\n    this.version = 1;\n    /** @type {Map<string, LockfileEntry | \"ignore\" | \"no-cache\">} */\n\n    this.entries = new Map();\n  }\n\n  _createClass(Lockfile, [{\n    key: \"toString\",\n    value: function toString() {\n      var str = \"{\\n\";\n      var entries = Array.from(this.entries).sort(function (_ref, _ref2) {\n        var _ref3 = _slicedToArray(_ref, 1),\n            a = _ref3[0];\n\n        var _ref4 = _slicedToArray(_ref2, 1),\n            b = _ref4[0];\n\n        return a < b ? -1 : 1;\n      });\n\n      var _iterator2 = _createForOfIteratorHelper(entries),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              key = _step2$value[0],\n              entry = _step2$value[1];\n\n          if (typeof entry === \"string\") {\n            str += \"  \".concat(JSON.stringify(key), \": \").concat(JSON.stringify(entry), \",\\n\");\n          } else {\n            str += \"  \".concat(JSON.stringify(key), \": { \");\n            if (entry.resolved !== key) str += \"\\\"resolved\\\": \".concat(JSON.stringify(entry.resolved), \", \");\n            str += \"\\\"integrity\\\": \".concat(JSON.stringify(entry.integrity), \", \\\"contentType\\\": \").concat(JSON.stringify(entry.contentType), \" },\\n\");\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      str += \"  \\\"version\\\": \".concat(this.version, \"\\n}\\n\");\n      return str;\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(content) {\n      // TODO handle merge conflicts\n      var data = JSON.parse(content);\n      if (data.version !== 1) throw new Error(\"Unsupported lockfile version \".concat(data.version));\n      var lockfile = new Lockfile();\n\n      for (var _i = 0, _Object$keys = Object.keys(data); _i < _Object$keys.length; _i++) {\n        var key = _Object$keys[_i];\n        if (key === \"version\") continue;\n        var entry = data[key];\n        lockfile.entries.set(key, typeof entry === \"string\" ? entry : _objectSpread({\n          resolved: key\n        }, entry));\n      }\n\n      return lockfile;\n    }\n  }]);\n\n  return Lockfile;\n}();\n/**\n * @template R\n * @param {function(function(Error=, R=): void): void} fn function\n * @returns {function(function((Error | null)=, R=): void): void} cached function\n */\n\n\nvar cachedWithoutKey = function cachedWithoutKey(fn) {\n  var inFlight = false;\n  /** @type {Error | undefined} */\n\n  var cachedError = undefined;\n  /** @type {R | undefined} */\n\n  var cachedResult = undefined;\n  /** @type {(function(Error=, R=): void)[] | undefined} */\n\n  var cachedCallbacks = undefined;\n  return function (callback) {\n    if (inFlight) {\n      if (cachedResult !== undefined) return callback(null, cachedResult);\n      if (cachedError !== undefined) return callback(cachedError);\n      if (cachedCallbacks === undefined) cachedCallbacks = [callback];else cachedCallbacks.push(callback);\n      return;\n    }\n\n    inFlight = true;\n    fn(function (err, result) {\n      if (err) cachedError = err;else cachedResult = result;\n      var callbacks = cachedCallbacks;\n      cachedCallbacks = undefined;\n      callback(err, result);\n\n      if (callbacks !== undefined) {\n        var _iterator3 = _createForOfIteratorHelper(callbacks),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var cb = _step3.value;\n            cb(err, result);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    });\n  };\n};\n/**\n * @template T\n * @template R\n * @param {function(T, function(Error=, R=): void): void} fn function\n * @param {function(T, function(Error=, R=): void): void=} forceFn function for the second try\n * @returns {(function(T, function((Error | null)=, R=): void): void) & { force: function(T, function((Error | null)=, R=): void): void }} cached function\n */\n\n\nvar cachedWithKey = function cachedWithKey(fn) {\n  var forceFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : fn;\n\n  /** @typedef {{ result?: R, error?: Error, callbacks?: (function((Error | null)=, R=): void)[], force?: true }} CacheEntry */\n\n  /** @type {Map<T, CacheEntry>} */\n  var cache = new Map();\n\n  var resultFn = function resultFn(arg, callback) {\n    var cacheEntry = cache.get(arg);\n\n    if (cacheEntry !== undefined) {\n      if (cacheEntry.result !== undefined) return callback(null, cacheEntry.result);\n      if (cacheEntry.error !== undefined) return callback(cacheEntry.error);\n      if (cacheEntry.callbacks === undefined) cacheEntry.callbacks = [callback];else cacheEntry.callbacks.push(callback);\n      return;\n    }\n    /** @type {CacheEntry} */\n\n\n    var newCacheEntry = {\n      result: undefined,\n      error: undefined,\n      callbacks: undefined\n    };\n    cache.set(arg, newCacheEntry);\n    fn(arg, function (err, result) {\n      if (err) newCacheEntry.error = err;else newCacheEntry.result = result;\n      var callbacks = newCacheEntry.callbacks;\n      newCacheEntry.callbacks = undefined;\n      callback(err, result);\n\n      if (callbacks !== undefined) {\n        var _iterator4 = _createForOfIteratorHelper(callbacks),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var cb = _step4.value;\n            cb(err, result);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n    });\n  };\n\n  resultFn.force = function (arg, callback) {\n    var cacheEntry = cache.get(arg);\n\n    if (cacheEntry !== undefined && cacheEntry.force) {\n      if (cacheEntry.result !== undefined) return callback(null, cacheEntry.result);\n      if (cacheEntry.error !== undefined) return callback(cacheEntry.error);\n      if (cacheEntry.callbacks === undefined) cacheEntry.callbacks = [callback];else cacheEntry.callbacks.push(callback);\n      return;\n    }\n    /** @type {CacheEntry} */\n\n\n    var newCacheEntry = {\n      result: undefined,\n      error: undefined,\n      callbacks: undefined,\n      force: true\n    };\n    cache.set(arg, newCacheEntry);\n    forceFn(arg, function (err, result) {\n      if (err) newCacheEntry.error = err;else newCacheEntry.result = result;\n      var callbacks = newCacheEntry.callbacks;\n      newCacheEntry.callbacks = undefined;\n      callback(err, result);\n\n      if (callbacks !== undefined) {\n        var _iterator5 = _createForOfIteratorHelper(callbacks),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var cb = _step5.value;\n            cb(err, result);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n    });\n  };\n\n  return resultFn;\n};\n\nvar HttpUriPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {HttpUriPluginOptions} options options\n   */\n  function HttpUriPlugin(options) {\n    _classCallCheck(this, HttpUriPlugin);\n\n    validate(options);\n    this._lockfileLocation = options.lockfileLocation;\n    this._cacheLocation = options.cacheLocation;\n    this._upgrade = options.upgrade;\n    this._frozen = options.frozen;\n    this._allowedUris = options.allowedUris;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  _createClass(HttpUriPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var _this = this;\n\n      var schemes = [{\n        scheme: \"http\",\n        fetch: function fetch(url, options, callback) {\n          return getHttp().get(url, options, callback);\n        }\n      }, {\n        scheme: \"https\",\n        fetch: function fetch(url, options, callback) {\n          return getHttps().get(url, options, callback);\n        }\n      }];\n      var lockfileCache;\n      compiler.hooks.compilation.tap(\"HttpUriPlugin\", function (compilation, _ref5) {\n        var normalModuleFactory = _ref5.normalModuleFactory;\n        var intermediateFs = compiler.intermediateFileSystem;\n        var fs = compilation.inputFileSystem;\n        var cache = compilation.getCache(\"webpack.HttpUriPlugin\");\n        var logger = compilation.getLogger(\"webpack.HttpUriPlugin\");\n        var lockfileLocation = _this._lockfileLocation || join(intermediateFs, compiler.context, compiler.name ? \"\".concat(toSafePath(compiler.name), \".webpack.lock\") : \"webpack.lock\");\n        var cacheLocation = _this._cacheLocation !== undefined ? _this._cacheLocation : lockfileLocation + \".data\";\n        var upgrade = _this._upgrade || false;\n        var frozen = _this._frozen || false;\n        var hashFunction = \"sha512\";\n        var hashDigest = \"hex\";\n        var hashDigestLength = 20;\n        var allowedUris = _this._allowedUris;\n        var warnedAboutEol = false;\n        var cacheKeyCache = new Map();\n        /**\n         * @param {string} url the url\n         * @returns {string} the key\n         */\n\n        var getCacheKey = function getCacheKey(url) {\n          var cachedResult = cacheKeyCache.get(url);\n          if (cachedResult !== undefined) return cachedResult;\n\n          var result = _getCacheKey(url);\n\n          cacheKeyCache.set(url, result);\n          return result;\n        };\n        /**\n         * @param {string} url the url\n         * @returns {string} the key\n         */\n\n\n        var _getCacheKey = function _getCacheKey(url) {\n          var parsedUrl = new URL(url);\n          var folder = toSafePath(parsedUrl.origin);\n          var name = toSafePath(parsedUrl.pathname);\n          var query = toSafePath(parsedUrl.search);\n          var ext = extname(name);\n          if (ext.length > 20) ext = \"\";\n          var basename = ext ? name.slice(0, -ext.length) : name;\n          var hash = createHash(hashFunction);\n          hash.update(url);\n          var digest = hash.digest(hashDigest).slice(0, hashDigestLength);\n          return \"\".concat(folder.slice(-50), \"/\").concat(\"\".concat(basename).concat(query ? \"_\".concat(query) : \"\").slice(0, 150), \"_\").concat(digest).concat(ext);\n        };\n\n        var getLockfile = cachedWithoutKey(\n        /**\n         * @param {function((Error | null)=, Lockfile=): void} callback callback\n         * @returns {void}\n         */\n        function (callback) {\n          var readLockfile = function readLockfile() {\n            intermediateFs.readFile(lockfileLocation, function (err, buffer) {\n              if (err && err.code !== \"ENOENT\") {\n                compilation.missingDependencies.add(lockfileLocation);\n                return callback(err);\n              }\n\n              compilation.fileDependencies.add(lockfileLocation);\n              compilation.fileSystemInfo.createSnapshot(compiler.fsStartTime, buffer ? [lockfileLocation] : [], [], buffer ? [] : [lockfileLocation], {\n                timestamp: true\n              }, function (err, snapshot) {\n                if (err) return callback(err);\n                var lockfile = buffer ? Lockfile.parse(buffer.toString(\"utf-8\")) : new Lockfile();\n                lockfileCache = {\n                  lockfile: lockfile,\n                  snapshot: snapshot\n                };\n                callback(null, lockfile);\n              });\n            });\n          };\n\n          if (lockfileCache) {\n            compilation.fileSystemInfo.checkSnapshotValid(lockfileCache.snapshot, function (err, valid) {\n              if (err) return callback(err);\n              if (!valid) return readLockfile();\n              callback(null, lockfileCache.lockfile);\n            });\n          } else {\n            readLockfile();\n          }\n        });\n        /** @type {Map<string, LockfileEntry | \"ignore\" | \"no-cache\"> | undefined} */\n\n        var lockfileUpdates = undefined;\n\n        var storeLockEntry = function storeLockEntry(lockfile, url, entry) {\n          var oldEntry = lockfile.entries.get(url);\n          if (lockfileUpdates === undefined) lockfileUpdates = new Map();\n          lockfileUpdates.set(url, entry);\n          lockfile.entries.set(url, entry);\n\n          if (!oldEntry) {\n            logger.log(\"\".concat(url, \" added to lockfile\"));\n          } else if (typeof oldEntry === \"string\") {\n            if (typeof entry === \"string\") {\n              logger.log(\"\".concat(url, \" updated in lockfile: \").concat(oldEntry, \" -> \").concat(entry));\n            } else {\n              logger.log(\"\".concat(url, \" updated in lockfile: \").concat(oldEntry, \" -> \").concat(entry.resolved));\n            }\n          } else if (typeof entry === \"string\") {\n            logger.log(\"\".concat(url, \" updated in lockfile: \").concat(oldEntry.resolved, \" -> \").concat(entry));\n          } else if (oldEntry.resolved !== entry.resolved) {\n            logger.log(\"\".concat(url, \" updated in lockfile: \").concat(oldEntry.resolved, \" -> \").concat(entry.resolved));\n          } else if (oldEntry.integrity !== entry.integrity) {\n            logger.log(\"\".concat(url, \" updated in lockfile: content changed\"));\n          } else if (oldEntry.contentType !== entry.contentType) {\n            logger.log(\"\".concat(url, \" updated in lockfile: \").concat(oldEntry.contentType, \" -> \").concat(entry.contentType));\n          } else {\n            logger.log(\"\".concat(url, \" updated in lockfile\"));\n          }\n        };\n\n        var storeResult = function storeResult(lockfile, url, result, callback) {\n          if (result.storeLock) {\n            storeLockEntry(lockfile, url, result.entry);\n            if (!cacheLocation || !result.content) return callback(null, result);\n            var key = getCacheKey(result.entry.resolved);\n            var filePath = join(intermediateFs, cacheLocation, key);\n            mkdirp(intermediateFs, dirname(intermediateFs, filePath), function (err) {\n              if (err) return callback(err);\n              intermediateFs.writeFile(filePath, result.content, function (err) {\n                if (err) return callback(err);\n                callback(null, result);\n              });\n            });\n          } else {\n            storeLockEntry(lockfile, url, \"no-cache\");\n            callback(null, result);\n          }\n        };\n\n        var _iterator6 = _createForOfIteratorHelper(schemes),\n            _step6;\n\n        try {\n          var _loop = function _loop() {\n            var _step6$value = _step6.value,\n                scheme = _step6$value.scheme,\n                fetch = _step6$value.fetch;\n\n            /**\n             *\n             * @param {string} url URL\n             * @param {string} integrity integrity\n             * @param {function((Error | null)=, { entry: LockfileEntry, content: Buffer, storeLock: boolean }=): void} callback callback\n             */\n            var resolveContent = function resolveContent(url, integrity, callback) {\n              var handleResult = function handleResult(err, result) {\n                if (err) return callback(err);\n\n                if (\"location\" in result) {\n                  return resolveContent(result.location, integrity, function (err, innerResult) {\n                    if (err) return callback(err);\n                    callback(null, {\n                      entry: innerResult.entry,\n                      content: innerResult.content,\n                      storeLock: innerResult.storeLock && result.storeLock\n                    });\n                  });\n                } else {\n                  if (!result.fresh && integrity && result.entry.integrity !== integrity && !verifyIntegrity(result.content, integrity)) {\n                    return fetchContent.force(url, handleResult);\n                  }\n\n                  return callback(null, {\n                    entry: result.entry,\n                    content: result.content,\n                    storeLock: result.storeLock\n                  });\n                }\n              };\n\n              fetchContent(url, handleResult);\n            };\n            /** @typedef {{ storeCache: boolean, storeLock: boolean, validUntil: number, etag: string | undefined, fresh: boolean }} FetchResultMeta */\n\n            /** @typedef {FetchResultMeta & { location: string }} RedirectFetchResult */\n\n            /** @typedef {FetchResultMeta & { entry: LockfileEntry, content: Buffer }} ContentFetchResult */\n\n            /** @typedef {RedirectFetchResult | ContentFetchResult} FetchResult */\n\n            /**\n             * @param {string} url URL\n             * @param {FetchResult | RedirectFetchResult} cachedResult result from cache\n             * @param {function((Error | null)=, FetchResult=): void} callback callback\n             * @returns {void}\n             */\n\n\n            var fetchContentRaw = function fetchContentRaw(url, cachedResult, callback) {\n              var requestTime = Date.now();\n              fetch(new URL(url), {\n                headers: {\n                  \"accept-encoding\": \"gzip, deflate, br\",\n                  \"user-agent\": \"webpack\",\n                  \"if-none-match\": cachedResult ? cachedResult.etag || null : null\n                }\n              }, function (res) {\n                var etag = res.headers[\"etag\"];\n                var location = res.headers[\"location\"];\n                var cacheControl = res.headers[\"cache-control\"];\n\n                var _parseCacheControl = parseCacheControl(cacheControl, requestTime),\n                    storeLock = _parseCacheControl.storeLock,\n                    storeCache = _parseCacheControl.storeCache,\n                    validUntil = _parseCacheControl.validUntil;\n                /**\n                 * @param {Partial<Pick<FetchResultMeta, \"fresh\">> & (Pick<RedirectFetchResult, \"location\"> | Pick<ContentFetchResult, \"content\" | \"entry\">)} partialResult result\n                 * @returns {void}\n                 */\n\n\n                var finishWith = function finishWith(partialResult) {\n                  if (\"location\" in partialResult) {\n                    logger.debug(\"GET \".concat(url, \" [\").concat(res.statusCode, \"] -> \").concat(partialResult.location));\n                  } else {\n                    logger.debug(\"GET \".concat(url, \" [\").concat(res.statusCode, \"] \").concat(Math.ceil(partialResult.content.length / 1024), \" kB\").concat(!storeLock ? \" no-cache\" : \"\"));\n                  }\n\n                  var result = _objectSpread(_objectSpread({}, partialResult), {}, {\n                    fresh: true,\n                    storeLock: storeLock,\n                    storeCache: storeCache,\n                    validUntil: validUntil,\n                    etag: etag\n                  });\n\n                  if (!storeCache) {\n                    logger.log(\"\".concat(url, \" can't be stored in cache, due to Cache-Control header: \").concat(cacheControl));\n                    return callback(null, result);\n                  }\n\n                  cache.store(url, null, _objectSpread(_objectSpread({}, result), {}, {\n                    fresh: false\n                  }), function (err) {\n                    if (err) {\n                      logger.warn(\"\".concat(url, \" can't be stored in cache: \").concat(err.message));\n                      logger.debug(err.stack);\n                    }\n\n                    callback(null, result);\n                  });\n                };\n\n                if (res.statusCode === 304) {\n                  if (cachedResult.validUntil < validUntil || cachedResult.storeLock !== storeLock || cachedResult.storeCache !== storeCache || cachedResult.etag !== etag) {\n                    return finishWith(cachedResult);\n                  } else {\n                    logger.debug(\"GET \".concat(url, \" [\").concat(res.statusCode, \"] (unchanged)\"));\n                    return callback(null, _objectSpread(_objectSpread({}, cachedResult), {}, {\n                      fresh: true\n                    }));\n                  }\n                }\n\n                if (location && res.statusCode >= 301 && res.statusCode <= 308) {\n                  var result = {\n                    location: new URL(location, url).href\n                  };\n\n                  if (!cachedResult || !(\"location\" in cachedResult) || cachedResult.location !== result.location || cachedResult.validUntil < validUntil || cachedResult.storeLock !== storeLock || cachedResult.storeCache !== storeCache || cachedResult.etag !== etag) {\n                    return finishWith(result);\n                  } else {\n                    logger.debug(\"GET \".concat(url, \" [\").concat(res.statusCode, \"] (unchanged)\"));\n                    return callback(null, _objectSpread(_objectSpread({}, result), {}, {\n                      fresh: true,\n                      storeLock: storeLock,\n                      storeCache: storeCache,\n                      validUntil: validUntil,\n                      etag: etag\n                    }));\n                  }\n                }\n\n                var contentType = res.headers[\"content-type\"] || \"\";\n                var bufferArr = [];\n                var contentEncoding = res.headers[\"content-encoding\"];\n                var stream = res;\n\n                if (contentEncoding === \"gzip\") {\n                  stream = stream.pipe(createGunzip());\n                } else if (contentEncoding === \"br\") {\n                  stream = stream.pipe(createBrotliDecompress());\n                } else if (contentEncoding === \"deflate\") {\n                  stream = stream.pipe(createInflate());\n                }\n\n                stream.on(\"data\", function (chunk) {\n                  bufferArr.push(chunk);\n                });\n                stream.on(\"end\", function () {\n                  if (!res.complete) {\n                    logger.log(\"GET \".concat(url, \" [\").concat(res.statusCode, \"] (terminated)\"));\n                    return callback(new Error(\"\".concat(url, \" request was terminated\")));\n                  }\n\n                  var content = Buffer.concat(bufferArr);\n\n                  if (res.statusCode !== 200) {\n                    logger.log(\"GET \".concat(url, \" [\").concat(res.statusCode, \"]\"));\n                    return callback(new Error(\"\".concat(url, \" request status code = \").concat(res.statusCode, \"\\n\").concat(content.toString(\"utf-8\"))));\n                  }\n\n                  var integrity = computeIntegrity(content);\n                  var entry = {\n                    resolved: url,\n                    integrity: integrity,\n                    contentType: contentType\n                  };\n                  finishWith({\n                    entry: entry,\n                    content: content\n                  });\n                });\n              }).on(\"error\", function (err) {\n                logger.log(\"GET \".concat(url, \" (error)\"));\n                err.message += \"\\nwhile fetching \".concat(url);\n                callback(err);\n              });\n            };\n\n            var fetchContent = cachedWithKey(\n            /**\n             * @param {string} url URL\n             * @param {function((Error | null)=, { validUntil: number, etag?: string, entry: LockfileEntry, content: Buffer, fresh: boolean } | { validUntil: number, etag?: string, location: string, fresh: boolean }=): void} callback callback\n             * @returns {void}\n             */\n            function (url, callback) {\n              cache.get(url, null, function (err, cachedResult) {\n                if (err) return callback(err);\n\n                if (cachedResult) {\n                  var isValid = cachedResult.validUntil >= Date.now();\n                  if (isValid) return callback(null, cachedResult);\n                }\n\n                fetchContentRaw(url, cachedResult, callback);\n              });\n            }, function (url, callback) {\n              return fetchContentRaw(url, undefined, callback);\n            });\n\n            var isAllowed = function isAllowed(uri) {\n              var _iterator8 = _createForOfIteratorHelper(allowedUris),\n                  _step8;\n\n              try {\n                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                  var allowed = _step8.value;\n\n                  if (typeof allowed === \"string\") {\n                    if (uri.startsWith(allowed)) return true;\n                  } else if (typeof allowed === \"function\") {\n                    if (allowed(uri)) return true;\n                  } else {\n                    if (allowed.test(uri)) return true;\n                  }\n                }\n              } catch (err) {\n                _iterator8.e(err);\n              } finally {\n                _iterator8.f();\n              }\n\n              return false;\n            };\n\n            var getInfo = cachedWithKey(\n            /**\n             * @param {string} url the url\n             * @param {function((Error | null)=, { entry: LockfileEntry, content: Buffer }=): void} callback callback\n             * @returns {void}\n             */\n            function (url, callback) {\n              if (!isAllowed(url)) {\n                return callback(new Error(\"\".concat(url, \" doesn't match the allowedUris policy. These URIs are allowed:\\n\").concat(allowedUris.map(function (uri) {\n                  return \" - \".concat(uri);\n                }).join(\"\\n\"))));\n              }\n\n              getLockfile(function (err, lockfile) {\n                if (err) return callback(err);\n                var entryOrString = lockfile.entries.get(url);\n\n                if (!entryOrString) {\n                  if (frozen) {\n                    return callback(new Error(\"\".concat(url, \" has no lockfile entry and lockfile is frozen\")));\n                  }\n\n                  resolveContent(url, null, function (err, result) {\n                    if (err) return callback(err);\n                    storeResult(lockfile, url, result, callback);\n                  });\n                  return;\n                }\n\n                if (typeof entryOrString === \"string\") {\n                  var entryTag = entryOrString;\n                  resolveContent(url, null, function (err, result) {\n                    if (err) return callback(err);\n                    if (!result.storeLock || entryTag === \"ignore\") return callback(null, result);\n\n                    if (frozen) {\n                      return callback(new Error(\"\".concat(url, \" used to have \").concat(entryTag, \" lockfile entry and has content now, but lockfile is frozen\")));\n                    }\n\n                    if (!upgrade) {\n                      return callback(new Error(\"\".concat(url, \" used to have \").concat(entryTag, \" lockfile entry and has content now.\\nThis should be reflected in the lockfile, so this lockfile entry must be upgraded, but upgrading is not enabled.\\nRemove this line from the lockfile to force upgrading.\")));\n                    }\n\n                    storeResult(lockfile, url, result, callback);\n                  });\n                  return;\n                }\n\n                var entry = entryOrString;\n\n                var doFetch = function doFetch(lockedContent) {\n                  resolveContent(url, entry.integrity, function (err, result) {\n                    if (err) {\n                      if (lockedContent) {\n                        logger.warn(\"Upgrade request to \".concat(url, \" failed: \").concat(err.message));\n                        logger.debug(err.stack);\n                        return callback(null, {\n                          entry: entry,\n                          content: lockedContent\n                        });\n                      }\n\n                      return callback(err);\n                    }\n\n                    if (!result.storeLock) {\n                      // When the lockfile entry should be no-cache\n                      // we need to update the lockfile\n                      if (frozen) {\n                        return callback(new Error(\"\".concat(url, \" has a lockfile entry and is no-cache now, but lockfile is frozen\\nLockfile: \").concat(entryToString(entry))));\n                      }\n\n                      storeResult(lockfile, url, result, callback);\n                      return;\n                    }\n\n                    if (!areLockfileEntriesEqual(result.entry, entry)) {\n                      // When the lockfile entry is outdated\n                      // we need to update the lockfile\n                      if (frozen) {\n                        return callback(new Error(\"\".concat(url, \" has an outdated lockfile entry, but lockfile is frozen\\nLockfile: \").concat(entryToString(entry), \"\\nExpected: \").concat(entryToString(result.entry))));\n                      }\n\n                      storeResult(lockfile, url, result, callback);\n                      return;\n                    }\n\n                    if (!lockedContent && cacheLocation) {\n                      // When the lockfile cache content is missing\n                      // we need to update the lockfile\n                      if (frozen) {\n                        return callback(new Error(\"\".concat(url, \" is missing content in the lockfile cache, but lockfile is frozen\\nLockfile: \").concat(entryToString(entry))));\n                      }\n\n                      storeResult(lockfile, url, result, callback);\n                      return;\n                    }\n\n                    return callback(null, result);\n                  });\n                };\n\n                if (cacheLocation) {\n                  // When there is a lockfile cache\n                  // we read the content from there\n                  var key = getCacheKey(entry.resolved);\n                  var filePath = join(intermediateFs, cacheLocation, key);\n                  fs.readFile(filePath, function (err, result) {\n                    var content =\n                    /** @type {Buffer} */\n                    result;\n\n                    if (err) {\n                      if (err.code === \"ENOENT\") return doFetch();\n                      return callback(err);\n                    }\n\n                    var continueWithCachedContent = function continueWithCachedContent(result) {\n                      if (!upgrade) {\n                        // When not in upgrade mode, we accept the result from the lockfile cache\n                        return callback(null, {\n                          entry: entry,\n                          content: content\n                        });\n                      }\n\n                      return doFetch(content);\n                    };\n\n                    if (!verifyIntegrity(content, entry.integrity)) {\n                      var contentWithChangedEol;\n                      var isEolChanged = false;\n\n                      try {\n                        contentWithChangedEol = Buffer.from(content.toString(\"utf-8\").replace(/\\r\\n/g, \"\\n\"));\n                        isEolChanged = verifyIntegrity(contentWithChangedEol, entry.integrity);\n                      } catch (e) {// ignore\n                      }\n\n                      if (isEolChanged) {\n                        if (!warnedAboutEol) {\n                          var explainer = \"Incorrect end of line sequence was detected in the lockfile cache.\\nThe lockfile cache is protected by integrity checks, so any external modification will lead to a corrupted lockfile cache.\\nWhen using git make sure to configure .gitattributes correctly for the lockfile cache:\\n  **/*webpack.lock.data/** -text\\nThis will avoid that the end of line sequence is changed by git on Windows.\";\n\n                          if (frozen) {\n                            logger.error(explainer);\n                          } else {\n                            logger.warn(explainer);\n                            logger.info(\"Lockfile cache will be automatically fixed now, but when lockfile is frozen this would result in an error.\");\n                          }\n\n                          warnedAboutEol = true;\n                        }\n\n                        if (!frozen) {\n                          // \"fix\" the end of line sequence of the lockfile content\n                          logger.log(\"\".concat(filePath, \" fixed end of line sequence (\\\\r\\\\n instead of \\\\n).\"));\n                          intermediateFs.writeFile(filePath, contentWithChangedEol, function (err) {\n                            if (err) return callback(err);\n                            continueWithCachedContent(contentWithChangedEol);\n                          });\n                          return;\n                        }\n                      }\n\n                      if (frozen) {\n                        return callback(new Error(\"\".concat(entry.resolved, \" integrity mismatch, expected content with integrity \").concat(entry.integrity, \" but got \").concat(computeIntegrity(content), \".\\nLockfile corrupted (\").concat(isEolChanged ? \"end of line sequence was unexpectedly changed\" : \"incorrectly merged? changed by other tools?\", \").\\nRun build with un-frozen lockfile to automatically fix lockfile.\")));\n                      } else {\n                        // \"fix\" the lockfile entry to the correct integrity\n                        // the content has priority over the integrity value\n                        entry = _objectSpread(_objectSpread({}, entry), {}, {\n                          integrity: computeIntegrity(content)\n                        });\n                        storeLockEntry(lockfile, url, entry);\n                      }\n                    }\n\n                    continueWithCachedContent(result);\n                  });\n                } else {\n                  doFetch();\n                }\n              });\n            });\n\n            var respondWithUrlModule = function respondWithUrlModule(url, resourceData, callback) {\n              getInfo(url.href, function (err, result) {\n                if (err) return callback(err);\n                resourceData.resource = url.href;\n                resourceData.path = url.origin + url.pathname;\n                resourceData.query = url.search;\n                resourceData.fragment = url.hash;\n                resourceData.context = new URL(\".\", result.entry.resolved).href.slice(0, -1);\n                resourceData.data.mimetype = result.entry.contentType;\n                callback(null, true);\n              });\n            };\n\n            normalModuleFactory.hooks.resolveForScheme.for(scheme).tapAsync(\"HttpUriPlugin\", function (resourceData, resolveData, callback) {\n              respondWithUrlModule(new URL(resourceData.resource), resourceData, callback);\n            });\n            normalModuleFactory.hooks.resolveInScheme.for(scheme).tapAsync(\"HttpUriPlugin\", function (resourceData, data, callback) {\n              // Only handle relative urls (./xxx, ../xxx, /xxx, //xxx)\n              if (data.dependencyType !== \"url\" && !/^\\.{0,2}\\//.test(resourceData.resource)) {\n                return callback();\n              }\n\n              respondWithUrlModule(new URL(resourceData.resource, data.context + \"/\"), resourceData, callback);\n            });\n            var hooks = NormalModule.getCompilationHooks(compilation);\n            hooks.readResourceForScheme.for(scheme).tapAsync(\"HttpUriPlugin\", function (resource, module, callback) {\n              return getInfo(resource, function (err, result) {\n                if (err) return callback(err);\n                module.buildInfo.resourceIntegrity = result.entry.integrity;\n                callback(null, result.content);\n              });\n            });\n            hooks.needBuild.tapAsync(\"HttpUriPlugin\", function (module, context, callback) {\n              if (module.resource && module.resource.startsWith(\"\".concat(scheme, \"://\"))) {\n                getInfo(module.resource, function (err, result) {\n                  if (err) return callback(err);\n\n                  if (result.entry.integrity !== module.buildInfo.resourceIntegrity) {\n                    return callback(null, true);\n                  }\n\n                  callback();\n                });\n              } else {\n                return callback();\n              }\n            });\n          };\n\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            _loop();\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n\n        compilation.hooks.finishModules.tapAsync(\"HttpUriPlugin\", function (modules, callback) {\n          if (!lockfileUpdates) return callback();\n          var ext = extname(lockfileLocation);\n          var tempFile = join(intermediateFs, dirname(intermediateFs, lockfileLocation), \".\".concat(basename(lockfileLocation, ext), \".\").concat(Math.random() * 10000 | 0).concat(ext));\n\n          var writeDone = function writeDone() {\n            var nextOperation = inProgressWrite.shift();\n\n            if (nextOperation) {\n              nextOperation();\n            } else {\n              inProgressWrite = undefined;\n            }\n          };\n\n          var runWrite = function runWrite() {\n            intermediateFs.readFile(lockfileLocation, function (err, buffer) {\n              if (err && err.code !== \"ENOENT\") {\n                writeDone();\n                return callback(err);\n              }\n\n              var lockfile = buffer ? Lockfile.parse(buffer.toString(\"utf-8\")) : new Lockfile();\n\n              var _iterator7 = _createForOfIteratorHelper(lockfileUpdates),\n                  _step7;\n\n              try {\n                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                  var _step7$value = _slicedToArray(_step7.value, 2),\n                      key = _step7$value[0],\n                      value = _step7$value[1];\n\n                  lockfile.entries.set(key, value);\n                }\n              } catch (err) {\n                _iterator7.e(err);\n              } finally {\n                _iterator7.f();\n              }\n\n              intermediateFs.writeFile(tempFile, lockfile.toString(), function (err) {\n                if (err) {\n                  writeDone();\n                  return intermediateFs.unlink(tempFile, function () {\n                    return callback(err);\n                  });\n                }\n\n                intermediateFs.rename(tempFile, lockfileLocation, function (err) {\n                  if (err) {\n                    writeDone();\n                    return intermediateFs.unlink(tempFile, function () {\n                      return callback(err);\n                    });\n                  }\n\n                  writeDone();\n                  callback();\n                });\n              });\n            });\n          };\n\n          if (inProgressWrite) {\n            inProgressWrite.push(runWrite);\n          } else {\n            inProgressWrite = [];\n            runWrite();\n          }\n        });\n      });\n    }\n  }]);\n\n  return HttpUriPlugin;\n}();\n\nmodule.exports = HttpUriPlugin;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/schemes/HttpUriPlugin.js"],"names":["require","extname","basename","URL","createGunzip","createBrotliDecompress","createInflate","NormalModule","createSchemaValidation","createHash","mkdirp","dirname","join","memoize","getHttp","getHttps","inProgressWrite","undefined","validate","name","baseDataPath","toSafePath","str","replace","computeIntegrity","content","hash","update","integrity","digest","verifyIntegrity","parseKeyValuePairs","result","split","item","i","indexOf","key","slice","trim","value","parseCacheControl","cacheControl","requestTime","storeCache","storeLock","validUntil","parsed","isNaN","areLockfileEntriesEqual","a","b","resolved","contentType","entryToString","entry","Lockfile","version","entries","Map","Array","from","sort","JSON","stringify","data","parse","Error","lockfile","Object","keys","set","cachedWithoutKey","fn","inFlight","cachedError","cachedResult","cachedCallbacks","callback","push","err","callbacks","cb","cachedWithKey","forceFn","cache","resultFn","arg","cacheEntry","get","error","newCacheEntry","force","HttpUriPlugin","options","_lockfileLocation","lockfileLocation","_cacheLocation","cacheLocation","_upgrade","upgrade","_frozen","frozen","_allowedUris","allowedUris","compiler","schemes","scheme","fetch","url","lockfileCache","hooks","compilation","tap","normalModuleFactory","intermediateFs","intermediateFileSystem","fs","inputFileSystem","getCache","logger","getLogger","context","hashFunction","hashDigest","hashDigestLength","warnedAboutEol","cacheKeyCache","getCacheKey","_getCacheKey","parsedUrl","folder","origin","pathname","query","search","ext","length","getLockfile","readLockfile","readFile","buffer","code","missingDependencies","add","fileDependencies","fileSystemInfo","createSnapshot","fsStartTime","timestamp","snapshot","toString","checkSnapshotValid","valid","lockfileUpdates","storeLockEntry","oldEntry","log","storeResult","filePath","writeFile","resolveContent","handleResult","location","innerResult","fresh","fetchContent","fetchContentRaw","Date","now","headers","etag","res","finishWith","partialResult","debug","statusCode","Math","ceil","store","warn","message","stack","href","bufferArr","contentEncoding","stream","pipe","on","chunk","complete","Buffer","concat","isValid","isAllowed","uri","allowed","startsWith","test","getInfo","map","entryOrString","entryTag","doFetch","lockedContent","continueWithCachedContent","contentWithChangedEol","isEolChanged","e","explainer","info","respondWithUrlModule","resourceData","resource","path","fragment","mimetype","resolveForScheme","for","tapAsync","resolveData","resolveInScheme","dependencyType","getCompilationHooks","readResourceForScheme","module","buildInfo","resourceIntegrity","needBuild","finishModules","modules","tempFile","random","writeDone","nextOperation","shift","runWrite","unlink","rename","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { extname, basename } = require(\"path\");\nconst { URL } = require(\"url\");\nconst { createGunzip, createBrotliDecompress, createInflate } = require(\"zlib\");\nconst NormalModule = require(\"../NormalModule\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst createHash = require(\"../util/createHash\");\nconst { mkdirp, dirname, join } = require(\"../util/fs\");\nconst memoize = require(\"../util/memoize\");\n\n/** @typedef {import(\"../../declarations/plugins/schemes/HttpUriPlugin\").HttpUriPluginOptions} HttpUriPluginOptions */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nconst getHttp = memoize(() => require(\"http\"));\nconst getHttps = memoize(() => require(\"https\"));\n\n/** @type {(() => void)[] | undefined} */\nlet inProgressWrite = undefined;\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/schemes/HttpUriPlugin.check.js\"),\n\t() => require(\"../../schemas/plugins/schemes/HttpUriPlugin.json\"),\n\t{\n\t\tname: \"Http Uri Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\nconst toSafePath = str =>\n\tstr\n\t\t.replace(/^[^a-zA-Z0-9]+|[^a-zA-Z0-9]+$/g, \"\")\n\t\t.replace(/[^a-zA-Z0-9._-]+/g, \"_\");\n\nconst computeIntegrity = content => {\n\tconst hash = createHash(\"sha512\");\n\thash.update(content);\n\tconst integrity = \"sha512-\" + hash.digest(\"base64\");\n\treturn integrity;\n};\n\nconst verifyIntegrity = (content, integrity) => {\n\tif (integrity === \"ignore\") return true;\n\treturn computeIntegrity(content) === integrity;\n};\n\n/**\n * @param {string} str input\n * @returns {Record<string, string>} parsed\n */\nconst parseKeyValuePairs = str => {\n\t/** @type {Record<string, string>} */\n\tconst result = {};\n\tfor (const item of str.split(\",\")) {\n\t\tconst i = item.indexOf(\"=\");\n\t\tif (i >= 0) {\n\t\t\tconst key = item.slice(0, i).trim();\n\t\t\tconst value = item.slice(i + 1).trim();\n\t\t\tresult[key] = value;\n\t\t} else {\n\t\t\tconst key = item.trim();\n\t\t\tif (!key) continue;\n\t\t\tresult[key] = key;\n\t\t}\n\t}\n\treturn result;\n};\n\nconst parseCacheControl = (cacheControl, requestTime) => {\n\t// When false resource is not stored in cache\n\tlet storeCache = true;\n\t// When false resource is not stored in lockfile cache\n\tlet storeLock = true;\n\t// Resource is only revalidated, after that timestamp and when upgrade is chosen\n\tlet validUntil = 0;\n\tif (cacheControl) {\n\t\tconst parsed = parseKeyValuePairs(cacheControl);\n\t\tif (parsed[\"no-cache\"]) storeCache = storeLock = false;\n\t\tif (parsed[\"max-age\"] && !isNaN(+parsed[\"max-age\"])) {\n\t\t\tvalidUntil = requestTime + +parsed[\"max-age\"] * 1000;\n\t\t}\n\t\tif (parsed[\"must-revalidate\"]) validUntil = 0;\n\t}\n\treturn {\n\t\tstoreLock,\n\t\tstoreCache,\n\t\tvalidUntil\n\t};\n};\n\n/**\n * @typedef {Object} LockfileEntry\n * @property {string} resolved\n * @property {string} integrity\n * @property {string} contentType\n */\n\nconst areLockfileEntriesEqual = (a, b) => {\n\treturn (\n\t\ta.resolved === b.resolved &&\n\t\ta.integrity === b.integrity &&\n\t\ta.contentType === b.contentType\n\t);\n};\n\nconst entryToString = entry => {\n\treturn `resolved: ${entry.resolved}, integrity: ${entry.integrity}, contentType: ${entry.contentType}`;\n};\n\nclass Lockfile {\n\tconstructor() {\n\t\tthis.version = 1;\n\t\t/** @type {Map<string, LockfileEntry | \"ignore\" | \"no-cache\">} */\n\t\tthis.entries = new Map();\n\t}\n\n\tstatic parse(content) {\n\t\t// TODO handle merge conflicts\n\t\tconst data = JSON.parse(content);\n\t\tif (data.version !== 1)\n\t\t\tthrow new Error(`Unsupported lockfile version ${data.version}`);\n\t\tconst lockfile = new Lockfile();\n\t\tfor (const key of Object.keys(data)) {\n\t\t\tif (key === \"version\") continue;\n\t\t\tconst entry = data[key];\n\t\t\tlockfile.entries.set(\n\t\t\t\tkey,\n\t\t\t\ttypeof entry === \"string\"\n\t\t\t\t\t? entry\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tresolved: key,\n\t\t\t\t\t\t\t...entry\n\t\t\t\t\t  }\n\t\t\t);\n\t\t}\n\t\treturn lockfile;\n\t}\n\n\ttoString() {\n\t\tlet str = \"{\\n\";\n\t\tconst entries = Array.from(this.entries).sort(([a], [b]) =>\n\t\t\ta < b ? -1 : 1\n\t\t);\n\t\tfor (const [key, entry] of entries) {\n\t\t\tif (typeof entry === \"string\") {\n\t\t\t\tstr += `  ${JSON.stringify(key)}: ${JSON.stringify(entry)},\\n`;\n\t\t\t} else {\n\t\t\t\tstr += `  ${JSON.stringify(key)}: { `;\n\t\t\t\tif (entry.resolved !== key)\n\t\t\t\t\tstr += `\"resolved\": ${JSON.stringify(entry.resolved)}, `;\n\t\t\t\tstr += `\"integrity\": ${JSON.stringify(\n\t\t\t\t\tentry.integrity\n\t\t\t\t)}, \"contentType\": ${JSON.stringify(entry.contentType)} },\\n`;\n\t\t\t}\n\t\t}\n\t\tstr += `  \"version\": ${this.version}\\n}\\n`;\n\t\treturn str;\n\t}\n}\n\n/**\n * @template R\n * @param {function(function(Error=, R=): void): void} fn function\n * @returns {function(function((Error | null)=, R=): void): void} cached function\n */\nconst cachedWithoutKey = fn => {\n\tlet inFlight = false;\n\t/** @type {Error | undefined} */\n\tlet cachedError = undefined;\n\t/** @type {R | undefined} */\n\tlet cachedResult = undefined;\n\t/** @type {(function(Error=, R=): void)[] | undefined} */\n\tlet cachedCallbacks = undefined;\n\treturn callback => {\n\t\tif (inFlight) {\n\t\t\tif (cachedResult !== undefined) return callback(null, cachedResult);\n\t\t\tif (cachedError !== undefined) return callback(cachedError);\n\t\t\tif (cachedCallbacks === undefined) cachedCallbacks = [callback];\n\t\t\telse cachedCallbacks.push(callback);\n\t\t\treturn;\n\t\t}\n\t\tinFlight = true;\n\t\tfn((err, result) => {\n\t\t\tif (err) cachedError = err;\n\t\t\telse cachedResult = result;\n\t\t\tconst callbacks = cachedCallbacks;\n\t\t\tcachedCallbacks = undefined;\n\t\t\tcallback(err, result);\n\t\t\tif (callbacks !== undefined) for (const cb of callbacks) cb(err, result);\n\t\t});\n\t};\n};\n\n/**\n * @template T\n * @template R\n * @param {function(T, function(Error=, R=): void): void} fn function\n * @param {function(T, function(Error=, R=): void): void=} forceFn function for the second try\n * @returns {(function(T, function((Error | null)=, R=): void): void) & { force: function(T, function((Error | null)=, R=): void): void }} cached function\n */\nconst cachedWithKey = (fn, forceFn = fn) => {\n\t/** @typedef {{ result?: R, error?: Error, callbacks?: (function((Error | null)=, R=): void)[], force?: true }} CacheEntry */\n\t/** @type {Map<T, CacheEntry>} */\n\tconst cache = new Map();\n\tconst resultFn = (arg, callback) => {\n\t\tconst cacheEntry = cache.get(arg);\n\t\tif (cacheEntry !== undefined) {\n\t\t\tif (cacheEntry.result !== undefined)\n\t\t\t\treturn callback(null, cacheEntry.result);\n\t\t\tif (cacheEntry.error !== undefined) return callback(cacheEntry.error);\n\t\t\tif (cacheEntry.callbacks === undefined) cacheEntry.callbacks = [callback];\n\t\t\telse cacheEntry.callbacks.push(callback);\n\t\t\treturn;\n\t\t}\n\t\t/** @type {CacheEntry} */\n\t\tconst newCacheEntry = {\n\t\t\tresult: undefined,\n\t\t\terror: undefined,\n\t\t\tcallbacks: undefined\n\t\t};\n\t\tcache.set(arg, newCacheEntry);\n\t\tfn(arg, (err, result) => {\n\t\t\tif (err) newCacheEntry.error = err;\n\t\t\telse newCacheEntry.result = result;\n\t\t\tconst callbacks = newCacheEntry.callbacks;\n\t\t\tnewCacheEntry.callbacks = undefined;\n\t\t\tcallback(err, result);\n\t\t\tif (callbacks !== undefined) for (const cb of callbacks) cb(err, result);\n\t\t});\n\t};\n\tresultFn.force = (arg, callback) => {\n\t\tconst cacheEntry = cache.get(arg);\n\t\tif (cacheEntry !== undefined && cacheEntry.force) {\n\t\t\tif (cacheEntry.result !== undefined)\n\t\t\t\treturn callback(null, cacheEntry.result);\n\t\t\tif (cacheEntry.error !== undefined) return callback(cacheEntry.error);\n\t\t\tif (cacheEntry.callbacks === undefined) cacheEntry.callbacks = [callback];\n\t\t\telse cacheEntry.callbacks.push(callback);\n\t\t\treturn;\n\t\t}\n\t\t/** @type {CacheEntry} */\n\t\tconst newCacheEntry = {\n\t\t\tresult: undefined,\n\t\t\terror: undefined,\n\t\t\tcallbacks: undefined,\n\t\t\tforce: true\n\t\t};\n\t\tcache.set(arg, newCacheEntry);\n\t\tforceFn(arg, (err, result) => {\n\t\t\tif (err) newCacheEntry.error = err;\n\t\t\telse newCacheEntry.result = result;\n\t\t\tconst callbacks = newCacheEntry.callbacks;\n\t\t\tnewCacheEntry.callbacks = undefined;\n\t\t\tcallback(err, result);\n\t\t\tif (callbacks !== undefined) for (const cb of callbacks) cb(err, result);\n\t\t});\n\t};\n\treturn resultFn;\n};\n\nclass HttpUriPlugin {\n\t/**\n\t * @param {HttpUriPluginOptions} options options\n\t */\n\tconstructor(options) {\n\t\tvalidate(options);\n\t\tthis._lockfileLocation = options.lockfileLocation;\n\t\tthis._cacheLocation = options.cacheLocation;\n\t\tthis._upgrade = options.upgrade;\n\t\tthis._frozen = options.frozen;\n\t\tthis._allowedUris = options.allowedUris;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst schemes = [\n\t\t\t{\n\t\t\t\tscheme: \"http\",\n\t\t\t\tfetch: (url, options, callback) => getHttp().get(url, options, callback)\n\t\t\t},\n\t\t\t{\n\t\t\t\tscheme: \"https\",\n\t\t\t\tfetch: (url, options, callback) =>\n\t\t\t\t\tgetHttps().get(url, options, callback)\n\t\t\t}\n\t\t];\n\t\tlet lockfileCache;\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"HttpUriPlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tconst intermediateFs = compiler.intermediateFileSystem;\n\t\t\t\tconst fs = compilation.inputFileSystem;\n\t\t\t\tconst cache = compilation.getCache(\"webpack.HttpUriPlugin\");\n\t\t\t\tconst logger = compilation.getLogger(\"webpack.HttpUriPlugin\");\n\t\t\t\tconst lockfileLocation =\n\t\t\t\t\tthis._lockfileLocation ||\n\t\t\t\t\tjoin(\n\t\t\t\t\t\tintermediateFs,\n\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\tcompiler.name\n\t\t\t\t\t\t\t? `${toSafePath(compiler.name)}.webpack.lock`\n\t\t\t\t\t\t\t: \"webpack.lock\"\n\t\t\t\t\t);\n\t\t\t\tconst cacheLocation =\n\t\t\t\t\tthis._cacheLocation !== undefined\n\t\t\t\t\t\t? this._cacheLocation\n\t\t\t\t\t\t: lockfileLocation + \".data\";\n\t\t\t\tconst upgrade = this._upgrade || false;\n\t\t\t\tconst frozen = this._frozen || false;\n\t\t\t\tconst hashFunction = \"sha512\";\n\t\t\t\tconst hashDigest = \"hex\";\n\t\t\t\tconst hashDigestLength = 20;\n\t\t\t\tconst allowedUris = this._allowedUris;\n\n\t\t\t\tlet warnedAboutEol = false;\n\n\t\t\t\tconst cacheKeyCache = new Map();\n\t\t\t\t/**\n\t\t\t\t * @param {string} url the url\n\t\t\t\t * @returns {string} the key\n\t\t\t\t */\n\t\t\t\tconst getCacheKey = url => {\n\t\t\t\t\tconst cachedResult = cacheKeyCache.get(url);\n\t\t\t\t\tif (cachedResult !== undefined) return cachedResult;\n\t\t\t\t\tconst result = _getCacheKey(url);\n\t\t\t\t\tcacheKeyCache.set(url, result);\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\t/**\n\t\t\t\t * @param {string} url the url\n\t\t\t\t * @returns {string} the key\n\t\t\t\t */\n\t\t\t\tconst _getCacheKey = url => {\n\t\t\t\t\tconst parsedUrl = new URL(url);\n\t\t\t\t\tconst folder = toSafePath(parsedUrl.origin);\n\t\t\t\t\tconst name = toSafePath(parsedUrl.pathname);\n\t\t\t\t\tconst query = toSafePath(parsedUrl.search);\n\t\t\t\t\tlet ext = extname(name);\n\t\t\t\t\tif (ext.length > 20) ext = \"\";\n\t\t\t\t\tconst basename = ext ? name.slice(0, -ext.length) : name;\n\t\t\t\t\tconst hash = createHash(hashFunction);\n\t\t\t\t\thash.update(url);\n\t\t\t\t\tconst digest = hash.digest(hashDigest).slice(0, hashDigestLength);\n\t\t\t\t\treturn `${folder.slice(-50)}/${`${basename}${\n\t\t\t\t\t\tquery ? `_${query}` : \"\"\n\t\t\t\t\t}`.slice(0, 150)}_${digest}${ext}`;\n\t\t\t\t};\n\n\t\t\t\tconst getLockfile = cachedWithoutKey(\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {function((Error | null)=, Lockfile=): void} callback callback\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tcallback => {\n\t\t\t\t\t\tconst readLockfile = () => {\n\t\t\t\t\t\t\tintermediateFs.readFile(lockfileLocation, (err, buffer) => {\n\t\t\t\t\t\t\t\tif (err && err.code !== \"ENOENT\") {\n\t\t\t\t\t\t\t\t\tcompilation.missingDependencies.add(lockfileLocation);\n\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcompilation.fileDependencies.add(lockfileLocation);\n\t\t\t\t\t\t\t\tcompilation.fileSystemInfo.createSnapshot(\n\t\t\t\t\t\t\t\t\tcompiler.fsStartTime,\n\t\t\t\t\t\t\t\t\tbuffer ? [lockfileLocation] : [],\n\t\t\t\t\t\t\t\t\t[],\n\t\t\t\t\t\t\t\t\tbuffer ? [] : [lockfileLocation],\n\t\t\t\t\t\t\t\t\t{ timestamp: true },\n\t\t\t\t\t\t\t\t\t(err, snapshot) => {\n\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\tconst lockfile = buffer\n\t\t\t\t\t\t\t\t\t\t\t? Lockfile.parse(buffer.toString(\"utf-8\"))\n\t\t\t\t\t\t\t\t\t\t\t: new Lockfile();\n\t\t\t\t\t\t\t\t\t\tlockfileCache = {\n\t\t\t\t\t\t\t\t\t\t\tlockfile,\n\t\t\t\t\t\t\t\t\t\t\tsnapshot\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tcallback(null, lockfile);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (lockfileCache) {\n\t\t\t\t\t\t\tcompilation.fileSystemInfo.checkSnapshotValid(\n\t\t\t\t\t\t\t\tlockfileCache.snapshot,\n\t\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\tif (!valid) return readLockfile();\n\t\t\t\t\t\t\t\t\tcallback(null, lockfileCache.lockfile);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treadLockfile();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t/** @type {Map<string, LockfileEntry | \"ignore\" | \"no-cache\"> | undefined} */\n\t\t\t\tlet lockfileUpdates = undefined;\n\t\t\t\tconst storeLockEntry = (lockfile, url, entry) => {\n\t\t\t\t\tconst oldEntry = lockfile.entries.get(url);\n\t\t\t\t\tif (lockfileUpdates === undefined) lockfileUpdates = new Map();\n\t\t\t\t\tlockfileUpdates.set(url, entry);\n\t\t\t\t\tlockfile.entries.set(url, entry);\n\t\t\t\t\tif (!oldEntry) {\n\t\t\t\t\t\tlogger.log(`${url} added to lockfile`);\n\t\t\t\t\t} else if (typeof oldEntry === \"string\") {\n\t\t\t\t\t\tif (typeof entry === \"string\") {\n\t\t\t\t\t\t\tlogger.log(`${url} updated in lockfile: ${oldEntry} -> ${entry}`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t`${url} updated in lockfile: ${oldEntry} -> ${entry.resolved}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (typeof entry === \"string\") {\n\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t`${url} updated in lockfile: ${oldEntry.resolved} -> ${entry}`\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (oldEntry.resolved !== entry.resolved) {\n\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t`${url} updated in lockfile: ${oldEntry.resolved} -> ${entry.resolved}`\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (oldEntry.integrity !== entry.integrity) {\n\t\t\t\t\t\tlogger.log(`${url} updated in lockfile: content changed`);\n\t\t\t\t\t} else if (oldEntry.contentType !== entry.contentType) {\n\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t`${url} updated in lockfile: ${oldEntry.contentType} -> ${entry.contentType}`\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.log(`${url} updated in lockfile`);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tconst storeResult = (lockfile, url, result, callback) => {\n\t\t\t\t\tif (result.storeLock) {\n\t\t\t\t\t\tstoreLockEntry(lockfile, url, result.entry);\n\t\t\t\t\t\tif (!cacheLocation || !result.content)\n\t\t\t\t\t\t\treturn callback(null, result);\n\t\t\t\t\t\tconst key = getCacheKey(result.entry.resolved);\n\t\t\t\t\t\tconst filePath = join(intermediateFs, cacheLocation, key);\n\t\t\t\t\t\tmkdirp(intermediateFs, dirname(intermediateFs, filePath), err => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tintermediateFs.writeFile(filePath, result.content, err => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstoreLockEntry(lockfile, url, \"no-cache\");\n\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tfor (const { scheme, fetch } of schemes) {\n\t\t\t\t\t/**\n\t\t\t\t\t *\n\t\t\t\t\t * @param {string} url URL\n\t\t\t\t\t * @param {string} integrity integrity\n\t\t\t\t\t * @param {function((Error | null)=, { entry: LockfileEntry, content: Buffer, storeLock: boolean }=): void} callback callback\n\t\t\t\t\t */\n\t\t\t\t\tconst resolveContent = (url, integrity, callback) => {\n\t\t\t\t\t\tconst handleResult = (err, result) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tif (\"location\" in result) {\n\t\t\t\t\t\t\t\treturn resolveContent(\n\t\t\t\t\t\t\t\t\tresult.location,\n\t\t\t\t\t\t\t\t\tintegrity,\n\t\t\t\t\t\t\t\t\t(err, innerResult) => {\n\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\tcallback(null, {\n\t\t\t\t\t\t\t\t\t\t\tentry: innerResult.entry,\n\t\t\t\t\t\t\t\t\t\t\tcontent: innerResult.content,\n\t\t\t\t\t\t\t\t\t\t\tstoreLock: innerResult.storeLock && result.storeLock\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t!result.fresh &&\n\t\t\t\t\t\t\t\t\tintegrity &&\n\t\t\t\t\t\t\t\t\tresult.entry.integrity !== integrity &&\n\t\t\t\t\t\t\t\t\t!verifyIntegrity(result.content, integrity)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\treturn fetchContent.force(url, handleResult);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\t\tentry: result.entry,\n\t\t\t\t\t\t\t\t\tcontent: result.content,\n\t\t\t\t\t\t\t\t\tstoreLock: result.storeLock\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfetchContent(url, handleResult);\n\t\t\t\t\t};\n\n\t\t\t\t\t/** @typedef {{ storeCache: boolean, storeLock: boolean, validUntil: number, etag: string | undefined, fresh: boolean }} FetchResultMeta */\n\t\t\t\t\t/** @typedef {FetchResultMeta & { location: string }} RedirectFetchResult */\n\t\t\t\t\t/** @typedef {FetchResultMeta & { entry: LockfileEntry, content: Buffer }} ContentFetchResult */\n\t\t\t\t\t/** @typedef {RedirectFetchResult | ContentFetchResult} FetchResult */\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} url URL\n\t\t\t\t\t * @param {FetchResult | RedirectFetchResult} cachedResult result from cache\n\t\t\t\t\t * @param {function((Error | null)=, FetchResult=): void} callback callback\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst fetchContentRaw = (url, cachedResult, callback) => {\n\t\t\t\t\t\tconst requestTime = Date.now();\n\t\t\t\t\t\tfetch(\n\t\t\t\t\t\t\tnew URL(url),\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t\t\"accept-encoding\": \"gzip, deflate, br\",\n\t\t\t\t\t\t\t\t\t\"user-agent\": \"webpack\",\n\t\t\t\t\t\t\t\t\t\"if-none-match\": cachedResult\n\t\t\t\t\t\t\t\t\t\t? cachedResult.etag || null\n\t\t\t\t\t\t\t\t\t\t: null\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tres => {\n\t\t\t\t\t\t\t\tconst etag = res.headers[\"etag\"];\n\t\t\t\t\t\t\t\tconst location = res.headers[\"location\"];\n\t\t\t\t\t\t\t\tconst cacheControl = res.headers[\"cache-control\"];\n\t\t\t\t\t\t\t\tconst { storeLock, storeCache, validUntil } = parseCacheControl(\n\t\t\t\t\t\t\t\t\tcacheControl,\n\t\t\t\t\t\t\t\t\trequestTime\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @param {Partial<Pick<FetchResultMeta, \"fresh\">> & (Pick<RedirectFetchResult, \"location\"> | Pick<ContentFetchResult, \"content\" | \"entry\">)} partialResult result\n\t\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst finishWith = partialResult => {\n\t\t\t\t\t\t\t\t\tif (\"location\" in partialResult) {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`GET ${url} [${res.statusCode}] -> ${partialResult.location}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`GET ${url} [${res.statusCode}] ${Math.ceil(\n\t\t\t\t\t\t\t\t\t\t\t\tpartialResult.content.length / 1024\n\t\t\t\t\t\t\t\t\t\t\t)} kB${!storeLock ? \" no-cache\" : \"\"}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst result = {\n\t\t\t\t\t\t\t\t\t\t...partialResult,\n\t\t\t\t\t\t\t\t\t\tfresh: true,\n\t\t\t\t\t\t\t\t\t\tstoreLock,\n\t\t\t\t\t\t\t\t\t\tstoreCache,\n\t\t\t\t\t\t\t\t\t\tvalidUntil,\n\t\t\t\t\t\t\t\t\t\tetag\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tif (!storeCache) {\n\t\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t\t`${url} can't be stored in cache, due to Cache-Control header: ${cacheControl}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\treturn callback(null, result);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcache.store(\n\t\t\t\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t...result,\n\t\t\t\t\t\t\t\t\t\t\tfresh: false\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t\t\t\t\t\t\t`${url} can't be stored in cache: ${err.message}`\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tif (res.statusCode === 304) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tcachedResult.validUntil < validUntil ||\n\t\t\t\t\t\t\t\t\t\tcachedResult.storeLock !== storeLock ||\n\t\t\t\t\t\t\t\t\t\tcachedResult.storeCache !== storeCache ||\n\t\t\t\t\t\t\t\t\t\tcachedResult.etag !== etag\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\treturn finishWith(cachedResult);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(`GET ${url} [${res.statusCode}] (unchanged)`);\n\t\t\t\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\t\t\t\t...cachedResult,\n\t\t\t\t\t\t\t\t\t\t\tfresh: true\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tlocation &&\n\t\t\t\t\t\t\t\t\tres.statusCode >= 301 &&\n\t\t\t\t\t\t\t\t\tres.statusCode <= 308\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tconst result = {\n\t\t\t\t\t\t\t\t\t\tlocation: new URL(location, url).href\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!cachedResult ||\n\t\t\t\t\t\t\t\t\t\t!(\"location\" in cachedResult) ||\n\t\t\t\t\t\t\t\t\t\tcachedResult.location !== result.location ||\n\t\t\t\t\t\t\t\t\t\tcachedResult.validUntil < validUntil ||\n\t\t\t\t\t\t\t\t\t\tcachedResult.storeLock !== storeLock ||\n\t\t\t\t\t\t\t\t\t\tcachedResult.storeCache !== storeCache ||\n\t\t\t\t\t\t\t\t\t\tcachedResult.etag !== etag\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\treturn finishWith(result);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(`GET ${url} [${res.statusCode}] (unchanged)`);\n\t\t\t\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\t\t\t\t...result,\n\t\t\t\t\t\t\t\t\t\t\tfresh: true,\n\t\t\t\t\t\t\t\t\t\t\tstoreLock,\n\t\t\t\t\t\t\t\t\t\t\tstoreCache,\n\t\t\t\t\t\t\t\t\t\t\tvalidUntil,\n\t\t\t\t\t\t\t\t\t\t\tetag\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst contentType = res.headers[\"content-type\"] || \"\";\n\t\t\t\t\t\t\t\tconst bufferArr = [];\n\n\t\t\t\t\t\t\t\tconst contentEncoding = res.headers[\"content-encoding\"];\n\t\t\t\t\t\t\t\tlet stream = res;\n\t\t\t\t\t\t\t\tif (contentEncoding === \"gzip\") {\n\t\t\t\t\t\t\t\t\tstream = stream.pipe(createGunzip());\n\t\t\t\t\t\t\t\t} else if (contentEncoding === \"br\") {\n\t\t\t\t\t\t\t\t\tstream = stream.pipe(createBrotliDecompress());\n\t\t\t\t\t\t\t\t} else if (contentEncoding === \"deflate\") {\n\t\t\t\t\t\t\t\t\tstream = stream.pipe(createInflate());\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tstream.on(\"data\", chunk => {\n\t\t\t\t\t\t\t\t\tbufferArr.push(chunk);\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tstream.on(\"end\", () => {\n\t\t\t\t\t\t\t\t\tif (!res.complete) {\n\t\t\t\t\t\t\t\t\t\tlogger.log(`GET ${url} [${res.statusCode}] (terminated)`);\n\t\t\t\t\t\t\t\t\t\treturn callback(new Error(`${url} request was terminated`));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tconst content = Buffer.concat(bufferArr);\n\n\t\t\t\t\t\t\t\t\tif (res.statusCode !== 200) {\n\t\t\t\t\t\t\t\t\t\tlogger.log(`GET ${url} [${res.statusCode}]`);\n\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t`${url} request status code = ${\n\t\t\t\t\t\t\t\t\t\t\t\t\tres.statusCode\n\t\t\t\t\t\t\t\t\t\t\t\t}\\n${content.toString(\"utf-8\")}`\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tconst integrity = computeIntegrity(content);\n\t\t\t\t\t\t\t\t\tconst entry = { resolved: url, integrity, contentType };\n\n\t\t\t\t\t\t\t\t\tfinishWith({\n\t\t\t\t\t\t\t\t\t\tentry,\n\t\t\t\t\t\t\t\t\t\tcontent\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t).on(\"error\", err => {\n\t\t\t\t\t\t\tlogger.log(`GET ${url} (error)`);\n\t\t\t\t\t\t\terr.message += `\\nwhile fetching ${url}`;\n\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\tconst fetchContent = cachedWithKey(\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {string} url URL\n\t\t\t\t\t\t * @param {function((Error | null)=, { validUntil: number, etag?: string, entry: LockfileEntry, content: Buffer, fresh: boolean } | { validUntil: number, etag?: string, location: string, fresh: boolean }=): void} callback callback\n\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t */ (url, callback) => {\n\t\t\t\t\t\t\tcache.get(url, null, (err, cachedResult) => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\tif (cachedResult) {\n\t\t\t\t\t\t\t\t\tconst isValid = cachedResult.validUntil >= Date.now();\n\t\t\t\t\t\t\t\t\tif (isValid) return callback(null, cachedResult);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfetchContentRaw(url, cachedResult, callback);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t\t(url, callback) => fetchContentRaw(url, undefined, callback)\n\t\t\t\t\t);\n\n\t\t\t\t\tconst isAllowed = uri => {\n\t\t\t\t\t\tfor (const allowed of allowedUris) {\n\t\t\t\t\t\t\tif (typeof allowed === \"string\") {\n\t\t\t\t\t\t\t\tif (uri.startsWith(allowed)) return true;\n\t\t\t\t\t\t\t} else if (typeof allowed === \"function\") {\n\t\t\t\t\t\t\t\tif (allowed(uri)) return true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (allowed.test(uri)) return true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t};\n\n\t\t\t\t\tconst getInfo = cachedWithKey(\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {string} url the url\n\t\t\t\t\t\t * @param {function((Error | null)=, { entry: LockfileEntry, content: Buffer }=): void} callback callback\n\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t */\n\t\t\t\t\t\t(url, callback) => {\n\t\t\t\t\t\t\tif (!isAllowed(url)) {\n\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t`${url} doesn't match the allowedUris policy. These URIs are allowed:\\n${allowedUris\n\t\t\t\t\t\t\t\t\t\t\t.map(uri => ` - ${uri}`)\n\t\t\t\t\t\t\t\t\t\t\t.join(\"\\n\")}`\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgetLockfile((err, lockfile) => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\tconst entryOrString = lockfile.entries.get(url);\n\t\t\t\t\t\t\t\tif (!entryOrString) {\n\t\t\t\t\t\t\t\t\tif (frozen) {\n\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t`${url} has no lockfile entry and lockfile is frozen`\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tresolveContent(url, null, (err, result) => {\n\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\tstoreResult(lockfile, url, result, callback);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (typeof entryOrString === \"string\") {\n\t\t\t\t\t\t\t\t\tconst entryTag = entryOrString;\n\t\t\t\t\t\t\t\t\tresolveContent(url, null, (err, result) => {\n\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\tif (!result.storeLock || entryTag === \"ignore\")\n\t\t\t\t\t\t\t\t\t\t\treturn callback(null, result);\n\t\t\t\t\t\t\t\t\t\tif (frozen) {\n\t\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\t`${url} used to have ${entryTag} lockfile entry and has content now, but lockfile is frozen`\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!upgrade) {\n\t\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\t`${url} used to have ${entryTag} lockfile entry and has content now.\nThis should be reflected in the lockfile, so this lockfile entry must be upgraded, but upgrading is not enabled.\nRemove this line from the lockfile to force upgrading.`\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tstoreResult(lockfile, url, result, callback);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet entry = entryOrString;\n\t\t\t\t\t\t\t\tconst doFetch = lockedContent => {\n\t\t\t\t\t\t\t\t\tresolveContent(url, entry.integrity, (err, result) => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tif (lockedContent) {\n\t\t\t\t\t\t\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t\t\t\t\t\t\t`Upgrade request to ${url} failed: ${err.message}`\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\t\t\t\t\t\tentry,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontent: lockedContent\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!result.storeLock) {\n\t\t\t\t\t\t\t\t\t\t\t// When the lockfile entry should be no-cache\n\t\t\t\t\t\t\t\t\t\t\t// we need to update the lockfile\n\t\t\t\t\t\t\t\t\t\t\tif (frozen) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`${url} has a lockfile entry and is no-cache now, but lockfile is frozen\\nLockfile: ${entryToString(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tentry\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)}`\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tstoreResult(lockfile, url, result, callback);\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!areLockfileEntriesEqual(result.entry, entry)) {\n\t\t\t\t\t\t\t\t\t\t\t// When the lockfile entry is outdated\n\t\t\t\t\t\t\t\t\t\t\t// we need to update the lockfile\n\t\t\t\t\t\t\t\t\t\t\tif (frozen) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`${url} has an outdated lockfile entry, but lockfile is frozen\\nLockfile: ${entryToString(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tentry\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)}\\nExpected: ${entryToString(result.entry)}`\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tstoreResult(lockfile, url, result, callback);\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!lockedContent && cacheLocation) {\n\t\t\t\t\t\t\t\t\t\t\t// When the lockfile cache content is missing\n\t\t\t\t\t\t\t\t\t\t\t// we need to update the lockfile\n\t\t\t\t\t\t\t\t\t\t\tif (frozen) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`${url} is missing content in the lockfile cache, but lockfile is frozen\\nLockfile: ${entryToString(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tentry\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)}`\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tstoreResult(lockfile, url, result, callback);\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn callback(null, result);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tif (cacheLocation) {\n\t\t\t\t\t\t\t\t\t// When there is a lockfile cache\n\t\t\t\t\t\t\t\t\t// we read the content from there\n\t\t\t\t\t\t\t\t\tconst key = getCacheKey(entry.resolved);\n\t\t\t\t\t\t\t\t\tconst filePath = join(intermediateFs, cacheLocation, key);\n\t\t\t\t\t\t\t\t\tfs.readFile(filePath, (err, result) => {\n\t\t\t\t\t\t\t\t\t\tconst content = /** @type {Buffer} */ (result);\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tif (err.code === \"ENOENT\") return doFetch();\n\t\t\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst continueWithCachedContent = result => {\n\t\t\t\t\t\t\t\t\t\t\tif (!upgrade) {\n\t\t\t\t\t\t\t\t\t\t\t\t// When not in upgrade mode, we accept the result from the lockfile cache\n\t\t\t\t\t\t\t\t\t\t\t\treturn callback(null, { entry, content });\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treturn doFetch(content);\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tif (!verifyIntegrity(content, entry.integrity)) {\n\t\t\t\t\t\t\t\t\t\t\tlet contentWithChangedEol;\n\t\t\t\t\t\t\t\t\t\t\tlet isEolChanged = false;\n\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\tcontentWithChangedEol = Buffer.from(\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontent.toString(\"utf-8\").replace(/\\r\\n/g, \"\\n\")\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tisEolChanged = verifyIntegrity(\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontentWithChangedEol,\n\t\t\t\t\t\t\t\t\t\t\t\t\tentry.integrity\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\t\t\t\t// ignore\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (isEolChanged) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (!warnedAboutEol) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst explainer = `Incorrect end of line sequence was detected in the lockfile cache.\nThe lockfile cache is protected by integrity checks, so any external modification will lead to a corrupted lockfile cache.\nWhen using git make sure to configure .gitattributes correctly for the lockfile cache:\n  **/*webpack.lock.data/** -text\nThis will avoid that the end of line sequence is changed by git on Windows.`;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (frozen) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlogger.error(explainer);\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlogger.warn(explainer);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"Lockfile cache will be automatically fixed now, but when lockfile is frozen this would result in an error.\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\twarnedAboutEol = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif (!frozen) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// \"fix\" the end of line sequence of the lockfile content\n\t\t\t\t\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`${filePath} fixed end of line sequence (\\\\r\\\\n instead of \\\\n).`\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\tintermediateFs.writeFile(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfilePath,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontentWithChangedEol,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontinueWithCachedContent(contentWithChangedEol);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (frozen) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`${\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tentry.resolved\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} integrity mismatch, expected content with integrity ${\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tentry.integrity\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} but got ${computeIntegrity(content)}.\nLockfile corrupted (${\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tisEolChanged\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? \"end of line sequence was unexpectedly changed\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: \"incorrectly merged? changed by other tools?\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}).\nRun build with un-frozen lockfile to automatically fix lockfile.`\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t// \"fix\" the lockfile entry to the correct integrity\n\t\t\t\t\t\t\t\t\t\t\t\t// the content has priority over the integrity value\n\t\t\t\t\t\t\t\t\t\t\t\tentry = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t...entry,\n\t\t\t\t\t\t\t\t\t\t\t\t\tintegrity: computeIntegrity(content)\n\t\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\t\t\tstoreLockEntry(lockfile, url, entry);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcontinueWithCachedContent(result);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdoFetch();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tconst respondWithUrlModule = (url, resourceData, callback) => {\n\t\t\t\t\t\tgetInfo(url.href, (err, result) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tresourceData.resource = url.href;\n\t\t\t\t\t\t\tresourceData.path = url.origin + url.pathname;\n\t\t\t\t\t\t\tresourceData.query = url.search;\n\t\t\t\t\t\t\tresourceData.fragment = url.hash;\n\t\t\t\t\t\t\tresourceData.context = new URL(\n\t\t\t\t\t\t\t\t\".\",\n\t\t\t\t\t\t\t\tresult.entry.resolved\n\t\t\t\t\t\t\t).href.slice(0, -1);\n\t\t\t\t\t\t\tresourceData.data.mimetype = result.entry.contentType;\n\t\t\t\t\t\t\tcallback(null, true);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\t\t\t\t\tnormalModuleFactory.hooks.resolveForScheme\n\t\t\t\t\t\t.for(scheme)\n\t\t\t\t\t\t.tapAsync(\n\t\t\t\t\t\t\t\"HttpUriPlugin\",\n\t\t\t\t\t\t\t(resourceData, resolveData, callback) => {\n\t\t\t\t\t\t\t\trespondWithUrlModule(\n\t\t\t\t\t\t\t\t\tnew URL(resourceData.resource),\n\t\t\t\t\t\t\t\t\tresourceData,\n\t\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\tnormalModuleFactory.hooks.resolveInScheme\n\t\t\t\t\t\t.for(scheme)\n\t\t\t\t\t\t.tapAsync(\"HttpUriPlugin\", (resourceData, data, callback) => {\n\t\t\t\t\t\t\t// Only handle relative urls (./xxx, ../xxx, /xxx, //xxx)\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tdata.dependencyType !== \"url\" &&\n\t\t\t\t\t\t\t\t!/^\\.{0,2}\\//.test(resourceData.resource)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trespondWithUrlModule(\n\t\t\t\t\t\t\t\tnew URL(resourceData.resource, data.context + \"/\"),\n\t\t\t\t\t\t\t\tresourceData,\n\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\tconst hooks = NormalModule.getCompilationHooks(compilation);\n\t\t\t\t\thooks.readResourceForScheme\n\t\t\t\t\t\t.for(scheme)\n\t\t\t\t\t\t.tapAsync(\"HttpUriPlugin\", (resource, module, callback) => {\n\t\t\t\t\t\t\treturn getInfo(resource, (err, result) => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\tmodule.buildInfo.resourceIntegrity = result.entry.integrity;\n\t\t\t\t\t\t\t\tcallback(null, result.content);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\thooks.needBuild.tapAsync(\n\t\t\t\t\t\t\"HttpUriPlugin\",\n\t\t\t\t\t\t(module, context, callback) => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tmodule.resource &&\n\t\t\t\t\t\t\t\tmodule.resource.startsWith(`${scheme}://`)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tgetInfo(module.resource, (err, result) => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tresult.entry.integrity !==\n\t\t\t\t\t\t\t\t\t\tmodule.buildInfo.resourceIntegrity\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\treturn callback(null, true);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcompilation.hooks.finishModules.tapAsync(\n\t\t\t\t\t\"HttpUriPlugin\",\n\t\t\t\t\t(modules, callback) => {\n\t\t\t\t\t\tif (!lockfileUpdates) return callback();\n\t\t\t\t\t\tconst ext = extname(lockfileLocation);\n\t\t\t\t\t\tconst tempFile = join(\n\t\t\t\t\t\t\tintermediateFs,\n\t\t\t\t\t\t\tdirname(intermediateFs, lockfileLocation),\n\t\t\t\t\t\t\t`.${basename(lockfileLocation, ext)}.${\n\t\t\t\t\t\t\t\t(Math.random() * 10000) | 0\n\t\t\t\t\t\t\t}${ext}`\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tconst writeDone = () => {\n\t\t\t\t\t\t\tconst nextOperation = inProgressWrite.shift();\n\t\t\t\t\t\t\tif (nextOperation) {\n\t\t\t\t\t\t\t\tnextOperation();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tinProgressWrite = undefined;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst runWrite = () => {\n\t\t\t\t\t\t\tintermediateFs.readFile(lockfileLocation, (err, buffer) => {\n\t\t\t\t\t\t\t\tif (err && err.code !== \"ENOENT\") {\n\t\t\t\t\t\t\t\t\twriteDone();\n\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst lockfile = buffer\n\t\t\t\t\t\t\t\t\t? Lockfile.parse(buffer.toString(\"utf-8\"))\n\t\t\t\t\t\t\t\t\t: new Lockfile();\n\t\t\t\t\t\t\t\tfor (const [key, value] of lockfileUpdates) {\n\t\t\t\t\t\t\t\t\tlockfile.entries.set(key, value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tintermediateFs.writeFile(tempFile, lockfile.toString(), err => {\n\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\twriteDone();\n\t\t\t\t\t\t\t\t\t\treturn intermediateFs.unlink(tempFile, () => callback(err));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tintermediateFs.rename(tempFile, lockfileLocation, err => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\twriteDone();\n\t\t\t\t\t\t\t\t\t\t\treturn intermediateFs.unlink(tempFile, () =>\n\t\t\t\t\t\t\t\t\t\t\t\tcallback(err)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\twriteDone();\n\t\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (inProgressWrite) {\n\t\t\t\t\t\t\tinProgressWrite.push(runWrite);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinProgressWrite = [];\n\t\t\t\t\t\t\trunWrite();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = HttpUriPlugin;\n"]},"metadata":{},"sourceType":"script"}