{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar util = require(\"util\");\n\nvar Entrypoint = require(\"./Entrypoint\");\n\nvar ModuleGraphConnection = require(\"./ModuleGraphConnection\");\n\nvar _require = require(\"./util/SetHelpers\"),\n    first = _require.first;\n\nvar SortableSet = require(\"./util/SortableSet\");\n\nvar _require2 = require(\"./util/comparators\"),\n    compareModulesById = _require2.compareModulesById,\n    compareIterables = _require2.compareIterables,\n    compareModulesByIdentifier = _require2.compareModulesByIdentifier,\n    concatComparators = _require2.concatComparators,\n    compareSelect = _require2.compareSelect,\n    compareIds = _require2.compareIds;\n\nvar createHash = require(\"./util/createHash\");\n\nvar findGraphRoots = require(\"./util/findGraphRoots\");\n\nvar _require3 = require(\"./util/runtime\"),\n    RuntimeSpecMap = _require3.RuntimeSpecMap,\n    RuntimeSpecSet = _require3.RuntimeSpecSet,\n    runtimeToString = _require3.runtimeToString,\n    mergeRuntime = _require3.mergeRuntime,\n    forEachRuntime = _require3.forEachRuntime;\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n\n/** @typedef {import(\"./RuntimeModule\")} RuntimeModule */\n\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @type {ReadonlySet<string>} */\n\n\nvar EMPTY_SET = new Set();\nvar ZERO_BIG_INT = BigInt(0);\nvar compareModuleIterables = compareIterables(compareModulesByIdentifier);\n/** @typedef {(c: Chunk, chunkGraph: ChunkGraph) => boolean} ChunkFilterPredicate */\n\n/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */\n\n/** @typedef {[Module, Entrypoint | undefined]} EntryModuleWithChunkGroup */\n\n/**\n * @typedef {Object} ChunkSizeOptions\n * @property {number=} chunkOverhead constant overhead for a chunk\n * @property {number=} entryChunkMultiplicator multiplicator for initial chunks\n */\n\nvar ModuleHashInfo = /*#__PURE__*/_createClass(function ModuleHashInfo(hash, renderedHash) {\n  _classCallCheck(this, ModuleHashInfo);\n\n  this.hash = hash;\n  this.renderedHash = renderedHash;\n});\n/** @template T @typedef {(set: SortableSet<T>) => T[]} SetToArrayFunction<T> */\n\n/**\n * @template T\n * @param {SortableSet<T>} set the set\n * @returns {T[]} set as array\n */\n\n\nvar getArray = function getArray(set) {\n  return Array.from(set);\n};\n/**\n * @param {SortableSet<Chunk>} chunks the chunks\n * @returns {RuntimeSpecSet} runtimes\n */\n\n\nvar _getModuleRuntimes = function getModuleRuntimes(chunks) {\n  var runtimes = new RuntimeSpecSet();\n\n  var _iterator = _createForOfIteratorHelper(chunks),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var chunk = _step.value;\n      runtimes.add(chunk.runtime);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return runtimes;\n};\n/**\n * @param {SortableSet<Module>} set the set\n * @returns {Map<string, SortableSet<Module>>} modules by source type\n */\n\n\nvar modulesBySourceType = function modulesBySourceType(set) {\n  /** @type {Map<string, SortableSet<Module>>} */\n  var map = new Map();\n\n  var _iterator2 = _createForOfIteratorHelper(set),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _module = _step2.value;\n\n      var _iterator4 = _createForOfIteratorHelper(_module.getSourceTypes()),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var sourceType = _step4.value;\n          var innerSet = map.get(sourceType);\n\n          if (innerSet === undefined) {\n            innerSet = new SortableSet();\n            map.set(sourceType, innerSet);\n          }\n\n          innerSet.add(_module);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  var _iterator3 = _createForOfIteratorHelper(map),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _step3$value = _slicedToArray(_step3.value, 2),\n          key = _step3$value[0],\n          _innerSet = _step3$value[1];\n\n      // When all modules have the source type, we reuse the original SortableSet\n      // to benefit from the shared cache (especially for sorting)\n      if (_innerSet.size === set.size) {\n        map.set(key, set);\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return map;\n};\n/** @type {WeakMap<Function, any>} */\n\n\nvar createOrderedArrayFunctionMap = new WeakMap();\n/**\n * @template T\n * @param {function(T, T): -1|0|1} comparator comparator function\n * @returns {SetToArrayFunction<T>} set as ordered array\n */\n\nvar createOrderedArrayFunction = function createOrderedArrayFunction(comparator) {\n  /** @type {SetToArrayFunction<T>} */\n  var fn = createOrderedArrayFunctionMap.get(comparator);\n  if (fn !== undefined) return fn;\n\n  fn = function fn(set) {\n    set.sortWith(comparator);\n    return Array.from(set);\n  };\n\n  createOrderedArrayFunctionMap.set(comparator, fn);\n  return fn;\n};\n/**\n * @param {Iterable<Module>} modules the modules to get the count/size of\n * @returns {number} the size of the modules\n */\n\n\nvar getModulesSize = function getModulesSize(modules) {\n  var size = 0;\n\n  var _iterator5 = _createForOfIteratorHelper(modules),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var _module2 = _step5.value;\n\n      var _iterator6 = _createForOfIteratorHelper(_module2.getSourceTypes()),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var type = _step6.value;\n          size += _module2.size(type);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return size;\n};\n/**\n * @param {Iterable<Module>} modules the sortable Set to get the size of\n * @returns {Record<string, number>} the sizes of the modules\n */\n\n\nvar getModulesSizes = function getModulesSizes(modules) {\n  var sizes = Object.create(null);\n\n  var _iterator7 = _createForOfIteratorHelper(modules),\n      _step7;\n\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var _module3 = _step7.value;\n\n      var _iterator8 = _createForOfIteratorHelper(_module3.getSourceTypes()),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var type = _step8.value;\n          sizes[type] = (sizes[type] || 0) + _module3.size(type);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n\n  return sizes;\n};\n/**\n * @param {Chunk} a chunk\n * @param {Chunk} b chunk\n * @returns {boolean} true, if a is always a parent of b\n */\n\n\nvar isAvailableChunk = function isAvailableChunk(a, b) {\n  var queue = new Set(b.groupsIterable);\n\n  var _iterator9 = _createForOfIteratorHelper(queue),\n      _step9;\n\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var chunkGroup = _step9.value;\n      if (a.isInGroup(chunkGroup)) continue;\n      if (chunkGroup.isInitial()) return false;\n\n      var _iterator10 = _createForOfIteratorHelper(chunkGroup.parentsIterable),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var parent = _step10.value;\n          queue.add(parent);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n\n  return true;\n};\n\nvar ChunkGraphModule = /*#__PURE__*/_createClass(function ChunkGraphModule() {\n  _classCallCheck(this, ChunkGraphModule);\n\n  /** @type {SortableSet<Chunk>} */\n  this.chunks = new SortableSet();\n  /** @type {Set<Chunk> | undefined} */\n\n  this.entryInChunks = undefined;\n  /** @type {Set<Chunk> | undefined} */\n\n  this.runtimeInChunks = undefined;\n  /** @type {RuntimeSpecMap<ModuleHashInfo>} */\n\n  this.hashes = undefined;\n  /** @type {string | number} */\n\n  this.id = null;\n  /** @type {RuntimeSpecMap<Set<string>> | undefined} */\n\n  this.runtimeRequirements = undefined;\n  /** @type {RuntimeSpecMap<string>} */\n\n  this.graphHashes = undefined;\n  /** @type {RuntimeSpecMap<string>} */\n\n  this.graphHashesWithConnections = undefined;\n});\n\nvar ChunkGraphChunk = /*#__PURE__*/_createClass(function ChunkGraphChunk() {\n  _classCallCheck(this, ChunkGraphChunk);\n\n  /** @type {SortableSet<Module>} */\n  this.modules = new SortableSet();\n  /** @type {Map<Module, Entrypoint>} */\n\n  this.entryModules = new Map();\n  /** @type {SortableSet<RuntimeModule>} */\n\n  this.runtimeModules = new SortableSet();\n  /** @type {Set<RuntimeModule> | undefined} */\n\n  this.fullHashModules = undefined;\n  /** @type {Set<RuntimeModule> | undefined} */\n\n  this.dependentHashModules = undefined;\n  /** @type {Set<string> | undefined} */\n\n  this.runtimeRequirements = undefined;\n  /** @type {Set<string>} */\n\n  this.runtimeRequirementsInTree = new Set();\n});\n\nvar ChunkGraph = /*#__PURE__*/function () {\n  /**\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @param {string | Hash} hashFunction the hash function to use\n   */\n  function ChunkGraph(moduleGraph) {\n    var hashFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"md4\";\n\n    _classCallCheck(this, ChunkGraph);\n\n    /** @private @type {WeakMap<Module, ChunkGraphModule>} */\n    this._modules = new WeakMap();\n    /** @private @type {WeakMap<Chunk, ChunkGraphChunk>} */\n\n    this._chunks = new WeakMap();\n    /** @private @type {WeakMap<AsyncDependenciesBlock, ChunkGroup>} */\n\n    this._blockChunkGroups = new WeakMap();\n    /** @private @type {Map<string, string | number>} */\n\n    this._runtimeIds = new Map();\n    /** @type {ModuleGraph} */\n\n    this.moduleGraph = moduleGraph;\n    this._hashFunction = hashFunction;\n    this._getGraphRoots = this._getGraphRoots.bind(this);\n  }\n  /**\n   * @private\n   * @param {Module} module the module\n   * @returns {ChunkGraphModule} internal module\n   */\n\n\n  _createClass(ChunkGraph, [{\n    key: \"_getChunkGraphModule\",\n    value: function _getChunkGraphModule(module) {\n      var cgm = this._modules.get(module);\n\n      if (cgm === undefined) {\n        cgm = new ChunkGraphModule();\n\n        this._modules.set(module, cgm);\n      }\n\n      return cgm;\n    }\n    /**\n     * @private\n     * @param {Chunk} chunk the chunk\n     * @returns {ChunkGraphChunk} internal chunk\n     */\n\n  }, {\n    key: \"_getChunkGraphChunk\",\n    value: function _getChunkGraphChunk(chunk) {\n      var cgc = this._chunks.get(chunk);\n\n      if (cgc === undefined) {\n        cgc = new ChunkGraphChunk();\n\n        this._chunks.set(chunk, cgc);\n      }\n\n      return cgc;\n    }\n    /**\n     * @param {SortableSet<Module>} set the sortable Set to get the roots of\n     * @returns {Module[]} the graph roots\n     */\n\n  }, {\n    key: \"_getGraphRoots\",\n    value: function _getGraphRoots(set) {\n      var moduleGraph = this.moduleGraph;\n      return Array.from(findGraphRoots(set, function (module) {\n        /** @type {Set<Module>} */\n        var set = new Set();\n\n        var addDependencies = function addDependencies(module) {\n          var _iterator11 = _createForOfIteratorHelper(moduleGraph.getOutgoingConnections(module)),\n              _step11;\n\n          try {\n            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n              var connection = _step11.value;\n              if (!connection.module) continue;\n              var activeState = connection.getActiveState(undefined);\n              if (activeState === false) continue;\n\n              if (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\n                addDependencies(connection.module);\n                continue;\n              }\n\n              set.add(connection.module);\n            }\n          } catch (err) {\n            _iterator11.e(err);\n          } finally {\n            _iterator11.f();\n          }\n        };\n\n        addDependencies(module);\n        return set;\n      })).sort(compareModulesByIdentifier);\n    }\n    /**\n     * @param {Chunk} chunk the new chunk\n     * @param {Module} module the module\n     * @returns {void}\n     */\n\n  }, {\n    key: \"connectChunkAndModule\",\n    value: function connectChunkAndModule(chunk, module) {\n      var cgm = this._getChunkGraphModule(module);\n\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      cgm.chunks.add(chunk);\n      cgc.modules.add(module);\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {Module} module the module\n     * @returns {void}\n     */\n\n  }, {\n    key: \"disconnectChunkAndModule\",\n    value: function disconnectChunkAndModule(chunk, module) {\n      var cgm = this._getChunkGraphModule(module);\n\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      cgc.modules.delete(module);\n      cgm.chunks.delete(chunk);\n    }\n    /**\n     * @param {Chunk} chunk the chunk which will be disconnected\n     * @returns {void}\n     */\n\n  }, {\n    key: \"disconnectChunk\",\n    value: function disconnectChunk(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      var _iterator12 = _createForOfIteratorHelper(cgc.modules),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var _module4 = _step12.value;\n\n          var cgm = this._getChunkGraphModule(_module4);\n\n          cgm.chunks.delete(chunk);\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n\n      cgc.modules.clear();\n      chunk.disconnectFromGroups();\n      ChunkGraph.clearChunkGraphForChunk(chunk);\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {Iterable<Module>} modules the modules\n     * @returns {void}\n     */\n\n  }, {\n    key: \"attachModules\",\n    value: function attachModules(chunk, modules) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      var _iterator13 = _createForOfIteratorHelper(modules),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var _module5 = _step13.value;\n          cgc.modules.add(_module5);\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {Iterable<RuntimeModule>} modules the runtime modules\n     * @returns {void}\n     */\n\n  }, {\n    key: \"attachRuntimeModules\",\n    value: function attachRuntimeModules(chunk, modules) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      var _iterator14 = _createForOfIteratorHelper(modules),\n          _step14;\n\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var _module6 = _step14.value;\n          cgc.runtimeModules.add(_module6);\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n     * @returns {void}\n     */\n\n  }, {\n    key: \"attachFullHashModules\",\n    value: function attachFullHashModules(chunk, modules) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      if (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n\n      var _iterator15 = _createForOfIteratorHelper(modules),\n          _step15;\n\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var _module7 = _step15.value;\n          cgc.fullHashModules.add(_module7);\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n     * @returns {void}\n     */\n\n  }, {\n    key: \"attachDependentHashModules\",\n    value: function attachDependentHashModules(chunk, modules) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      if (cgc.dependentHashModules === undefined) cgc.dependentHashModules = new Set();\n\n      var _iterator16 = _createForOfIteratorHelper(modules),\n          _step16;\n\n      try {\n        for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n          var _module8 = _step16.value;\n          cgc.dependentHashModules.add(_module8);\n        }\n      } catch (err) {\n        _iterator16.e(err);\n      } finally {\n        _iterator16.f();\n      }\n    }\n    /**\n     * @param {Module} oldModule the replaced module\n     * @param {Module} newModule the replacing module\n     * @returns {void}\n     */\n\n  }, {\n    key: \"replaceModule\",\n    value: function replaceModule(oldModule, newModule) {\n      var oldCgm = this._getChunkGraphModule(oldModule);\n\n      var newCgm = this._getChunkGraphModule(newModule);\n\n      var _iterator17 = _createForOfIteratorHelper(oldCgm.chunks),\n          _step17;\n\n      try {\n        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n          var _chunk2 = _step17.value;\n\n          var _cgc2 = this._getChunkGraphChunk(_chunk2);\n\n          _cgc2.modules.delete(oldModule);\n\n          _cgc2.modules.add(newModule);\n\n          newCgm.chunks.add(_chunk2);\n        }\n      } catch (err) {\n        _iterator17.e(err);\n      } finally {\n        _iterator17.f();\n      }\n\n      oldCgm.chunks.clear();\n\n      if (oldCgm.entryInChunks !== undefined) {\n        if (newCgm.entryInChunks === undefined) {\n          newCgm.entryInChunks = new Set();\n        }\n\n        var _iterator18 = _createForOfIteratorHelper(oldCgm.entryInChunks),\n            _step18;\n\n        try {\n          for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n            var chunk = _step18.value;\n\n            var cgc = this._getChunkGraphChunk(chunk);\n\n            var old = cgc.entryModules.get(oldModule);\n            /** @type {Map<Module, Entrypoint>} */\n\n            var newEntryModules = new Map();\n\n            var _iterator19 = _createForOfIteratorHelper(cgc.entryModules),\n                _step19;\n\n            try {\n              for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                var _step19$value = _slicedToArray(_step19.value, 2),\n                    m = _step19$value[0],\n                    cg = _step19$value[1];\n\n                if (m === oldModule) {\n                  newEntryModules.set(newModule, old);\n                } else {\n                  newEntryModules.set(m, cg);\n                }\n              }\n            } catch (err) {\n              _iterator19.e(err);\n            } finally {\n              _iterator19.f();\n            }\n\n            cgc.entryModules = newEntryModules;\n            newCgm.entryInChunks.add(chunk);\n          }\n        } catch (err) {\n          _iterator18.e(err);\n        } finally {\n          _iterator18.f();\n        }\n\n        oldCgm.entryInChunks = undefined;\n      }\n\n      if (oldCgm.runtimeInChunks !== undefined) {\n        if (newCgm.runtimeInChunks === undefined) {\n          newCgm.runtimeInChunks = new Set();\n        }\n\n        var _iterator20 = _createForOfIteratorHelper(oldCgm.runtimeInChunks),\n            _step20;\n\n        try {\n          for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n            var _chunk = _step20.value;\n\n            var _cgc = this._getChunkGraphChunk(_chunk);\n\n            _cgc.runtimeModules.delete(\n            /** @type {RuntimeModule} */\n            oldModule);\n\n            _cgc.runtimeModules.add(\n            /** @type {RuntimeModule} */\n            newModule);\n\n            newCgm.runtimeInChunks.add(_chunk);\n\n            if (_cgc.fullHashModules !== undefined && _cgc.fullHashModules.has(\n            /** @type {RuntimeModule} */\n            oldModule)) {\n              _cgc.fullHashModules.delete(\n              /** @type {RuntimeModule} */\n              oldModule);\n\n              _cgc.fullHashModules.add(\n              /** @type {RuntimeModule} */\n              newModule);\n            }\n\n            if (_cgc.dependentHashModules !== undefined && _cgc.dependentHashModules.has(\n            /** @type {RuntimeModule} */\n            oldModule)) {\n              _cgc.dependentHashModules.delete(\n              /** @type {RuntimeModule} */\n              oldModule);\n\n              _cgc.dependentHashModules.add(\n              /** @type {RuntimeModule} */\n              newModule);\n            }\n          }\n        } catch (err) {\n          _iterator20.e(err);\n        } finally {\n          _iterator20.f();\n        }\n\n        oldCgm.runtimeInChunks = undefined;\n      }\n    }\n    /**\n     * @param {Module} module the checked module\n     * @param {Chunk} chunk the checked chunk\n     * @returns {boolean} true, if the chunk contains the module\n     */\n\n  }, {\n    key: \"isModuleInChunk\",\n    value: function isModuleInChunk(module, chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      return cgc.modules.has(module);\n    }\n    /**\n     * @param {Module} module the checked module\n     * @param {ChunkGroup} chunkGroup the checked chunk group\n     * @returns {boolean} true, if the chunk contains the module\n     */\n\n  }, {\n    key: \"isModuleInChunkGroup\",\n    value: function isModuleInChunkGroup(module, chunkGroup) {\n      var _iterator21 = _createForOfIteratorHelper(chunkGroup.chunks),\n          _step21;\n\n      try {\n        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n          var chunk = _step21.value;\n          if (this.isModuleInChunk(module, chunk)) return true;\n        }\n      } catch (err) {\n        _iterator21.e(err);\n      } finally {\n        _iterator21.f();\n      }\n\n      return false;\n    }\n    /**\n     * @param {Module} module the checked module\n     * @returns {boolean} true, if the module is entry of any chunk\n     */\n\n  }, {\n    key: \"isEntryModule\",\n    value: function isEntryModule(module) {\n      var cgm = this._getChunkGraphModule(module);\n\n      return cgm.entryInChunks !== undefined;\n    }\n    /**\n     * @param {Module} module the module\n     * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n     */\n\n  }, {\n    key: \"getModuleChunksIterable\",\n    value: function getModuleChunksIterable(module) {\n      var cgm = this._getChunkGraphModule(module);\n\n      return cgm.chunks;\n    }\n    /**\n     * @param {Module} module the module\n     * @param {function(Chunk, Chunk): -1|0|1} sortFn sort function\n     * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n     */\n\n  }, {\n    key: \"getOrderedModuleChunksIterable\",\n    value: function getOrderedModuleChunksIterable(module, sortFn) {\n      var cgm = this._getChunkGraphModule(module);\n\n      cgm.chunks.sortWith(sortFn);\n      return cgm.chunks;\n    }\n    /**\n     * @param {Module} module the module\n     * @returns {Chunk[]} array of chunks (cached, do not modify)\n     */\n\n  }, {\n    key: \"getModuleChunks\",\n    value: function getModuleChunks(module) {\n      var cgm = this._getChunkGraphModule(module);\n\n      return cgm.chunks.getFromCache(getArray);\n    }\n    /**\n     * @param {Module} module the module\n     * @returns {number} the number of chunk which contain the module\n     */\n\n  }, {\n    key: \"getNumberOfModuleChunks\",\n    value: function getNumberOfModuleChunks(module) {\n      var cgm = this._getChunkGraphModule(module);\n\n      return cgm.chunks.size;\n    }\n    /**\n     * @param {Module} module the module\n     * @returns {RuntimeSpecSet} runtimes\n     */\n\n  }, {\n    key: \"getModuleRuntimes\",\n    value: function getModuleRuntimes(module) {\n      var cgm = this._getChunkGraphModule(module);\n\n      return cgm.chunks.getFromUnorderedCache(_getModuleRuntimes);\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {number} the number of modules which are contained in this chunk\n     */\n\n  }, {\n    key: \"getNumberOfChunkModules\",\n    value: function getNumberOfChunkModules(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      return cgc.modules.size;\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {number} the number of full hash modules which are contained in this chunk\n     */\n\n  }, {\n    key: \"getNumberOfChunkFullHashModules\",\n    value: function getNumberOfChunkFullHashModules(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      return cgc.fullHashModules === undefined ? 0 : cgc.fullHashModules.size;\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {Iterable<Module>} return the modules for this chunk\n     */\n\n  }, {\n    key: \"getChunkModulesIterable\",\n    value: function getChunkModulesIterable(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      return cgc.modules;\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {string} sourceType source type\n     * @returns {Iterable<Module> | undefined} return the modules for this chunk\n     */\n\n  }, {\n    key: \"getChunkModulesIterableBySourceType\",\n    value: function getChunkModulesIterableBySourceType(chunk, sourceType) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      var modulesWithSourceType = cgc.modules.getFromUnorderedCache(modulesBySourceType).get(sourceType);\n      return modulesWithSourceType;\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {function(Module, Module): -1|0|1} comparator comparator function\n     * @returns {Iterable<Module>} return the modules for this chunk\n     */\n\n  }, {\n    key: \"getOrderedChunkModulesIterable\",\n    value: function getOrderedChunkModulesIterable(chunk, comparator) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      cgc.modules.sortWith(comparator);\n      return cgc.modules;\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {string} sourceType source type\n     * @param {function(Module, Module): -1|0|1} comparator comparator function\n     * @returns {Iterable<Module> | undefined} return the modules for this chunk\n     */\n\n  }, {\n    key: \"getOrderedChunkModulesIterableBySourceType\",\n    value: function getOrderedChunkModulesIterableBySourceType(chunk, sourceType, comparator) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      var modulesWithSourceType = cgc.modules.getFromUnorderedCache(modulesBySourceType).get(sourceType);\n      if (modulesWithSourceType === undefined) return undefined;\n      modulesWithSourceType.sortWith(comparator);\n      return modulesWithSourceType;\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n     */\n\n  }, {\n    key: \"getChunkModules\",\n    value: function getChunkModules(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      return cgc.modules.getFromUnorderedCache(getArray);\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {function(Module, Module): -1|0|1} comparator comparator function\n     * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n     */\n\n  }, {\n    key: \"getOrderedChunkModules\",\n    value: function getOrderedChunkModules(chunk, comparator) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      var arrayFunction = createOrderedArrayFunction(comparator);\n      return cgc.modules.getFromUnorderedCache(arrayFunction);\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {ModuleFilterPredicate} filterFn function used to filter modules\n     * @param {boolean} includeAllChunks all chunks or only async chunks\n     * @returns {Record<string|number, (string|number)[]>} chunk to module ids object\n     */\n\n  }, {\n    key: \"getChunkModuleIdMap\",\n    value: function getChunkModuleIdMap(chunk, filterFn) {\n      var includeAllChunks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      /** @type {Record<string|number, (string|number)[]>} */\n      var chunkModuleIdMap = Object.create(null);\n\n      var _iterator22 = _createForOfIteratorHelper(includeAllChunks ? chunk.getAllReferencedChunks() : chunk.getAllAsyncChunks()),\n          _step22;\n\n      try {\n        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n          var asyncChunk = _step22.value;\n\n          /** @type {(string|number)[]} */\n          var array = void 0;\n\n          var _iterator23 = _createForOfIteratorHelper(this.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(this))),\n              _step23;\n\n          try {\n            for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n              var _module9 = _step23.value;\n\n              if (filterFn(_module9)) {\n                if (array === undefined) {\n                  array = [];\n                  chunkModuleIdMap[asyncChunk.id] = array;\n                }\n\n                var moduleId = this.getModuleId(_module9);\n                array.push(moduleId);\n              }\n            }\n          } catch (err) {\n            _iterator23.e(err);\n          } finally {\n            _iterator23.f();\n          }\n        }\n      } catch (err) {\n        _iterator22.e(err);\n      } finally {\n        _iterator22.f();\n      }\n\n      return chunkModuleIdMap;\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {ModuleFilterPredicate} filterFn function used to filter modules\n     * @param {number} hashLength length of the hash\n     * @param {boolean} includeAllChunks all chunks or only async chunks\n     * @returns {Record<string|number, Record<string|number, string>>} chunk to module id to module hash object\n     */\n\n  }, {\n    key: \"getChunkModuleRenderedHashMap\",\n    value: function getChunkModuleRenderedHashMap(chunk, filterFn) {\n      var hashLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var includeAllChunks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      /** @type {Record<string|number, Record<string|number, string>>} */\n      var chunkModuleHashMap = Object.create(null);\n\n      var _iterator24 = _createForOfIteratorHelper(includeAllChunks ? chunk.getAllReferencedChunks() : chunk.getAllAsyncChunks()),\n          _step24;\n\n      try {\n        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n          var asyncChunk = _step24.value;\n\n          /** @type {Record<string|number, string>} */\n          var idToHashMap = void 0;\n\n          var _iterator25 = _createForOfIteratorHelper(this.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(this))),\n              _step25;\n\n          try {\n            for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n              var _module10 = _step25.value;\n\n              if (filterFn(_module10)) {\n                if (idToHashMap === undefined) {\n                  idToHashMap = Object.create(null);\n                  chunkModuleHashMap[asyncChunk.id] = idToHashMap;\n                }\n\n                var moduleId = this.getModuleId(_module10);\n                var hash = this.getRenderedModuleHash(_module10, asyncChunk.runtime);\n                idToHashMap[moduleId] = hashLength ? hash.slice(0, hashLength) : hash;\n              }\n            }\n          } catch (err) {\n            _iterator25.e(err);\n          } finally {\n            _iterator25.f();\n          }\n        }\n      } catch (err) {\n        _iterator24.e(err);\n      } finally {\n        _iterator24.f();\n      }\n\n      return chunkModuleHashMap;\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {ChunkFilterPredicate} filterFn function used to filter chunks\n     * @returns {Record<string|number, boolean>} chunk map\n     */\n\n  }, {\n    key: \"getChunkConditionMap\",\n    value: function getChunkConditionMap(chunk, filterFn) {\n      var map = Object.create(null);\n\n      var _iterator26 = _createForOfIteratorHelper(chunk.getAllReferencedChunks()),\n          _step26;\n\n      try {\n        for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n          var c = _step26.value;\n          map[c.id] = filterFn(c, this);\n        }\n      } catch (err) {\n        _iterator26.e(err);\n      } finally {\n        _iterator26.f();\n      }\n\n      return map;\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\n     * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\n     * @returns {boolean} return true if module exists in graph\n     */\n\n  }, {\n    key: \"hasModuleInGraph\",\n    value: function hasModuleInGraph(chunk, filterFn, filterChunkFn) {\n      var queue = new Set(chunk.groupsIterable);\n      var chunksProcessed = new Set();\n\n      var _iterator27 = _createForOfIteratorHelper(queue),\n          _step27;\n\n      try {\n        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n          var chunkGroup = _step27.value;\n\n          var _iterator28 = _createForOfIteratorHelper(chunkGroup.chunks),\n              _step28;\n\n          try {\n            for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n              var innerChunk = _step28.value;\n\n              if (!chunksProcessed.has(innerChunk)) {\n                chunksProcessed.add(innerChunk);\n\n                if (!filterChunkFn || filterChunkFn(innerChunk, this)) {\n                  var _iterator30 = _createForOfIteratorHelper(this.getChunkModulesIterable(innerChunk)),\n                      _step30;\n\n                  try {\n                    for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n                      var _module11 = _step30.value;\n\n                      if (filterFn(_module11)) {\n                        return true;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator30.e(err);\n                  } finally {\n                    _iterator30.f();\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _iterator28.e(err);\n          } finally {\n            _iterator28.f();\n          }\n\n          var _iterator29 = _createForOfIteratorHelper(chunkGroup.childrenIterable),\n              _step29;\n\n          try {\n            for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n              var child = _step29.value;\n              queue.add(child);\n            }\n          } catch (err) {\n            _iterator29.e(err);\n          } finally {\n            _iterator29.f();\n          }\n        }\n      } catch (err) {\n        _iterator27.e(err);\n      } finally {\n        _iterator27.f();\n      }\n\n      return false;\n    }\n    /**\n     * @param {Chunk} chunkA first chunk\n     * @param {Chunk} chunkB second chunk\n     * @returns {-1|0|1} this is a comparator function like sort and returns -1, 0, or 1 based on sort order\n     */\n\n  }, {\n    key: \"compareChunks\",\n    value: function compareChunks(chunkA, chunkB) {\n      var cgcA = this._getChunkGraphChunk(chunkA);\n\n      var cgcB = this._getChunkGraphChunk(chunkB);\n\n      if (cgcA.modules.size > cgcB.modules.size) return -1;\n      if (cgcA.modules.size < cgcB.modules.size) return 1;\n      cgcA.modules.sortWith(compareModulesByIdentifier);\n      cgcB.modules.sortWith(compareModulesByIdentifier);\n      return compareModuleIterables(cgcA.modules, cgcB.modules);\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {number} total size of all modules in the chunk\n     */\n\n  }, {\n    key: \"getChunkModulesSize\",\n    value: function getChunkModulesSize(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      return cgc.modules.getFromUnorderedCache(getModulesSize);\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {Record<string, number>} total sizes of all modules in the chunk by source type\n     */\n\n  }, {\n    key: \"getChunkModulesSizes\",\n    value: function getChunkModulesSizes(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      return cgc.modules.getFromUnorderedCache(getModulesSizes);\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {Module[]} root modules of the chunks (ordered by identifier)\n     */\n\n  }, {\n    key: \"getChunkRootModules\",\n    value: function getChunkRootModules(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      return cgc.modules.getFromUnorderedCache(this._getGraphRoots);\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {ChunkSizeOptions} options options object\n     * @returns {number} total size of the chunk\n     */\n\n  }, {\n    key: \"getChunkSize\",\n    value: function getChunkSize(chunk) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      var modulesSize = cgc.modules.getFromUnorderedCache(getModulesSize);\n      var chunkOverhead = typeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n      var entryChunkMultiplicator = typeof options.entryChunkMultiplicator === \"number\" ? options.entryChunkMultiplicator : 10;\n      return chunkOverhead + modulesSize * (chunk.canBeInitial() ? entryChunkMultiplicator : 1);\n    }\n    /**\n     * @param {Chunk} chunkA chunk\n     * @param {Chunk} chunkB chunk\n     * @param {ChunkSizeOptions} options options object\n     * @returns {number} total size of the chunk or false if chunks can't be integrated\n     */\n\n  }, {\n    key: \"getIntegratedChunksSize\",\n    value: function getIntegratedChunksSize(chunkA, chunkB) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var cgcA = this._getChunkGraphChunk(chunkA);\n\n      var cgcB = this._getChunkGraphChunk(chunkB);\n\n      var allModules = new Set(cgcA.modules);\n\n      var _iterator31 = _createForOfIteratorHelper(cgcB.modules),\n          _step31;\n\n      try {\n        for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n          var m = _step31.value;\n          allModules.add(m);\n        }\n      } catch (err) {\n        _iterator31.e(err);\n      } finally {\n        _iterator31.f();\n      }\n\n      var modulesSize = getModulesSize(allModules);\n      var chunkOverhead = typeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n      var entryChunkMultiplicator = typeof options.entryChunkMultiplicator === \"number\" ? options.entryChunkMultiplicator : 10;\n      return chunkOverhead + modulesSize * (chunkA.canBeInitial() || chunkB.canBeInitial() ? entryChunkMultiplicator : 1);\n    }\n    /**\n     * @param {Chunk} chunkA chunk\n     * @param {Chunk} chunkB chunk\n     * @returns {boolean} true, if chunks could be integrated\n     */\n\n  }, {\n    key: \"canChunksBeIntegrated\",\n    value: function canChunksBeIntegrated(chunkA, chunkB) {\n      if (chunkA.preventIntegration || chunkB.preventIntegration) {\n        return false;\n      }\n\n      var hasRuntimeA = chunkA.hasRuntime();\n      var hasRuntimeB = chunkB.hasRuntime();\n\n      if (hasRuntimeA !== hasRuntimeB) {\n        if (hasRuntimeA) {\n          return isAvailableChunk(chunkA, chunkB);\n        } else if (hasRuntimeB) {\n          return isAvailableChunk(chunkB, chunkA);\n        } else {\n          return false;\n        }\n      }\n\n      if (this.getNumberOfEntryModules(chunkA) > 0 || this.getNumberOfEntryModules(chunkB) > 0) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * @param {Chunk} chunkA the target chunk\n     * @param {Chunk} chunkB the chunk to integrate\n     * @returns {void}\n     */\n\n  }, {\n    key: \"integrateChunks\",\n    value: function integrateChunks(chunkA, chunkB) {\n      // Decide for one name (deterministic)\n      if (chunkA.name && chunkB.name) {\n        if (this.getNumberOfEntryModules(chunkA) > 0 === this.getNumberOfEntryModules(chunkB) > 0) {\n          // When both chunks have entry modules or none have one, use\n          // shortest name\n          if (chunkA.name.length !== chunkB.name.length) {\n            chunkA.name = chunkA.name.length < chunkB.name.length ? chunkA.name : chunkB.name;\n          } else {\n            chunkA.name = chunkA.name < chunkB.name ? chunkA.name : chunkB.name;\n          }\n        } else if (this.getNumberOfEntryModules(chunkB) > 0) {\n          // Pick the name of the chunk with the entry module\n          chunkA.name = chunkB.name;\n        }\n      } else if (chunkB.name) {\n        chunkA.name = chunkB.name;\n      } // Merge id name hints\n\n\n      var _iterator32 = _createForOfIteratorHelper(chunkB.idNameHints),\n          _step32;\n\n      try {\n        for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n          var hint = _step32.value;\n          chunkA.idNameHints.add(hint);\n        } // Merge runtime\n\n      } catch (err) {\n        _iterator32.e(err);\n      } finally {\n        _iterator32.f();\n      }\n\n      chunkA.runtime = mergeRuntime(chunkA.runtime, chunkB.runtime); // getChunkModules is used here to create a clone, because disconnectChunkAndModule modifies\n\n      var _iterator33 = _createForOfIteratorHelper(this.getChunkModules(chunkB)),\n          _step33;\n\n      try {\n        for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n          var _module13 = _step33.value;\n          this.disconnectChunkAndModule(chunkB, _module13);\n          this.connectChunkAndModule(chunkA, _module13);\n        }\n      } catch (err) {\n        _iterator33.e(err);\n      } finally {\n        _iterator33.f();\n      }\n\n      for (var _i = 0, _Array$from = Array.from(this.getChunkEntryModulesWithChunkGroupIterable(chunkB)); _i < _Array$from.length; _i++) {\n        var _Array$from$_i = _slicedToArray(_Array$from[_i], 2),\n            _module12 = _Array$from$_i[0],\n            chunkGroup = _Array$from$_i[1];\n\n        this.disconnectChunkAndEntryModule(chunkB, _module12);\n        this.connectChunkAndEntryModule(chunkA, _module12, chunkGroup);\n      }\n\n      var _iterator34 = _createForOfIteratorHelper(chunkB.groupsIterable),\n          _step34;\n\n      try {\n        for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n          var _chunkGroup = _step34.value;\n\n          _chunkGroup.replaceChunk(chunkB, chunkA);\n\n          chunkA.addGroup(_chunkGroup);\n          chunkB.removeGroup(_chunkGroup);\n        }\n      } catch (err) {\n        _iterator34.e(err);\n      } finally {\n        _iterator34.f();\n      }\n\n      ChunkGraph.clearChunkGraphForChunk(chunkB);\n    }\n    /**\n     * @param {Chunk} chunk the chunk to upgrade\n     * @returns {void}\n     */\n\n  }, {\n    key: \"upgradeDependentToFullHashModules\",\n    value: function upgradeDependentToFullHashModules(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      if (cgc.dependentHashModules === undefined) return;\n\n      if (cgc.fullHashModules === undefined) {\n        cgc.fullHashModules = cgc.dependentHashModules;\n      } else {\n        var _iterator35 = _createForOfIteratorHelper(cgc.dependentHashModules),\n            _step35;\n\n        try {\n          for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {\n            var m = _step35.value;\n            cgc.fullHashModules.add(m);\n          }\n        } catch (err) {\n          _iterator35.e(err);\n        } finally {\n          _iterator35.f();\n        }\n\n        cgc.dependentHashModules = undefined;\n      }\n    }\n    /**\n     * @param {Module} module the checked module\n     * @param {Chunk} chunk the checked chunk\n     * @returns {boolean} true, if the chunk contains the module as entry\n     */\n\n  }, {\n    key: \"isEntryModuleInChunk\",\n    value: function isEntryModuleInChunk(module, chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      return cgc.entryModules.has(module);\n    }\n    /**\n     * @param {Chunk} chunk the new chunk\n     * @param {Module} module the entry module\n     * @param {Entrypoint=} entrypoint the chunk group which must be loaded before the module is executed\n     * @returns {void}\n     */\n\n  }, {\n    key: \"connectChunkAndEntryModule\",\n    value: function connectChunkAndEntryModule(chunk, module, entrypoint) {\n      var cgm = this._getChunkGraphModule(module);\n\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      if (cgm.entryInChunks === undefined) {\n        cgm.entryInChunks = new Set();\n      }\n\n      cgm.entryInChunks.add(chunk);\n      cgc.entryModules.set(module, entrypoint);\n    }\n    /**\n     * @param {Chunk} chunk the new chunk\n     * @param {RuntimeModule} module the runtime module\n     * @returns {void}\n     */\n\n  }, {\n    key: \"connectChunkAndRuntimeModule\",\n    value: function connectChunkAndRuntimeModule(chunk, module) {\n      var cgm = this._getChunkGraphModule(module);\n\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      if (cgm.runtimeInChunks === undefined) {\n        cgm.runtimeInChunks = new Set();\n      }\n\n      cgm.runtimeInChunks.add(chunk);\n      cgc.runtimeModules.add(module);\n    }\n    /**\n     * @param {Chunk} chunk the new chunk\n     * @param {RuntimeModule} module the module that require a full hash\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addFullHashModuleToChunk\",\n    value: function addFullHashModuleToChunk(chunk, module) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      if (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n      cgc.fullHashModules.add(module);\n    }\n    /**\n     * @param {Chunk} chunk the new chunk\n     * @param {RuntimeModule} module the module that require a full hash\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addDependentHashModuleToChunk\",\n    value: function addDependentHashModuleToChunk(chunk, module) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      if (cgc.dependentHashModules === undefined) cgc.dependentHashModules = new Set();\n      cgc.dependentHashModules.add(module);\n    }\n    /**\n     * @param {Chunk} chunk the new chunk\n     * @param {Module} module the entry module\n     * @returns {void}\n     */\n\n  }, {\n    key: \"disconnectChunkAndEntryModule\",\n    value: function disconnectChunkAndEntryModule(chunk, module) {\n      var cgm = this._getChunkGraphModule(module);\n\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      cgm.entryInChunks.delete(chunk);\n\n      if (cgm.entryInChunks.size === 0) {\n        cgm.entryInChunks = undefined;\n      }\n\n      cgc.entryModules.delete(module);\n    }\n    /**\n     * @param {Chunk} chunk the new chunk\n     * @param {RuntimeModule} module the runtime module\n     * @returns {void}\n     */\n\n  }, {\n    key: \"disconnectChunkAndRuntimeModule\",\n    value: function disconnectChunkAndRuntimeModule(chunk, module) {\n      var cgm = this._getChunkGraphModule(module);\n\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      cgm.runtimeInChunks.delete(chunk);\n\n      if (cgm.runtimeInChunks.size === 0) {\n        cgm.runtimeInChunks = undefined;\n      }\n\n      cgc.runtimeModules.delete(module);\n    }\n    /**\n     * @param {Module} module the entry module, it will no longer be entry\n     * @returns {void}\n     */\n\n  }, {\n    key: \"disconnectEntryModule\",\n    value: function disconnectEntryModule(module) {\n      var cgm = this._getChunkGraphModule(module);\n\n      var _iterator36 = _createForOfIteratorHelper(cgm.entryInChunks),\n          _step36;\n\n      try {\n        for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {\n          var chunk = _step36.value;\n\n          var cgc = this._getChunkGraphChunk(chunk);\n\n          cgc.entryModules.delete(module);\n        }\n      } catch (err) {\n        _iterator36.e(err);\n      } finally {\n        _iterator36.f();\n      }\n\n      cgm.entryInChunks = undefined;\n    }\n    /**\n     * @param {Chunk} chunk the chunk, for which all entries will be removed\n     * @returns {void}\n     */\n\n  }, {\n    key: \"disconnectEntries\",\n    value: function disconnectEntries(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      var _iterator37 = _createForOfIteratorHelper(cgc.entryModules.keys()),\n          _step37;\n\n      try {\n        for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {\n          var _module14 = _step37.value;\n\n          var cgm = this._getChunkGraphModule(_module14);\n\n          cgm.entryInChunks.delete(chunk);\n\n          if (cgm.entryInChunks.size === 0) {\n            cgm.entryInChunks = undefined;\n          }\n        }\n      } catch (err) {\n        _iterator37.e(err);\n      } finally {\n        _iterator37.f();\n      }\n\n      cgc.entryModules.clear();\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {number} the amount of entry modules in chunk\n     */\n\n  }, {\n    key: \"getNumberOfEntryModules\",\n    value: function getNumberOfEntryModules(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      return cgc.entryModules.size;\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {number} the amount of entry modules in chunk\n     */\n\n  }, {\n    key: \"getNumberOfRuntimeModules\",\n    value: function getNumberOfRuntimeModules(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      return cgc.runtimeModules.size;\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {Iterable<Module>} iterable of modules (do not modify)\n     */\n\n  }, {\n    key: \"getChunkEntryModulesIterable\",\n    value: function getChunkEntryModulesIterable(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      return cgc.entryModules.keys();\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {Iterable<Chunk>} iterable of chunks\n     */\n\n  }, {\n    key: \"getChunkEntryDependentChunksIterable\",\n    value: function getChunkEntryDependentChunksIterable(chunk) {\n      /** @type {Set<Chunk>} */\n      var set = new Set();\n\n      var _iterator38 = _createForOfIteratorHelper(chunk.groupsIterable),\n          _step38;\n\n      try {\n        for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {\n          var chunkGroup = _step38.value;\n\n          if (chunkGroup instanceof Entrypoint) {\n            var entrypointChunk = chunkGroup.getEntrypointChunk();\n\n            var cgc = this._getChunkGraphChunk(entrypointChunk);\n\n            var _iterator39 = _createForOfIteratorHelper(cgc.entryModules.values()),\n                _step39;\n\n            try {\n              for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {\n                var _chunkGroup2 = _step39.value;\n\n                var _iterator40 = _createForOfIteratorHelper(_chunkGroup2.chunks),\n                    _step40;\n\n                try {\n                  for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {\n                    var c = _step40.value;\n\n                    if (c !== chunk && c !== entrypointChunk && !c.hasRuntime()) {\n                      set.add(c);\n                    }\n                  }\n                } catch (err) {\n                  _iterator40.e(err);\n                } finally {\n                  _iterator40.f();\n                }\n              }\n            } catch (err) {\n              _iterator39.e(err);\n            } finally {\n              _iterator39.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator38.e(err);\n      } finally {\n        _iterator38.f();\n      }\n\n      return set;\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {boolean} true, when it has dependent chunks\n     */\n\n  }, {\n    key: \"hasChunkEntryDependentChunks\",\n    value: function hasChunkEntryDependentChunks(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      var _iterator41 = _createForOfIteratorHelper(cgc.entryModules.values()),\n          _step41;\n\n      try {\n        for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {\n          var chunkGroup = _step41.value;\n\n          var _iterator42 = _createForOfIteratorHelper(chunkGroup.chunks),\n              _step42;\n\n          try {\n            for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {\n              var c = _step42.value;\n\n              if (c !== chunk) {\n                return true;\n              }\n            }\n          } catch (err) {\n            _iterator42.e(err);\n          } finally {\n            _iterator42.f();\n          }\n        }\n      } catch (err) {\n        _iterator41.e(err);\n      } finally {\n        _iterator41.f();\n      }\n\n      return false;\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {Iterable<RuntimeModule>} iterable of modules (do not modify)\n     */\n\n  }, {\n    key: \"getChunkRuntimeModulesIterable\",\n    value: function getChunkRuntimeModulesIterable(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      return cgc.runtimeModules;\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {RuntimeModule[]} array of modules in order of execution\n     */\n\n  }, {\n    key: \"getChunkRuntimeModulesInOrder\",\n    value: function getChunkRuntimeModulesInOrder(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      var array = Array.from(cgc.runtimeModules);\n      array.sort(concatComparators(compareSelect(\n      /**\n       * @param {RuntimeModule} r runtime module\n       * @returns {number=} stage\n       */\n      function (r) {\n        return r.stage;\n      }, compareIds), compareModulesByIdentifier));\n      return array;\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n     */\n\n  }, {\n    key: \"getChunkFullHashModulesIterable\",\n    value: function getChunkFullHashModulesIterable(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      return cgc.fullHashModules;\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {ReadonlySet<RuntimeModule> | undefined} set of modules (do not modify)\n     */\n\n  }, {\n    key: \"getChunkFullHashModulesSet\",\n    value: function getChunkFullHashModulesSet(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      return cgc.fullHashModules;\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n     */\n\n  }, {\n    key: \"getChunkDependentHashModulesIterable\",\n    value: function getChunkDependentHashModulesIterable(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      return cgc.dependentHashModules;\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {Iterable<EntryModuleWithChunkGroup>} iterable of modules (do not modify)\n     */\n\n  }, {\n    key: \"getChunkEntryModulesWithChunkGroupIterable\",\n    value: function getChunkEntryModulesWithChunkGroupIterable(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      return cgc.entryModules;\n    }\n    /**\n     * @param {AsyncDependenciesBlock} depBlock the async block\n     * @returns {ChunkGroup} the chunk group\n     */\n\n  }, {\n    key: \"getBlockChunkGroup\",\n    value: function getBlockChunkGroup(depBlock) {\n      return this._blockChunkGroups.get(depBlock);\n    }\n    /**\n     * @param {AsyncDependenciesBlock} depBlock the async block\n     * @param {ChunkGroup} chunkGroup the chunk group\n     * @returns {void}\n     */\n\n  }, {\n    key: \"connectBlockAndChunkGroup\",\n    value: function connectBlockAndChunkGroup(depBlock, chunkGroup) {\n      this._blockChunkGroups.set(depBlock, chunkGroup);\n\n      chunkGroup.addBlock(depBlock);\n    }\n    /**\n     * @param {ChunkGroup} chunkGroup the chunk group\n     * @returns {void}\n     */\n\n  }, {\n    key: \"disconnectChunkGroup\",\n    value: function disconnectChunkGroup(chunkGroup) {\n      var _iterator43 = _createForOfIteratorHelper(chunkGroup.blocksIterable),\n          _step43;\n\n      try {\n        for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {\n          var block = _step43.value;\n\n          this._blockChunkGroups.delete(block);\n        } // TODO refactor by moving blocks list into ChunkGraph\n\n      } catch (err) {\n        _iterator43.e(err);\n      } finally {\n        _iterator43.f();\n      }\n\n      chunkGroup._blocks.clear();\n    }\n    /**\n     * @param {Module} module the module\n     * @returns {string | number} the id of the module\n     */\n\n  }, {\n    key: \"getModuleId\",\n    value: function getModuleId(module) {\n      var cgm = this._getChunkGraphModule(module);\n\n      return cgm.id;\n    }\n    /**\n     * @param {Module} module the module\n     * @param {string | number} id the id of the module\n     * @returns {void}\n     */\n\n  }, {\n    key: \"setModuleId\",\n    value: function setModuleId(module, id) {\n      var cgm = this._getChunkGraphModule(module);\n\n      cgm.id = id;\n    }\n    /**\n     * @param {string} runtime runtime\n     * @returns {string | number} the id of the runtime\n     */\n\n  }, {\n    key: \"getRuntimeId\",\n    value: function getRuntimeId(runtime) {\n      return this._runtimeIds.get(runtime);\n    }\n    /**\n     * @param {string} runtime runtime\n     * @param {string | number} id the id of the runtime\n     * @returns {void}\n     */\n\n  }, {\n    key: \"setRuntimeId\",\n    value: function setRuntimeId(runtime, id) {\n      this._runtimeIds.set(runtime, id);\n    }\n    /**\n     * @template T\n     * @param {Module} module the module\n     * @param {RuntimeSpecMap<T>} hashes hashes data\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {T} hash\n     */\n\n  }, {\n    key: \"_getModuleHashInfo\",\n    value: function _getModuleHashInfo(module, hashes, runtime) {\n      if (!hashes) {\n        throw new Error(\"Module \".concat(module.identifier(), \" has no hash info for runtime \").concat(runtimeToString(runtime), \" (hashes not set at all)\"));\n      } else if (runtime === undefined) {\n        var hashInfoItems = new Set(hashes.values());\n\n        if (hashInfoItems.size !== 1) {\n          throw new Error(\"No unique hash info entry for unspecified runtime for \".concat(module.identifier(), \" (existing runtimes: \").concat(Array.from(hashes.keys(), function (r) {\n            return runtimeToString(r);\n          }).join(\", \"), \").\\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \\\"global\\\").\"));\n        }\n\n        return first(hashInfoItems);\n      } else {\n        var hashInfo = hashes.get(runtime);\n\n        if (!hashInfo) {\n          throw new Error(\"Module \".concat(module.identifier(), \" has no hash info for runtime \").concat(runtimeToString(runtime), \" (available runtimes \").concat(Array.from(hashes.keys(), runtimeToString).join(\", \"), \")\"));\n        }\n\n        return hashInfo;\n      }\n    }\n    /**\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {boolean} true, if the module has hashes for this runtime\n     */\n\n  }, {\n    key: \"hasModuleHashes\",\n    value: function hasModuleHashes(module, runtime) {\n      var cgm = this._getChunkGraphModule(module);\n\n      var hashes = cgm.hashes;\n      return hashes && hashes.has(runtime);\n    }\n    /**\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {string} hash\n     */\n\n  }, {\n    key: \"getModuleHash\",\n    value: function getModuleHash(module, runtime) {\n      var cgm = this._getChunkGraphModule(module);\n\n      var hashes = cgm.hashes;\n      return this._getModuleHashInfo(module, hashes, runtime).hash;\n    }\n    /**\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {string} hash\n     */\n\n  }, {\n    key: \"getRenderedModuleHash\",\n    value: function getRenderedModuleHash(module, runtime) {\n      var cgm = this._getChunkGraphModule(module);\n\n      var hashes = cgm.hashes;\n      return this._getModuleHashInfo(module, hashes, runtime).renderedHash;\n    }\n    /**\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime the runtime\n     * @param {string} hash the full hash\n     * @param {string} renderedHash the shortened hash for rendering\n     * @returns {void}\n     */\n\n  }, {\n    key: \"setModuleHashes\",\n    value: function setModuleHashes(module, runtime, hash, renderedHash) {\n      var cgm = this._getChunkGraphModule(module);\n\n      if (cgm.hashes === undefined) {\n        cgm.hashes = new RuntimeSpecMap();\n      }\n\n      cgm.hashes.set(runtime, new ModuleHashInfo(hash, renderedHash));\n    }\n    /**\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime the runtime\n     * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph when transferOwnership not false)\n     * @param {boolean} transferOwnership true: transfer ownership of the items object, false: items is immutable and shared and won't be modified\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addModuleRuntimeRequirements\",\n    value: function addModuleRuntimeRequirements(module, runtime, items) {\n      var transferOwnership = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n      var cgm = this._getChunkGraphModule(module);\n\n      var runtimeRequirementsMap = cgm.runtimeRequirements;\n\n      if (runtimeRequirementsMap === undefined) {\n        var map = new RuntimeSpecMap(); // TODO avoid cloning item and track ownership instead\n\n        map.set(runtime, transferOwnership ? items : new Set(items));\n        cgm.runtimeRequirements = map;\n        return;\n      }\n\n      runtimeRequirementsMap.update(runtime, function (runtimeRequirements) {\n        if (runtimeRequirements === undefined) {\n          return transferOwnership ? items : new Set(items);\n        } else if (!transferOwnership || runtimeRequirements.size >= items.size) {\n          var _iterator44 = _createForOfIteratorHelper(items),\n              _step44;\n\n          try {\n            for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {\n              var item = _step44.value;\n              runtimeRequirements.add(item);\n            }\n          } catch (err) {\n            _iterator44.e(err);\n          } finally {\n            _iterator44.f();\n          }\n\n          return runtimeRequirements;\n        } else {\n          var _iterator45 = _createForOfIteratorHelper(runtimeRequirements),\n              _step45;\n\n          try {\n            for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {\n              var _item = _step45.value;\n              items.add(_item);\n            }\n          } catch (err) {\n            _iterator45.e(err);\n          } finally {\n            _iterator45.f();\n          }\n\n          return items;\n        }\n      });\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph)\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addChunkRuntimeRequirements\",\n    value: function addChunkRuntimeRequirements(chunk, items) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      var runtimeRequirements = cgc.runtimeRequirements;\n\n      if (runtimeRequirements === undefined) {\n        cgc.runtimeRequirements = items;\n      } else if (runtimeRequirements.size >= items.size) {\n        var _iterator46 = _createForOfIteratorHelper(items),\n            _step46;\n\n        try {\n          for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {\n            var item = _step46.value;\n            runtimeRequirements.add(item);\n          }\n        } catch (err) {\n          _iterator46.e(err);\n        } finally {\n          _iterator46.f();\n        }\n      } else {\n        var _iterator47 = _createForOfIteratorHelper(runtimeRequirements),\n            _step47;\n\n        try {\n          for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {\n            var _item2 = _step47.value;\n            items.add(_item2);\n          }\n        } catch (err) {\n          _iterator47.e(err);\n        } finally {\n          _iterator47.f();\n        }\n\n        cgc.runtimeRequirements = items;\n      }\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {Iterable<string>} items runtime requirements to be added\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addTreeRuntimeRequirements\",\n    value: function addTreeRuntimeRequirements(chunk, items) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      var runtimeRequirements = cgc.runtimeRequirementsInTree;\n\n      var _iterator48 = _createForOfIteratorHelper(items),\n          _step48;\n\n      try {\n        for (_iterator48.s(); !(_step48 = _iterator48.n()).done;) {\n          var item = _step48.value;\n          runtimeRequirements.add(item);\n        }\n      } catch (err) {\n        _iterator48.e(err);\n      } finally {\n        _iterator48.f();\n      }\n    }\n    /**\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {ReadonlySet<string>} runtime requirements\n     */\n\n  }, {\n    key: \"getModuleRuntimeRequirements\",\n    value: function getModuleRuntimeRequirements(module, runtime) {\n      var cgm = this._getChunkGraphModule(module);\n\n      var runtimeRequirements = cgm.runtimeRequirements && cgm.runtimeRequirements.get(runtime);\n      return runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {ReadonlySet<string>} runtime requirements\n     */\n\n  }, {\n    key: \"getChunkRuntimeRequirements\",\n    value: function getChunkRuntimeRequirements(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      var runtimeRequirements = cgc.runtimeRequirements;\n      return runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n    }\n    /**\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime the runtime\n     * @param {boolean} withConnections include connections\n     * @returns {string} hash\n     */\n\n  }, {\n    key: \"getModuleGraphHash\",\n    value: function getModuleGraphHash(module, runtime) {\n      var withConnections = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      var cgm = this._getChunkGraphModule(module);\n\n      return withConnections ? this._getModuleGraphHashWithConnections(cgm, module, runtime) : this._getModuleGraphHashBigInt(cgm, module, runtime).toString(16);\n    }\n    /**\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime the runtime\n     * @param {boolean} withConnections include connections\n     * @returns {bigint} hash\n     */\n\n  }, {\n    key: \"getModuleGraphHashBigInt\",\n    value: function getModuleGraphHashBigInt(module, runtime) {\n      var withConnections = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      var cgm = this._getChunkGraphModule(module);\n\n      return withConnections ? BigInt(\"0x\".concat(this._getModuleGraphHashWithConnections(cgm, module, runtime))) : this._getModuleGraphHashBigInt(cgm, module, runtime);\n    }\n    /**\n     * @param {ChunkGraphModule} cgm the ChunkGraphModule\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {bigint} hash as big int\n     */\n\n  }, {\n    key: \"_getModuleGraphHashBigInt\",\n    value: function _getModuleGraphHashBigInt(cgm, module, runtime) {\n      var _this = this;\n\n      if (cgm.graphHashes === undefined) {\n        cgm.graphHashes = new RuntimeSpecMap();\n      }\n\n      var graphHash = cgm.graphHashes.provide(runtime, function () {\n        var hash = createHash(_this._hashFunction);\n        hash.update(\"\".concat(cgm.id).concat(_this.moduleGraph.isAsync(module)));\n\n        _this.moduleGraph.getExportsInfo(module).updateHash(hash, runtime);\n\n        return BigInt(\"0x\".concat(\n        /** @type {string} */\n        hash.digest(\"hex\")));\n      });\n      return graphHash;\n    }\n    /**\n     * @param {ChunkGraphModule} cgm the ChunkGraphModule\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {string} hash\n     */\n\n  }, {\n    key: \"_getModuleGraphHashWithConnections\",\n    value: function _getModuleGraphHashWithConnections(cgm, module, runtime) {\n      var _this2 = this;\n\n      if (cgm.graphHashesWithConnections === undefined) {\n        cgm.graphHashesWithConnections = new RuntimeSpecMap();\n      }\n\n      var activeStateToString = function activeStateToString(state) {\n        if (state === false) return \"F\";\n        if (state === true) return \"T\";\n        if (state === ModuleGraphConnection.TRANSITIVE_ONLY) return \"O\";\n        throw new Error(\"Not implemented active state\");\n      };\n\n      var strict = module.buildMeta && module.buildMeta.strictHarmonyModule;\n      return cgm.graphHashesWithConnections.provide(runtime, function () {\n        var graphHash = _this2._getModuleGraphHashBigInt(cgm, module, runtime).toString(16);\n\n        var connections = _this2.moduleGraph.getOutgoingConnections(module);\n        /** @type {Set<Module>} */\n\n\n        var activeNamespaceModules = new Set();\n        /** @type {Map<string, Module | Set<Module>>} */\n\n        var connectedModules = new Map();\n\n        var processConnection = function processConnection(connection, stateInfo) {\n          var module = connection.module;\n          stateInfo += module.getExportsType(_this2.moduleGraph, strict); // cspell:word Tnamespace\n\n          if (stateInfo === \"Tnamespace\") activeNamespaceModules.add(module);else {\n            var oldModule = connectedModules.get(stateInfo);\n\n            if (oldModule === undefined) {\n              connectedModules.set(stateInfo, module);\n            } else if (oldModule instanceof Set) {\n              oldModule.add(module);\n            } else if (oldModule !== module) {\n              connectedModules.set(stateInfo, new Set([oldModule, module]));\n            }\n          }\n        };\n\n        if (runtime === undefined || typeof runtime === \"string\") {\n          var _iterator49 = _createForOfIteratorHelper(connections),\n              _step49;\n\n          try {\n            for (_iterator49.s(); !(_step49 = _iterator49.n()).done;) {\n              var connection = _step49.value;\n              var state = connection.getActiveState(runtime);\n              if (state === false) continue;\n              processConnection(connection, state === true ? \"T\" : \"O\");\n            }\n          } catch (err) {\n            _iterator49.e(err);\n          } finally {\n            _iterator49.f();\n          }\n        } else {\n          // cspell:word Tnamespace\n          var _iterator50 = _createForOfIteratorHelper(connections),\n              _step50;\n\n          try {\n            var _loop = function _loop() {\n              var connection = _step50.value;\n              var states = new Set();\n              var stateInfo = \"\";\n              forEachRuntime(runtime, function (runtime) {\n                var state = connection.getActiveState(runtime);\n                states.add(state);\n                stateInfo += activeStateToString(state) + runtime;\n              }, true);\n\n              if (states.size === 1) {\n                var _state = first(states);\n\n                if (_state === false) return \"continue\";\n                stateInfo = activeStateToString(_state);\n              }\n\n              processConnection(connection, stateInfo);\n            };\n\n            for (_iterator50.s(); !(_step50 = _iterator50.n()).done;) {\n              var _ret = _loop();\n\n              if (_ret === \"continue\") continue;\n            }\n          } catch (err) {\n            _iterator50.e(err);\n          } finally {\n            _iterator50.f();\n          }\n        } // cspell:word Tnamespace\n\n\n        if (activeNamespaceModules.size === 0 && connectedModules.size === 0) return graphHash;\n        var connectedModulesInOrder = connectedModules.size > 1 ? Array.from(connectedModules).sort(function (_ref, _ref2) {\n          var _ref3 = _slicedToArray(_ref, 1),\n              a = _ref3[0];\n\n          var _ref4 = _slicedToArray(_ref2, 1),\n              b = _ref4[0];\n\n          return a < b ? -1 : 1;\n        }) : connectedModules;\n        var hash = createHash(_this2._hashFunction);\n\n        var addModuleToHash = function addModuleToHash(module) {\n          hash.update(_this2._getModuleGraphHashBigInt(_this2._getChunkGraphModule(module), module, runtime).toString(16));\n        };\n\n        var addModulesToHash = function addModulesToHash(modules) {\n          var xor = ZERO_BIG_INT;\n\n          var _iterator51 = _createForOfIteratorHelper(modules),\n              _step51;\n\n          try {\n            for (_iterator51.s(); !(_step51 = _iterator51.n()).done;) {\n              var m = _step51.value;\n              xor = xor ^ _this2._getModuleGraphHashBigInt(_this2._getChunkGraphModule(m), m, runtime);\n            }\n          } catch (err) {\n            _iterator51.e(err);\n          } finally {\n            _iterator51.f();\n          }\n\n          hash.update(xor.toString(16));\n        };\n\n        if (activeNamespaceModules.size === 1) addModuleToHash(activeNamespaceModules.values().next().value);else if (activeNamespaceModules.size > 1) addModulesToHash(activeNamespaceModules);\n\n        var _iterator52 = _createForOfIteratorHelper(connectedModulesInOrder),\n            _step52;\n\n        try {\n          for (_iterator52.s(); !(_step52 = _iterator52.n()).done;) {\n            var _step52$value = _slicedToArray(_step52.value, 2),\n                stateInfo = _step52$value[0],\n                modules = _step52$value[1];\n\n            hash.update(stateInfo);\n\n            if (modules instanceof Set) {\n              addModulesToHash(modules);\n            } else {\n              addModuleToHash(modules);\n            }\n          }\n        } catch (err) {\n          _iterator52.e(err);\n        } finally {\n          _iterator52.f();\n        }\n\n        hash.update(graphHash);\n        return (\n          /** @type {string} */\n          hash.digest(\"hex\")\n        );\n      });\n    }\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {ReadonlySet<string>} runtime requirements\n     */\n\n  }, {\n    key: \"getTreeRuntimeRequirements\",\n    value: function getTreeRuntimeRequirements(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n\n      return cgc.runtimeRequirementsInTree;\n    } // TODO remove in webpack 6\n\n    /**\n     * @param {Module} module the module\n     * @param {string} deprecateMessage message for the deprecation message\n     * @param {string} deprecationCode code for the deprecation\n     * @returns {ChunkGraph} the chunk graph\n     */\n\n  }], [{\n    key: \"getChunkGraphForModule\",\n    value: function getChunkGraphForModule(module, deprecateMessage, deprecationCode) {\n      var fn = deprecateGetChunkGraphForModuleMap.get(deprecateMessage);\n      if (fn) return fn(module);\n      var newFn = util.deprecate(\n      /**\n       * @param {Module} module the module\n       * @returns {ChunkGraph} the chunk graph\n       */\n      function (module) {\n        var chunkGraph = chunkGraphForModuleMap.get(module);\n        if (!chunkGraph) throw new Error(deprecateMessage + \": There was no ChunkGraph assigned to the Module for backward-compat (Use the new API)\");\n        return chunkGraph;\n      }, deprecateMessage + \": Use new ChunkGraph API\", deprecationCode);\n      deprecateGetChunkGraphForModuleMap.set(deprecateMessage, newFn);\n      return newFn(module);\n    } // TODO remove in webpack 6\n\n    /**\n     * @param {Module} module the module\n     * @param {ChunkGraph} chunkGraph the chunk graph\n     * @returns {void}\n     */\n\n  }, {\n    key: \"setChunkGraphForModule\",\n    value: function setChunkGraphForModule(module, chunkGraph) {\n      chunkGraphForModuleMap.set(module, chunkGraph);\n    } // TODO remove in webpack 6\n\n    /**\n     * @param {Module} module the module\n     * @returns {void}\n     */\n\n  }, {\n    key: \"clearChunkGraphForModule\",\n    value: function clearChunkGraphForModule(module) {\n      chunkGraphForModuleMap.delete(module);\n    } // TODO remove in webpack 6\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {string} deprecateMessage message for the deprecation message\n     * @param {string} deprecationCode code for the deprecation\n     * @returns {ChunkGraph} the chunk graph\n     */\n\n  }, {\n    key: \"getChunkGraphForChunk\",\n    value: function getChunkGraphForChunk(chunk, deprecateMessage, deprecationCode) {\n      var fn = deprecateGetChunkGraphForChunkMap.get(deprecateMessage);\n      if (fn) return fn(chunk);\n      var newFn = util.deprecate(\n      /**\n       * @param {Chunk} chunk the chunk\n       * @returns {ChunkGraph} the chunk graph\n       */\n      function (chunk) {\n        var chunkGraph = chunkGraphForChunkMap.get(chunk);\n        if (!chunkGraph) throw new Error(deprecateMessage + \"There was no ChunkGraph assigned to the Chunk for backward-compat (Use the new API)\");\n        return chunkGraph;\n      }, deprecateMessage + \": Use new ChunkGraph API\", deprecationCode);\n      deprecateGetChunkGraphForChunkMap.set(deprecateMessage, newFn);\n      return newFn(chunk);\n    } // TODO remove in webpack 6\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {ChunkGraph} chunkGraph the chunk graph\n     * @returns {void}\n     */\n\n  }, {\n    key: \"setChunkGraphForChunk\",\n    value: function setChunkGraphForChunk(chunk, chunkGraph) {\n      chunkGraphForChunkMap.set(chunk, chunkGraph);\n    } // TODO remove in webpack 6\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {void}\n     */\n\n  }, {\n    key: \"clearChunkGraphForChunk\",\n    value: function clearChunkGraphForChunk(chunk) {\n      chunkGraphForChunkMap.delete(chunk);\n    }\n  }]);\n\n  return ChunkGraph;\n}(); // TODO remove in webpack 6\n\n/** @type {WeakMap<Module, ChunkGraph>} */\n\n\nvar chunkGraphForModuleMap = new WeakMap(); // TODO remove in webpack 6\n\n/** @type {WeakMap<Chunk, ChunkGraph>} */\n\nvar chunkGraphForChunkMap = new WeakMap(); // TODO remove in webpack 6\n\n/** @type {Map<string, (module: Module) => ChunkGraph>} */\n\nvar deprecateGetChunkGraphForModuleMap = new Map(); // TODO remove in webpack 6\n\n/** @type {Map<string, (chunk: Chunk) => ChunkGraph>} */\n\nvar deprecateGetChunkGraphForChunkMap = new Map();\nmodule.exports = ChunkGraph;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/ChunkGraph.js"],"names":["util","require","Entrypoint","ModuleGraphConnection","first","SortableSet","compareModulesById","compareIterables","compareModulesByIdentifier","concatComparators","compareSelect","compareIds","createHash","findGraphRoots","RuntimeSpecMap","RuntimeSpecSet","runtimeToString","mergeRuntime","forEachRuntime","EMPTY_SET","Set","ZERO_BIG_INT","BigInt","compareModuleIterables","ModuleHashInfo","hash","renderedHash","getArray","set","Array","from","getModuleRuntimes","chunks","runtimes","chunk","add","runtime","modulesBySourceType","map","Map","module","getSourceTypes","sourceType","innerSet","get","undefined","key","size","createOrderedArrayFunctionMap","WeakMap","createOrderedArrayFunction","comparator","fn","sortWith","getModulesSize","modules","type","getModulesSizes","sizes","Object","create","isAvailableChunk","a","b","queue","groupsIterable","chunkGroup","isInGroup","isInitial","parentsIterable","parent","ChunkGraphModule","entryInChunks","runtimeInChunks","hashes","id","runtimeRequirements","graphHashes","graphHashesWithConnections","ChunkGraphChunk","entryModules","runtimeModules","fullHashModules","dependentHashModules","runtimeRequirementsInTree","ChunkGraph","moduleGraph","hashFunction","_modules","_chunks","_blockChunkGroups","_runtimeIds","_hashFunction","_getGraphRoots","bind","cgm","cgc","addDependencies","getOutgoingConnections","connection","activeState","getActiveState","TRANSITIVE_ONLY","sort","_getChunkGraphModule","_getChunkGraphChunk","delete","clear","disconnectFromGroups","clearChunkGraphForChunk","oldModule","newModule","oldCgm","newCgm","old","newEntryModules","m","cg","has","isModuleInChunk","sortFn","getFromCache","getFromUnorderedCache","modulesWithSourceType","arrayFunction","filterFn","includeAllChunks","chunkModuleIdMap","getAllReferencedChunks","getAllAsyncChunks","asyncChunk","array","getOrderedChunkModulesIterable","moduleId","getModuleId","push","hashLength","chunkModuleHashMap","idToHashMap","getRenderedModuleHash","slice","c","filterChunkFn","chunksProcessed","innerChunk","getChunkModulesIterable","childrenIterable","child","chunkA","chunkB","cgcA","cgcB","options","modulesSize","chunkOverhead","entryChunkMultiplicator","canBeInitial","allModules","preventIntegration","hasRuntimeA","hasRuntime","hasRuntimeB","getNumberOfEntryModules","name","length","idNameHints","hint","getChunkModules","disconnectChunkAndModule","connectChunkAndModule","getChunkEntryModulesWithChunkGroupIterable","disconnectChunkAndEntryModule","connectChunkAndEntryModule","replaceChunk","addGroup","removeGroup","entrypoint","keys","entrypointChunk","getEntrypointChunk","values","r","stage","depBlock","addBlock","blocksIterable","block","_blocks","Error","identifier","hashInfoItems","join","hashInfo","_getModuleHashInfo","items","transferOwnership","runtimeRequirementsMap","update","item","withConnections","_getModuleGraphHashWithConnections","_getModuleGraphHashBigInt","toString","graphHash","provide","isAsync","getExportsInfo","updateHash","digest","activeStateToString","state","strict","buildMeta","strictHarmonyModule","connections","activeNamespaceModules","connectedModules","processConnection","stateInfo","getExportsType","states","connectedModulesInOrder","addModuleToHash","addModulesToHash","xor","next","value","deprecateMessage","deprecationCode","deprecateGetChunkGraphForModuleMap","newFn","deprecate","chunkGraph","chunkGraphForModuleMap","deprecateGetChunkGraphForChunkMap","chunkGraphForChunkMap","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst util = require(\"util\");\nconst Entrypoint = require(\"./Entrypoint\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst { first } = require(\"./util/SetHelpers\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst {\n\tcompareModulesById,\n\tcompareIterables,\n\tcompareModulesByIdentifier,\n\tconcatComparators,\n\tcompareSelect,\n\tcompareIds\n} = require(\"./util/comparators\");\nconst createHash = require(\"./util/createHash\");\nconst findGraphRoots = require(\"./util/findGraphRoots\");\nconst {\n\tRuntimeSpecMap,\n\tRuntimeSpecSet,\n\truntimeToString,\n\tmergeRuntime,\n\tforEachRuntime\n} = require(\"./util/runtime\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./RuntimeModule\")} RuntimeModule */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @type {ReadonlySet<string>} */\nconst EMPTY_SET = new Set();\n\nconst ZERO_BIG_INT = BigInt(0);\n\nconst compareModuleIterables = compareIterables(compareModulesByIdentifier);\n\n/** @typedef {(c: Chunk, chunkGraph: ChunkGraph) => boolean} ChunkFilterPredicate */\n/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */\n/** @typedef {[Module, Entrypoint | undefined]} EntryModuleWithChunkGroup */\n\n/**\n * @typedef {Object} ChunkSizeOptions\n * @property {number=} chunkOverhead constant overhead for a chunk\n * @property {number=} entryChunkMultiplicator multiplicator for initial chunks\n */\n\nclass ModuleHashInfo {\n\tconstructor(hash, renderedHash) {\n\t\tthis.hash = hash;\n\t\tthis.renderedHash = renderedHash;\n\t}\n}\n\n/** @template T @typedef {(set: SortableSet<T>) => T[]} SetToArrayFunction<T> */\n\n/**\n * @template T\n * @param {SortableSet<T>} set the set\n * @returns {T[]} set as array\n */\nconst getArray = set => {\n\treturn Array.from(set);\n};\n\n/**\n * @param {SortableSet<Chunk>} chunks the chunks\n * @returns {RuntimeSpecSet} runtimes\n */\nconst getModuleRuntimes = chunks => {\n\tconst runtimes = new RuntimeSpecSet();\n\tfor (const chunk of chunks) {\n\t\truntimes.add(chunk.runtime);\n\t}\n\treturn runtimes;\n};\n\n/**\n * @param {SortableSet<Module>} set the set\n * @returns {Map<string, SortableSet<Module>>} modules by source type\n */\nconst modulesBySourceType = set => {\n\t/** @type {Map<string, SortableSet<Module>>} */\n\tconst map = new Map();\n\tfor (const module of set) {\n\t\tfor (const sourceType of module.getSourceTypes()) {\n\t\t\tlet innerSet = map.get(sourceType);\n\t\t\tif (innerSet === undefined) {\n\t\t\t\tinnerSet = new SortableSet();\n\t\t\t\tmap.set(sourceType, innerSet);\n\t\t\t}\n\t\t\tinnerSet.add(module);\n\t\t}\n\t}\n\tfor (const [key, innerSet] of map) {\n\t\t// When all modules have the source type, we reuse the original SortableSet\n\t\t// to benefit from the shared cache (especially for sorting)\n\t\tif (innerSet.size === set.size) {\n\t\t\tmap.set(key, set);\n\t\t}\n\t}\n\treturn map;\n};\n\n/** @type {WeakMap<Function, any>} */\nconst createOrderedArrayFunctionMap = new WeakMap();\n\n/**\n * @template T\n * @param {function(T, T): -1|0|1} comparator comparator function\n * @returns {SetToArrayFunction<T>} set as ordered array\n */\nconst createOrderedArrayFunction = comparator => {\n\t/** @type {SetToArrayFunction<T>} */\n\tlet fn = createOrderedArrayFunctionMap.get(comparator);\n\tif (fn !== undefined) return fn;\n\tfn = set => {\n\t\tset.sortWith(comparator);\n\t\treturn Array.from(set);\n\t};\n\tcreateOrderedArrayFunctionMap.set(comparator, fn);\n\treturn fn;\n};\n\n/**\n * @param {Iterable<Module>} modules the modules to get the count/size of\n * @returns {number} the size of the modules\n */\nconst getModulesSize = modules => {\n\tlet size = 0;\n\tfor (const module of modules) {\n\t\tfor (const type of module.getSourceTypes()) {\n\t\t\tsize += module.size(type);\n\t\t}\n\t}\n\treturn size;\n};\n\n/**\n * @param {Iterable<Module>} modules the sortable Set to get the size of\n * @returns {Record<string, number>} the sizes of the modules\n */\nconst getModulesSizes = modules => {\n\tlet sizes = Object.create(null);\n\tfor (const module of modules) {\n\t\tfor (const type of module.getSourceTypes()) {\n\t\t\tsizes[type] = (sizes[type] || 0) + module.size(type);\n\t\t}\n\t}\n\treturn sizes;\n};\n\n/**\n * @param {Chunk} a chunk\n * @param {Chunk} b chunk\n * @returns {boolean} true, if a is always a parent of b\n */\nconst isAvailableChunk = (a, b) => {\n\tconst queue = new Set(b.groupsIterable);\n\tfor (const chunkGroup of queue) {\n\t\tif (a.isInGroup(chunkGroup)) continue;\n\t\tif (chunkGroup.isInitial()) return false;\n\t\tfor (const parent of chunkGroup.parentsIterable) {\n\t\t\tqueue.add(parent);\n\t\t}\n\t}\n\treturn true;\n};\n\nclass ChunkGraphModule {\n\tconstructor() {\n\t\t/** @type {SortableSet<Chunk>} */\n\t\tthis.chunks = new SortableSet();\n\t\t/** @type {Set<Chunk> | undefined} */\n\t\tthis.entryInChunks = undefined;\n\t\t/** @type {Set<Chunk> | undefined} */\n\t\tthis.runtimeInChunks = undefined;\n\t\t/** @type {RuntimeSpecMap<ModuleHashInfo>} */\n\t\tthis.hashes = undefined;\n\t\t/** @type {string | number} */\n\t\tthis.id = null;\n\t\t/** @type {RuntimeSpecMap<Set<string>> | undefined} */\n\t\tthis.runtimeRequirements = undefined;\n\t\t/** @type {RuntimeSpecMap<string>} */\n\t\tthis.graphHashes = undefined;\n\t\t/** @type {RuntimeSpecMap<string>} */\n\t\tthis.graphHashesWithConnections = undefined;\n\t}\n}\n\nclass ChunkGraphChunk {\n\tconstructor() {\n\t\t/** @type {SortableSet<Module>} */\n\t\tthis.modules = new SortableSet();\n\t\t/** @type {Map<Module, Entrypoint>} */\n\t\tthis.entryModules = new Map();\n\t\t/** @type {SortableSet<RuntimeModule>} */\n\t\tthis.runtimeModules = new SortableSet();\n\t\t/** @type {Set<RuntimeModule> | undefined} */\n\t\tthis.fullHashModules = undefined;\n\t\t/** @type {Set<RuntimeModule> | undefined} */\n\t\tthis.dependentHashModules = undefined;\n\t\t/** @type {Set<string> | undefined} */\n\t\tthis.runtimeRequirements = undefined;\n\t\t/** @type {Set<string>} */\n\t\tthis.runtimeRequirementsInTree = new Set();\n\t}\n}\n\nclass ChunkGraph {\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {string | Hash} hashFunction the hash function to use\n\t */\n\tconstructor(moduleGraph, hashFunction = \"md4\") {\n\t\t/** @private @type {WeakMap<Module, ChunkGraphModule>} */\n\t\tthis._modules = new WeakMap();\n\t\t/** @private @type {WeakMap<Chunk, ChunkGraphChunk>} */\n\t\tthis._chunks = new WeakMap();\n\t\t/** @private @type {WeakMap<AsyncDependenciesBlock, ChunkGroup>} */\n\t\tthis._blockChunkGroups = new WeakMap();\n\t\t/** @private @type {Map<string, string | number>} */\n\t\tthis._runtimeIds = new Map();\n\t\t/** @type {ModuleGraph} */\n\t\tthis.moduleGraph = moduleGraph;\n\n\t\tthis._hashFunction = hashFunction;\n\n\t\tthis._getGraphRoots = this._getGraphRoots.bind(this);\n\t}\n\n\t/**\n\t * @private\n\t * @param {Module} module the module\n\t * @returns {ChunkGraphModule} internal module\n\t */\n\t_getChunkGraphModule(module) {\n\t\tlet cgm = this._modules.get(module);\n\t\tif (cgm === undefined) {\n\t\t\tcgm = new ChunkGraphModule();\n\t\t\tthis._modules.set(module, cgm);\n\t\t}\n\t\treturn cgm;\n\t}\n\n\t/**\n\t * @private\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ChunkGraphChunk} internal chunk\n\t */\n\t_getChunkGraphChunk(chunk) {\n\t\tlet cgc = this._chunks.get(chunk);\n\t\tif (cgc === undefined) {\n\t\t\tcgc = new ChunkGraphChunk();\n\t\t\tthis._chunks.set(chunk, cgc);\n\t\t}\n\t\treturn cgc;\n\t}\n\n\t/**\n\t * @param {SortableSet<Module>} set the sortable Set to get the roots of\n\t * @returns {Module[]} the graph roots\n\t */\n\t_getGraphRoots(set) {\n\t\tconst { moduleGraph } = this;\n\t\treturn Array.from(\n\t\t\tfindGraphRoots(set, module => {\n\t\t\t\t/** @type {Set<Module>} */\n\t\t\t\tconst set = new Set();\n\t\t\t\tconst addDependencies = module => {\n\t\t\t\t\tfor (const connection of moduleGraph.getOutgoingConnections(module)) {\n\t\t\t\t\t\tif (!connection.module) continue;\n\t\t\t\t\t\tconst activeState = connection.getActiveState(undefined);\n\t\t\t\t\t\tif (activeState === false) continue;\n\t\t\t\t\t\tif (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\n\t\t\t\t\t\t\taddDependencies(connection.module);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tset.add(connection.module);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\taddDependencies(module);\n\t\t\t\treturn set;\n\t\t\t})\n\t\t).sort(compareModulesByIdentifier);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tconnectChunkAndModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgm.chunks.add(chunk);\n\t\tcgc.modules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tdisconnectChunkAndModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgc.modules.delete(module);\n\t\tcgm.chunks.delete(chunk);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk which will be disconnected\n\t * @returns {void}\n\t */\n\tdisconnectChunk(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of cgc.modules) {\n\t\t\tconst cgm = this._getChunkGraphModule(module);\n\t\t\tcgm.chunks.delete(chunk);\n\t\t}\n\t\tcgc.modules.clear();\n\t\tchunk.disconnectFromGroups();\n\t\tChunkGraph.clearChunkGraphForChunk(chunk);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<Module>} modules the modules\n\t * @returns {void}\n\t */\n\tattachModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of modules) {\n\t\t\tcgc.modules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<RuntimeModule>} modules the runtime modules\n\t * @returns {void}\n\t */\n\tattachRuntimeModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of modules) {\n\t\t\tcgc.runtimeModules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n\t * @returns {void}\n\t */\n\tattachFullHashModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n\t\tfor (const module of modules) {\n\t\t\tcgc.fullHashModules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n\t * @returns {void}\n\t */\n\tattachDependentHashModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.dependentHashModules === undefined)\n\t\t\tcgc.dependentHashModules = new Set();\n\t\tfor (const module of modules) {\n\t\t\tcgc.dependentHashModules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} oldModule the replaced module\n\t * @param {Module} newModule the replacing module\n\t * @returns {void}\n\t */\n\treplaceModule(oldModule, newModule) {\n\t\tconst oldCgm = this._getChunkGraphModule(oldModule);\n\t\tconst newCgm = this._getChunkGraphModule(newModule);\n\n\t\tfor (const chunk of oldCgm.chunks) {\n\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\tcgc.modules.delete(oldModule);\n\t\t\tcgc.modules.add(newModule);\n\t\t\tnewCgm.chunks.add(chunk);\n\t\t}\n\t\toldCgm.chunks.clear();\n\n\t\tif (oldCgm.entryInChunks !== undefined) {\n\t\t\tif (newCgm.entryInChunks === undefined) {\n\t\t\t\tnewCgm.entryInChunks = new Set();\n\t\t\t}\n\t\t\tfor (const chunk of oldCgm.entryInChunks) {\n\t\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\t\tconst old = cgc.entryModules.get(oldModule);\n\t\t\t\t/** @type {Map<Module, Entrypoint>} */\n\t\t\t\tconst newEntryModules = new Map();\n\t\t\t\tfor (const [m, cg] of cgc.entryModules) {\n\t\t\t\t\tif (m === oldModule) {\n\t\t\t\t\t\tnewEntryModules.set(newModule, old);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewEntryModules.set(m, cg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcgc.entryModules = newEntryModules;\n\t\t\t\tnewCgm.entryInChunks.add(chunk);\n\t\t\t}\n\t\t\toldCgm.entryInChunks = undefined;\n\t\t}\n\n\t\tif (oldCgm.runtimeInChunks !== undefined) {\n\t\t\tif (newCgm.runtimeInChunks === undefined) {\n\t\t\t\tnewCgm.runtimeInChunks = new Set();\n\t\t\t}\n\t\t\tfor (const chunk of oldCgm.runtimeInChunks) {\n\t\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\t\tcgc.runtimeModules.delete(/** @type {RuntimeModule} */ (oldModule));\n\t\t\t\tcgc.runtimeModules.add(/** @type {RuntimeModule} */ (newModule));\n\t\t\t\tnewCgm.runtimeInChunks.add(chunk);\n\t\t\t\tif (\n\t\t\t\t\tcgc.fullHashModules !== undefined &&\n\t\t\t\t\tcgc.fullHashModules.has(/** @type {RuntimeModule} */ (oldModule))\n\t\t\t\t) {\n\t\t\t\t\tcgc.fullHashModules.delete(/** @type {RuntimeModule} */ (oldModule));\n\t\t\t\t\tcgc.fullHashModules.add(/** @type {RuntimeModule} */ (newModule));\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tcgc.dependentHashModules !== undefined &&\n\t\t\t\t\tcgc.dependentHashModules.has(/** @type {RuntimeModule} */ (oldModule))\n\t\t\t\t) {\n\t\t\t\t\tcgc.dependentHashModules.delete(\n\t\t\t\t\t\t/** @type {RuntimeModule} */ (oldModule)\n\t\t\t\t\t);\n\t\t\t\t\tcgc.dependentHashModules.add(\n\t\t\t\t\t\t/** @type {RuntimeModule} */ (newModule)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\toldCgm.runtimeInChunks = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @param {Chunk} chunk the checked chunk\n\t * @returns {boolean} true, if the chunk contains the module\n\t */\n\tisModuleInChunk(module, chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.has(module);\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @param {ChunkGroup} chunkGroup the checked chunk group\n\t * @returns {boolean} true, if the chunk contains the module\n\t */\n\tisModuleInChunkGroup(module, chunkGroup) {\n\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\tif (this.isModuleInChunk(module, chunk)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @returns {boolean} true, if the module is entry of any chunk\n\t */\n\tisEntryModule(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.entryInChunks !== undefined;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n\t */\n\tgetModuleChunksIterable(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {function(Chunk, Chunk): -1|0|1} sortFn sort function\n\t * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n\t */\n\tgetOrderedModuleChunksIterable(module, sortFn) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tcgm.chunks.sortWith(sortFn);\n\t\treturn cgm.chunks;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {Chunk[]} array of chunks (cached, do not modify)\n\t */\n\tgetModuleChunks(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks.getFromCache(getArray);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {number} the number of chunk which contain the module\n\t */\n\tgetNumberOfModuleChunks(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks.size;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {RuntimeSpecSet} runtimes\n\t */\n\tgetModuleRuntimes(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks.getFromUnorderedCache(getModuleRuntimes);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the number of modules which are contained in this chunk\n\t */\n\tgetNumberOfChunkModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the number of full hash modules which are contained in this chunk\n\t */\n\tgetNumberOfChunkFullHashModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.fullHashModules === undefined ? 0 : cgc.fullHashModules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<Module>} return the modules for this chunk\n\t */\n\tgetChunkModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {string} sourceType source type\n\t * @returns {Iterable<Module> | undefined} return the modules for this chunk\n\t */\n\tgetChunkModulesIterableBySourceType(chunk, sourceType) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst modulesWithSourceType = cgc.modules\n\t\t\t.getFromUnorderedCache(modulesBySourceType)\n\t\t\t.get(sourceType);\n\t\treturn modulesWithSourceType;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {function(Module, Module): -1|0|1} comparator comparator function\n\t * @returns {Iterable<Module>} return the modules for this chunk\n\t */\n\tgetOrderedChunkModulesIterable(chunk, comparator) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgc.modules.sortWith(comparator);\n\t\treturn cgc.modules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {string} sourceType source type\n\t * @param {function(Module, Module): -1|0|1} comparator comparator function\n\t * @returns {Iterable<Module> | undefined} return the modules for this chunk\n\t */\n\tgetOrderedChunkModulesIterableBySourceType(chunk, sourceType, comparator) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst modulesWithSourceType = cgc.modules\n\t\t\t.getFromUnorderedCache(modulesBySourceType)\n\t\t\t.get(sourceType);\n\t\tif (modulesWithSourceType === undefined) return undefined;\n\t\tmodulesWithSourceType.sortWith(comparator);\n\t\treturn modulesWithSourceType;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n\t */\n\tgetChunkModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(getArray);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {function(Module, Module): -1|0|1} comparator comparator function\n\t * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n\t */\n\tgetOrderedChunkModules(chunk, comparator) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst arrayFunction = createOrderedArrayFunction(comparator);\n\t\treturn cgc.modules.getFromUnorderedCache(arrayFunction);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\n\t * @param {boolean} includeAllChunks all chunks or only async chunks\n\t * @returns {Record<string|number, (string|number)[]>} chunk to module ids object\n\t */\n\tgetChunkModuleIdMap(chunk, filterFn, includeAllChunks = false) {\n\t\t/** @type {Record<string|number, (string|number)[]>} */\n\t\tconst chunkModuleIdMap = Object.create(null);\n\n\t\tfor (const asyncChunk of includeAllChunks\n\t\t\t? chunk.getAllReferencedChunks()\n\t\t\t: chunk.getAllAsyncChunks()) {\n\t\t\t/** @type {(string|number)[]} */\n\t\t\tlet array;\n\t\t\tfor (const module of this.getOrderedChunkModulesIterable(\n\t\t\t\tasyncChunk,\n\t\t\t\tcompareModulesById(this)\n\t\t\t)) {\n\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\tchunkModuleIdMap[asyncChunk.id] = array;\n\t\t\t\t\t}\n\t\t\t\t\tconst moduleId = this.getModuleId(module);\n\t\t\t\t\tarray.push(moduleId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chunkModuleIdMap;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\n\t * @param {number} hashLength length of the hash\n\t * @param {boolean} includeAllChunks all chunks or only async chunks\n\t * @returns {Record<string|number, Record<string|number, string>>} chunk to module id to module hash object\n\t */\n\tgetChunkModuleRenderedHashMap(\n\t\tchunk,\n\t\tfilterFn,\n\t\thashLength = 0,\n\t\tincludeAllChunks = false\n\t) {\n\t\t/** @type {Record<string|number, Record<string|number, string>>} */\n\t\tconst chunkModuleHashMap = Object.create(null);\n\n\t\tfor (const asyncChunk of includeAllChunks\n\t\t\t? chunk.getAllReferencedChunks()\n\t\t\t: chunk.getAllAsyncChunks()) {\n\t\t\t/** @type {Record<string|number, string>} */\n\t\t\tlet idToHashMap;\n\t\t\tfor (const module of this.getOrderedChunkModulesIterable(\n\t\t\t\tasyncChunk,\n\t\t\t\tcompareModulesById(this)\n\t\t\t)) {\n\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\tif (idToHashMap === undefined) {\n\t\t\t\t\t\tidToHashMap = Object.create(null);\n\t\t\t\t\t\tchunkModuleHashMap[asyncChunk.id] = idToHashMap;\n\t\t\t\t\t}\n\t\t\t\t\tconst moduleId = this.getModuleId(module);\n\t\t\t\t\tconst hash = this.getRenderedModuleHash(module, asyncChunk.runtime);\n\t\t\t\t\tidToHashMap[moduleId] = hashLength ? hash.slice(0, hashLength) : hash;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chunkModuleHashMap;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ChunkFilterPredicate} filterFn function used to filter chunks\n\t * @returns {Record<string|number, boolean>} chunk map\n\t */\n\tgetChunkConditionMap(chunk, filterFn) {\n\t\tconst map = Object.create(null);\n\t\tfor (const c of chunk.getAllReferencedChunks()) {\n\t\t\tmap[c.id] = filterFn(c, this);\n\t\t}\n\t\treturn map;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\n\t * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\n\t * @returns {boolean} return true if module exists in graph\n\t */\n\thasModuleInGraph(chunk, filterFn, filterChunkFn) {\n\t\tconst queue = new Set(chunk.groupsIterable);\n\t\tconst chunksProcessed = new Set();\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const innerChunk of chunkGroup.chunks) {\n\t\t\t\tif (!chunksProcessed.has(innerChunk)) {\n\t\t\t\t\tchunksProcessed.add(innerChunk);\n\t\t\t\t\tif (!filterChunkFn || filterChunkFn(innerChunk, this)) {\n\t\t\t\t\t\tfor (const module of this.getChunkModulesIterable(innerChunk)) {\n\t\t\t\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA first chunk\n\t * @param {Chunk} chunkB second chunk\n\t * @returns {-1|0|1} this is a comparator function like sort and returns -1, 0, or 1 based on sort order\n\t */\n\tcompareChunks(chunkA, chunkB) {\n\t\tconst cgcA = this._getChunkGraphChunk(chunkA);\n\t\tconst cgcB = this._getChunkGraphChunk(chunkB);\n\t\tif (cgcA.modules.size > cgcB.modules.size) return -1;\n\t\tif (cgcA.modules.size < cgcB.modules.size) return 1;\n\t\tcgcA.modules.sortWith(compareModulesByIdentifier);\n\t\tcgcB.modules.sortWith(compareModulesByIdentifier);\n\t\treturn compareModuleIterables(cgcA.modules, cgcB.modules);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} total size of all modules in the chunk\n\t */\n\tgetChunkModulesSize(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(getModulesSize);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Record<string, number>} total sizes of all modules in the chunk by source type\n\t */\n\tgetChunkModulesSizes(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(getModulesSizes);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Module[]} root modules of the chunks (ordered by identifier)\n\t */\n\tgetChunkRootModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(this._getGraphRoots);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ChunkSizeOptions} options options object\n\t * @returns {number} total size of the chunk\n\t */\n\tgetChunkSize(chunk, options = {}) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst modulesSize = cgc.modules.getFromUnorderedCache(getModulesSize);\n\t\tconst chunkOverhead =\n\t\t\ttypeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n\t\tconst entryChunkMultiplicator =\n\t\t\ttypeof options.entryChunkMultiplicator === \"number\"\n\t\t\t\t? options.entryChunkMultiplicator\n\t\t\t\t: 10;\n\t\treturn (\n\t\t\tchunkOverhead +\n\t\t\tmodulesSize * (chunk.canBeInitial() ? entryChunkMultiplicator : 1)\n\t\t);\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA chunk\n\t * @param {Chunk} chunkB chunk\n\t * @param {ChunkSizeOptions} options options object\n\t * @returns {number} total size of the chunk or false if chunks can't be integrated\n\t */\n\tgetIntegratedChunksSize(chunkA, chunkB, options = {}) {\n\t\tconst cgcA = this._getChunkGraphChunk(chunkA);\n\t\tconst cgcB = this._getChunkGraphChunk(chunkB);\n\t\tconst allModules = new Set(cgcA.modules);\n\t\tfor (const m of cgcB.modules) allModules.add(m);\n\t\tlet modulesSize = getModulesSize(allModules);\n\t\tconst chunkOverhead =\n\t\t\ttypeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n\t\tconst entryChunkMultiplicator =\n\t\t\ttypeof options.entryChunkMultiplicator === \"number\"\n\t\t\t\t? options.entryChunkMultiplicator\n\t\t\t\t: 10;\n\t\treturn (\n\t\t\tchunkOverhead +\n\t\t\tmodulesSize *\n\t\t\t\t(chunkA.canBeInitial() || chunkB.canBeInitial()\n\t\t\t\t\t? entryChunkMultiplicator\n\t\t\t\t\t: 1)\n\t\t);\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA chunk\n\t * @param {Chunk} chunkB chunk\n\t * @returns {boolean} true, if chunks could be integrated\n\t */\n\tcanChunksBeIntegrated(chunkA, chunkB) {\n\t\tif (chunkA.preventIntegration || chunkB.preventIntegration) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst hasRuntimeA = chunkA.hasRuntime();\n\t\tconst hasRuntimeB = chunkB.hasRuntime();\n\n\t\tif (hasRuntimeA !== hasRuntimeB) {\n\t\t\tif (hasRuntimeA) {\n\t\t\t\treturn isAvailableChunk(chunkA, chunkB);\n\t\t\t} else if (hasRuntimeB) {\n\t\t\t\treturn isAvailableChunk(chunkB, chunkA);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tthis.getNumberOfEntryModules(chunkA) > 0 ||\n\t\t\tthis.getNumberOfEntryModules(chunkB) > 0\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA the target chunk\n\t * @param {Chunk} chunkB the chunk to integrate\n\t * @returns {void}\n\t */\n\tintegrateChunks(chunkA, chunkB) {\n\t\t// Decide for one name (deterministic)\n\t\tif (chunkA.name && chunkB.name) {\n\t\t\tif (\n\t\t\t\tthis.getNumberOfEntryModules(chunkA) > 0 ===\n\t\t\t\tthis.getNumberOfEntryModules(chunkB) > 0\n\t\t\t) {\n\t\t\t\t// When both chunks have entry modules or none have one, use\n\t\t\t\t// shortest name\n\t\t\t\tif (chunkA.name.length !== chunkB.name.length) {\n\t\t\t\t\tchunkA.name =\n\t\t\t\t\t\tchunkA.name.length < chunkB.name.length ? chunkA.name : chunkB.name;\n\t\t\t\t} else {\n\t\t\t\t\tchunkA.name = chunkA.name < chunkB.name ? chunkA.name : chunkB.name;\n\t\t\t\t}\n\t\t\t} else if (this.getNumberOfEntryModules(chunkB) > 0) {\n\t\t\t\t// Pick the name of the chunk with the entry module\n\t\t\t\tchunkA.name = chunkB.name;\n\t\t\t}\n\t\t} else if (chunkB.name) {\n\t\t\tchunkA.name = chunkB.name;\n\t\t}\n\n\t\t// Merge id name hints\n\t\tfor (const hint of chunkB.idNameHints) {\n\t\t\tchunkA.idNameHints.add(hint);\n\t\t}\n\n\t\t// Merge runtime\n\t\tchunkA.runtime = mergeRuntime(chunkA.runtime, chunkB.runtime);\n\n\t\t// getChunkModules is used here to create a clone, because disconnectChunkAndModule modifies\n\t\tfor (const module of this.getChunkModules(chunkB)) {\n\t\t\tthis.disconnectChunkAndModule(chunkB, module);\n\t\t\tthis.connectChunkAndModule(chunkA, module);\n\t\t}\n\n\t\tfor (const [module, chunkGroup] of Array.from(\n\t\t\tthis.getChunkEntryModulesWithChunkGroupIterable(chunkB)\n\t\t)) {\n\t\t\tthis.disconnectChunkAndEntryModule(chunkB, module);\n\t\t\tthis.connectChunkAndEntryModule(chunkA, module, chunkGroup);\n\t\t}\n\n\t\tfor (const chunkGroup of chunkB.groupsIterable) {\n\t\t\tchunkGroup.replaceChunk(chunkB, chunkA);\n\t\t\tchunkA.addGroup(chunkGroup);\n\t\t\tchunkB.removeGroup(chunkGroup);\n\t\t}\n\t\tChunkGraph.clearChunkGraphForChunk(chunkB);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk to upgrade\n\t * @returns {void}\n\t */\n\tupgradeDependentToFullHashModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.dependentHashModules === undefined) return;\n\t\tif (cgc.fullHashModules === undefined) {\n\t\t\tcgc.fullHashModules = cgc.dependentHashModules;\n\t\t} else {\n\t\t\tfor (const m of cgc.dependentHashModules) {\n\t\t\t\tcgc.fullHashModules.add(m);\n\t\t\t}\n\t\t\tcgc.dependentHashModules = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @param {Chunk} chunk the checked chunk\n\t * @returns {boolean} true, if the chunk contains the module as entry\n\t */\n\tisEntryModuleInChunk(module, chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules.has(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {Module} module the entry module\n\t * @param {Entrypoint=} entrypoint the chunk group which must be loaded before the module is executed\n\t * @returns {void}\n\t */\n\tconnectChunkAndEntryModule(chunk, module, entrypoint) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgm.entryInChunks === undefined) {\n\t\t\tcgm.entryInChunks = new Set();\n\t\t}\n\t\tcgm.entryInChunks.add(chunk);\n\t\tcgc.entryModules.set(module, entrypoint);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the runtime module\n\t * @returns {void}\n\t */\n\tconnectChunkAndRuntimeModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgm.runtimeInChunks === undefined) {\n\t\t\tcgm.runtimeInChunks = new Set();\n\t\t}\n\t\tcgm.runtimeInChunks.add(chunk);\n\t\tcgc.runtimeModules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the module that require a full hash\n\t * @returns {void}\n\t */\n\taddFullHashModuleToChunk(chunk, module) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n\t\tcgc.fullHashModules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the module that require a full hash\n\t * @returns {void}\n\t */\n\taddDependentHashModuleToChunk(chunk, module) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.dependentHashModules === undefined)\n\t\t\tcgc.dependentHashModules = new Set();\n\t\tcgc.dependentHashModules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {Module} module the entry module\n\t * @returns {void}\n\t */\n\tdisconnectChunkAndEntryModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgm.entryInChunks.delete(chunk);\n\t\tif (cgm.entryInChunks.size === 0) {\n\t\t\tcgm.entryInChunks = undefined;\n\t\t}\n\t\tcgc.entryModules.delete(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the runtime module\n\t * @returns {void}\n\t */\n\tdisconnectChunkAndRuntimeModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgm.runtimeInChunks.delete(chunk);\n\t\tif (cgm.runtimeInChunks.size === 0) {\n\t\t\tcgm.runtimeInChunks = undefined;\n\t\t}\n\t\tcgc.runtimeModules.delete(module);\n\t}\n\n\t/**\n\t * @param {Module} module the entry module, it will no longer be entry\n\t * @returns {void}\n\t */\n\tdisconnectEntryModule(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tfor (const chunk of cgm.entryInChunks) {\n\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\tcgc.entryModules.delete(module);\n\t\t}\n\t\tcgm.entryInChunks = undefined;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk, for which all entries will be removed\n\t * @returns {void}\n\t */\n\tdisconnectEntries(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of cgc.entryModules.keys()) {\n\t\t\tconst cgm = this._getChunkGraphModule(module);\n\t\t\tcgm.entryInChunks.delete(chunk);\n\t\t\tif (cgm.entryInChunks.size === 0) {\n\t\t\t\tcgm.entryInChunks = undefined;\n\t\t\t}\n\t\t}\n\t\tcgc.entryModules.clear();\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the amount of entry modules in chunk\n\t */\n\tgetNumberOfEntryModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the amount of entry modules in chunk\n\t */\n\tgetNumberOfRuntimeModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.runtimeModules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<Module>} iterable of modules (do not modify)\n\t */\n\tgetChunkEntryModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules.keys();\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<Chunk>} iterable of chunks\n\t */\n\tgetChunkEntryDependentChunksIterable(chunk) {\n\t\t/** @type {Set<Chunk>} */\n\t\tconst set = new Set();\n\t\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\t\tif (chunkGroup instanceof Entrypoint) {\n\t\t\t\tconst entrypointChunk = chunkGroup.getEntrypointChunk();\n\t\t\t\tconst cgc = this._getChunkGraphChunk(entrypointChunk);\n\t\t\t\tfor (const chunkGroup of cgc.entryModules.values()) {\n\t\t\t\t\tfor (const c of chunkGroup.chunks) {\n\t\t\t\t\t\tif (c !== chunk && c !== entrypointChunk && !c.hasRuntime()) {\n\t\t\t\t\t\t\tset.add(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn set;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {boolean} true, when it has dependent chunks\n\t */\n\thasChunkEntryDependentChunks(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const chunkGroup of cgc.entryModules.values()) {\n\t\t\tfor (const c of chunkGroup.chunks) {\n\t\t\t\tif (c !== chunk) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<RuntimeModule>} iterable of modules (do not modify)\n\t */\n\tgetChunkRuntimeModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.runtimeModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {RuntimeModule[]} array of modules in order of execution\n\t */\n\tgetChunkRuntimeModulesInOrder(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst array = Array.from(cgc.runtimeModules);\n\t\tarray.sort(\n\t\t\tconcatComparators(\n\t\t\t\tcompareSelect(\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {RuntimeModule} r runtime module\n\t\t\t\t\t * @returns {number=} stage\n\t\t\t\t\t */\n\t\t\t\t\tr => r.stage,\n\t\t\t\t\tcompareIds\n\t\t\t\t),\n\t\t\t\tcompareModulesByIdentifier\n\t\t\t)\n\t\t);\n\t\treturn array;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n\t */\n\tgetChunkFullHashModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.fullHashModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ReadonlySet<RuntimeModule> | undefined} set of modules (do not modify)\n\t */\n\tgetChunkFullHashModulesSet(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.fullHashModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n\t */\n\tgetChunkDependentHashModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.dependentHashModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<EntryModuleWithChunkGroup>} iterable of modules (do not modify)\n\t */\n\tgetChunkEntryModulesWithChunkGroupIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules;\n\t}\n\n\t/**\n\t * @param {AsyncDependenciesBlock} depBlock the async block\n\t * @returns {ChunkGroup} the chunk group\n\t */\n\tgetBlockChunkGroup(depBlock) {\n\t\treturn this._blockChunkGroups.get(depBlock);\n\t}\n\n\t/**\n\t * @param {AsyncDependenciesBlock} depBlock the async block\n\t * @param {ChunkGroup} chunkGroup the chunk group\n\t * @returns {void}\n\t */\n\tconnectBlockAndChunkGroup(depBlock, chunkGroup) {\n\t\tthis._blockChunkGroups.set(depBlock, chunkGroup);\n\t\tchunkGroup.addBlock(depBlock);\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunk group\n\t * @returns {void}\n\t */\n\tdisconnectChunkGroup(chunkGroup) {\n\t\tfor (const block of chunkGroup.blocksIterable) {\n\t\t\tthis._blockChunkGroups.delete(block);\n\t\t}\n\t\t// TODO refactor by moving blocks list into ChunkGraph\n\t\tchunkGroup._blocks.clear();\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {string | number} the id of the module\n\t */\n\tgetModuleId(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.id;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {string | number} id the id of the module\n\t * @returns {void}\n\t */\n\tsetModuleId(module, id) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tcgm.id = id;\n\t}\n\n\t/**\n\t * @param {string} runtime runtime\n\t * @returns {string | number} the id of the runtime\n\t */\n\tgetRuntimeId(runtime) {\n\t\treturn this._runtimeIds.get(runtime);\n\t}\n\n\t/**\n\t * @param {string} runtime runtime\n\t * @param {string | number} id the id of the runtime\n\t * @returns {void}\n\t */\n\tsetRuntimeId(runtime, id) {\n\t\tthis._runtimeIds.set(runtime, id);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {Module} module the module\n\t * @param {RuntimeSpecMap<T>} hashes hashes data\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {T} hash\n\t */\n\t_getModuleHashInfo(module, hashes, runtime) {\n\t\tif (!hashes) {\n\t\t\tthrow new Error(\n\t\t\t\t`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(\n\t\t\t\t\truntime\n\t\t\t\t)} (hashes not set at all)`\n\t\t\t);\n\t\t} else if (runtime === undefined) {\n\t\t\tconst hashInfoItems = new Set(hashes.values());\n\t\t\tif (hashInfoItems.size !== 1) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`No unique hash info entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(\n\t\t\t\t\t\thashes.keys(),\n\t\t\t\t\t\tr => runtimeToString(r)\n\t\t\t\t\t).join(\", \")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \"global\").`\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn first(hashInfoItems);\n\t\t} else {\n\t\t\tconst hashInfo = hashes.get(runtime);\n\t\t\tif (!hashInfo) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(\n\t\t\t\t\t\truntime\n\t\t\t\t\t)} (available runtimes ${Array.from(\n\t\t\t\t\t\thashes.keys(),\n\t\t\t\t\t\truntimeToString\n\t\t\t\t\t).join(\", \")})`\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn hashInfo;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {boolean} true, if the module has hashes for this runtime\n\t */\n\thasModuleHashes(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst hashes = cgm.hashes;\n\t\treturn hashes && hashes.has(runtime);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {string} hash\n\t */\n\tgetModuleHash(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst hashes = cgm.hashes;\n\t\treturn this._getModuleHashInfo(module, hashes, runtime).hash;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {string} hash\n\t */\n\tgetRenderedModuleHash(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst hashes = cgm.hashes;\n\t\treturn this._getModuleHashInfo(module, hashes, runtime).renderedHash;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {string} hash the full hash\n\t * @param {string} renderedHash the shortened hash for rendering\n\t * @returns {void}\n\t */\n\tsetModuleHashes(module, runtime, hash, renderedHash) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tif (cgm.hashes === undefined) {\n\t\t\tcgm.hashes = new RuntimeSpecMap();\n\t\t}\n\t\tcgm.hashes.set(runtime, new ModuleHashInfo(hash, renderedHash));\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph when transferOwnership not false)\n\t * @param {boolean} transferOwnership true: transfer ownership of the items object, false: items is immutable and shared and won't be modified\n\t * @returns {void}\n\t */\n\taddModuleRuntimeRequirements(\n\t\tmodule,\n\t\truntime,\n\t\titems,\n\t\ttransferOwnership = true\n\t) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst runtimeRequirementsMap = cgm.runtimeRequirements;\n\t\tif (runtimeRequirementsMap === undefined) {\n\t\t\tconst map = new RuntimeSpecMap();\n\t\t\t// TODO avoid cloning item and track ownership instead\n\t\t\tmap.set(runtime, transferOwnership ? items : new Set(items));\n\t\t\tcgm.runtimeRequirements = map;\n\t\t\treturn;\n\t\t}\n\t\truntimeRequirementsMap.update(runtime, runtimeRequirements => {\n\t\t\tif (runtimeRequirements === undefined) {\n\t\t\t\treturn transferOwnership ? items : new Set(items);\n\t\t\t} else if (!transferOwnership || runtimeRequirements.size >= items.size) {\n\t\t\t\tfor (const item of items) runtimeRequirements.add(item);\n\t\t\t\treturn runtimeRequirements;\n\t\t\t} else {\n\t\t\t\tfor (const item of runtimeRequirements) items.add(item);\n\t\t\t\treturn items;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph)\n\t * @returns {void}\n\t */\n\taddChunkRuntimeRequirements(chunk, items) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst runtimeRequirements = cgc.runtimeRequirements;\n\t\tif (runtimeRequirements === undefined) {\n\t\t\tcgc.runtimeRequirements = items;\n\t\t} else if (runtimeRequirements.size >= items.size) {\n\t\t\tfor (const item of items) runtimeRequirements.add(item);\n\t\t} else {\n\t\t\tfor (const item of runtimeRequirements) items.add(item);\n\t\t\tcgc.runtimeRequirements = items;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<string>} items runtime requirements to be added\n\t * @returns {void}\n\t */\n\taddTreeRuntimeRequirements(chunk, items) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst runtimeRequirements = cgc.runtimeRequirementsInTree;\n\t\tfor (const item of items) runtimeRequirements.add(item);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetModuleRuntimeRequirements(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst runtimeRequirements =\n\t\t\tcgm.runtimeRequirements && cgm.runtimeRequirements.get(runtime);\n\t\treturn runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetChunkRuntimeRequirements(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst runtimeRequirements = cgc.runtimeRequirements;\n\t\treturn runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {boolean} withConnections include connections\n\t * @returns {string} hash\n\t */\n\tgetModuleGraphHash(module, runtime, withConnections = true) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn withConnections\n\t\t\t? this._getModuleGraphHashWithConnections(cgm, module, runtime)\n\t\t\t: this._getModuleGraphHashBigInt(cgm, module, runtime).toString(16);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {boolean} withConnections include connections\n\t * @returns {bigint} hash\n\t */\n\tgetModuleGraphHashBigInt(module, runtime, withConnections = true) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn withConnections\n\t\t\t? BigInt(\n\t\t\t\t\t`0x${this._getModuleGraphHashWithConnections(cgm, module, runtime)}`\n\t\t\t  )\n\t\t\t: this._getModuleGraphHashBigInt(cgm, module, runtime);\n\t}\n\n\t/**\n\t * @param {ChunkGraphModule} cgm the ChunkGraphModule\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {bigint} hash as big int\n\t */\n\t_getModuleGraphHashBigInt(cgm, module, runtime) {\n\t\tif (cgm.graphHashes === undefined) {\n\t\t\tcgm.graphHashes = new RuntimeSpecMap();\n\t\t}\n\t\tconst graphHash = cgm.graphHashes.provide(runtime, () => {\n\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\thash.update(`${cgm.id}${this.moduleGraph.isAsync(module)}`);\n\t\t\tthis.moduleGraph.getExportsInfo(module).updateHash(hash, runtime);\n\t\t\treturn BigInt(`0x${/** @type {string} */ (hash.digest(\"hex\"))}`);\n\t\t});\n\t\treturn graphHash;\n\t}\n\n\t/**\n\t * @param {ChunkGraphModule} cgm the ChunkGraphModule\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {string} hash\n\t */\n\t_getModuleGraphHashWithConnections(cgm, module, runtime) {\n\t\tif (cgm.graphHashesWithConnections === undefined) {\n\t\t\tcgm.graphHashesWithConnections = new RuntimeSpecMap();\n\t\t}\n\t\tconst activeStateToString = state => {\n\t\t\tif (state === false) return \"F\";\n\t\t\tif (state === true) return \"T\";\n\t\t\tif (state === ModuleGraphConnection.TRANSITIVE_ONLY) return \"O\";\n\t\t\tthrow new Error(\"Not implemented active state\");\n\t\t};\n\t\tconst strict = module.buildMeta && module.buildMeta.strictHarmonyModule;\n\t\treturn cgm.graphHashesWithConnections.provide(runtime, () => {\n\t\t\tconst graphHash = this._getModuleGraphHashBigInt(\n\t\t\t\tcgm,\n\t\t\t\tmodule,\n\t\t\t\truntime\n\t\t\t).toString(16);\n\t\t\tconst connections = this.moduleGraph.getOutgoingConnections(module);\n\t\t\t/** @type {Set<Module>} */\n\t\t\tconst activeNamespaceModules = new Set();\n\t\t\t/** @type {Map<string, Module | Set<Module>>} */\n\t\t\tconst connectedModules = new Map();\n\t\t\tconst processConnection = (connection, stateInfo) => {\n\t\t\t\tconst module = connection.module;\n\t\t\t\tstateInfo += module.getExportsType(this.moduleGraph, strict);\n\t\t\t\t// cspell:word Tnamespace\n\t\t\t\tif (stateInfo === \"Tnamespace\") activeNamespaceModules.add(module);\n\t\t\t\telse {\n\t\t\t\t\tconst oldModule = connectedModules.get(stateInfo);\n\t\t\t\t\tif (oldModule === undefined) {\n\t\t\t\t\t\tconnectedModules.set(stateInfo, module);\n\t\t\t\t\t} else if (oldModule instanceof Set) {\n\t\t\t\t\t\toldModule.add(module);\n\t\t\t\t\t} else if (oldModule !== module) {\n\t\t\t\t\t\tconnectedModules.set(stateInfo, new Set([oldModule, module]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (runtime === undefined || typeof runtime === \"string\") {\n\t\t\t\tfor (const connection of connections) {\n\t\t\t\t\tconst state = connection.getActiveState(runtime);\n\t\t\t\t\tif (state === false) continue;\n\t\t\t\t\tprocessConnection(connection, state === true ? \"T\" : \"O\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// cspell:word Tnamespace\n\t\t\t\tfor (const connection of connections) {\n\t\t\t\t\tconst states = new Set();\n\t\t\t\t\tlet stateInfo = \"\";\n\t\t\t\t\tforEachRuntime(\n\t\t\t\t\t\truntime,\n\t\t\t\t\t\truntime => {\n\t\t\t\t\t\t\tconst state = connection.getActiveState(runtime);\n\t\t\t\t\t\t\tstates.add(state);\n\t\t\t\t\t\t\tstateInfo += activeStateToString(state) + runtime;\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttrue\n\t\t\t\t\t);\n\t\t\t\t\tif (states.size === 1) {\n\t\t\t\t\t\tconst state = first(states);\n\t\t\t\t\t\tif (state === false) continue;\n\t\t\t\t\t\tstateInfo = activeStateToString(state);\n\t\t\t\t\t}\n\t\t\t\t\tprocessConnection(connection, stateInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// cspell:word Tnamespace\n\t\t\tif (activeNamespaceModules.size === 0 && connectedModules.size === 0)\n\t\t\t\treturn graphHash;\n\t\t\tconst connectedModulesInOrder =\n\t\t\t\tconnectedModules.size > 1\n\t\t\t\t\t? Array.from(connectedModules).sort(([a], [b]) => (a < b ? -1 : 1))\n\t\t\t\t\t: connectedModules;\n\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\tconst addModuleToHash = module => {\n\t\t\t\thash.update(\n\t\t\t\t\tthis._getModuleGraphHashBigInt(\n\t\t\t\t\t\tthis._getChunkGraphModule(module),\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\truntime\n\t\t\t\t\t).toString(16)\n\t\t\t\t);\n\t\t\t};\n\t\t\tconst addModulesToHash = modules => {\n\t\t\t\tlet xor = ZERO_BIG_INT;\n\t\t\t\tfor (const m of modules) {\n\t\t\t\t\txor =\n\t\t\t\t\t\txor ^\n\t\t\t\t\t\tthis._getModuleGraphHashBigInt(\n\t\t\t\t\t\t\tthis._getChunkGraphModule(m),\n\t\t\t\t\t\t\tm,\n\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\thash.update(xor.toString(16));\n\t\t\t};\n\t\t\tif (activeNamespaceModules.size === 1)\n\t\t\t\taddModuleToHash(activeNamespaceModules.values().next().value);\n\t\t\telse if (activeNamespaceModules.size > 1)\n\t\t\t\taddModulesToHash(activeNamespaceModules);\n\t\t\tfor (const [stateInfo, modules] of connectedModulesInOrder) {\n\t\t\t\thash.update(stateInfo);\n\t\t\t\tif (modules instanceof Set) {\n\t\t\t\t\taddModulesToHash(modules);\n\t\t\t\t} else {\n\t\t\t\t\taddModuleToHash(modules);\n\t\t\t\t}\n\t\t\t}\n\t\t\thash.update(graphHash);\n\t\t\treturn /** @type {string} */ (hash.digest(\"hex\"));\n\t\t});\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetTreeRuntimeRequirements(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.runtimeRequirementsInTree;\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Module} module the module\n\t * @param {string} deprecateMessage message for the deprecation message\n\t * @param {string} deprecationCode code for the deprecation\n\t * @returns {ChunkGraph} the chunk graph\n\t */\n\tstatic getChunkGraphForModule(module, deprecateMessage, deprecationCode) {\n\t\tconst fn = deprecateGetChunkGraphForModuleMap.get(deprecateMessage);\n\t\tif (fn) return fn(module);\n\t\tconst newFn = util.deprecate(\n\t\t\t/**\n\t\t\t * @param {Module} module the module\n\t\t\t * @returns {ChunkGraph} the chunk graph\n\t\t\t */\n\t\t\tmodule => {\n\t\t\t\tconst chunkGraph = chunkGraphForModuleMap.get(module);\n\t\t\t\tif (!chunkGraph)\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\tdeprecateMessage +\n\t\t\t\t\t\t\t\": There was no ChunkGraph assigned to the Module for backward-compat (Use the new API)\"\n\t\t\t\t\t);\n\t\t\t\treturn chunkGraph;\n\t\t\t},\n\t\t\tdeprecateMessage + \": Use new ChunkGraph API\",\n\t\t\tdeprecationCode\n\t\t);\n\t\tdeprecateGetChunkGraphForModuleMap.set(deprecateMessage, newFn);\n\t\treturn newFn(module);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Module} module the module\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @returns {void}\n\t */\n\tstatic setChunkGraphForModule(module, chunkGraph) {\n\t\tchunkGraphForModuleMap.set(module, chunkGraph);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tstatic clearChunkGraphForModule(module) {\n\t\tchunkGraphForModuleMap.delete(module);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {string} deprecateMessage message for the deprecation message\n\t * @param {string} deprecationCode code for the deprecation\n\t * @returns {ChunkGraph} the chunk graph\n\t */\n\tstatic getChunkGraphForChunk(chunk, deprecateMessage, deprecationCode) {\n\t\tconst fn = deprecateGetChunkGraphForChunkMap.get(deprecateMessage);\n\t\tif (fn) return fn(chunk);\n\t\tconst newFn = util.deprecate(\n\t\t\t/**\n\t\t\t * @param {Chunk} chunk the chunk\n\t\t\t * @returns {ChunkGraph} the chunk graph\n\t\t\t */\n\t\t\tchunk => {\n\t\t\t\tconst chunkGraph = chunkGraphForChunkMap.get(chunk);\n\t\t\t\tif (!chunkGraph)\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\tdeprecateMessage +\n\t\t\t\t\t\t\t\"There was no ChunkGraph assigned to the Chunk for backward-compat (Use the new API)\"\n\t\t\t\t\t);\n\t\t\t\treturn chunkGraph;\n\t\t\t},\n\t\t\tdeprecateMessage + \": Use new ChunkGraph API\",\n\t\t\tdeprecationCode\n\t\t);\n\t\tdeprecateGetChunkGraphForChunkMap.set(deprecateMessage, newFn);\n\t\treturn newFn(chunk);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @returns {void}\n\t */\n\tstatic setChunkGraphForChunk(chunk, chunkGraph) {\n\t\tchunkGraphForChunkMap.set(chunk, chunkGraph);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {void}\n\t */\n\tstatic clearChunkGraphForChunk(chunk) {\n\t\tchunkGraphForChunkMap.delete(chunk);\n\t}\n}\n\n// TODO remove in webpack 6\n/** @type {WeakMap<Module, ChunkGraph>} */\nconst chunkGraphForModuleMap = new WeakMap();\n\n// TODO remove in webpack 6\n/** @type {WeakMap<Chunk, ChunkGraph>} */\nconst chunkGraphForChunkMap = new WeakMap();\n\n// TODO remove in webpack 6\n/** @type {Map<string, (module: Module) => ChunkGraph>} */\nconst deprecateGetChunkGraphForModuleMap = new Map();\n\n// TODO remove in webpack 6\n/** @type {Map<string, (chunk: Chunk) => ChunkGraph>} */\nconst deprecateGetChunkGraphForChunkMap = new Map();\n\nmodule.exports = ChunkGraph;\n"]},"metadata":{},"sourceType":"script"}