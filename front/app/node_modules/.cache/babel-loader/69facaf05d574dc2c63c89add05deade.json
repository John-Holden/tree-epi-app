{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _objectSpread = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _toConsumableArray = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar parseJson = require(\"json-parse-better-errors\");\n\nvar asyncLib = require(\"neo-async\");\n\nvar _require = require(\"tapable\"),\n    SyncHook = _require.SyncHook,\n    SyncBailHook = _require.SyncBailHook,\n    AsyncParallelHook = _require.AsyncParallelHook,\n    AsyncSeriesHook = _require.AsyncSeriesHook;\n\nvar _require2 = require(\"webpack-sources\"),\n    SizeOnlySource = _require2.SizeOnlySource;\n\nvar webpack = require(\"./\");\n\nvar Cache = require(\"./Cache\");\n\nvar CacheFacade = require(\"./CacheFacade\");\n\nvar ChunkGraph = require(\"./ChunkGraph\");\n\nvar Compilation = require(\"./Compilation\");\n\nvar ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\n\nvar ContextModuleFactory = require(\"./ContextModuleFactory\");\n\nvar ModuleGraph = require(\"./ModuleGraph\");\n\nvar NormalModuleFactory = require(\"./NormalModuleFactory\");\n\nvar RequestShortener = require(\"./RequestShortener\");\n\nvar ResolverFactory = require(\"./ResolverFactory\");\n\nvar Stats = require(\"./Stats\");\n\nvar Watching = require(\"./Watching\");\n\nvar WebpackError = require(\"./WebpackError\");\n\nvar _require3 = require(\"./logging/Logger\"),\n    Logger = _require3.Logger;\n\nvar _require4 = require(\"./util/fs\"),\n    join = _require4.join,\n    dirname = _require4.dirname,\n    mkdirp = _require4.mkdirp;\n\nvar _require5 = require(\"./util/identifier\"),\n    makePathsRelative = _require5.makePathsRelative;\n\nvar _require6 = require(\"./util/source\"),\n    isSourceEqual = _require6.isSourceEqual;\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../declarations/WebpackOptions\").EntryNormalized} Entry */\n\n/** @typedef {import(\"../declarations/WebpackOptions\").OutputNormalized} OutputOptions */\n\n/** @typedef {import(\"../declarations/WebpackOptions\").WatchOptions} WatchOptions */\n\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackOptionsNormalized} WebpackOptions */\n\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackPluginInstance} WebpackPluginInstance */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./Dependency\")} Dependency */\n\n/** @typedef {import(\"./FileSystemInfo\").FileSystemInfoEntry} FileSystemInfoEntry */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./util/WeakTupleMap\")} WeakTupleMap */\n\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n\n/** @typedef {import(\"./util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n\n/** @typedef {import(\"./util/fs\").WatchFileSystem} WatchFileSystem */\n\n/**\n * @typedef {Object} CompilationParams\n * @property {NormalModuleFactory} normalModuleFactory\n * @property {ContextModuleFactory} contextModuleFactory\n */\n\n/**\n * @template T\n * @callback Callback\n * @param {(Error | null)=} err\n * @param {T=} result\n */\n\n/**\n * @callback RunAsChildCallback\n * @param {(Error | null)=} err\n * @param {Chunk[]=} entries\n * @param {Compilation=} compilation\n */\n\n/**\n * @typedef {Object} AssetEmittedInfo\n * @property {Buffer} content\n * @property {Source} source\n * @property {Compilation} compilation\n * @property {string} outputPath\n * @property {string} targetPath\n */\n\n/**\n * @param {string[]} array an array\n * @returns {boolean} true, if the array is sorted\n */\n\n\nvar isSorted = function isSorted(array) {\n  for (var i = 1; i < array.length; i++) {\n    if (array[i - 1] > array[i]) return false;\n  }\n\n  return true;\n};\n/**\n * @param {Object} obj an object\n * @param {string[]} keys the keys of the object\n * @returns {Object} the object with properties sorted by property name\n */\n\n\nvar sortObject = function sortObject(obj, keys) {\n  var o = {};\n\n  var _iterator = _createForOfIteratorHelper(keys.sort()),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var k = _step.value;\n      o[k] = obj[k];\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return o;\n};\n/**\n * @param {string} filename filename\n * @param {string | string[] | undefined} hashes list of hashes\n * @returns {boolean} true, if the filename contains any hash\n */\n\n\nvar includesHash = function includesHash(filename, hashes) {\n  if (!hashes) return false;\n\n  if (Array.isArray(hashes)) {\n    return hashes.some(function (hash) {\n      return filename.includes(hash);\n    });\n  } else {\n    return filename.includes(hashes);\n  }\n};\n\nvar Compiler = /*#__PURE__*/function () {\n  /**\n   * @param {string} context the compilation path\n   * @param {WebpackOptions} options options\n   */\n  function Compiler(context) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] :\n    /** @type {WebpackOptions} */\n    {};\n\n    _classCallCheck(this, Compiler);\n\n    this.hooks = Object.freeze({\n      /** @type {SyncHook<[]>} */\n      initialize: new SyncHook([]),\n\n      /** @type {SyncBailHook<[Compilation], boolean>} */\n      shouldEmit: new SyncBailHook([\"compilation\"]),\n\n      /** @type {AsyncSeriesHook<[Stats]>} */\n      done: new AsyncSeriesHook([\"stats\"]),\n\n      /** @type {SyncHook<[Stats]>} */\n      afterDone: new SyncHook([\"stats\"]),\n\n      /** @type {AsyncSeriesHook<[]>} */\n      additionalPass: new AsyncSeriesHook([]),\n\n      /** @type {AsyncSeriesHook<[Compiler]>} */\n      beforeRun: new AsyncSeriesHook([\"compiler\"]),\n\n      /** @type {AsyncSeriesHook<[Compiler]>} */\n      run: new AsyncSeriesHook([\"compiler\"]),\n\n      /** @type {AsyncSeriesHook<[Compilation]>} */\n      emit: new AsyncSeriesHook([\"compilation\"]),\n\n      /** @type {AsyncSeriesHook<[string, AssetEmittedInfo]>} */\n      assetEmitted: new AsyncSeriesHook([\"file\", \"info\"]),\n\n      /** @type {AsyncSeriesHook<[Compilation]>} */\n      afterEmit: new AsyncSeriesHook([\"compilation\"]),\n\n      /** @type {SyncHook<[Compilation, CompilationParams]>} */\n      thisCompilation: new SyncHook([\"compilation\", \"params\"]),\n\n      /** @type {SyncHook<[Compilation, CompilationParams]>} */\n      compilation: new SyncHook([\"compilation\", \"params\"]),\n\n      /** @type {SyncHook<[NormalModuleFactory]>} */\n      normalModuleFactory: new SyncHook([\"normalModuleFactory\"]),\n\n      /** @type {SyncHook<[ContextModuleFactory]>}  */\n      contextModuleFactory: new SyncHook([\"contextModuleFactory\"]),\n\n      /** @type {AsyncSeriesHook<[CompilationParams]>} */\n      beforeCompile: new AsyncSeriesHook([\"params\"]),\n\n      /** @type {SyncHook<[CompilationParams]>} */\n      compile: new SyncHook([\"params\"]),\n\n      /** @type {AsyncParallelHook<[Compilation]>} */\n      make: new AsyncParallelHook([\"compilation\"]),\n\n      /** @type {AsyncParallelHook<[Compilation]>} */\n      finishMake: new AsyncSeriesHook([\"compilation\"]),\n\n      /** @type {AsyncSeriesHook<[Compilation]>} */\n      afterCompile: new AsyncSeriesHook([\"compilation\"]),\n\n      /** @type {AsyncSeriesHook<[]>} */\n      readRecords: new AsyncSeriesHook([]),\n\n      /** @type {AsyncSeriesHook<[]>} */\n      emitRecords: new AsyncSeriesHook([]),\n\n      /** @type {AsyncSeriesHook<[Compiler]>} */\n      watchRun: new AsyncSeriesHook([\"compiler\"]),\n\n      /** @type {SyncHook<[Error]>} */\n      failed: new SyncHook([\"error\"]),\n\n      /** @type {SyncHook<[string | null, number]>} */\n      invalid: new SyncHook([\"filename\", \"changeTime\"]),\n\n      /** @type {SyncHook<[]>} */\n      watchClose: new SyncHook([]),\n\n      /** @type {AsyncSeriesHook<[]>} */\n      shutdown: new AsyncSeriesHook([]),\n\n      /** @type {SyncBailHook<[string, string, any[]], true>} */\n      infrastructureLog: new SyncBailHook([\"origin\", \"type\", \"args\"]),\n      // TODO the following hooks are weirdly located here\n      // TODO move them for webpack 5\n\n      /** @type {SyncHook<[]>} */\n      environment: new SyncHook([]),\n\n      /** @type {SyncHook<[]>} */\n      afterEnvironment: new SyncHook([]),\n\n      /** @type {SyncHook<[Compiler]>} */\n      afterPlugins: new SyncHook([\"compiler\"]),\n\n      /** @type {SyncHook<[Compiler]>} */\n      afterResolvers: new SyncHook([\"compiler\"]),\n\n      /** @type {SyncBailHook<[string, Entry], boolean>} */\n      entryOption: new SyncBailHook([\"context\", \"entry\"])\n    });\n    this.webpack = webpack;\n    /** @type {string=} */\n\n    this.name = undefined;\n    /** @type {Compilation=} */\n\n    this.parentCompilation = undefined;\n    /** @type {Compiler} */\n\n    this.root = this;\n    /** @type {string} */\n\n    this.outputPath = \"\";\n    /** @type {Watching} */\n\n    this.watching = undefined;\n    /** @type {OutputFileSystem} */\n\n    this.outputFileSystem = null;\n    /** @type {IntermediateFileSystem} */\n\n    this.intermediateFileSystem = null;\n    /** @type {InputFileSystem} */\n\n    this.inputFileSystem = null;\n    /** @type {WatchFileSystem} */\n\n    this.watchFileSystem = null;\n    /** @type {string|null} */\n\n    this.recordsInputPath = null;\n    /** @type {string|null} */\n\n    this.recordsOutputPath = null;\n    this.records = {};\n    /** @type {Set<string | RegExp>} */\n\n    this.managedPaths = new Set();\n    /** @type {Set<string | RegExp>} */\n\n    this.immutablePaths = new Set();\n    /** @type {ReadonlySet<string>} */\n\n    this.modifiedFiles = undefined;\n    /** @type {ReadonlySet<string>} */\n\n    this.removedFiles = undefined;\n    /** @type {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} */\n\n    this.fileTimestamps = undefined;\n    /** @type {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} */\n\n    this.contextTimestamps = undefined;\n    /** @type {number} */\n\n    this.fsStartTime = undefined;\n    /** @type {ResolverFactory} */\n\n    this.resolverFactory = new ResolverFactory();\n    this.infrastructureLogger = undefined;\n    this.options = options;\n    this.context = context;\n    this.requestShortener = new RequestShortener(context, this.root);\n    this.cache = new Cache();\n    /** @type {Map<Module, { buildInfo: object, references: WeakMap<Dependency, Module>, memCache: WeakTupleMap }> | undefined} */\n\n    this.moduleMemCaches = undefined;\n    this.compilerPath = \"\";\n    /** @type {boolean} */\n\n    this.running = false;\n    /** @type {boolean} */\n\n    this.idle = false;\n    /** @type {boolean} */\n\n    this.watchMode = false;\n    this._backCompat = this.options.experiments.backCompat !== false;\n    /** @type {Compilation} */\n\n    this._lastCompilation = undefined;\n    /** @type {NormalModuleFactory} */\n\n    this._lastNormalModuleFactory = undefined;\n    /** @private @type {WeakMap<Source, { sizeOnlySource: SizeOnlySource, writtenTo: Map<string, number> }>} */\n\n    this._assetEmittingSourceCache = new WeakMap();\n    /** @private @type {Map<string, number>} */\n\n    this._assetEmittingWrittenFiles = new Map();\n    /** @private @type {Set<string>} */\n\n    this._assetEmittingPreviousFiles = new Set();\n  }\n  /**\n   * @param {string} name cache name\n   * @returns {CacheFacade} the cache facade instance\n   */\n\n\n  _createClass(Compiler, [{\n    key: \"getCache\",\n    value: function getCache(name) {\n      return new CacheFacade(this.cache, \"\".concat(this.compilerPath).concat(name), this.options.output.hashFunction);\n    }\n    /**\n     * @param {string | (function(): string)} name name of the logger, or function called once to get the logger name\n     * @returns {Logger} a logger with that name\n     */\n\n  }, {\n    key: \"getInfrastructureLogger\",\n    value: function getInfrastructureLogger(name) {\n      var _this = this;\n\n      if (!name) {\n        throw new TypeError(\"Compiler.getInfrastructureLogger(name) called without a name\");\n      }\n\n      return new Logger(function (type, args) {\n        if (typeof name === \"function\") {\n          name = name();\n\n          if (!name) {\n            throw new TypeError(\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\");\n          }\n        }\n\n        if (_this.hooks.infrastructureLog.call(name, type, args) === undefined) {\n          if (_this.infrastructureLogger !== undefined) {\n            _this.infrastructureLogger(name, type, args);\n          }\n        }\n      }, function (childName) {\n        if (typeof name === \"function\") {\n          if (typeof childName === \"function\") {\n            return _this.getInfrastructureLogger(function () {\n              if (typeof name === \"function\") {\n                name = name();\n\n                if (!name) {\n                  throw new TypeError(\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\");\n                }\n              }\n\n              if (typeof childName === \"function\") {\n                childName = childName();\n\n                if (!childName) {\n                  throw new TypeError(\"Logger.getChildLogger(name) called with a function not returning a name\");\n                }\n              }\n\n              return \"\".concat(name, \"/\").concat(childName);\n            });\n          } else {\n            return _this.getInfrastructureLogger(function () {\n              if (typeof name === \"function\") {\n                name = name();\n\n                if (!name) {\n                  throw new TypeError(\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\");\n                }\n              }\n\n              return \"\".concat(name, \"/\").concat(childName);\n            });\n          }\n        } else {\n          if (typeof childName === \"function\") {\n            return _this.getInfrastructureLogger(function () {\n              if (typeof childName === \"function\") {\n                childName = childName();\n\n                if (!childName) {\n                  throw new TypeError(\"Logger.getChildLogger(name) called with a function not returning a name\");\n                }\n              }\n\n              return \"\".concat(name, \"/\").concat(childName);\n            });\n          } else {\n            return _this.getInfrastructureLogger(\"\".concat(name, \"/\").concat(childName));\n          }\n        }\n      });\n    } // TODO webpack 6: solve this in a better way\n    // e.g. move compilation specific info from Modules into ModuleGraph\n\n  }, {\n    key: \"_cleanupLastCompilation\",\n    value: function _cleanupLastCompilation() {\n      if (this._lastCompilation !== undefined) {\n        var _iterator2 = _createForOfIteratorHelper(this._lastCompilation.modules),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _module = _step2.value;\n            ChunkGraph.clearChunkGraphForModule(_module);\n            ModuleGraph.clearModuleGraphForModule(_module);\n\n            _module.cleanupForCache();\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        var _iterator3 = _createForOfIteratorHelper(this._lastCompilation.chunks),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var chunk = _step3.value;\n            ChunkGraph.clearChunkGraphForChunk(chunk);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        this._lastCompilation = undefined;\n      }\n    } // TODO webpack 6: solve this in a better way\n\n  }, {\n    key: \"_cleanupLastNormalModuleFactory\",\n    value: function _cleanupLastNormalModuleFactory() {\n      if (this._lastNormalModuleFactory !== undefined) {\n        this._lastNormalModuleFactory.cleanupForCache();\n\n        this._lastNormalModuleFactory = undefined;\n      }\n    }\n    /**\n     * @param {WatchOptions} watchOptions the watcher's options\n     * @param {Callback<Stats>} handler signals when the call finishes\n     * @returns {Watching} a compiler watcher\n     */\n\n  }, {\n    key: \"watch\",\n    value: function watch(watchOptions, handler) {\n      if (this.running) {\n        return handler(new ConcurrentCompilationError());\n      }\n\n      this.running = true;\n      this.watchMode = true;\n      this.watching = new Watching(this, watchOptions, handler);\n      return this.watching;\n    }\n    /**\n     * @param {Callback<Stats>} callback signals when the call finishes\n     * @returns {void}\n     */\n\n  }, {\n    key: \"run\",\n    value: function run(callback) {\n      var _this2 = this;\n\n      if (this.running) {\n        return callback(new ConcurrentCompilationError());\n      }\n\n      var logger;\n\n      var finalCallback = function finalCallback(err, stats) {\n        if (logger) logger.time(\"beginIdle\");\n        _this2.idle = true;\n\n        _this2.cache.beginIdle();\n\n        _this2.idle = true;\n        if (logger) logger.timeEnd(\"beginIdle\");\n        _this2.running = false;\n\n        if (err) {\n          _this2.hooks.failed.call(err);\n        }\n\n        if (callback !== undefined) callback(err, stats);\n\n        _this2.hooks.afterDone.call(stats);\n      };\n\n      var startTime = Date.now();\n      this.running = true;\n\n      var onCompiled = function onCompiled(err, compilation) {\n        if (err) return finalCallback(err);\n\n        if (_this2.hooks.shouldEmit.call(compilation) === false) {\n          compilation.startTime = startTime;\n          compilation.endTime = Date.now();\n          var stats = new Stats(compilation);\n\n          _this2.hooks.done.callAsync(stats, function (err) {\n            if (err) return finalCallback(err);\n            return finalCallback(null, stats);\n          });\n\n          return;\n        }\n\n        process.nextTick(function () {\n          logger = compilation.getLogger(\"webpack.Compiler\");\n          logger.time(\"emitAssets\");\n\n          _this2.emitAssets(compilation, function (err) {\n            logger.timeEnd(\"emitAssets\");\n            if (err) return finalCallback(err);\n\n            if (compilation.hooks.needAdditionalPass.call()) {\n              compilation.needAdditionalPass = true;\n              compilation.startTime = startTime;\n              compilation.endTime = Date.now();\n              logger.time(\"done hook\");\n\n              var _stats = new Stats(compilation);\n\n              _this2.hooks.done.callAsync(_stats, function (err) {\n                logger.timeEnd(\"done hook\");\n                if (err) return finalCallback(err);\n\n                _this2.hooks.additionalPass.callAsync(function (err) {\n                  if (err) return finalCallback(err);\n\n                  _this2.compile(onCompiled);\n                });\n              });\n\n              return;\n            }\n\n            logger.time(\"emitRecords\");\n\n            _this2.emitRecords(function (err) {\n              logger.timeEnd(\"emitRecords\");\n              if (err) return finalCallback(err);\n              compilation.startTime = startTime;\n              compilation.endTime = Date.now();\n              logger.time(\"done hook\");\n              var stats = new Stats(compilation);\n\n              _this2.hooks.done.callAsync(stats, function (err) {\n                logger.timeEnd(\"done hook\");\n                if (err) return finalCallback(err);\n\n                _this2.cache.storeBuildDependencies(compilation.buildDependencies, function (err) {\n                  if (err) return finalCallback(err);\n                  return finalCallback(null, stats);\n                });\n              });\n            });\n          });\n        });\n      };\n\n      var run = function run() {\n        _this2.hooks.beforeRun.callAsync(_this2, function (err) {\n          if (err) return finalCallback(err);\n\n          _this2.hooks.run.callAsync(_this2, function (err) {\n            if (err) return finalCallback(err);\n\n            _this2.readRecords(function (err) {\n              if (err) return finalCallback(err);\n\n              _this2.compile(onCompiled);\n            });\n          });\n        });\n      };\n\n      if (this.idle) {\n        this.cache.endIdle(function (err) {\n          if (err) return finalCallback(err);\n          _this2.idle = false;\n          run();\n        });\n      } else {\n        run();\n      }\n    }\n    /**\n     * @param {RunAsChildCallback} callback signals when the call finishes\n     * @returns {void}\n     */\n\n  }, {\n    key: \"runAsChild\",\n    value: function runAsChild(callback) {\n      var _this3 = this;\n\n      var startTime = Date.now();\n      this.compile(function (err, compilation) {\n        if (err) return callback(err);\n\n        _this3.parentCompilation.children.push(compilation);\n\n        var _iterator4 = _createForOfIteratorHelper(compilation.getAssets()),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _step4$value = _step4.value,\n                name = _step4$value.name,\n                source = _step4$value.source,\n                info = _step4$value.info;\n\n            _this3.parentCompilation.emitAsset(name, source, info);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        var entries = [];\n\n        var _iterator5 = _createForOfIteratorHelper(compilation.entrypoints.values()),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var ep = _step5.value;\n            entries.push.apply(entries, _toConsumableArray(ep.chunks));\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n\n        compilation.startTime = startTime;\n        compilation.endTime = Date.now();\n        return callback(null, entries, compilation);\n      });\n    }\n  }, {\n    key: \"purgeInputFileSystem\",\n    value: function purgeInputFileSystem() {\n      if (this.inputFileSystem && this.inputFileSystem.purge) {\n        this.inputFileSystem.purge();\n      }\n    }\n    /**\n     * @param {Compilation} compilation the compilation\n     * @param {Callback<void>} callback signals when the assets are emitted\n     * @returns {void}\n     */\n\n  }, {\n    key: \"emitAssets\",\n    value: function emitAssets(compilation, callback) {\n      var _this4 = this;\n\n      var outputPath;\n\n      var emitFiles = function emitFiles(err) {\n        if (err) return callback(err);\n        var assets = compilation.getAssets();\n        compilation.assets = _objectSpread({}, compilation.assets);\n        /** @type {Map<string, { path: string, source: Source, size: number, waiting: { cacheEntry: any, file: string }[] }>} */\n\n        var caseInsensitiveMap = new Map();\n        /** @type {Set<string>} */\n\n        var allTargetPaths = new Set();\n        asyncLib.forEachLimit(assets, 15, function (_ref, callback) {\n          var file = _ref.name,\n              source = _ref.source,\n              info = _ref.info;\n          var targetFile = file;\n          var immutable = info.immutable;\n          var queryStringIdx = targetFile.indexOf(\"?\");\n\n          if (queryStringIdx >= 0) {\n            targetFile = targetFile.substr(0, queryStringIdx); // We may remove the hash, which is in the query string\n            // So we recheck if the file is immutable\n            // This doesn't cover all cases, but immutable is only a performance optimization anyway\n\n            immutable = immutable && (includesHash(targetFile, info.contenthash) || includesHash(targetFile, info.chunkhash) || includesHash(targetFile, info.modulehash) || includesHash(targetFile, info.fullhash));\n          }\n\n          var writeOut = function writeOut(err) {\n            if (err) return callback(err);\n            var targetPath = join(_this4.outputFileSystem, outputPath, targetFile);\n            allTargetPaths.add(targetPath); // check if the target file has already been written by this Compiler\n\n            var targetFileGeneration = _this4._assetEmittingWrittenFiles.get(targetPath); // create an cache entry for this Source if not already existing\n\n\n            var cacheEntry = _this4._assetEmittingSourceCache.get(source);\n\n            if (cacheEntry === undefined) {\n              cacheEntry = {\n                sizeOnlySource: undefined,\n                writtenTo: new Map()\n              };\n\n              _this4._assetEmittingSourceCache.set(source, cacheEntry);\n            }\n\n            var similarEntry;\n\n            var checkSimilarFile = function checkSimilarFile() {\n              var caseInsensitiveTargetPath = targetPath.toLowerCase();\n              similarEntry = caseInsensitiveMap.get(caseInsensitiveTargetPath);\n\n              if (similarEntry !== undefined) {\n                var _similarEntry = similarEntry,\n                    other = _similarEntry.path,\n                    otherSource = _similarEntry.source;\n\n                if (isSourceEqual(otherSource, source)) {\n                  // Size may or may not be available at this point.\n                  // If it's not available add to \"waiting\" list and it will be updated once available\n                  if (similarEntry.size !== undefined) {\n                    updateWithReplacementSource(similarEntry.size);\n                  } else {\n                    if (!similarEntry.waiting) similarEntry.waiting = [];\n                    similarEntry.waiting.push({\n                      file: file,\n                      cacheEntry: cacheEntry\n                    });\n                  }\n\n                  alreadyWritten();\n                } else {\n                  var _err = new WebpackError(\"Prevent writing to file that only differs in casing or query string from already written file.\\nThis will lead to a race-condition and corrupted files on case-insensitive file systems.\\n\".concat(targetPath, \"\\n\").concat(other));\n\n                  _err.file = file;\n                  callback(_err);\n                }\n\n                return true;\n              } else {\n                caseInsensitiveMap.set(caseInsensitiveTargetPath, similarEntry = {\n                  path: targetPath,\n                  source: source,\n                  size: undefined,\n                  waiting: undefined\n                });\n                return false;\n              }\n            };\n            /**\n             * get the binary (Buffer) content from the Source\n             * @returns {Buffer} content for the source\n             */\n\n\n            var getContent = function getContent() {\n              if (typeof source.buffer === \"function\") {\n                return source.buffer();\n              } else {\n                var bufferOrString = source.source();\n\n                if (Buffer.isBuffer(bufferOrString)) {\n                  return bufferOrString;\n                } else {\n                  return Buffer.from(bufferOrString, \"utf8\");\n                }\n              }\n            };\n\n            var alreadyWritten = function alreadyWritten() {\n              // cache the information that the Source has been already been written to that location\n              if (targetFileGeneration === undefined) {\n                var newGeneration = 1;\n\n                _this4._assetEmittingWrittenFiles.set(targetPath, newGeneration);\n\n                cacheEntry.writtenTo.set(targetPath, newGeneration);\n              } else {\n                cacheEntry.writtenTo.set(targetPath, targetFileGeneration);\n              }\n\n              callback();\n            };\n            /**\n             * Write the file to output file system\n             * @param {Buffer} content content to be written\n             * @returns {void}\n             */\n\n\n            var doWrite = function doWrite(content) {\n              _this4.outputFileSystem.writeFile(targetPath, content, function (err) {\n                if (err) return callback(err); // information marker that the asset has been emitted\n\n                compilation.emittedAssets.add(file); // cache the information that the Source has been written to that location\n\n                var newGeneration = targetFileGeneration === undefined ? 1 : targetFileGeneration + 1;\n                cacheEntry.writtenTo.set(targetPath, newGeneration);\n\n                _this4._assetEmittingWrittenFiles.set(targetPath, newGeneration);\n\n                _this4.hooks.assetEmitted.callAsync(file, {\n                  content: content,\n                  source: source,\n                  outputPath: outputPath,\n                  compilation: compilation,\n                  targetPath: targetPath\n                }, callback);\n              });\n            };\n\n            var updateWithReplacementSource = function updateWithReplacementSource(size) {\n              updateFileWithReplacementSource(file, cacheEntry, size);\n              similarEntry.size = size;\n\n              if (similarEntry.waiting !== undefined) {\n                var _iterator6 = _createForOfIteratorHelper(similarEntry.waiting),\n                    _step6;\n\n                try {\n                  for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                    var _step6$value = _step6.value,\n                        _file = _step6$value.file,\n                        _cacheEntry = _step6$value.cacheEntry;\n                    updateFileWithReplacementSource(_file, _cacheEntry, size);\n                  }\n                } catch (err) {\n                  _iterator6.e(err);\n                } finally {\n                  _iterator6.f();\n                }\n              }\n            };\n\n            var updateFileWithReplacementSource = function updateFileWithReplacementSource(file, cacheEntry, size) {\n              // Create a replacement resource which only allows to ask for size\n              // This allows to GC all memory allocated by the Source\n              // (expect when the Source is stored in any other cache)\n              if (!cacheEntry.sizeOnlySource) {\n                cacheEntry.sizeOnlySource = new SizeOnlySource(size);\n              }\n\n              compilation.updateAsset(file, cacheEntry.sizeOnlySource, {\n                size: size\n              });\n            };\n\n            var processExistingFile = function processExistingFile(stats) {\n              // skip emitting if it's already there and an immutable file\n              if (immutable) {\n                updateWithReplacementSource(stats.size);\n                return alreadyWritten();\n              }\n\n              var content = getContent();\n              updateWithReplacementSource(content.length); // if it exists and content on disk matches content\n              // skip writing the same content again\n              // (to keep mtime and don't trigger watchers)\n              // for a fast negative match file size is compared first\n\n              if (content.length === stats.size) {\n                compilation.comparedForEmitAssets.add(file);\n                return _this4.outputFileSystem.readFile(targetPath, function (err, existingContent) {\n                  if (err || !content.equals(\n                  /** @type {Buffer} */\n                  existingContent)) {\n                    return doWrite(content);\n                  } else {\n                    return alreadyWritten();\n                  }\n                });\n              }\n\n              return doWrite(content);\n            };\n\n            var processMissingFile = function processMissingFile() {\n              var content = getContent();\n              updateWithReplacementSource(content.length);\n              return doWrite(content);\n            }; // if the target file has already been written\n\n\n            if (targetFileGeneration !== undefined) {\n              // check if the Source has been written to this target file\n              var writtenGeneration = cacheEntry.writtenTo.get(targetPath);\n\n              if (writtenGeneration === targetFileGeneration) {\n                // if yes, we may skip writing the file\n                // if it's already there\n                // (we assume one doesn't modify files while the Compiler is running, other then removing them)\n                if (_this4._assetEmittingPreviousFiles.has(targetPath)) {\n                  // We assume that assets from the last compilation say intact on disk (they are not removed)\n                  compilation.updateAsset(file, cacheEntry.sizeOnlySource, {\n                    size: cacheEntry.sizeOnlySource.size()\n                  });\n                  return callback();\n                } else {\n                  // Settings immutable will make it accept file content without comparing when file exist\n                  immutable = true;\n                }\n              } else if (!immutable) {\n                if (checkSimilarFile()) return; // We wrote to this file before which has very likely a different content\n                // skip comparing and assume content is different for performance\n                // This case happens often during watch mode.\n\n                return processMissingFile();\n              }\n            }\n\n            if (checkSimilarFile()) return;\n\n            if (_this4.options.output.compareBeforeEmit) {\n              _this4.outputFileSystem.stat(targetPath, function (err, stats) {\n                var exists = !err && stats.isFile();\n\n                if (exists) {\n                  processExistingFile(stats);\n                } else {\n                  processMissingFile();\n                }\n              });\n            } else {\n              processMissingFile();\n            }\n          };\n\n          if (targetFile.match(/\\/|\\\\/)) {\n            var fs = _this4.outputFileSystem;\n            var dir = dirname(fs, join(fs, outputPath, targetFile));\n            mkdirp(fs, dir, writeOut);\n          } else {\n            writeOut();\n          }\n        }, function (err) {\n          // Clear map to free up memory\n          caseInsensitiveMap.clear();\n\n          if (err) {\n            _this4._assetEmittingPreviousFiles.clear();\n\n            return callback(err);\n          }\n\n          _this4._assetEmittingPreviousFiles = allTargetPaths;\n\n          _this4.hooks.afterEmit.callAsync(compilation, function (err) {\n            if (err) return callback(err);\n            return callback();\n          });\n        });\n      };\n\n      this.hooks.emit.callAsync(compilation, function (err) {\n        if (err) return callback(err);\n        outputPath = compilation.getPath(_this4.outputPath, {});\n        mkdirp(_this4.outputFileSystem, outputPath, emitFiles);\n      });\n    }\n    /**\n     * @param {Callback<void>} callback signals when the call finishes\n     * @returns {void}\n     */\n\n  }, {\n    key: \"emitRecords\",\n    value: function emitRecords(callback) {\n      var _this5 = this;\n\n      if (this.hooks.emitRecords.isUsed()) {\n        if (this.recordsOutputPath) {\n          asyncLib.parallel([function (cb) {\n            return _this5.hooks.emitRecords.callAsync(cb);\n          }, this._emitRecords.bind(this)], function (err) {\n            return callback(err);\n          });\n        } else {\n          this.hooks.emitRecords.callAsync(callback);\n        }\n      } else {\n        if (this.recordsOutputPath) {\n          this._emitRecords(callback);\n        } else {\n          callback();\n        }\n      }\n    }\n    /**\n     * @param {Callback<void>} callback signals when the call finishes\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_emitRecords\",\n    value: function _emitRecords(callback) {\n      var _this6 = this;\n\n      var writeFile = function writeFile() {\n        _this6.outputFileSystem.writeFile(_this6.recordsOutputPath, JSON.stringify(_this6.records, function (n, value) {\n          if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n            var keys = Object.keys(value);\n\n            if (!isSorted(keys)) {\n              return sortObject(value, keys);\n            }\n          }\n\n          return value;\n        }, 2), callback);\n      };\n\n      var recordsOutputPathDirectory = dirname(this.outputFileSystem, this.recordsOutputPath);\n\n      if (!recordsOutputPathDirectory) {\n        return writeFile();\n      }\n\n      mkdirp(this.outputFileSystem, recordsOutputPathDirectory, function (err) {\n        if (err) return callback(err);\n        writeFile();\n      });\n    }\n    /**\n     * @param {Callback<void>} callback signals when the call finishes\n     * @returns {void}\n     */\n\n  }, {\n    key: \"readRecords\",\n    value: function readRecords(callback) {\n      var _this7 = this;\n\n      if (this.hooks.readRecords.isUsed()) {\n        if (this.recordsInputPath) {\n          asyncLib.parallel([function (cb) {\n            return _this7.hooks.readRecords.callAsync(cb);\n          }, this._readRecords.bind(this)]);\n        } else {\n          this.records = {};\n          this.hooks.readRecords.callAsync(callback);\n        }\n      } else {\n        if (this.recordsInputPath) {\n          this._readRecords(callback);\n        } else {\n          this.records = {};\n          callback();\n        }\n      }\n    }\n    /**\n     * @param {Callback<void>} callback signals when the call finishes\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_readRecords\",\n    value: function _readRecords(callback) {\n      var _this8 = this;\n\n      if (!this.recordsInputPath) {\n        this.records = {};\n        return callback();\n      }\n\n      this.inputFileSystem.stat(this.recordsInputPath, function (err) {\n        // It doesn't exist\n        // We can ignore this.\n        if (err) return callback();\n\n        _this8.inputFileSystem.readFile(_this8.recordsInputPath, function (err, content) {\n          if (err) return callback(err);\n\n          try {\n            _this8.records = parseJson(content.toString(\"utf-8\"));\n          } catch (e) {\n            e.message = \"Cannot parse records: \" + e.message;\n            return callback(e);\n          }\n\n          return callback();\n        });\n      });\n    }\n    /**\n     * @param {Compilation} compilation the compilation\n     * @param {string} compilerName the compiler's name\n     * @param {number} compilerIndex the compiler's index\n     * @param {OutputOptions=} outputOptions the output options\n     * @param {WebpackPluginInstance[]=} plugins the plugins to apply\n     * @returns {Compiler} a child compiler\n     */\n\n  }, {\n    key: \"createChildCompiler\",\n    value: function createChildCompiler(compilation, compilerName, compilerIndex, outputOptions, plugins) {\n      var childCompiler = new Compiler(this.context, _objectSpread(_objectSpread({}, this.options), {}, {\n        output: _objectSpread(_objectSpread({}, this.options.output), outputOptions)\n      }));\n      childCompiler.name = compilerName;\n      childCompiler.outputPath = this.outputPath;\n      childCompiler.inputFileSystem = this.inputFileSystem;\n      childCompiler.outputFileSystem = null;\n      childCompiler.resolverFactory = this.resolverFactory;\n      childCompiler.modifiedFiles = this.modifiedFiles;\n      childCompiler.removedFiles = this.removedFiles;\n      childCompiler.fileTimestamps = this.fileTimestamps;\n      childCompiler.contextTimestamps = this.contextTimestamps;\n      childCompiler.fsStartTime = this.fsStartTime;\n      childCompiler.cache = this.cache;\n      childCompiler.compilerPath = \"\".concat(this.compilerPath).concat(compilerName, \"|\").concat(compilerIndex, \"|\");\n      childCompiler._backCompat = this._backCompat;\n      var relativeCompilerName = makePathsRelative(this.context, compilerName, this.root);\n\n      if (!this.records[relativeCompilerName]) {\n        this.records[relativeCompilerName] = [];\n      }\n\n      if (this.records[relativeCompilerName][compilerIndex]) {\n        childCompiler.records = this.records[relativeCompilerName][compilerIndex];\n      } else {\n        this.records[relativeCompilerName].push(childCompiler.records = {});\n      }\n\n      childCompiler.parentCompilation = compilation;\n      childCompiler.root = this.root;\n\n      if (Array.isArray(plugins)) {\n        var _iterator7 = _createForOfIteratorHelper(plugins),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var plugin = _step7.value;\n            plugin.apply(childCompiler);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      }\n\n      for (var name in this.hooks) {\n        if (![\"make\", \"compile\", \"emit\", \"afterEmit\", \"invalid\", \"done\", \"thisCompilation\"].includes(name)) {\n          if (childCompiler.hooks[name]) {\n            childCompiler.hooks[name].taps = this.hooks[name].taps.slice();\n          }\n        }\n      }\n\n      compilation.hooks.childCompiler.call(childCompiler, compilerName, compilerIndex);\n      return childCompiler;\n    }\n  }, {\n    key: \"isChild\",\n    value: function isChild() {\n      return !!this.parentCompilation;\n    }\n  }, {\n    key: \"createCompilation\",\n    value: function createCompilation(params) {\n      this._cleanupLastCompilation();\n\n      return this._lastCompilation = new Compilation(this, params);\n    }\n    /**\n     * @param {CompilationParams} params the compilation parameters\n     * @returns {Compilation} the created compilation\n     */\n\n  }, {\n    key: \"newCompilation\",\n    value: function newCompilation(params) {\n      var compilation = this.createCompilation(params);\n      compilation.name = this.name;\n      compilation.records = this.records;\n      this.hooks.thisCompilation.call(compilation, params);\n      this.hooks.compilation.call(compilation, params);\n      return compilation;\n    }\n  }, {\n    key: \"createNormalModuleFactory\",\n    value: function createNormalModuleFactory() {\n      this._cleanupLastNormalModuleFactory();\n\n      var normalModuleFactory = new NormalModuleFactory({\n        context: this.options.context,\n        fs: this.inputFileSystem,\n        resolverFactory: this.resolverFactory,\n        options: this.options.module,\n        associatedObjectForCache: this.root,\n        layers: this.options.experiments.layers\n      });\n      this._lastNormalModuleFactory = normalModuleFactory;\n      this.hooks.normalModuleFactory.call(normalModuleFactory);\n      return normalModuleFactory;\n    }\n  }, {\n    key: \"createContextModuleFactory\",\n    value: function createContextModuleFactory() {\n      var contextModuleFactory = new ContextModuleFactory(this.resolverFactory);\n      this.hooks.contextModuleFactory.call(contextModuleFactory);\n      return contextModuleFactory;\n    }\n  }, {\n    key: \"newCompilationParams\",\n    value: function newCompilationParams() {\n      var params = {\n        normalModuleFactory: this.createNormalModuleFactory(),\n        contextModuleFactory: this.createContextModuleFactory()\n      };\n      return params;\n    }\n    /**\n     * @param {Callback<Compilation>} callback signals when the compilation finishes\n     * @returns {void}\n     */\n\n  }, {\n    key: \"compile\",\n    value: function compile(callback) {\n      var _this9 = this;\n\n      var params = this.newCompilationParams();\n      this.hooks.beforeCompile.callAsync(params, function (err) {\n        if (err) return callback(err);\n\n        _this9.hooks.compile.call(params);\n\n        var compilation = _this9.newCompilation(params);\n\n        var logger = compilation.getLogger(\"webpack.Compiler\");\n        logger.time(\"make hook\");\n\n        _this9.hooks.make.callAsync(compilation, function (err) {\n          logger.timeEnd(\"make hook\");\n          if (err) return callback(err);\n          logger.time(\"finish make hook\");\n\n          _this9.hooks.finishMake.callAsync(compilation, function (err) {\n            logger.timeEnd(\"finish make hook\");\n            if (err) return callback(err);\n            process.nextTick(function () {\n              logger.time(\"finish compilation\");\n              compilation.finish(function (err) {\n                logger.timeEnd(\"finish compilation\");\n                if (err) return callback(err);\n                logger.time(\"seal compilation\");\n                compilation.seal(function (err) {\n                  logger.timeEnd(\"seal compilation\");\n                  if (err) return callback(err);\n                  logger.time(\"afterCompile hook\");\n\n                  _this9.hooks.afterCompile.callAsync(compilation, function (err) {\n                    logger.timeEnd(\"afterCompile hook\");\n                    if (err) return callback(err);\n                    return callback(null, compilation);\n                  });\n                });\n              });\n            });\n          });\n        });\n      });\n    }\n    /**\n     * @param {Callback<void>} callback signals when the compiler closes\n     * @returns {void}\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(callback) {\n      var _this10 = this;\n\n      if (this.watching) {\n        // When there is still an active watching, close this first\n        this.watching.close(function (err) {\n          _this10.close(callback);\n        });\n        return;\n      }\n\n      this.hooks.shutdown.callAsync(function (err) {\n        if (err) return callback(err); // Get rid of reference to last compilation to avoid leaking memory\n        // We can't run this._cleanupLastCompilation() as the Stats to this compilation\n        // might be still in use. We try to get rid of the reference to the cache instead.\n\n        _this10._lastCompilation = undefined;\n        _this10._lastNormalModuleFactory = undefined;\n\n        _this10.cache.shutdown(callback);\n      });\n    }\n  }]);\n\n  return Compiler;\n}();\n\nmodule.exports = Compiler;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/Compiler.js"],"names":["parseJson","require","asyncLib","SyncHook","SyncBailHook","AsyncParallelHook","AsyncSeriesHook","SizeOnlySource","webpack","Cache","CacheFacade","ChunkGraph","Compilation","ConcurrentCompilationError","ContextModuleFactory","ModuleGraph","NormalModuleFactory","RequestShortener","ResolverFactory","Stats","Watching","WebpackError","Logger","join","dirname","mkdirp","makePathsRelative","isSourceEqual","isSorted","array","i","length","sortObject","obj","keys","o","sort","k","includesHash","filename","hashes","Array","isArray","some","hash","includes","Compiler","context","options","hooks","Object","freeze","initialize","shouldEmit","done","afterDone","additionalPass","beforeRun","run","emit","assetEmitted","afterEmit","thisCompilation","compilation","normalModuleFactory","contextModuleFactory","beforeCompile","compile","make","finishMake","afterCompile","readRecords","emitRecords","watchRun","failed","invalid","watchClose","shutdown","infrastructureLog","environment","afterEnvironment","afterPlugins","afterResolvers","entryOption","name","undefined","parentCompilation","root","outputPath","watching","outputFileSystem","intermediateFileSystem","inputFileSystem","watchFileSystem","recordsInputPath","recordsOutputPath","records","managedPaths","Set","immutablePaths","modifiedFiles","removedFiles","fileTimestamps","contextTimestamps","fsStartTime","resolverFactory","infrastructureLogger","requestShortener","cache","moduleMemCaches","compilerPath","running","idle","watchMode","_backCompat","experiments","backCompat","_lastCompilation","_lastNormalModuleFactory","_assetEmittingSourceCache","WeakMap","_assetEmittingWrittenFiles","Map","_assetEmittingPreviousFiles","output","hashFunction","TypeError","type","args","call","childName","getInfrastructureLogger","modules","module","clearChunkGraphForModule","clearModuleGraphForModule","cleanupForCache","chunks","chunk","clearChunkGraphForChunk","watchOptions","handler","callback","logger","finalCallback","err","stats","time","beginIdle","timeEnd","startTime","Date","now","onCompiled","endTime","callAsync","process","nextTick","getLogger","emitAssets","needAdditionalPass","storeBuildDependencies","buildDependencies","endIdle","children","push","getAssets","source","info","emitAsset","entries","entrypoints","values","ep","purge","emitFiles","assets","caseInsensitiveMap","allTargetPaths","forEachLimit","file","targetFile","immutable","queryStringIdx","indexOf","substr","contenthash","chunkhash","modulehash","fullhash","writeOut","targetPath","add","targetFileGeneration","get","cacheEntry","sizeOnlySource","writtenTo","set","similarEntry","checkSimilarFile","caseInsensitiveTargetPath","toLowerCase","other","path","otherSource","size","updateWithReplacementSource","waiting","alreadyWritten","getContent","buffer","bufferOrString","Buffer","isBuffer","from","newGeneration","doWrite","content","writeFile","emittedAssets","updateFileWithReplacementSource","updateAsset","processExistingFile","comparedForEmitAssets","readFile","existingContent","equals","processMissingFile","writtenGeneration","has","compareBeforeEmit","stat","exists","isFile","match","fs","dir","clear","getPath","isUsed","parallel","cb","_emitRecords","bind","JSON","stringify","n","value","recordsOutputPathDirectory","_readRecords","toString","e","message","compilerName","compilerIndex","outputOptions","plugins","childCompiler","relativeCompilerName","plugin","apply","taps","slice","params","_cleanupLastCompilation","createCompilation","_cleanupLastNormalModuleFactory","associatedObjectForCache","layers","createNormalModuleFactory","createContextModuleFactory","newCompilationParams","newCompilation","finish","seal","close","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst parseJson = require(\"json-parse-better-errors\");\nconst asyncLib = require(\"neo-async\");\nconst {\n\tSyncHook,\n\tSyncBailHook,\n\tAsyncParallelHook,\n\tAsyncSeriesHook\n} = require(\"tapable\");\nconst { SizeOnlySource } = require(\"webpack-sources\");\nconst webpack = require(\"./\");\nconst Cache = require(\"./Cache\");\nconst CacheFacade = require(\"./CacheFacade\");\nconst ChunkGraph = require(\"./ChunkGraph\");\nconst Compilation = require(\"./Compilation\");\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\nconst ContextModuleFactory = require(\"./ContextModuleFactory\");\nconst ModuleGraph = require(\"./ModuleGraph\");\nconst NormalModuleFactory = require(\"./NormalModuleFactory\");\nconst RequestShortener = require(\"./RequestShortener\");\nconst ResolverFactory = require(\"./ResolverFactory\");\nconst Stats = require(\"./Stats\");\nconst Watching = require(\"./Watching\");\nconst WebpackError = require(\"./WebpackError\");\nconst { Logger } = require(\"./logging/Logger\");\nconst { join, dirname, mkdirp } = require(\"./util/fs\");\nconst { makePathsRelative } = require(\"./util/identifier\");\nconst { isSourceEqual } = require(\"./util/source\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../declarations/WebpackOptions\").EntryNormalized} Entry */\n/** @typedef {import(\"../declarations/WebpackOptions\").OutputNormalized} OutputOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").WatchOptions} WatchOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackOptionsNormalized} WebpackOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackPluginInstance} WebpackPluginInstance */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./FileSystemInfo\").FileSystemInfoEntry} FileSystemInfoEntry */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./util/WeakTupleMap\")} WeakTupleMap */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n/** @typedef {import(\"./util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n/** @typedef {import(\"./util/fs\").WatchFileSystem} WatchFileSystem */\n\n/**\n * @typedef {Object} CompilationParams\n * @property {NormalModuleFactory} normalModuleFactory\n * @property {ContextModuleFactory} contextModuleFactory\n */\n\n/**\n * @template T\n * @callback Callback\n * @param {(Error | null)=} err\n * @param {T=} result\n */\n\n/**\n * @callback RunAsChildCallback\n * @param {(Error | null)=} err\n * @param {Chunk[]=} entries\n * @param {Compilation=} compilation\n */\n\n/**\n * @typedef {Object} AssetEmittedInfo\n * @property {Buffer} content\n * @property {Source} source\n * @property {Compilation} compilation\n * @property {string} outputPath\n * @property {string} targetPath\n */\n\n/**\n * @param {string[]} array an array\n * @returns {boolean} true, if the array is sorted\n */\nconst isSorted = array => {\n\tfor (let i = 1; i < array.length; i++) {\n\t\tif (array[i - 1] > array[i]) return false;\n\t}\n\treturn true;\n};\n\n/**\n * @param {Object} obj an object\n * @param {string[]} keys the keys of the object\n * @returns {Object} the object with properties sorted by property name\n */\nconst sortObject = (obj, keys) => {\n\tconst o = {};\n\tfor (const k of keys.sort()) {\n\t\to[k] = obj[k];\n\t}\n\treturn o;\n};\n\n/**\n * @param {string} filename filename\n * @param {string | string[] | undefined} hashes list of hashes\n * @returns {boolean} true, if the filename contains any hash\n */\nconst includesHash = (filename, hashes) => {\n\tif (!hashes) return false;\n\tif (Array.isArray(hashes)) {\n\t\treturn hashes.some(hash => filename.includes(hash));\n\t} else {\n\t\treturn filename.includes(hashes);\n\t}\n};\n\nclass Compiler {\n\t/**\n\t * @param {string} context the compilation path\n\t * @param {WebpackOptions} options options\n\t */\n\tconstructor(context, options = /** @type {WebpackOptions} */ ({})) {\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\tinitialize: new SyncHook([]),\n\n\t\t\t/** @type {SyncBailHook<[Compilation], boolean>} */\n\t\t\tshouldEmit: new SyncBailHook([\"compilation\"]),\n\t\t\t/** @type {AsyncSeriesHook<[Stats]>} */\n\t\t\tdone: new AsyncSeriesHook([\"stats\"]),\n\t\t\t/** @type {SyncHook<[Stats]>} */\n\t\t\tafterDone: new SyncHook([\"stats\"]),\n\t\t\t/** @type {AsyncSeriesHook<[]>} */\n\t\t\tadditionalPass: new AsyncSeriesHook([]),\n\t\t\t/** @type {AsyncSeriesHook<[Compiler]>} */\n\t\t\tbeforeRun: new AsyncSeriesHook([\"compiler\"]),\n\t\t\t/** @type {AsyncSeriesHook<[Compiler]>} */\n\t\t\trun: new AsyncSeriesHook([\"compiler\"]),\n\t\t\t/** @type {AsyncSeriesHook<[Compilation]>} */\n\t\t\temit: new AsyncSeriesHook([\"compilation\"]),\n\t\t\t/** @type {AsyncSeriesHook<[string, AssetEmittedInfo]>} */\n\t\t\tassetEmitted: new AsyncSeriesHook([\"file\", \"info\"]),\n\t\t\t/** @type {AsyncSeriesHook<[Compilation]>} */\n\t\t\tafterEmit: new AsyncSeriesHook([\"compilation\"]),\n\n\t\t\t/** @type {SyncHook<[Compilation, CompilationParams]>} */\n\t\t\tthisCompilation: new SyncHook([\"compilation\", \"params\"]),\n\t\t\t/** @type {SyncHook<[Compilation, CompilationParams]>} */\n\t\t\tcompilation: new SyncHook([\"compilation\", \"params\"]),\n\t\t\t/** @type {SyncHook<[NormalModuleFactory]>} */\n\t\t\tnormalModuleFactory: new SyncHook([\"normalModuleFactory\"]),\n\t\t\t/** @type {SyncHook<[ContextModuleFactory]>}  */\n\t\t\tcontextModuleFactory: new SyncHook([\"contextModuleFactory\"]),\n\n\t\t\t/** @type {AsyncSeriesHook<[CompilationParams]>} */\n\t\t\tbeforeCompile: new AsyncSeriesHook([\"params\"]),\n\t\t\t/** @type {SyncHook<[CompilationParams]>} */\n\t\t\tcompile: new SyncHook([\"params\"]),\n\t\t\t/** @type {AsyncParallelHook<[Compilation]>} */\n\t\t\tmake: new AsyncParallelHook([\"compilation\"]),\n\t\t\t/** @type {AsyncParallelHook<[Compilation]>} */\n\t\t\tfinishMake: new AsyncSeriesHook([\"compilation\"]),\n\t\t\t/** @type {AsyncSeriesHook<[Compilation]>} */\n\t\t\tafterCompile: new AsyncSeriesHook([\"compilation\"]),\n\n\t\t\t/** @type {AsyncSeriesHook<[]>} */\n\t\t\treadRecords: new AsyncSeriesHook([]),\n\t\t\t/** @type {AsyncSeriesHook<[]>} */\n\t\t\temitRecords: new AsyncSeriesHook([]),\n\n\t\t\t/** @type {AsyncSeriesHook<[Compiler]>} */\n\t\t\twatchRun: new AsyncSeriesHook([\"compiler\"]),\n\t\t\t/** @type {SyncHook<[Error]>} */\n\t\t\tfailed: new SyncHook([\"error\"]),\n\t\t\t/** @type {SyncHook<[string | null, number]>} */\n\t\t\tinvalid: new SyncHook([\"filename\", \"changeTime\"]),\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\twatchClose: new SyncHook([]),\n\t\t\t/** @type {AsyncSeriesHook<[]>} */\n\t\t\tshutdown: new AsyncSeriesHook([]),\n\n\t\t\t/** @type {SyncBailHook<[string, string, any[]], true>} */\n\t\t\tinfrastructureLog: new SyncBailHook([\"origin\", \"type\", \"args\"]),\n\n\t\t\t// TODO the following hooks are weirdly located here\n\t\t\t// TODO move them for webpack 5\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\tenvironment: new SyncHook([]),\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\tafterEnvironment: new SyncHook([]),\n\t\t\t/** @type {SyncHook<[Compiler]>} */\n\t\t\tafterPlugins: new SyncHook([\"compiler\"]),\n\t\t\t/** @type {SyncHook<[Compiler]>} */\n\t\t\tafterResolvers: new SyncHook([\"compiler\"]),\n\t\t\t/** @type {SyncBailHook<[string, Entry], boolean>} */\n\t\t\tentryOption: new SyncBailHook([\"context\", \"entry\"])\n\t\t});\n\n\t\tthis.webpack = webpack;\n\n\t\t/** @type {string=} */\n\t\tthis.name = undefined;\n\t\t/** @type {Compilation=} */\n\t\tthis.parentCompilation = undefined;\n\t\t/** @type {Compiler} */\n\t\tthis.root = this;\n\t\t/** @type {string} */\n\t\tthis.outputPath = \"\";\n\t\t/** @type {Watching} */\n\t\tthis.watching = undefined;\n\n\t\t/** @type {OutputFileSystem} */\n\t\tthis.outputFileSystem = null;\n\t\t/** @type {IntermediateFileSystem} */\n\t\tthis.intermediateFileSystem = null;\n\t\t/** @type {InputFileSystem} */\n\t\tthis.inputFileSystem = null;\n\t\t/** @type {WatchFileSystem} */\n\t\tthis.watchFileSystem = null;\n\n\t\t/** @type {string|null} */\n\t\tthis.recordsInputPath = null;\n\t\t/** @type {string|null} */\n\t\tthis.recordsOutputPath = null;\n\t\tthis.records = {};\n\t\t/** @type {Set<string | RegExp>} */\n\t\tthis.managedPaths = new Set();\n\t\t/** @type {Set<string | RegExp>} */\n\t\tthis.immutablePaths = new Set();\n\n\t\t/** @type {ReadonlySet<string>} */\n\t\tthis.modifiedFiles = undefined;\n\t\t/** @type {ReadonlySet<string>} */\n\t\tthis.removedFiles = undefined;\n\t\t/** @type {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} */\n\t\tthis.fileTimestamps = undefined;\n\t\t/** @type {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} */\n\t\tthis.contextTimestamps = undefined;\n\t\t/** @type {number} */\n\t\tthis.fsStartTime = undefined;\n\n\t\t/** @type {ResolverFactory} */\n\t\tthis.resolverFactory = new ResolverFactory();\n\n\t\tthis.infrastructureLogger = undefined;\n\n\t\tthis.options = options;\n\n\t\tthis.context = context;\n\n\t\tthis.requestShortener = new RequestShortener(context, this.root);\n\n\t\tthis.cache = new Cache();\n\n\t\t/** @type {Map<Module, { buildInfo: object, references: WeakMap<Dependency, Module>, memCache: WeakTupleMap }> | undefined} */\n\t\tthis.moduleMemCaches = undefined;\n\n\t\tthis.compilerPath = \"\";\n\n\t\t/** @type {boolean} */\n\t\tthis.running = false;\n\n\t\t/** @type {boolean} */\n\t\tthis.idle = false;\n\n\t\t/** @type {boolean} */\n\t\tthis.watchMode = false;\n\n\t\tthis._backCompat = this.options.experiments.backCompat !== false;\n\n\t\t/** @type {Compilation} */\n\t\tthis._lastCompilation = undefined;\n\t\t/** @type {NormalModuleFactory} */\n\t\tthis._lastNormalModuleFactory = undefined;\n\n\t\t/** @private @type {WeakMap<Source, { sizeOnlySource: SizeOnlySource, writtenTo: Map<string, number> }>} */\n\t\tthis._assetEmittingSourceCache = new WeakMap();\n\t\t/** @private @type {Map<string, number>} */\n\t\tthis._assetEmittingWrittenFiles = new Map();\n\t\t/** @private @type {Set<string>} */\n\t\tthis._assetEmittingPreviousFiles = new Set();\n\t}\n\n\t/**\n\t * @param {string} name cache name\n\t * @returns {CacheFacade} the cache facade instance\n\t */\n\tgetCache(name) {\n\t\treturn new CacheFacade(\n\t\t\tthis.cache,\n\t\t\t`${this.compilerPath}${name}`,\n\t\t\tthis.options.output.hashFunction\n\t\t);\n\t}\n\n\t/**\n\t * @param {string | (function(): string)} name name of the logger, or function called once to get the logger name\n\t * @returns {Logger} a logger with that name\n\t */\n\tgetInfrastructureLogger(name) {\n\t\tif (!name) {\n\t\t\tthrow new TypeError(\n\t\t\t\t\"Compiler.getInfrastructureLogger(name) called without a name\"\n\t\t\t);\n\t\t}\n\t\treturn new Logger(\n\t\t\t(type, args) => {\n\t\t\t\tif (typeof name === \"function\") {\n\t\t\t\t\tname = name();\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\t\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.hooks.infrastructureLog.call(name, type, args) === undefined) {\n\t\t\t\t\tif (this.infrastructureLogger !== undefined) {\n\t\t\t\t\t\tthis.infrastructureLogger(name, type, args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tchildName => {\n\t\t\t\tif (typeof name === \"function\") {\n\t\t\t\t\tif (typeof childName === \"function\") {\n\t\t\t\t\t\treturn this.getInfrastructureLogger(() => {\n\t\t\t\t\t\t\tif (typeof name === \"function\") {\n\t\t\t\t\t\t\t\tname = name();\n\t\t\t\t\t\t\t\tif (!name) {\n\t\t\t\t\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\t\t\t\t\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (typeof childName === \"function\") {\n\t\t\t\t\t\t\t\tchildName = childName();\n\t\t\t\t\t\t\t\tif (!childName) {\n\t\t\t\t\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\t\t\t\t\"Logger.getChildLogger(name) called with a function not returning a name\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn `${name}/${childName}`;\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this.getInfrastructureLogger(() => {\n\t\t\t\t\t\t\tif (typeof name === \"function\") {\n\t\t\t\t\t\t\t\tname = name();\n\t\t\t\t\t\t\t\tif (!name) {\n\t\t\t\t\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\t\t\t\t\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn `${name}/${childName}`;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (typeof childName === \"function\") {\n\t\t\t\t\t\treturn this.getInfrastructureLogger(() => {\n\t\t\t\t\t\t\tif (typeof childName === \"function\") {\n\t\t\t\t\t\t\t\tchildName = childName();\n\t\t\t\t\t\t\t\tif (!childName) {\n\t\t\t\t\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\t\t\t\t\"Logger.getChildLogger(name) called with a function not returning a name\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn `${name}/${childName}`;\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this.getInfrastructureLogger(`${name}/${childName}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\n\t// TODO webpack 6: solve this in a better way\n\t// e.g. move compilation specific info from Modules into ModuleGraph\n\t_cleanupLastCompilation() {\n\t\tif (this._lastCompilation !== undefined) {\n\t\t\tfor (const module of this._lastCompilation.modules) {\n\t\t\t\tChunkGraph.clearChunkGraphForModule(module);\n\t\t\t\tModuleGraph.clearModuleGraphForModule(module);\n\t\t\t\tmodule.cleanupForCache();\n\t\t\t}\n\t\t\tfor (const chunk of this._lastCompilation.chunks) {\n\t\t\t\tChunkGraph.clearChunkGraphForChunk(chunk);\n\t\t\t}\n\t\t\tthis._lastCompilation = undefined;\n\t\t}\n\t}\n\n\t// TODO webpack 6: solve this in a better way\n\t_cleanupLastNormalModuleFactory() {\n\t\tif (this._lastNormalModuleFactory !== undefined) {\n\t\t\tthis._lastNormalModuleFactory.cleanupForCache();\n\t\t\tthis._lastNormalModuleFactory = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {WatchOptions} watchOptions the watcher's options\n\t * @param {Callback<Stats>} handler signals when the call finishes\n\t * @returns {Watching} a compiler watcher\n\t */\n\twatch(watchOptions, handler) {\n\t\tif (this.running) {\n\t\t\treturn handler(new ConcurrentCompilationError());\n\t\t}\n\n\t\tthis.running = true;\n\t\tthis.watchMode = true;\n\t\tthis.watching = new Watching(this, watchOptions, handler);\n\t\treturn this.watching;\n\t}\n\n\t/**\n\t * @param {Callback<Stats>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\trun(callback) {\n\t\tif (this.running) {\n\t\t\treturn callback(new ConcurrentCompilationError());\n\t\t}\n\n\t\tlet logger;\n\n\t\tconst finalCallback = (err, stats) => {\n\t\t\tif (logger) logger.time(\"beginIdle\");\n\t\t\tthis.idle = true;\n\t\t\tthis.cache.beginIdle();\n\t\t\tthis.idle = true;\n\t\t\tif (logger) logger.timeEnd(\"beginIdle\");\n\t\t\tthis.running = false;\n\t\t\tif (err) {\n\t\t\t\tthis.hooks.failed.call(err);\n\t\t\t}\n\t\t\tif (callback !== undefined) callback(err, stats);\n\t\t\tthis.hooks.afterDone.call(stats);\n\t\t};\n\n\t\tconst startTime = Date.now();\n\n\t\tthis.running = true;\n\n\t\tconst onCompiled = (err, compilation) => {\n\t\t\tif (err) return finalCallback(err);\n\n\t\t\tif (this.hooks.shouldEmit.call(compilation) === false) {\n\t\t\t\tcompilation.startTime = startTime;\n\t\t\t\tcompilation.endTime = Date.now();\n\t\t\t\tconst stats = new Stats(compilation);\n\t\t\t\tthis.hooks.done.callAsync(stats, err => {\n\t\t\t\t\tif (err) return finalCallback(err);\n\t\t\t\t\treturn finalCallback(null, stats);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tprocess.nextTick(() => {\n\t\t\t\tlogger = compilation.getLogger(\"webpack.Compiler\");\n\t\t\t\tlogger.time(\"emitAssets\");\n\t\t\t\tthis.emitAssets(compilation, err => {\n\t\t\t\t\tlogger.timeEnd(\"emitAssets\");\n\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\tif (compilation.hooks.needAdditionalPass.call()) {\n\t\t\t\t\t\tcompilation.needAdditionalPass = true;\n\n\t\t\t\t\t\tcompilation.startTime = startTime;\n\t\t\t\t\t\tcompilation.endTime = Date.now();\n\t\t\t\t\t\tlogger.time(\"done hook\");\n\t\t\t\t\t\tconst stats = new Stats(compilation);\n\t\t\t\t\t\tthis.hooks.done.callAsync(stats, err => {\n\t\t\t\t\t\t\tlogger.timeEnd(\"done hook\");\n\t\t\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\t\t\tthis.hooks.additionalPass.callAsync(err => {\n\t\t\t\t\t\t\t\tif (err) return finalCallback(err);\n\t\t\t\t\t\t\t\tthis.compile(onCompiled);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tlogger.time(\"emitRecords\");\n\t\t\t\t\tthis.emitRecords(err => {\n\t\t\t\t\t\tlogger.timeEnd(\"emitRecords\");\n\t\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\t\tcompilation.startTime = startTime;\n\t\t\t\t\t\tcompilation.endTime = Date.now();\n\t\t\t\t\t\tlogger.time(\"done hook\");\n\t\t\t\t\t\tconst stats = new Stats(compilation);\n\t\t\t\t\t\tthis.hooks.done.callAsync(stats, err => {\n\t\t\t\t\t\t\tlogger.timeEnd(\"done hook\");\n\t\t\t\t\t\t\tif (err) return finalCallback(err);\n\t\t\t\t\t\t\tthis.cache.storeBuildDependencies(\n\t\t\t\t\t\t\t\tcompilation.buildDependencies,\n\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\tif (err) return finalCallback(err);\n\t\t\t\t\t\t\t\t\treturn finalCallback(null, stats);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\tconst run = () => {\n\t\t\tthis.hooks.beforeRun.callAsync(this, err => {\n\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\tthis.hooks.run.callAsync(this, err => {\n\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\tthis.readRecords(err => {\n\t\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\t\tthis.compile(onCompiled);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\tif (this.idle) {\n\t\t\tthis.cache.endIdle(err => {\n\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\tthis.idle = false;\n\t\t\t\trun();\n\t\t\t});\n\t\t} else {\n\t\t\trun();\n\t\t}\n\t}\n\n\t/**\n\t * @param {RunAsChildCallback} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\trunAsChild(callback) {\n\t\tconst startTime = Date.now();\n\t\tthis.compile((err, compilation) => {\n\t\t\tif (err) return callback(err);\n\n\t\t\tthis.parentCompilation.children.push(compilation);\n\t\t\tfor (const { name, source, info } of compilation.getAssets()) {\n\t\t\t\tthis.parentCompilation.emitAsset(name, source, info);\n\t\t\t}\n\n\t\t\tconst entries = [];\n\t\t\tfor (const ep of compilation.entrypoints.values()) {\n\t\t\t\tentries.push(...ep.chunks);\n\t\t\t}\n\n\t\t\tcompilation.startTime = startTime;\n\t\t\tcompilation.endTime = Date.now();\n\n\t\t\treturn callback(null, entries, compilation);\n\t\t});\n\t}\n\n\tpurgeInputFileSystem() {\n\t\tif (this.inputFileSystem && this.inputFileSystem.purge) {\n\t\t\tthis.inputFileSystem.purge();\n\t\t}\n\t}\n\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @param {Callback<void>} callback signals when the assets are emitted\n\t * @returns {void}\n\t */\n\temitAssets(compilation, callback) {\n\t\tlet outputPath;\n\n\t\tconst emitFiles = err => {\n\t\t\tif (err) return callback(err);\n\n\t\t\tconst assets = compilation.getAssets();\n\t\t\tcompilation.assets = { ...compilation.assets };\n\t\t\t/** @type {Map<string, { path: string, source: Source, size: number, waiting: { cacheEntry: any, file: string }[] }>} */\n\t\t\tconst caseInsensitiveMap = new Map();\n\t\t\t/** @type {Set<string>} */\n\t\t\tconst allTargetPaths = new Set();\n\t\t\tasyncLib.forEachLimit(\n\t\t\t\tassets,\n\t\t\t\t15,\n\t\t\t\t({ name: file, source, info }, callback) => {\n\t\t\t\t\tlet targetFile = file;\n\t\t\t\t\tlet immutable = info.immutable;\n\t\t\t\t\tconst queryStringIdx = targetFile.indexOf(\"?\");\n\t\t\t\t\tif (queryStringIdx >= 0) {\n\t\t\t\t\t\ttargetFile = targetFile.substr(0, queryStringIdx);\n\t\t\t\t\t\t// We may remove the hash, which is in the query string\n\t\t\t\t\t\t// So we recheck if the file is immutable\n\t\t\t\t\t\t// This doesn't cover all cases, but immutable is only a performance optimization anyway\n\t\t\t\t\t\timmutable =\n\t\t\t\t\t\t\timmutable &&\n\t\t\t\t\t\t\t(includesHash(targetFile, info.contenthash) ||\n\t\t\t\t\t\t\t\tincludesHash(targetFile, info.chunkhash) ||\n\t\t\t\t\t\t\t\tincludesHash(targetFile, info.modulehash) ||\n\t\t\t\t\t\t\t\tincludesHash(targetFile, info.fullhash));\n\t\t\t\t\t}\n\n\t\t\t\t\tconst writeOut = err => {\n\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\tconst targetPath = join(\n\t\t\t\t\t\t\tthis.outputFileSystem,\n\t\t\t\t\t\t\toutputPath,\n\t\t\t\t\t\t\ttargetFile\n\t\t\t\t\t\t);\n\t\t\t\t\t\tallTargetPaths.add(targetPath);\n\n\t\t\t\t\t\t// check if the target file has already been written by this Compiler\n\t\t\t\t\t\tconst targetFileGeneration =\n\t\t\t\t\t\t\tthis._assetEmittingWrittenFiles.get(targetPath);\n\n\t\t\t\t\t\t// create an cache entry for this Source if not already existing\n\t\t\t\t\t\tlet cacheEntry = this._assetEmittingSourceCache.get(source);\n\t\t\t\t\t\tif (cacheEntry === undefined) {\n\t\t\t\t\t\t\tcacheEntry = {\n\t\t\t\t\t\t\t\tsizeOnlySource: undefined,\n\t\t\t\t\t\t\t\twrittenTo: new Map()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tthis._assetEmittingSourceCache.set(source, cacheEntry);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet similarEntry;\n\n\t\t\t\t\t\tconst checkSimilarFile = () => {\n\t\t\t\t\t\t\tconst caseInsensitiveTargetPath = targetPath.toLowerCase();\n\t\t\t\t\t\t\tsimilarEntry = caseInsensitiveMap.get(caseInsensitiveTargetPath);\n\t\t\t\t\t\t\tif (similarEntry !== undefined) {\n\t\t\t\t\t\t\t\tconst { path: other, source: otherSource } = similarEntry;\n\t\t\t\t\t\t\t\tif (isSourceEqual(otherSource, source)) {\n\t\t\t\t\t\t\t\t\t// Size may or may not be available at this point.\n\t\t\t\t\t\t\t\t\t// If it's not available add to \"waiting\" list and it will be updated once available\n\t\t\t\t\t\t\t\t\tif (similarEntry.size !== undefined) {\n\t\t\t\t\t\t\t\t\t\tupdateWithReplacementSource(similarEntry.size);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif (!similarEntry.waiting) similarEntry.waiting = [];\n\t\t\t\t\t\t\t\t\t\tsimilarEntry.waiting.push({ file, cacheEntry });\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\talreadyWritten();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst err =\n\t\t\t\t\t\t\t\t\t\tnew WebpackError(`Prevent writing to file that only differs in casing or query string from already written file.\nThis will lead to a race-condition and corrupted files on case-insensitive file systems.\n${targetPath}\n${other}`);\n\t\t\t\t\t\t\t\t\terr.file = file;\n\t\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcaseInsensitiveMap.set(\n\t\t\t\t\t\t\t\t\tcaseInsensitiveTargetPath,\n\t\t\t\t\t\t\t\t\t(similarEntry = {\n\t\t\t\t\t\t\t\t\t\tpath: targetPath,\n\t\t\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\t\t\tsize: undefined,\n\t\t\t\t\t\t\t\t\t\twaiting: undefined\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * get the binary (Buffer) content from the Source\n\t\t\t\t\t\t * @returns {Buffer} content for the source\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst getContent = () => {\n\t\t\t\t\t\t\tif (typeof source.buffer === \"function\") {\n\t\t\t\t\t\t\t\treturn source.buffer();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst bufferOrString = source.source();\n\t\t\t\t\t\t\t\tif (Buffer.isBuffer(bufferOrString)) {\n\t\t\t\t\t\t\t\t\treturn bufferOrString;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn Buffer.from(bufferOrString, \"utf8\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst alreadyWritten = () => {\n\t\t\t\t\t\t\t// cache the information that the Source has been already been written to that location\n\t\t\t\t\t\t\tif (targetFileGeneration === undefined) {\n\t\t\t\t\t\t\t\tconst newGeneration = 1;\n\t\t\t\t\t\t\t\tthis._assetEmittingWrittenFiles.set(targetPath, newGeneration);\n\t\t\t\t\t\t\t\tcacheEntry.writtenTo.set(targetPath, newGeneration);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcacheEntry.writtenTo.set(targetPath, targetFileGeneration);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Write the file to output file system\n\t\t\t\t\t\t * @param {Buffer} content content to be written\n\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst doWrite = content => {\n\t\t\t\t\t\t\tthis.outputFileSystem.writeFile(targetPath, content, err => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\t// information marker that the asset has been emitted\n\t\t\t\t\t\t\t\tcompilation.emittedAssets.add(file);\n\n\t\t\t\t\t\t\t\t// cache the information that the Source has been written to that location\n\t\t\t\t\t\t\t\tconst newGeneration =\n\t\t\t\t\t\t\t\t\ttargetFileGeneration === undefined\n\t\t\t\t\t\t\t\t\t\t? 1\n\t\t\t\t\t\t\t\t\t\t: targetFileGeneration + 1;\n\t\t\t\t\t\t\t\tcacheEntry.writtenTo.set(targetPath, newGeneration);\n\t\t\t\t\t\t\t\tthis._assetEmittingWrittenFiles.set(targetPath, newGeneration);\n\t\t\t\t\t\t\t\tthis.hooks.assetEmitted.callAsync(\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tcontent,\n\t\t\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\t\t\toutputPath,\n\t\t\t\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\t\t\t\ttargetPath\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst updateWithReplacementSource = size => {\n\t\t\t\t\t\t\tupdateFileWithReplacementSource(file, cacheEntry, size);\n\t\t\t\t\t\t\tsimilarEntry.size = size;\n\t\t\t\t\t\t\tif (similarEntry.waiting !== undefined) {\n\t\t\t\t\t\t\t\tfor (const { file, cacheEntry } of similarEntry.waiting) {\n\t\t\t\t\t\t\t\t\tupdateFileWithReplacementSource(file, cacheEntry, size);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst updateFileWithReplacementSource = (\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\tcacheEntry,\n\t\t\t\t\t\t\tsize\n\t\t\t\t\t\t) => {\n\t\t\t\t\t\t\t// Create a replacement resource which only allows to ask for size\n\t\t\t\t\t\t\t// This allows to GC all memory allocated by the Source\n\t\t\t\t\t\t\t// (expect when the Source is stored in any other cache)\n\t\t\t\t\t\t\tif (!cacheEntry.sizeOnlySource) {\n\t\t\t\t\t\t\t\tcacheEntry.sizeOnlySource = new SizeOnlySource(size);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcompilation.updateAsset(file, cacheEntry.sizeOnlySource, {\n\t\t\t\t\t\t\t\tsize\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst processExistingFile = stats => {\n\t\t\t\t\t\t\t// skip emitting if it's already there and an immutable file\n\t\t\t\t\t\t\tif (immutable) {\n\t\t\t\t\t\t\t\tupdateWithReplacementSource(stats.size);\n\t\t\t\t\t\t\t\treturn alreadyWritten();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst content = getContent();\n\n\t\t\t\t\t\t\tupdateWithReplacementSource(content.length);\n\n\t\t\t\t\t\t\t// if it exists and content on disk matches content\n\t\t\t\t\t\t\t// skip writing the same content again\n\t\t\t\t\t\t\t// (to keep mtime and don't trigger watchers)\n\t\t\t\t\t\t\t// for a fast negative match file size is compared first\n\t\t\t\t\t\t\tif (content.length === stats.size) {\n\t\t\t\t\t\t\t\tcompilation.comparedForEmitAssets.add(file);\n\t\t\t\t\t\t\t\treturn this.outputFileSystem.readFile(\n\t\t\t\t\t\t\t\t\ttargetPath,\n\t\t\t\t\t\t\t\t\t(err, existingContent) => {\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\terr ||\n\t\t\t\t\t\t\t\t\t\t\t!content.equals(/** @type {Buffer} */ (existingContent))\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\treturn doWrite(content);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\treturn alreadyWritten();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn doWrite(content);\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst processMissingFile = () => {\n\t\t\t\t\t\t\tconst content = getContent();\n\n\t\t\t\t\t\t\tupdateWithReplacementSource(content.length);\n\n\t\t\t\t\t\t\treturn doWrite(content);\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// if the target file has already been written\n\t\t\t\t\t\tif (targetFileGeneration !== undefined) {\n\t\t\t\t\t\t\t// check if the Source has been written to this target file\n\t\t\t\t\t\t\tconst writtenGeneration = cacheEntry.writtenTo.get(targetPath);\n\t\t\t\t\t\t\tif (writtenGeneration === targetFileGeneration) {\n\t\t\t\t\t\t\t\t// if yes, we may skip writing the file\n\t\t\t\t\t\t\t\t// if it's already there\n\t\t\t\t\t\t\t\t// (we assume one doesn't modify files while the Compiler is running, other then removing them)\n\n\t\t\t\t\t\t\t\tif (this._assetEmittingPreviousFiles.has(targetPath)) {\n\t\t\t\t\t\t\t\t\t// We assume that assets from the last compilation say intact on disk (they are not removed)\n\t\t\t\t\t\t\t\t\tcompilation.updateAsset(file, cacheEntry.sizeOnlySource, {\n\t\t\t\t\t\t\t\t\t\tsize: cacheEntry.sizeOnlySource.size()\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Settings immutable will make it accept file content without comparing when file exist\n\t\t\t\t\t\t\t\t\timmutable = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (!immutable) {\n\t\t\t\t\t\t\t\tif (checkSimilarFile()) return;\n\t\t\t\t\t\t\t\t// We wrote to this file before which has very likely a different content\n\t\t\t\t\t\t\t\t// skip comparing and assume content is different for performance\n\t\t\t\t\t\t\t\t// This case happens often during watch mode.\n\t\t\t\t\t\t\t\treturn processMissingFile();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (checkSimilarFile()) return;\n\t\t\t\t\t\tif (this.options.output.compareBeforeEmit) {\n\t\t\t\t\t\t\tthis.outputFileSystem.stat(targetPath, (err, stats) => {\n\t\t\t\t\t\t\t\tconst exists = !err && stats.isFile();\n\n\t\t\t\t\t\t\t\tif (exists) {\n\t\t\t\t\t\t\t\t\tprocessExistingFile(stats);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tprocessMissingFile();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprocessMissingFile();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tif (targetFile.match(/\\/|\\\\/)) {\n\t\t\t\t\t\tconst fs = this.outputFileSystem;\n\t\t\t\t\t\tconst dir = dirname(fs, join(fs, outputPath, targetFile));\n\t\t\t\t\t\tmkdirp(fs, dir, writeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twriteOut();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\terr => {\n\t\t\t\t\t// Clear map to free up memory\n\t\t\t\t\tcaseInsensitiveMap.clear();\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tthis._assetEmittingPreviousFiles.clear();\n\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._assetEmittingPreviousFiles = allTargetPaths;\n\n\t\t\t\t\tthis.hooks.afterEmit.callAsync(compilation, err => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\treturn callback();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t);\n\t\t};\n\n\t\tthis.hooks.emit.callAsync(compilation, err => {\n\t\t\tif (err) return callback(err);\n\t\t\toutputPath = compilation.getPath(this.outputPath, {});\n\t\t\tmkdirp(this.outputFileSystem, outputPath, emitFiles);\n\t\t});\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\temitRecords(callback) {\n\t\tif (this.hooks.emitRecords.isUsed()) {\n\t\t\tif (this.recordsOutputPath) {\n\t\t\t\tasyncLib.parallel(\n\t\t\t\t\t[\n\t\t\t\t\t\tcb => this.hooks.emitRecords.callAsync(cb),\n\t\t\t\t\t\tthis._emitRecords.bind(this)\n\t\t\t\t\t],\n\t\t\t\t\terr => callback(err)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.hooks.emitRecords.callAsync(callback);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.recordsOutputPath) {\n\t\t\t\tthis._emitRecords(callback);\n\t\t\t} else {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\t_emitRecords(callback) {\n\t\tconst writeFile = () => {\n\t\t\tthis.outputFileSystem.writeFile(\n\t\t\t\tthis.recordsOutputPath,\n\t\t\t\tJSON.stringify(\n\t\t\t\t\tthis.records,\n\t\t\t\t\t(n, value) => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttypeof value === \"object\" &&\n\t\t\t\t\t\t\tvalue !== null &&\n\t\t\t\t\t\t\t!Array.isArray(value)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst keys = Object.keys(value);\n\t\t\t\t\t\t\tif (!isSorted(keys)) {\n\t\t\t\t\t\t\t\treturn sortObject(value, keys);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t},\n\t\t\t\t\t2\n\t\t\t\t),\n\t\t\t\tcallback\n\t\t\t);\n\t\t};\n\n\t\tconst recordsOutputPathDirectory = dirname(\n\t\t\tthis.outputFileSystem,\n\t\t\tthis.recordsOutputPath\n\t\t);\n\t\tif (!recordsOutputPathDirectory) {\n\t\t\treturn writeFile();\n\t\t}\n\t\tmkdirp(this.outputFileSystem, recordsOutputPathDirectory, err => {\n\t\t\tif (err) return callback(err);\n\t\t\twriteFile();\n\t\t});\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\treadRecords(callback) {\n\t\tif (this.hooks.readRecords.isUsed()) {\n\t\t\tif (this.recordsInputPath) {\n\t\t\t\tasyncLib.parallel([\n\t\t\t\t\tcb => this.hooks.readRecords.callAsync(cb),\n\t\t\t\t\tthis._readRecords.bind(this)\n\t\t\t\t]);\n\t\t\t} else {\n\t\t\t\tthis.records = {};\n\t\t\t\tthis.hooks.readRecords.callAsync(callback);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.recordsInputPath) {\n\t\t\t\tthis._readRecords(callback);\n\t\t\t} else {\n\t\t\t\tthis.records = {};\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\t_readRecords(callback) {\n\t\tif (!this.recordsInputPath) {\n\t\t\tthis.records = {};\n\t\t\treturn callback();\n\t\t}\n\t\tthis.inputFileSystem.stat(this.recordsInputPath, err => {\n\t\t\t// It doesn't exist\n\t\t\t// We can ignore this.\n\t\t\tif (err) return callback();\n\n\t\t\tthis.inputFileSystem.readFile(this.recordsInputPath, (err, content) => {\n\t\t\t\tif (err) return callback(err);\n\n\t\t\t\ttry {\n\t\t\t\t\tthis.records = parseJson(content.toString(\"utf-8\"));\n\t\t\t\t} catch (e) {\n\t\t\t\t\te.message = \"Cannot parse records: \" + e.message;\n\t\t\t\t\treturn callback(e);\n\t\t\t\t}\n\n\t\t\t\treturn callback();\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @param {string} compilerName the compiler's name\n\t * @param {number} compilerIndex the compiler's index\n\t * @param {OutputOptions=} outputOptions the output options\n\t * @param {WebpackPluginInstance[]=} plugins the plugins to apply\n\t * @returns {Compiler} a child compiler\n\t */\n\tcreateChildCompiler(\n\t\tcompilation,\n\t\tcompilerName,\n\t\tcompilerIndex,\n\t\toutputOptions,\n\t\tplugins\n\t) {\n\t\tconst childCompiler = new Compiler(this.context, {\n\t\t\t...this.options,\n\t\t\toutput: {\n\t\t\t\t...this.options.output,\n\t\t\t\t...outputOptions\n\t\t\t}\n\t\t});\n\t\tchildCompiler.name = compilerName;\n\t\tchildCompiler.outputPath = this.outputPath;\n\t\tchildCompiler.inputFileSystem = this.inputFileSystem;\n\t\tchildCompiler.outputFileSystem = null;\n\t\tchildCompiler.resolverFactory = this.resolverFactory;\n\t\tchildCompiler.modifiedFiles = this.modifiedFiles;\n\t\tchildCompiler.removedFiles = this.removedFiles;\n\t\tchildCompiler.fileTimestamps = this.fileTimestamps;\n\t\tchildCompiler.contextTimestamps = this.contextTimestamps;\n\t\tchildCompiler.fsStartTime = this.fsStartTime;\n\t\tchildCompiler.cache = this.cache;\n\t\tchildCompiler.compilerPath = `${this.compilerPath}${compilerName}|${compilerIndex}|`;\n\t\tchildCompiler._backCompat = this._backCompat;\n\n\t\tconst relativeCompilerName = makePathsRelative(\n\t\t\tthis.context,\n\t\t\tcompilerName,\n\t\t\tthis.root\n\t\t);\n\t\tif (!this.records[relativeCompilerName]) {\n\t\t\tthis.records[relativeCompilerName] = [];\n\t\t}\n\t\tif (this.records[relativeCompilerName][compilerIndex]) {\n\t\t\tchildCompiler.records = this.records[relativeCompilerName][compilerIndex];\n\t\t} else {\n\t\t\tthis.records[relativeCompilerName].push((childCompiler.records = {}));\n\t\t}\n\n\t\tchildCompiler.parentCompilation = compilation;\n\t\tchildCompiler.root = this.root;\n\t\tif (Array.isArray(plugins)) {\n\t\t\tfor (const plugin of plugins) {\n\t\t\t\tplugin.apply(childCompiler);\n\t\t\t}\n\t\t}\n\t\tfor (const name in this.hooks) {\n\t\t\tif (\n\t\t\t\t![\n\t\t\t\t\t\"make\",\n\t\t\t\t\t\"compile\",\n\t\t\t\t\t\"emit\",\n\t\t\t\t\t\"afterEmit\",\n\t\t\t\t\t\"invalid\",\n\t\t\t\t\t\"done\",\n\t\t\t\t\t\"thisCompilation\"\n\t\t\t\t].includes(name)\n\t\t\t) {\n\t\t\t\tif (childCompiler.hooks[name]) {\n\t\t\t\t\tchildCompiler.hooks[name].taps = this.hooks[name].taps.slice();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcompilation.hooks.childCompiler.call(\n\t\t\tchildCompiler,\n\t\t\tcompilerName,\n\t\t\tcompilerIndex\n\t\t);\n\n\t\treturn childCompiler;\n\t}\n\n\tisChild() {\n\t\treturn !!this.parentCompilation;\n\t}\n\n\tcreateCompilation(params) {\n\t\tthis._cleanupLastCompilation();\n\t\treturn (this._lastCompilation = new Compilation(this, params));\n\t}\n\n\t/**\n\t * @param {CompilationParams} params the compilation parameters\n\t * @returns {Compilation} the created compilation\n\t */\n\tnewCompilation(params) {\n\t\tconst compilation = this.createCompilation(params);\n\t\tcompilation.name = this.name;\n\t\tcompilation.records = this.records;\n\t\tthis.hooks.thisCompilation.call(compilation, params);\n\t\tthis.hooks.compilation.call(compilation, params);\n\t\treturn compilation;\n\t}\n\n\tcreateNormalModuleFactory() {\n\t\tthis._cleanupLastNormalModuleFactory();\n\t\tconst normalModuleFactory = new NormalModuleFactory({\n\t\t\tcontext: this.options.context,\n\t\t\tfs: this.inputFileSystem,\n\t\t\tresolverFactory: this.resolverFactory,\n\t\t\toptions: this.options.module,\n\t\t\tassociatedObjectForCache: this.root,\n\t\t\tlayers: this.options.experiments.layers\n\t\t});\n\t\tthis._lastNormalModuleFactory = normalModuleFactory;\n\t\tthis.hooks.normalModuleFactory.call(normalModuleFactory);\n\t\treturn normalModuleFactory;\n\t}\n\n\tcreateContextModuleFactory() {\n\t\tconst contextModuleFactory = new ContextModuleFactory(this.resolverFactory);\n\t\tthis.hooks.contextModuleFactory.call(contextModuleFactory);\n\t\treturn contextModuleFactory;\n\t}\n\n\tnewCompilationParams() {\n\t\tconst params = {\n\t\t\tnormalModuleFactory: this.createNormalModuleFactory(),\n\t\t\tcontextModuleFactory: this.createContextModuleFactory()\n\t\t};\n\t\treturn params;\n\t}\n\n\t/**\n\t * @param {Callback<Compilation>} callback signals when the compilation finishes\n\t * @returns {void}\n\t */\n\tcompile(callback) {\n\t\tconst params = this.newCompilationParams();\n\t\tthis.hooks.beforeCompile.callAsync(params, err => {\n\t\t\tif (err) return callback(err);\n\n\t\t\tthis.hooks.compile.call(params);\n\n\t\t\tconst compilation = this.newCompilation(params);\n\n\t\t\tconst logger = compilation.getLogger(\"webpack.Compiler\");\n\n\t\t\tlogger.time(\"make hook\");\n\t\t\tthis.hooks.make.callAsync(compilation, err => {\n\t\t\t\tlogger.timeEnd(\"make hook\");\n\t\t\t\tif (err) return callback(err);\n\n\t\t\t\tlogger.time(\"finish make hook\");\n\t\t\t\tthis.hooks.finishMake.callAsync(compilation, err => {\n\t\t\t\t\tlogger.timeEnd(\"finish make hook\");\n\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\t\tlogger.time(\"finish compilation\");\n\t\t\t\t\t\tcompilation.finish(err => {\n\t\t\t\t\t\t\tlogger.timeEnd(\"finish compilation\");\n\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\tlogger.time(\"seal compilation\");\n\t\t\t\t\t\t\tcompilation.seal(err => {\n\t\t\t\t\t\t\t\tlogger.timeEnd(\"seal compilation\");\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\tlogger.time(\"afterCompile hook\");\n\t\t\t\t\t\t\t\tthis.hooks.afterCompile.callAsync(compilation, err => {\n\t\t\t\t\t\t\t\t\tlogger.timeEnd(\"afterCompile hook\");\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\t\treturn callback(null, compilation);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the compiler closes\n\t * @returns {void}\n\t */\n\tclose(callback) {\n\t\tif (this.watching) {\n\t\t\t// When there is still an active watching, close this first\n\t\t\tthis.watching.close(err => {\n\t\t\t\tthis.close(callback);\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tthis.hooks.shutdown.callAsync(err => {\n\t\t\tif (err) return callback(err);\n\t\t\t// Get rid of reference to last compilation to avoid leaking memory\n\t\t\t// We can't run this._cleanupLastCompilation() as the Stats to this compilation\n\t\t\t// might be still in use. We try to get rid of the reference to the cache instead.\n\t\t\tthis._lastCompilation = undefined;\n\t\t\tthis._lastNormalModuleFactory = undefined;\n\t\t\tthis.cache.shutdown(callback);\n\t\t});\n\t}\n}\n\nmodule.exports = Compiler;\n"]},"metadata":{},"sourceType":"script"}