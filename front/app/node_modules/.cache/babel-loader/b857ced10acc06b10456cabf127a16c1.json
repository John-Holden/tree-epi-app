{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/** @typedef {import(\"./Module\")} Module */\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar MODULE_REFERENCE_REGEXP = /^__WEBPACK_MODULE_REFERENCE__(\\d+)_([\\da-f]+|ns)(_call)?(_directImport)?(?:_asiSafe(\\d))?__$/;\nvar DEFAULT_EXPORT = \"__WEBPACK_DEFAULT_EXPORT__\";\nvar NAMESPACE_OBJECT_EXPORT = \"__WEBPACK_NAMESPACE_OBJECT__\";\n/**\n * @typedef {Object} ExternalModuleInfo\n * @property {number} index\n * @property {Module} module\n */\n\n/**\n * @typedef {Object} ConcatenatedModuleInfo\n * @property {number} index\n * @property {Module} module\n * @property {Map<string, string>} exportMap mapping from export name to symbol\n * @property {Map<string, string>} rawExportMap mapping from export name to symbol\n * @property {string=} namespaceExportSymbol\n */\n\n/** @typedef {ConcatenatedModuleInfo | ExternalModuleInfo} ModuleInfo */\n\n/**\n * @typedef {Object} ModuleReferenceOptions\n * @property {string[]} ids the properties/exports of the module\n * @property {boolean} call true, when this referenced export is called\n * @property {boolean} directImport true, when this referenced export is directly imported (not via property access)\n * @property {boolean | undefined} asiSafe if the position is ASI safe or unknown\n */\n\nvar ConcatenationScope = /*#__PURE__*/function () {\n  /**\n   * @param {ModuleInfo[] | Map<Module, ModuleInfo>} modulesMap all module info by module\n   * @param {ConcatenatedModuleInfo} currentModule the current module info\n   */\n  function ConcatenationScope(modulesMap, currentModule) {\n    _classCallCheck(this, ConcatenationScope);\n\n    this._currentModule = currentModule;\n\n    if (Array.isArray(modulesMap)) {\n      var map = new Map();\n\n      var _iterator = _createForOfIteratorHelper(modulesMap),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var info = _step.value;\n          map.set(info.module, info);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      modulesMap = map;\n    }\n\n    this._modulesMap = modulesMap;\n  }\n  /**\n   * @param {Module} module the referenced module\n   * @returns {boolean} true, when it's in the scope\n   */\n\n\n  _createClass(ConcatenationScope, [{\n    key: \"isModuleInScope\",\n    value: function isModuleInScope(module) {\n      return this._modulesMap.has(module);\n    }\n    /**\n     *\n     * @param {string} exportName name of the export\n     * @param {string} symbol identifier of the export in source code\n     */\n\n  }, {\n    key: \"registerExport\",\n    value: function registerExport(exportName, symbol) {\n      if (!this._currentModule.exportMap) {\n        this._currentModule.exportMap = new Map();\n      }\n\n      if (!this._currentModule.exportMap.has(exportName)) {\n        this._currentModule.exportMap.set(exportName, symbol);\n      }\n    }\n    /**\n     *\n     * @param {string} exportName name of the export\n     * @param {string} expression expression to be used\n     */\n\n  }, {\n    key: \"registerRawExport\",\n    value: function registerRawExport(exportName, expression) {\n      if (!this._currentModule.rawExportMap) {\n        this._currentModule.rawExportMap = new Map();\n      }\n\n      if (!this._currentModule.rawExportMap.has(exportName)) {\n        this._currentModule.rawExportMap.set(exportName, expression);\n      }\n    }\n    /**\n     * @param {string} symbol identifier of the export in source code\n     */\n\n  }, {\n    key: \"registerNamespaceExport\",\n    value: function registerNamespaceExport(symbol) {\n      this._currentModule.namespaceExportSymbol = symbol;\n    }\n    /**\n     *\n     * @param {Module} module the referenced module\n     * @param {Partial<ModuleReferenceOptions>} options options\n     * @returns {string} the reference as identifier\n     */\n\n  }, {\n    key: \"createModuleReference\",\n    value: function createModuleReference(module, _ref) {\n      var _ref$ids = _ref.ids,\n          ids = _ref$ids === void 0 ? undefined : _ref$ids,\n          _ref$call = _ref.call,\n          call = _ref$call === void 0 ? false : _ref$call,\n          _ref$directImport = _ref.directImport,\n          directImport = _ref$directImport === void 0 ? false : _ref$directImport,\n          _ref$asiSafe = _ref.asiSafe,\n          asiSafe = _ref$asiSafe === void 0 ? false : _ref$asiSafe;\n\n      var info = this._modulesMap.get(module);\n\n      var callFlag = call ? \"_call\" : \"\";\n      var directImportFlag = directImport ? \"_directImport\" : \"\";\n      var asiSafeFlag = asiSafe ? \"_asiSafe1\" : asiSafe === false ? \"_asiSafe0\" : \"\";\n      var exportData = ids ? Buffer.from(JSON.stringify(ids), \"utf-8\").toString(\"hex\") : \"ns\"; // a \"._\" is appended to allow \"delete ...\", which would cause a SyntaxError in strict mode\n\n      return \"__WEBPACK_MODULE_REFERENCE__\".concat(info.index, \"_\").concat(exportData).concat(callFlag).concat(directImportFlag).concat(asiSafeFlag, \"__._\");\n    }\n    /**\n     * @param {string} name the identifier\n     * @returns {boolean} true, when it's an module reference\n     */\n\n  }], [{\n    key: \"isModuleReference\",\n    value: function isModuleReference(name) {\n      return MODULE_REFERENCE_REGEXP.test(name);\n    }\n    /**\n     * @param {string} name the identifier\n     * @returns {ModuleReferenceOptions & { index: number }} parsed options and index\n     */\n\n  }, {\n    key: \"matchModuleReference\",\n    value: function matchModuleReference(name) {\n      var match = MODULE_REFERENCE_REGEXP.exec(name);\n      if (!match) return null;\n      var index = +match[1];\n      var asiSafe = match[5];\n      return {\n        index: index,\n        ids: match[2] === \"ns\" ? [] : JSON.parse(Buffer.from(match[2], \"hex\").toString(\"utf-8\")),\n        call: !!match[3],\n        directImport: !!match[4],\n        asiSafe: asiSafe ? asiSafe === \"1\" : undefined\n      };\n    }\n  }]);\n\n  return ConcatenationScope;\n}();\n\nConcatenationScope.DEFAULT_EXPORT = DEFAULT_EXPORT;\nConcatenationScope.NAMESPACE_OBJECT_EXPORT = NAMESPACE_OBJECT_EXPORT;\nmodule.exports = ConcatenationScope;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/ConcatenationScope.js"],"names":["MODULE_REFERENCE_REGEXP","DEFAULT_EXPORT","NAMESPACE_OBJECT_EXPORT","ConcatenationScope","modulesMap","currentModule","_currentModule","Array","isArray","map","Map","info","set","module","_modulesMap","has","exportName","symbol","exportMap","expression","rawExportMap","namespaceExportSymbol","ids","undefined","call","directImport","asiSafe","get","callFlag","directImportFlag","asiSafeFlag","exportData","Buffer","from","JSON","stringify","toString","index","name","test","match","exec","parse","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @typedef {import(\"./Module\")} Module */\n\nconst MODULE_REFERENCE_REGEXP =\n\t/^__WEBPACK_MODULE_REFERENCE__(\\d+)_([\\da-f]+|ns)(_call)?(_directImport)?(?:_asiSafe(\\d))?__$/;\n\nconst DEFAULT_EXPORT = \"__WEBPACK_DEFAULT_EXPORT__\";\nconst NAMESPACE_OBJECT_EXPORT = \"__WEBPACK_NAMESPACE_OBJECT__\";\n\n/**\n * @typedef {Object} ExternalModuleInfo\n * @property {number} index\n * @property {Module} module\n */\n\n/**\n * @typedef {Object} ConcatenatedModuleInfo\n * @property {number} index\n * @property {Module} module\n * @property {Map<string, string>} exportMap mapping from export name to symbol\n * @property {Map<string, string>} rawExportMap mapping from export name to symbol\n * @property {string=} namespaceExportSymbol\n */\n\n/** @typedef {ConcatenatedModuleInfo | ExternalModuleInfo} ModuleInfo */\n\n/**\n * @typedef {Object} ModuleReferenceOptions\n * @property {string[]} ids the properties/exports of the module\n * @property {boolean} call true, when this referenced export is called\n * @property {boolean} directImport true, when this referenced export is directly imported (not via property access)\n * @property {boolean | undefined} asiSafe if the position is ASI safe or unknown\n */\n\nclass ConcatenationScope {\n\t/**\n\t * @param {ModuleInfo[] | Map<Module, ModuleInfo>} modulesMap all module info by module\n\t * @param {ConcatenatedModuleInfo} currentModule the current module info\n\t */\n\tconstructor(modulesMap, currentModule) {\n\t\tthis._currentModule = currentModule;\n\t\tif (Array.isArray(modulesMap)) {\n\t\t\tconst map = new Map();\n\t\t\tfor (const info of modulesMap) {\n\t\t\t\tmap.set(info.module, info);\n\t\t\t}\n\t\t\tmodulesMap = map;\n\t\t}\n\t\tthis._modulesMap = modulesMap;\n\t}\n\n\t/**\n\t * @param {Module} module the referenced module\n\t * @returns {boolean} true, when it's in the scope\n\t */\n\tisModuleInScope(module) {\n\t\treturn this._modulesMap.has(module);\n\t}\n\n\t/**\n\t *\n\t * @param {string} exportName name of the export\n\t * @param {string} symbol identifier of the export in source code\n\t */\n\tregisterExport(exportName, symbol) {\n\t\tif (!this._currentModule.exportMap) {\n\t\t\tthis._currentModule.exportMap = new Map();\n\t\t}\n\t\tif (!this._currentModule.exportMap.has(exportName)) {\n\t\t\tthis._currentModule.exportMap.set(exportName, symbol);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param {string} exportName name of the export\n\t * @param {string} expression expression to be used\n\t */\n\tregisterRawExport(exportName, expression) {\n\t\tif (!this._currentModule.rawExportMap) {\n\t\t\tthis._currentModule.rawExportMap = new Map();\n\t\t}\n\t\tif (!this._currentModule.rawExportMap.has(exportName)) {\n\t\t\tthis._currentModule.rawExportMap.set(exportName, expression);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} symbol identifier of the export in source code\n\t */\n\tregisterNamespaceExport(symbol) {\n\t\tthis._currentModule.namespaceExportSymbol = symbol;\n\t}\n\n\t/**\n\t *\n\t * @param {Module} module the referenced module\n\t * @param {Partial<ModuleReferenceOptions>} options options\n\t * @returns {string} the reference as identifier\n\t */\n\tcreateModuleReference(\n\t\tmodule,\n\t\t{ ids = undefined, call = false, directImport = false, asiSafe = false }\n\t) {\n\t\tconst info = this._modulesMap.get(module);\n\t\tconst callFlag = call ? \"_call\" : \"\";\n\t\tconst directImportFlag = directImport ? \"_directImport\" : \"\";\n\t\tconst asiSafeFlag = asiSafe\n\t\t\t? \"_asiSafe1\"\n\t\t\t: asiSafe === false\n\t\t\t? \"_asiSafe0\"\n\t\t\t: \"\";\n\t\tconst exportData = ids\n\t\t\t? Buffer.from(JSON.stringify(ids), \"utf-8\").toString(\"hex\")\n\t\t\t: \"ns\";\n\t\t// a \"._\" is appended to allow \"delete ...\", which would cause a SyntaxError in strict mode\n\t\treturn `__WEBPACK_MODULE_REFERENCE__${info.index}_${exportData}${callFlag}${directImportFlag}${asiSafeFlag}__._`;\n\t}\n\n\t/**\n\t * @param {string} name the identifier\n\t * @returns {boolean} true, when it's an module reference\n\t */\n\tstatic isModuleReference(name) {\n\t\treturn MODULE_REFERENCE_REGEXP.test(name);\n\t}\n\n\t/**\n\t * @param {string} name the identifier\n\t * @returns {ModuleReferenceOptions & { index: number }} parsed options and index\n\t */\n\tstatic matchModuleReference(name) {\n\t\tconst match = MODULE_REFERENCE_REGEXP.exec(name);\n\t\tif (!match) return null;\n\t\tconst index = +match[1];\n\t\tconst asiSafe = match[5];\n\t\treturn {\n\t\t\tindex,\n\t\t\tids:\n\t\t\t\tmatch[2] === \"ns\"\n\t\t\t\t\t? []\n\t\t\t\t\t: JSON.parse(Buffer.from(match[2], \"hex\").toString(\"utf-8\")),\n\t\t\tcall: !!match[3],\n\t\t\tdirectImport: !!match[4],\n\t\t\tasiSafe: asiSafe ? asiSafe === \"1\" : undefined\n\t\t};\n\t}\n}\n\nConcatenationScope.DEFAULT_EXPORT = DEFAULT_EXPORT;\nConcatenationScope.NAMESPACE_OBJECT_EXPORT = NAMESPACE_OBJECT_EXPORT;\n\nmodule.exports = ConcatenationScope;\n"]},"metadata":{},"sourceType":"script"}