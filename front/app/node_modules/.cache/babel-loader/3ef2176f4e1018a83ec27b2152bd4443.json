{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _require = require(\"../OptimizationStages\"),\n    STAGE_ADVANCED = _require.STAGE_ADVANCED;\n\nvar LazyBucketSortedSet = require(\"../util/LazyBucketSortedSet\");\n\nvar _require2 = require(\"../util/comparators\"),\n    compareChunks = _require2.compareChunks;\n\nvar createSchemaValidation = require(\"../util/create-schema-validation\");\n/** @typedef {import(\"../../declarations/plugins/optimize/LimitChunkCountPlugin\").LimitChunkCountPluginOptions} LimitChunkCountPluginOptions */\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n\nvar validate = createSchemaValidation(require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.check.js\"), function () {\n  return require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.json\");\n}, {\n  name: \"Limit Chunk Count Plugin\",\n  baseDataPath: \"options\"\n});\n/**\n * @typedef {Object} ChunkCombination\n * @property {boolean} deleted this is set to true when combination was removed\n * @property {number} sizeDiff\n * @property {number} integratedSize\n * @property {Chunk} a\n * @property {Chunk} b\n * @property {number} aIdx\n * @property {number} bIdx\n * @property {number} aSize\n * @property {number} bSize\n */\n\nvar addToSetMap = function addToSetMap(map, key, value) {\n  var set = map.get(key);\n\n  if (set === undefined) {\n    map.set(key, new Set([value]));\n  } else {\n    set.add(value);\n  }\n};\n\nvar LimitChunkCountPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {LimitChunkCountPluginOptions=} options options object\n   */\n  function LimitChunkCountPlugin(options) {\n    _classCallCheck(this, LimitChunkCountPlugin);\n\n    validate(options);\n    this.options = options;\n  }\n  /**\n   * @param {Compiler} compiler the webpack compiler\n   * @returns {void}\n   */\n\n\n  _createClass(LimitChunkCountPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var options = this.options;\n      compiler.hooks.compilation.tap(\"LimitChunkCountPlugin\", function (compilation) {\n        compilation.hooks.optimizeChunks.tap({\n          name: \"LimitChunkCountPlugin\",\n          stage: STAGE_ADVANCED\n        }, function (chunks) {\n          var chunkGraph = compilation.chunkGraph;\n          var maxChunks = options.maxChunks;\n          if (!maxChunks) return;\n          if (maxChunks < 1) return;\n          if (compilation.chunks.size <= maxChunks) return;\n          var remainingChunksToMerge = compilation.chunks.size - maxChunks; // order chunks in a deterministic way\n\n          var compareChunksWithGraph = compareChunks(chunkGraph);\n          var orderedChunks = Array.from(chunks).sort(compareChunksWithGraph); // create a lazy sorted data structure to keep all combinations\n          // this is large. Size = chunks * (chunks - 1) / 2\n          // It uses a multi layer bucket sort plus normal sort in the last layer\n          // It's also lazy so only accessed buckets are sorted\n\n          var combinations = new LazyBucketSortedSet( // Layer 1: ordered by largest size benefit\n          function (c) {\n            return c.sizeDiff;\n          }, function (a, b) {\n            return b - a;\n          }, // Layer 2: ordered by smallest combined size\n          function (c) {\n            return c.integratedSize;\n          }, function (a, b) {\n            return a - b;\n          }, // Layer 3: ordered by position difference in orderedChunk (-> to be deterministic)\n          function (c) {\n            return c.bIdx - c.aIdx;\n          }, function (a, b) {\n            return a - b;\n          }, // Layer 4: ordered by position in orderedChunk (-> to be deterministic)\n          function (a, b) {\n            return a.bIdx - b.bIdx;\n          }); // we keep a mapping from chunk to all combinations\n          // but this mapping is not kept up-to-date with deletions\n          // so `deleted` flag need to be considered when iterating this\n\n          /** @type {Map<Chunk, Set<ChunkCombination>>} */\n\n          var combinationsByChunk = new Map();\n          orderedChunks.forEach(function (b, bIdx) {\n            // create combination pairs with size and integrated size\n            for (var aIdx = 0; aIdx < bIdx; aIdx++) {\n              var a = orderedChunks[aIdx]; // filter pairs that can not be integrated!\n\n              if (!chunkGraph.canChunksBeIntegrated(a, b)) continue;\n              var integratedSize = chunkGraph.getIntegratedChunksSize(a, b, options);\n              var aSize = chunkGraph.getChunkSize(a, options);\n              var bSize = chunkGraph.getChunkSize(b, options);\n              var c = {\n                deleted: false,\n                sizeDiff: aSize + bSize - integratedSize,\n                integratedSize: integratedSize,\n                a: a,\n                b: b,\n                aIdx: aIdx,\n                bIdx: bIdx,\n                aSize: aSize,\n                bSize: bSize\n              };\n              combinations.add(c);\n              addToSetMap(combinationsByChunk, a, c);\n              addToSetMap(combinationsByChunk, b, c);\n            }\n\n            return combinations;\n          }); // list of modified chunks during this run\n          // combinations affected by this change are skipped to allow\n          // further optimizations\n\n          /** @type {Set<Chunk>} */\n\n          var modifiedChunks = new Set();\n          var changed = false; // eslint-disable-next-line no-constant-condition\n\n          loop: while (true) {\n            var combination = combinations.popFirst();\n            if (combination === undefined) break;\n            combination.deleted = true;\n            var a = combination.a,\n                b = combination.b,\n                integratedSize = combination.integratedSize; // skip over pair when\n            // one of the already merged chunks is a parent of one of the chunks\n\n            if (modifiedChunks.size > 0) {\n              var queue = new Set(a.groupsIterable);\n\n              var _iterator = _createForOfIteratorHelper(b.groupsIterable),\n                  _step;\n\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var group = _step.value;\n                  queue.add(group);\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n\n              var _iterator2 = _createForOfIteratorHelper(queue),\n                  _step2;\n\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var _group = _step2.value;\n\n                  var _iterator3 = _createForOfIteratorHelper(modifiedChunks),\n                      _step3;\n\n                  try {\n                    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                      var mChunk = _step3.value;\n\n                      if (mChunk !== a && mChunk !== b && mChunk.isInGroup(_group)) {\n                        // This is a potential pair which needs recalculation\n                        // We can't do that now, but it merge before following pairs\n                        // so we leave space for it, and consider chunks as modified\n                        // just for the worse case\n                        remainingChunksToMerge--;\n                        if (remainingChunksToMerge <= 0) break loop;\n                        modifiedChunks.add(a);\n                        modifiedChunks.add(b);\n                        continue loop;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator3.e(err);\n                  } finally {\n                    _iterator3.f();\n                  }\n\n                  var _iterator4 = _createForOfIteratorHelper(_group.parentsIterable),\n                      _step4;\n\n                  try {\n                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                      var parent = _step4.value;\n                      queue.add(parent);\n                    }\n                  } catch (err) {\n                    _iterator4.e(err);\n                  } finally {\n                    _iterator4.f();\n                  }\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n            } // merge the chunks\n\n\n            if (chunkGraph.canChunksBeIntegrated(a, b)) {\n              chunkGraph.integrateChunks(a, b);\n              compilation.chunks.delete(b); // flag chunk a as modified as further optimization are possible for all children here\n\n              modifiedChunks.add(a);\n              changed = true;\n              remainingChunksToMerge--;\n              if (remainingChunksToMerge <= 0) break; // Update all affected combinations\n              // delete all combination with the removed chunk\n              // we will use combinations with the kept chunk instead\n\n              var _iterator5 = _createForOfIteratorHelper(combinationsByChunk.get(a)),\n                  _step5;\n\n              try {\n                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                  var _combination = _step5.value;\n                  if (_combination.deleted) continue;\n                  _combination.deleted = true;\n                  combinations.delete(_combination);\n                } // Update combinations with the kept chunk with new sizes\n\n              } catch (err) {\n                _iterator5.e(err);\n              } finally {\n                _iterator5.f();\n              }\n\n              var _iterator6 = _createForOfIteratorHelper(combinationsByChunk.get(b)),\n                  _step6;\n\n              try {\n                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                  var _combination2 = _step6.value;\n                  if (_combination2.deleted) continue;\n\n                  if (_combination2.a === b) {\n                    if (!chunkGraph.canChunksBeIntegrated(a, _combination2.b)) {\n                      _combination2.deleted = true;\n                      combinations.delete(_combination2);\n                      continue;\n                    } // Update size\n\n\n                    var newIntegratedSize = chunkGraph.getIntegratedChunksSize(a, _combination2.b, options);\n                    var finishUpdate = combinations.startUpdate(_combination2);\n                    _combination2.a = a;\n                    _combination2.integratedSize = newIntegratedSize;\n                    _combination2.aSize = integratedSize;\n                    _combination2.sizeDiff = _combination2.bSize + integratedSize - newIntegratedSize;\n                    finishUpdate();\n                  } else if (_combination2.b === b) {\n                    if (!chunkGraph.canChunksBeIntegrated(_combination2.a, a)) {\n                      _combination2.deleted = true;\n                      combinations.delete(_combination2);\n                      continue;\n                    } // Update size\n\n\n                    var _newIntegratedSize = chunkGraph.getIntegratedChunksSize(_combination2.a, a, options);\n\n                    var _finishUpdate = combinations.startUpdate(_combination2);\n\n                    _combination2.b = a;\n                    _combination2.integratedSize = _newIntegratedSize;\n                    _combination2.bSize = integratedSize;\n                    _combination2.sizeDiff = integratedSize + _combination2.aSize - _newIntegratedSize;\n\n                    _finishUpdate();\n                  }\n                }\n              } catch (err) {\n                _iterator6.e(err);\n              } finally {\n                _iterator6.f();\n              }\n\n              combinationsByChunk.set(a, combinationsByChunk.get(b));\n              combinationsByChunk.delete(b);\n            }\n          }\n\n          if (changed) return true;\n        });\n      });\n    }\n  }]);\n\n  return LimitChunkCountPlugin;\n}();\n\nmodule.exports = LimitChunkCountPlugin;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/optimize/LimitChunkCountPlugin.js"],"names":["require","STAGE_ADVANCED","LazyBucketSortedSet","compareChunks","createSchemaValidation","validate","name","baseDataPath","addToSetMap","map","key","value","set","get","undefined","Set","add","LimitChunkCountPlugin","options","compiler","hooks","compilation","tap","optimizeChunks","stage","chunks","chunkGraph","maxChunks","size","remainingChunksToMerge","compareChunksWithGraph","orderedChunks","Array","from","sort","combinations","c","sizeDiff","a","b","integratedSize","bIdx","aIdx","combinationsByChunk","Map","forEach","canChunksBeIntegrated","getIntegratedChunksSize","aSize","getChunkSize","bSize","deleted","modifiedChunks","changed","loop","combination","popFirst","queue","groupsIterable","group","mChunk","isInGroup","parentsIterable","parent","integrateChunks","delete","newIntegratedSize","finishUpdate","startUpdate","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { STAGE_ADVANCED } = require(\"../OptimizationStages\");\nconst LazyBucketSortedSet = require(\"../util/LazyBucketSortedSet\");\nconst { compareChunks } = require(\"../util/comparators\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/LimitChunkCountPlugin\").LimitChunkCountPluginOptions} LimitChunkCountPluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.check.js\"),\n\t() => require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.json\"),\n\t{\n\t\tname: \"Limit Chunk Count Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\n/**\n * @typedef {Object} ChunkCombination\n * @property {boolean} deleted this is set to true when combination was removed\n * @property {number} sizeDiff\n * @property {number} integratedSize\n * @property {Chunk} a\n * @property {Chunk} b\n * @property {number} aIdx\n * @property {number} bIdx\n * @property {number} aSize\n * @property {number} bSize\n */\n\nconst addToSetMap = (map, key, value) => {\n\tconst set = map.get(key);\n\tif (set === undefined) {\n\t\tmap.set(key, new Set([value]));\n\t} else {\n\t\tset.add(value);\n\t}\n};\n\nclass LimitChunkCountPlugin {\n\t/**\n\t * @param {LimitChunkCountPluginOptions=} options options object\n\t */\n\tconstructor(options) {\n\t\tvalidate(options);\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * @param {Compiler} compiler the webpack compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst options = this.options;\n\t\tcompiler.hooks.compilation.tap(\"LimitChunkCountPlugin\", compilation => {\n\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t{\n\t\t\t\t\tname: \"LimitChunkCountPlugin\",\n\t\t\t\t\tstage: STAGE_ADVANCED\n\t\t\t\t},\n\t\t\t\tchunks => {\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\tconst maxChunks = options.maxChunks;\n\t\t\t\t\tif (!maxChunks) return;\n\t\t\t\t\tif (maxChunks < 1) return;\n\t\t\t\t\tif (compilation.chunks.size <= maxChunks) return;\n\n\t\t\t\t\tlet remainingChunksToMerge = compilation.chunks.size - maxChunks;\n\n\t\t\t\t\t// order chunks in a deterministic way\n\t\t\t\t\tconst compareChunksWithGraph = compareChunks(chunkGraph);\n\t\t\t\t\tconst orderedChunks = Array.from(chunks).sort(compareChunksWithGraph);\n\n\t\t\t\t\t// create a lazy sorted data structure to keep all combinations\n\t\t\t\t\t// this is large. Size = chunks * (chunks - 1) / 2\n\t\t\t\t\t// It uses a multi layer bucket sort plus normal sort in the last layer\n\t\t\t\t\t// It's also lazy so only accessed buckets are sorted\n\t\t\t\t\tconst combinations = new LazyBucketSortedSet(\n\t\t\t\t\t\t// Layer 1: ordered by largest size benefit\n\t\t\t\t\t\tc => c.sizeDiff,\n\t\t\t\t\t\t(a, b) => b - a,\n\t\t\t\t\t\t// Layer 2: ordered by smallest combined size\n\t\t\t\t\t\tc => c.integratedSize,\n\t\t\t\t\t\t(a, b) => a - b,\n\t\t\t\t\t\t// Layer 3: ordered by position difference in orderedChunk (-> to be deterministic)\n\t\t\t\t\t\tc => c.bIdx - c.aIdx,\n\t\t\t\t\t\t(a, b) => a - b,\n\t\t\t\t\t\t// Layer 4: ordered by position in orderedChunk (-> to be deterministic)\n\t\t\t\t\t\t(a, b) => a.bIdx - b.bIdx\n\t\t\t\t\t);\n\n\t\t\t\t\t// we keep a mapping from chunk to all combinations\n\t\t\t\t\t// but this mapping is not kept up-to-date with deletions\n\t\t\t\t\t// so `deleted` flag need to be considered when iterating this\n\t\t\t\t\t/** @type {Map<Chunk, Set<ChunkCombination>>} */\n\t\t\t\t\tconst combinationsByChunk = new Map();\n\n\t\t\t\t\torderedChunks.forEach((b, bIdx) => {\n\t\t\t\t\t\t// create combination pairs with size and integrated size\n\t\t\t\t\t\tfor (let aIdx = 0; aIdx < bIdx; aIdx++) {\n\t\t\t\t\t\t\tconst a = orderedChunks[aIdx];\n\t\t\t\t\t\t\t// filter pairs that can not be integrated!\n\t\t\t\t\t\t\tif (!chunkGraph.canChunksBeIntegrated(a, b)) continue;\n\n\t\t\t\t\t\t\tconst integratedSize = chunkGraph.getIntegratedChunksSize(\n\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\tb,\n\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tconst aSize = chunkGraph.getChunkSize(a, options);\n\t\t\t\t\t\t\tconst bSize = chunkGraph.getChunkSize(b, options);\n\t\t\t\t\t\t\tconst c = {\n\t\t\t\t\t\t\t\tdeleted: false,\n\t\t\t\t\t\t\t\tsizeDiff: aSize + bSize - integratedSize,\n\t\t\t\t\t\t\t\tintegratedSize,\n\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\tb,\n\t\t\t\t\t\t\t\taIdx,\n\t\t\t\t\t\t\t\tbIdx,\n\t\t\t\t\t\t\t\taSize,\n\t\t\t\t\t\t\t\tbSize\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcombinations.add(c);\n\t\t\t\t\t\t\taddToSetMap(combinationsByChunk, a, c);\n\t\t\t\t\t\t\taddToSetMap(combinationsByChunk, b, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn combinations;\n\t\t\t\t\t});\n\n\t\t\t\t\t// list of modified chunks during this run\n\t\t\t\t\t// combinations affected by this change are skipped to allow\n\t\t\t\t\t// further optimizations\n\t\t\t\t\t/** @type {Set<Chunk>} */\n\t\t\t\t\tconst modifiedChunks = new Set();\n\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\t// eslint-disable-next-line no-constant-condition\n\t\t\t\t\tloop: while (true) {\n\t\t\t\t\t\tconst combination = combinations.popFirst();\n\t\t\t\t\t\tif (combination === undefined) break;\n\n\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\tconst { a, b, integratedSize } = combination;\n\n\t\t\t\t\t\t// skip over pair when\n\t\t\t\t\t\t// one of the already merged chunks is a parent of one of the chunks\n\t\t\t\t\t\tif (modifiedChunks.size > 0) {\n\t\t\t\t\t\t\tconst queue = new Set(a.groupsIterable);\n\t\t\t\t\t\t\tfor (const group of b.groupsIterable) {\n\t\t\t\t\t\t\t\tqueue.add(group);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const group of queue) {\n\t\t\t\t\t\t\t\tfor (const mChunk of modifiedChunks) {\n\t\t\t\t\t\t\t\t\tif (mChunk !== a && mChunk !== b && mChunk.isInGroup(group)) {\n\t\t\t\t\t\t\t\t\t\t// This is a potential pair which needs recalculation\n\t\t\t\t\t\t\t\t\t\t// We can't do that now, but it merge before following pairs\n\t\t\t\t\t\t\t\t\t\t// so we leave space for it, and consider chunks as modified\n\t\t\t\t\t\t\t\t\t\t// just for the worse case\n\t\t\t\t\t\t\t\t\t\tremainingChunksToMerge--;\n\t\t\t\t\t\t\t\t\t\tif (remainingChunksToMerge <= 0) break loop;\n\t\t\t\t\t\t\t\t\t\tmodifiedChunks.add(a);\n\t\t\t\t\t\t\t\t\t\tmodifiedChunks.add(b);\n\t\t\t\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const parent of group.parentsIterable) {\n\t\t\t\t\t\t\t\t\tqueue.add(parent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// merge the chunks\n\t\t\t\t\t\tif (chunkGraph.canChunksBeIntegrated(a, b)) {\n\t\t\t\t\t\t\tchunkGraph.integrateChunks(a, b);\n\t\t\t\t\t\t\tcompilation.chunks.delete(b);\n\n\t\t\t\t\t\t\t// flag chunk a as modified as further optimization are possible for all children here\n\t\t\t\t\t\t\tmodifiedChunks.add(a);\n\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\tremainingChunksToMerge--;\n\t\t\t\t\t\t\tif (remainingChunksToMerge <= 0) break;\n\n\t\t\t\t\t\t\t// Update all affected combinations\n\t\t\t\t\t\t\t// delete all combination with the removed chunk\n\t\t\t\t\t\t\t// we will use combinations with the kept chunk instead\n\t\t\t\t\t\t\tfor (const combination of combinationsByChunk.get(a)) {\n\t\t\t\t\t\t\t\tif (combination.deleted) continue;\n\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Update combinations with the kept chunk with new sizes\n\t\t\t\t\t\t\tfor (const combination of combinationsByChunk.get(b)) {\n\t\t\t\t\t\t\t\tif (combination.deleted) continue;\n\t\t\t\t\t\t\t\tif (combination.a === b) {\n\t\t\t\t\t\t\t\t\tif (!chunkGraph.canChunksBeIntegrated(a, combination.b)) {\n\t\t\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Update size\n\t\t\t\t\t\t\t\t\tconst newIntegratedSize = chunkGraph.getIntegratedChunksSize(\n\t\t\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\t\t\tcombination.b,\n\t\t\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tconst finishUpdate = combinations.startUpdate(combination);\n\t\t\t\t\t\t\t\t\tcombination.a = a;\n\t\t\t\t\t\t\t\t\tcombination.integratedSize = newIntegratedSize;\n\t\t\t\t\t\t\t\t\tcombination.aSize = integratedSize;\n\t\t\t\t\t\t\t\t\tcombination.sizeDiff =\n\t\t\t\t\t\t\t\t\t\tcombination.bSize + integratedSize - newIntegratedSize;\n\t\t\t\t\t\t\t\t\tfinishUpdate();\n\t\t\t\t\t\t\t\t} else if (combination.b === b) {\n\t\t\t\t\t\t\t\t\tif (!chunkGraph.canChunksBeIntegrated(combination.a, a)) {\n\t\t\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Update size\n\t\t\t\t\t\t\t\t\tconst newIntegratedSize = chunkGraph.getIntegratedChunksSize(\n\t\t\t\t\t\t\t\t\t\tcombination.a,\n\t\t\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tconst finishUpdate = combinations.startUpdate(combination);\n\t\t\t\t\t\t\t\t\tcombination.b = a;\n\t\t\t\t\t\t\t\t\tcombination.integratedSize = newIntegratedSize;\n\t\t\t\t\t\t\t\t\tcombination.bSize = integratedSize;\n\t\t\t\t\t\t\t\t\tcombination.sizeDiff =\n\t\t\t\t\t\t\t\t\t\tintegratedSize + combination.aSize - newIntegratedSize;\n\t\t\t\t\t\t\t\t\tfinishUpdate();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcombinationsByChunk.set(a, combinationsByChunk.get(b));\n\t\t\t\t\t\t\tcombinationsByChunk.delete(b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (changed) return true;\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = LimitChunkCountPlugin;\n"]},"metadata":{},"sourceType":"script"}