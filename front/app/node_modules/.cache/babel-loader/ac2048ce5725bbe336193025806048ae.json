{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _require = require(\"../OptimizationStages\"),\n    STAGE_ADVANCED = _require.STAGE_ADVANCED;\n\nvar _require2 = require(\"../util/SetHelpers\"),\n    intersect = _require2.intersect;\n\nvar _require3 = require(\"../util/comparators\"),\n    compareModulesByIdentifier = _require3.compareModulesByIdentifier,\n    compareChunks = _require3.compareChunks;\n\nvar createSchemaValidation = require(\"../util/create-schema-validation\");\n\nvar identifierUtils = require(\"../util/identifier\");\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Module\")} Module */\n\n\nvar validate = createSchemaValidation(require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.check.js\"), function () {\n  return require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\");\n}, {\n  name: \"Aggressive Splitting Plugin\",\n  baseDataPath: \"options\"\n});\n\nvar moveModuleBetween = function moveModuleBetween(chunkGraph, oldChunk, newChunk) {\n  return function (module) {\n    chunkGraph.disconnectChunkAndModule(oldChunk, module);\n    chunkGraph.connectChunkAndModule(newChunk, module);\n  };\n};\n/**\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Chunk} chunk the chunk\n * @returns {function(Module): boolean} filter for entry module\n */\n\n\nvar isNotAEntryModule = function isNotAEntryModule(chunkGraph, chunk) {\n  return function (module) {\n    return !chunkGraph.isEntryModuleInChunk(module, chunk);\n  };\n};\n/** @type {WeakSet<Chunk>} */\n\n\nvar recordedChunks = new WeakSet();\n\nvar AggressiveSplittingPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {AggressiveSplittingPluginOptions=} options options object\n   */\n  function AggressiveSplittingPlugin() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, AggressiveSplittingPlugin);\n\n    validate(options);\n    this.options = options;\n\n    if (typeof this.options.minSize !== \"number\") {\n      this.options.minSize = 30 * 1024;\n    }\n\n    if (typeof this.options.maxSize !== \"number\") {\n      this.options.maxSize = 50 * 1024;\n    }\n\n    if (typeof this.options.chunkOverhead !== \"number\") {\n      this.options.chunkOverhead = 0;\n    }\n\n    if (typeof this.options.entryChunkMultiplicator !== \"number\") {\n      this.options.entryChunkMultiplicator = 1;\n    }\n  }\n  /**\n   * @param {Chunk} chunk the chunk to test\n   * @returns {boolean} true if the chunk was recorded\n   */\n\n\n  _createClass(AggressiveSplittingPlugin, [{\n    key: \"apply\",\n    value:\n    /**\n     * Apply the plugin\n     * @param {Compiler} compiler the compiler instance\n     * @returns {void}\n     */\n    function apply(compiler) {\n      var _this = this;\n\n      compiler.hooks.thisCompilation.tap(\"AggressiveSplittingPlugin\", function (compilation) {\n        var needAdditionalSeal = false;\n        var newSplits;\n        var fromAggressiveSplittingSet;\n        var chunkSplitDataMap;\n        compilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", function () {\n          newSplits = [];\n          fromAggressiveSplittingSet = new Set();\n          chunkSplitDataMap = new Map();\n        });\n        compilation.hooks.optimizeChunks.tap({\n          name: \"AggressiveSplittingPlugin\",\n          stage: STAGE_ADVANCED\n        }, function (chunks) {\n          var chunkGraph = compilation.chunkGraph; // Precompute stuff\n\n          var nameToModuleMap = new Map();\n          var moduleToNameMap = new Map();\n          var makePathsRelative = identifierUtils.makePathsRelative.bindContextCache(compiler.context, compiler.root);\n\n          var _iterator = _createForOfIteratorHelper(compilation.modules),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var m = _step.value;\n              var name = makePathsRelative(m.identifier());\n              nameToModuleMap.set(name, m);\n              moduleToNameMap.set(m, name);\n            } // Check used chunk ids\n\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          var usedIds = new Set();\n\n          var _iterator2 = _createForOfIteratorHelper(chunks),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var chunk = _step2.value;\n              usedIds.add(chunk.id);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          var recordedSplits = compilation.records && compilation.records.aggressiveSplits || [];\n          var usedSplits = newSplits ? recordedSplits.concat(newSplits) : recordedSplits;\n          var minSize = _this.options.minSize;\n          var maxSize = _this.options.maxSize;\n\n          var applySplit = function applySplit(splitData) {\n            // Cannot split if id is already taken\n            if (splitData.id !== undefined && usedIds.has(splitData.id)) {\n              return false;\n            } // Get module objects from names\n\n\n            var selectedModules = splitData.modules.map(function (name) {\n              return nameToModuleMap.get(name);\n            }); // Does the modules exist at all?\n\n            if (!selectedModules.every(Boolean)) return false; // Check if size matches (faster than waiting for hash)\n\n            var size = 0;\n\n            var _iterator3 = _createForOfIteratorHelper(selectedModules),\n                _step3;\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var m = _step3.value;\n                size += m.size();\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n\n            if (size !== splitData.size) return false; // get chunks with all modules\n\n            var selectedChunks = intersect(selectedModules.map(function (m) {\n              return new Set(chunkGraph.getModuleChunksIterable(m));\n            })); // No relevant chunks found\n\n            if (selectedChunks.size === 0) return false; // The found chunk is already the split or similar\n\n            if (selectedChunks.size === 1 && chunkGraph.getNumberOfChunkModules(Array.from(selectedChunks)[0]) === selectedModules.length) {\n              var chunk = Array.from(selectedChunks)[0];\n              if (fromAggressiveSplittingSet.has(chunk)) return false;\n              fromAggressiveSplittingSet.add(chunk);\n              chunkSplitDataMap.set(chunk, splitData);\n              return true;\n            } // split the chunk into two parts\n\n\n            var newChunk = compilation.addChunk();\n            newChunk.chunkReason = \"aggressive splitted\";\n\n            var _iterator4 = _createForOfIteratorHelper(selectedChunks),\n                _step4;\n\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var _chunk = _step4.value;\n                selectedModules.forEach(moveModuleBetween(chunkGraph, _chunk, newChunk));\n\n                _chunk.split(newChunk);\n\n                _chunk.name = null;\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n\n            fromAggressiveSplittingSet.add(newChunk);\n            chunkSplitDataMap.set(newChunk, splitData);\n\n            if (splitData.id !== null && splitData.id !== undefined) {\n              newChunk.id = splitData.id;\n              newChunk.ids = [splitData.id];\n            }\n\n            return true;\n          }; // try to restore to recorded splitting\n\n\n          var changed = false;\n\n          for (var j = 0; j < usedSplits.length; j++) {\n            var splitData = usedSplits[j];\n            if (applySplit(splitData)) changed = true;\n          } // for any chunk which isn't splitted yet, split it and create a new entry\n          // start with the biggest chunk\n\n\n          var cmpFn = compareChunks(chunkGraph);\n          var sortedChunks = Array.from(chunks).sort(function (a, b) {\n            var diff1 = chunkGraph.getChunkModulesSize(b) - chunkGraph.getChunkModulesSize(a);\n            if (diff1) return diff1;\n            var diff2 = chunkGraph.getNumberOfChunkModules(a) - chunkGraph.getNumberOfChunkModules(b);\n            if (diff2) return diff2;\n            return cmpFn(a, b);\n          });\n\n          var _iterator5 = _createForOfIteratorHelper(sortedChunks),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _chunk2 = _step5.value;\n              if (fromAggressiveSplittingSet.has(_chunk2)) continue;\n              var size = chunkGraph.getChunkModulesSize(_chunk2);\n\n              if (size > maxSize && chunkGraph.getNumberOfChunkModules(_chunk2) > 1) {\n                var modules = chunkGraph.getOrderedChunkModules(_chunk2, compareModulesByIdentifier).filter(isNotAEntryModule(chunkGraph, _chunk2));\n                var selectedModules = [];\n                var selectedModulesSize = 0;\n\n                for (var k = 0; k < modules.length; k++) {\n                  var _module = modules[k];\n\n                  var newSize = selectedModulesSize + _module.size();\n\n                  if (newSize > maxSize && selectedModulesSize >= minSize) {\n                    break;\n                  }\n\n                  selectedModulesSize = newSize;\n                  selectedModules.push(_module);\n                }\n\n                if (selectedModules.length === 0) continue;\n                var _splitData = {\n                  modules: selectedModules.map(function (m) {\n                    return moduleToNameMap.get(m);\n                  }).sort(),\n                  size: selectedModulesSize\n                };\n\n                if (applySplit(_splitData)) {\n                  newSplits = (newSplits || []).concat(_splitData);\n                  changed = true;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n\n          if (changed) return true;\n        });\n        compilation.hooks.recordHash.tap(\"AggressiveSplittingPlugin\", function (records) {\n          // 4. save made splittings to records\n          var allSplits = new Set();\n          var invalidSplits = new Set(); // Check if some splittings are invalid\n          // We remove invalid splittings and try again\n\n          var _iterator6 = _createForOfIteratorHelper(compilation.chunks),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var _chunk3 = _step6.value;\n\n              var _splitData3 = chunkSplitDataMap.get(_chunk3);\n\n              if (_splitData3 !== undefined) {\n                if (_splitData3.hash && _chunk3.hash !== _splitData3.hash) {\n                  // Split was successful, but hash doesn't equal\n                  // We can throw away the split since it's useless now\n                  invalidSplits.add(_splitData3);\n                }\n              }\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n\n          if (invalidSplits.size > 0) {\n            records.aggressiveSplits = records.aggressiveSplits.filter(function (splitData) {\n              return !invalidSplits.has(splitData);\n            });\n            needAdditionalSeal = true;\n          } else {\n            // set hash and id values on all (new) splittings\n            var _iterator7 = _createForOfIteratorHelper(compilation.chunks),\n                _step7;\n\n            try {\n              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                var chunk = _step7.value;\n\n                var _splitData2 = chunkSplitDataMap.get(chunk);\n\n                if (_splitData2 !== undefined) {\n                  _splitData2.hash = chunk.hash;\n                  _splitData2.id = chunk.id;\n                  allSplits.add(_splitData2); // set flag for stats\n\n                  recordedChunks.add(chunk);\n                }\n              } // Also add all unused historical splits (after the used ones)\n              // They can still be used in some future compilation\n\n            } catch (err) {\n              _iterator7.e(err);\n            } finally {\n              _iterator7.f();\n            }\n\n            var recordedSplits = compilation.records && compilation.records.aggressiveSplits;\n\n            if (recordedSplits) {\n              var _iterator8 = _createForOfIteratorHelper(recordedSplits),\n                  _step8;\n\n              try {\n                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                  var splitData = _step8.value;\n                  if (!invalidSplits.has(splitData)) allSplits.add(splitData);\n                }\n              } catch (err) {\n                _iterator8.e(err);\n              } finally {\n                _iterator8.f();\n              }\n            } // record all splits\n\n\n            records.aggressiveSplits = Array.from(allSplits);\n            needAdditionalSeal = false;\n          }\n        });\n        compilation.hooks.needAdditionalSeal.tap(\"AggressiveSplittingPlugin\", function () {\n          if (needAdditionalSeal) {\n            needAdditionalSeal = false;\n            return true;\n          }\n        });\n      });\n    }\n  }], [{\n    key: \"wasChunkRecorded\",\n    value: function wasChunkRecorded(chunk) {\n      return recordedChunks.has(chunk);\n    }\n  }]);\n\n  return AggressiveSplittingPlugin;\n}();\n\nmodule.exports = AggressiveSplittingPlugin;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/optimize/AggressiveSplittingPlugin.js"],"names":["require","STAGE_ADVANCED","intersect","compareModulesByIdentifier","compareChunks","createSchemaValidation","identifierUtils","validate","name","baseDataPath","moveModuleBetween","chunkGraph","oldChunk","newChunk","module","disconnectChunkAndModule","connectChunkAndModule","isNotAEntryModule","chunk","isEntryModuleInChunk","recordedChunks","WeakSet","AggressiveSplittingPlugin","options","minSize","maxSize","chunkOverhead","entryChunkMultiplicator","compiler","hooks","thisCompilation","tap","compilation","needAdditionalSeal","newSplits","fromAggressiveSplittingSet","chunkSplitDataMap","optimize","Set","Map","optimizeChunks","stage","chunks","nameToModuleMap","moduleToNameMap","makePathsRelative","bindContextCache","context","root","modules","m","identifier","set","usedIds","add","id","recordedSplits","records","aggressiveSplits","usedSplits","concat","applySplit","splitData","undefined","has","selectedModules","map","get","every","Boolean","size","selectedChunks","getModuleChunksIterable","getNumberOfChunkModules","Array","from","length","addChunk","chunkReason","forEach","split","ids","changed","j","cmpFn","sortedChunks","sort","a","b","diff1","getChunkModulesSize","diff2","getOrderedChunkModules","filter","selectedModulesSize","k","newSize","push","recordHash","allSplits","invalidSplits","hash","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { STAGE_ADVANCED } = require(\"../OptimizationStages\");\nconst { intersect } = require(\"../util/SetHelpers\");\nconst {\n\tcompareModulesByIdentifier,\n\tcompareChunks\n} = require(\"../util/comparators\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst identifierUtils = require(\"../util/identifier\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.check.js\"),\n\t() =>\n\t\trequire(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\"),\n\t{\n\t\tname: \"Aggressive Splitting Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\nconst moveModuleBetween = (chunkGraph, oldChunk, newChunk) => {\n\treturn module => {\n\t\tchunkGraph.disconnectChunkAndModule(oldChunk, module);\n\t\tchunkGraph.connectChunkAndModule(newChunk, module);\n\t};\n};\n\n/**\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Chunk} chunk the chunk\n * @returns {function(Module): boolean} filter for entry module\n */\nconst isNotAEntryModule = (chunkGraph, chunk) => {\n\treturn module => {\n\t\treturn !chunkGraph.isEntryModuleInChunk(module, chunk);\n\t};\n};\n\n/** @type {WeakSet<Chunk>} */\nconst recordedChunks = new WeakSet();\n\nclass AggressiveSplittingPlugin {\n\t/**\n\t * @param {AggressiveSplittingPluginOptions=} options options object\n\t */\n\tconstructor(options = {}) {\n\t\tvalidate(options);\n\n\t\tthis.options = options;\n\t\tif (typeof this.options.minSize !== \"number\") {\n\t\t\tthis.options.minSize = 30 * 1024;\n\t\t}\n\t\tif (typeof this.options.maxSize !== \"number\") {\n\t\t\tthis.options.maxSize = 50 * 1024;\n\t\t}\n\t\tif (typeof this.options.chunkOverhead !== \"number\") {\n\t\t\tthis.options.chunkOverhead = 0;\n\t\t}\n\t\tif (typeof this.options.entryChunkMultiplicator !== \"number\") {\n\t\t\tthis.options.entryChunkMultiplicator = 1;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk to test\n\t * @returns {boolean} true if the chunk was recorded\n\t */\n\tstatic wasChunkRecorded(chunk) {\n\t\treturn recordedChunks.has(chunk);\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.thisCompilation.tap(\n\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\tcompilation => {\n\t\t\t\tlet needAdditionalSeal = false;\n\t\t\t\tlet newSplits;\n\t\t\t\tlet fromAggressiveSplittingSet;\n\t\t\t\tlet chunkSplitDataMap;\n\t\t\t\tcompilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", () => {\n\t\t\t\t\tnewSplits = [];\n\t\t\t\t\tfromAggressiveSplittingSet = new Set();\n\t\t\t\t\tchunkSplitDataMap = new Map();\n\t\t\t\t});\n\t\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"AggressiveSplittingPlugin\",\n\t\t\t\t\t\tstage: STAGE_ADVANCED\n\t\t\t\t\t},\n\t\t\t\t\tchunks => {\n\t\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\t\t// Precompute stuff\n\t\t\t\t\t\tconst nameToModuleMap = new Map();\n\t\t\t\t\t\tconst moduleToNameMap = new Map();\n\t\t\t\t\t\tconst makePathsRelative =\n\t\t\t\t\t\t\tidentifierUtils.makePathsRelative.bindContextCache(\n\t\t\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\t\t\tcompiler.root\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tfor (const m of compilation.modules) {\n\t\t\t\t\t\t\tconst name = makePathsRelative(m.identifier());\n\t\t\t\t\t\t\tnameToModuleMap.set(name, m);\n\t\t\t\t\t\t\tmoduleToNameMap.set(m, name);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check used chunk ids\n\t\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\tusedIds.add(chunk.id);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst recordedSplits =\n\t\t\t\t\t\t\t(compilation.records && compilation.records.aggressiveSplits) ||\n\t\t\t\t\t\t\t[];\n\t\t\t\t\t\tconst usedSplits = newSplits\n\t\t\t\t\t\t\t? recordedSplits.concat(newSplits)\n\t\t\t\t\t\t\t: recordedSplits;\n\n\t\t\t\t\t\tconst minSize = this.options.minSize;\n\t\t\t\t\t\tconst maxSize = this.options.maxSize;\n\n\t\t\t\t\t\tconst applySplit = splitData => {\n\t\t\t\t\t\t\t// Cannot split if id is already taken\n\t\t\t\t\t\t\tif (splitData.id !== undefined && usedIds.has(splitData.id)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get module objects from names\n\t\t\t\t\t\t\tconst selectedModules = splitData.modules.map(name =>\n\t\t\t\t\t\t\t\tnameToModuleMap.get(name)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Does the modules exist at all?\n\t\t\t\t\t\t\tif (!selectedModules.every(Boolean)) return false;\n\n\t\t\t\t\t\t\t// Check if size matches (faster than waiting for hash)\n\t\t\t\t\t\t\tlet size = 0;\n\t\t\t\t\t\t\tfor (const m of selectedModules) size += m.size();\n\t\t\t\t\t\t\tif (size !== splitData.size) return false;\n\n\t\t\t\t\t\t\t// get chunks with all modules\n\t\t\t\t\t\t\tconst selectedChunks = intersect(\n\t\t\t\t\t\t\t\tselectedModules.map(\n\t\t\t\t\t\t\t\t\tm => new Set(chunkGraph.getModuleChunksIterable(m))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// No relevant chunks found\n\t\t\t\t\t\t\tif (selectedChunks.size === 0) return false;\n\n\t\t\t\t\t\t\t// The found chunk is already the split or similar\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tselectedChunks.size === 1 &&\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(\n\t\t\t\t\t\t\t\t\tArray.from(selectedChunks)[0]\n\t\t\t\t\t\t\t\t) === selectedModules.length\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst chunk = Array.from(selectedChunks)[0];\n\t\t\t\t\t\t\t\tif (fromAggressiveSplittingSet.has(chunk)) return false;\n\t\t\t\t\t\t\t\tfromAggressiveSplittingSet.add(chunk);\n\t\t\t\t\t\t\t\tchunkSplitDataMap.set(chunk, splitData);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// split the chunk into two parts\n\t\t\t\t\t\t\tconst newChunk = compilation.addChunk();\n\t\t\t\t\t\t\tnewChunk.chunkReason = \"aggressive splitted\";\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\tselectedModules.forEach(\n\t\t\t\t\t\t\t\t\tmoveModuleBetween(chunkGraph, chunk, newChunk)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tchunk.split(newChunk);\n\t\t\t\t\t\t\t\tchunk.name = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfromAggressiveSplittingSet.add(newChunk);\n\t\t\t\t\t\t\tchunkSplitDataMap.set(newChunk, splitData);\n\n\t\t\t\t\t\t\tif (splitData.id !== null && splitData.id !== undefined) {\n\t\t\t\t\t\t\t\tnewChunk.id = splitData.id;\n\t\t\t\t\t\t\t\tnewChunk.ids = [splitData.id];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// try to restore to recorded splitting\n\t\t\t\t\t\tlet changed = false;\n\t\t\t\t\t\tfor (let j = 0; j < usedSplits.length; j++) {\n\t\t\t\t\t\t\tconst splitData = usedSplits[j];\n\t\t\t\t\t\t\tif (applySplit(splitData)) changed = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// for any chunk which isn't splitted yet, split it and create a new entry\n\t\t\t\t\t\t// start with the biggest chunk\n\t\t\t\t\t\tconst cmpFn = compareChunks(chunkGraph);\n\t\t\t\t\t\tconst sortedChunks = Array.from(chunks).sort((a, b) => {\n\t\t\t\t\t\t\tconst diff1 =\n\t\t\t\t\t\t\t\tchunkGraph.getChunkModulesSize(b) -\n\t\t\t\t\t\t\t\tchunkGraph.getChunkModulesSize(a);\n\t\t\t\t\t\t\tif (diff1) return diff1;\n\t\t\t\t\t\t\tconst diff2 =\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(a) -\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(b);\n\t\t\t\t\t\t\tif (diff2) return diff2;\n\t\t\t\t\t\t\treturn cmpFn(a, b);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfor (const chunk of sortedChunks) {\n\t\t\t\t\t\t\tif (fromAggressiveSplittingSet.has(chunk)) continue;\n\t\t\t\t\t\t\tconst size = chunkGraph.getChunkModulesSize(chunk);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tsize > maxSize &&\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(chunk) > 1\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst modules = chunkGraph\n\t\t\t\t\t\t\t\t\t.getOrderedChunkModules(chunk, compareModulesByIdentifier)\n\t\t\t\t\t\t\t\t\t.filter(isNotAEntryModule(chunkGraph, chunk));\n\t\t\t\t\t\t\t\tconst selectedModules = [];\n\t\t\t\t\t\t\t\tlet selectedModulesSize = 0;\n\t\t\t\t\t\t\t\tfor (let k = 0; k < modules.length; k++) {\n\t\t\t\t\t\t\t\t\tconst module = modules[k];\n\t\t\t\t\t\t\t\t\tconst newSize = selectedModulesSize + module.size();\n\t\t\t\t\t\t\t\t\tif (newSize > maxSize && selectedModulesSize >= minSize) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tselectedModulesSize = newSize;\n\t\t\t\t\t\t\t\t\tselectedModules.push(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (selectedModules.length === 0) continue;\n\t\t\t\t\t\t\t\tconst splitData = {\n\t\t\t\t\t\t\t\t\tmodules: selectedModules\n\t\t\t\t\t\t\t\t\t\t.map(m => moduleToNameMap.get(m))\n\t\t\t\t\t\t\t\t\t\t.sort(),\n\t\t\t\t\t\t\t\t\tsize: selectedModulesSize\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tif (applySplit(splitData)) {\n\t\t\t\t\t\t\t\t\tnewSplits = (newSplits || []).concat(splitData);\n\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (changed) return true;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.recordHash.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\trecords => {\n\t\t\t\t\t\t// 4. save made splittings to records\n\t\t\t\t\t\tconst allSplits = new Set();\n\t\t\t\t\t\tconst invalidSplits = new Set();\n\n\t\t\t\t\t\t// Check if some splittings are invalid\n\t\t\t\t\t\t// We remove invalid splittings and try again\n\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\tconst splitData = chunkSplitDataMap.get(chunk);\n\t\t\t\t\t\t\tif (splitData !== undefined) {\n\t\t\t\t\t\t\t\tif (splitData.hash && chunk.hash !== splitData.hash) {\n\t\t\t\t\t\t\t\t\t// Split was successful, but hash doesn't equal\n\t\t\t\t\t\t\t\t\t// We can throw away the split since it's useless now\n\t\t\t\t\t\t\t\t\tinvalidSplits.add(splitData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (invalidSplits.size > 0) {\n\t\t\t\t\t\t\trecords.aggressiveSplits = records.aggressiveSplits.filter(\n\t\t\t\t\t\t\t\tsplitData => !invalidSplits.has(splitData)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tneedAdditionalSeal = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// set hash and id values on all (new) splittings\n\t\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\t\tconst splitData = chunkSplitDataMap.get(chunk);\n\t\t\t\t\t\t\t\tif (splitData !== undefined) {\n\t\t\t\t\t\t\t\t\tsplitData.hash = chunk.hash;\n\t\t\t\t\t\t\t\t\tsplitData.id = chunk.id;\n\t\t\t\t\t\t\t\t\tallSplits.add(splitData);\n\t\t\t\t\t\t\t\t\t// set flag for stats\n\t\t\t\t\t\t\t\t\trecordedChunks.add(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Also add all unused historical splits (after the used ones)\n\t\t\t\t\t\t\t// They can still be used in some future compilation\n\t\t\t\t\t\t\tconst recordedSplits =\n\t\t\t\t\t\t\t\tcompilation.records && compilation.records.aggressiveSplits;\n\t\t\t\t\t\t\tif (recordedSplits) {\n\t\t\t\t\t\t\t\tfor (const splitData of recordedSplits) {\n\t\t\t\t\t\t\t\t\tif (!invalidSplits.has(splitData)) allSplits.add(splitData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// record all splits\n\t\t\t\t\t\t\trecords.aggressiveSplits = Array.from(allSplits);\n\n\t\t\t\t\t\t\tneedAdditionalSeal = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.needAdditionalSeal.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\t() => {\n\t\t\t\t\t\tif (needAdditionalSeal) {\n\t\t\t\t\t\t\tneedAdditionalSeal = false;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = AggressiveSplittingPlugin;\n"]},"metadata":{},"sourceType":"script"}