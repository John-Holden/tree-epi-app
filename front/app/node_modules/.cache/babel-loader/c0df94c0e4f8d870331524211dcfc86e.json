{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar ChunkGraph = require(\"./ChunkGraph\");\n\nvar Entrypoint = require(\"./Entrypoint\");\n\nvar _require = require(\"./util/SetHelpers\"),\n    intersect = _require.intersect;\n\nvar SortableSet = require(\"./util/SortableSet\");\n\nvar StringXor = require(\"./util/StringXor\");\n\nvar _require2 = require(\"./util/comparators\"),\n    compareModulesByIdentifier = _require2.compareModulesByIdentifier,\n    compareChunkGroupsByIndex = _require2.compareChunkGroupsByIndex,\n    compareModulesById = _require2.compareModulesById;\n\nvar _require3 = require(\"./util/deprecation\"),\n    createArrayToSetDeprecationSet = _require3.createArrayToSetDeprecationSet;\n\nvar _require4 = require(\"./util/runtime\"),\n    mergeRuntime = _require4.mergeRuntime;\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"./ChunkGraph\").ChunkFilterPredicate} ChunkFilterPredicate */\n\n/** @typedef {import(\"./ChunkGraph\").ChunkSizeOptions} ChunkSizeOptions */\n\n/** @typedef {import(\"./ChunkGraph\").ModuleFilterPredicate} ModuleFilterPredicate */\n\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"./Compilation\")} Compilation */\n\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n\n/** @typedef {import(\"./Compilation\").PathData} PathData */\n\n/** @typedef {import(\"./Entrypoint\").EntryOptions} EntryOptions */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n\n/** @typedef {import(\"./util/Hash\")} Hash */\n\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n\nvar ChunkFilesSet = createArrayToSetDeprecationSet(\"chunk.files\");\n/**\n * @typedef {Object} WithId an object who has an id property *\n * @property {string | number} id the id of the object\n */\n\n/**\n * @deprecated\n * @typedef {Object} ChunkMaps\n * @property {Record<string|number, string>} hash\n * @property {Record<string|number, Record<string, string>>} contentHash\n * @property {Record<string|number, string>} name\n */\n\n/**\n * @deprecated\n * @typedef {Object} ChunkModuleMaps\n * @property {Record<string|number, (string|number)[]>} id\n * @property {Record<string|number, string>} hash\n */\n\nvar debugId = 1000;\n/**\n * A Chunk is a unit of encapsulation for Modules.\n * Chunks are \"rendered\" into bundles that get emitted when the build completes.\n */\n\nvar Chunk = /*#__PURE__*/function () {\n  /**\n   * @param {string=} name of chunk being created, is optional (for subclasses)\n   * @param {boolean} backCompat enable backward-compatibility\n   */\n  function Chunk(name) {\n    var backCompat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    _classCallCheck(this, Chunk);\n\n    /** @type {number | string | null} */\n    this.id = null;\n    /** @type {(number|string)[] | null} */\n\n    this.ids = null;\n    /** @type {number} */\n\n    this.debugId = debugId++;\n    /** @type {string} */\n\n    this.name = name;\n    /** @type {SortableSet<string>} */\n\n    this.idNameHints = new SortableSet();\n    /** @type {boolean} */\n\n    this.preventIntegration = false;\n    /** @type {(string | function(PathData, AssetInfo=): string)?} */\n\n    this.filenameTemplate = undefined;\n    /** @type {(string | function(PathData, AssetInfo=): string)?} */\n\n    this.cssFilenameTemplate = undefined;\n    /** @private @type {SortableSet<ChunkGroup>} */\n\n    this._groups = new SortableSet(undefined, compareChunkGroupsByIndex);\n    /** @type {RuntimeSpec} */\n\n    this.runtime = undefined;\n    /** @type {Set<string>} */\n\n    this.files = backCompat ? new ChunkFilesSet() : new Set();\n    /** @type {Set<string>} */\n\n    this.auxiliaryFiles = new Set();\n    /** @type {boolean} */\n\n    this.rendered = false;\n    /** @type {string=} */\n\n    this.hash = undefined;\n    /** @type {Record<string, string>} */\n\n    this.contentHash = Object.create(null);\n    /** @type {string=} */\n\n    this.renderedHash = undefined;\n    /** @type {string=} */\n\n    this.chunkReason = undefined;\n    /** @type {boolean} */\n\n    this.extraAsync = false;\n  } // TODO remove in webpack 6\n  // BACKWARD-COMPAT START\n\n\n  _createClass(Chunk, [{\n    key: \"entryModule\",\n    get: function get() {\n      var entryModules = Array.from(ChunkGraph.getChunkGraphForChunk(this, \"Chunk.entryModule\", \"DEP_WEBPACK_CHUNK_ENTRY_MODULE\").getChunkEntryModulesIterable(this));\n\n      if (entryModules.length === 0) {\n        return undefined;\n      } else if (entryModules.length === 1) {\n        return entryModules[0];\n      } else {\n        throw new Error(\"Module.entryModule: Multiple entry modules are not supported by the deprecated API (Use the new ChunkGroup API)\");\n      }\n    }\n    /**\n     * @returns {boolean} true, if the chunk contains an entry module\n     */\n\n  }, {\n    key: \"hasEntryModule\",\n    value: function hasEntryModule() {\n      return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.hasEntryModule\", \"DEP_WEBPACK_CHUNK_HAS_ENTRY_MODULE\").getNumberOfEntryModules(this) > 0;\n    }\n    /**\n     * @param {Module} module the module\n     * @returns {boolean} true, if the chunk could be added\n     */\n\n  }, {\n    key: \"addModule\",\n    value: function addModule(module) {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.addModule\", \"DEP_WEBPACK_CHUNK_ADD_MODULE\");\n      if (chunkGraph.isModuleInChunk(module, this)) return false;\n      chunkGraph.connectChunkAndModule(this, module);\n      return true;\n    }\n    /**\n     * @param {Module} module the module\n     * @returns {void}\n     */\n\n  }, {\n    key: \"removeModule\",\n    value: function removeModule(module) {\n      ChunkGraph.getChunkGraphForChunk(this, \"Chunk.removeModule\", \"DEP_WEBPACK_CHUNK_REMOVE_MODULE\").disconnectChunkAndModule(this, module);\n    }\n    /**\n     * @returns {number} the number of module which are contained in this chunk\n     */\n\n  }, {\n    key: \"getNumberOfModules\",\n    value: function getNumberOfModules() {\n      return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.getNumberOfModules\", \"DEP_WEBPACK_CHUNK_GET_NUMBER_OF_MODULES\").getNumberOfChunkModules(this);\n    }\n  }, {\n    key: \"modulesIterable\",\n    get: function get() {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.modulesIterable\", \"DEP_WEBPACK_CHUNK_MODULES_ITERABLE\");\n      return chunkGraph.getOrderedChunkModulesIterable(this, compareModulesByIdentifier);\n    }\n    /**\n     * @param {Chunk} otherChunk the chunk to compare with\n     * @returns {-1|0|1} the comparison result\n     */\n\n  }, {\n    key: \"compareTo\",\n    value: function compareTo(otherChunk) {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.compareTo\", \"DEP_WEBPACK_CHUNK_COMPARE_TO\");\n      return chunkGraph.compareChunks(this, otherChunk);\n    }\n    /**\n     * @param {Module} module the module\n     * @returns {boolean} true, if the chunk contains the module\n     */\n\n  }, {\n    key: \"containsModule\",\n    value: function containsModule(module) {\n      return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.containsModule\", \"DEP_WEBPACK_CHUNK_CONTAINS_MODULE\").isModuleInChunk(module, this);\n    }\n    /**\n     * @returns {Module[]} the modules for this chunk\n     */\n\n  }, {\n    key: \"getModules\",\n    value: function getModules() {\n      return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.getModules\", \"DEP_WEBPACK_CHUNK_GET_MODULES\").getChunkModules(this);\n    }\n    /**\n     * @returns {void}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.remove\", \"DEP_WEBPACK_CHUNK_REMOVE\");\n      chunkGraph.disconnectChunk(this);\n      this.disconnectFromGroups();\n    }\n    /**\n     * @param {Module} module the module\n     * @param {Chunk} otherChunk the target chunk\n     * @returns {void}\n     */\n\n  }, {\n    key: \"moveModule\",\n    value: function moveModule(module, otherChunk) {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.moveModule\", \"DEP_WEBPACK_CHUNK_MOVE_MODULE\");\n      chunkGraph.disconnectChunkAndModule(this, module);\n      chunkGraph.connectChunkAndModule(otherChunk, module);\n    }\n    /**\n     * @param {Chunk} otherChunk the other chunk\n     * @returns {boolean} true, if the specified chunk has been integrated\n     */\n\n  }, {\n    key: \"integrate\",\n    value: function integrate(otherChunk) {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.integrate\", \"DEP_WEBPACK_CHUNK_INTEGRATE\");\n\n      if (chunkGraph.canChunksBeIntegrated(this, otherChunk)) {\n        chunkGraph.integrateChunks(this, otherChunk);\n        return true;\n      } else {\n        return false;\n      }\n    }\n    /**\n     * @param {Chunk} otherChunk the other chunk\n     * @returns {boolean} true, if chunks could be integrated\n     */\n\n  }, {\n    key: \"canBeIntegrated\",\n    value: function canBeIntegrated(otherChunk) {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.canBeIntegrated\", \"DEP_WEBPACK_CHUNK_CAN_BE_INTEGRATED\");\n      return chunkGraph.canChunksBeIntegrated(this, otherChunk);\n    }\n    /**\n     * @returns {boolean} true, if this chunk contains no module\n     */\n\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.isEmpty\", \"DEP_WEBPACK_CHUNK_IS_EMPTY\");\n      return chunkGraph.getNumberOfChunkModules(this) === 0;\n    }\n    /**\n     * @returns {number} total size of all modules in this chunk\n     */\n\n  }, {\n    key: \"modulesSize\",\n    value: function modulesSize() {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.modulesSize\", \"DEP_WEBPACK_CHUNK_MODULES_SIZE\");\n      return chunkGraph.getChunkModulesSize(this);\n    }\n    /**\n     * @param {ChunkSizeOptions} options options object\n     * @returns {number} total size of this chunk\n     */\n\n  }, {\n    key: \"size\",\n    value: function size() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.size\", \"DEP_WEBPACK_CHUNK_SIZE\");\n      return chunkGraph.getChunkSize(this, options);\n    }\n    /**\n     * @param {Chunk} otherChunk the other chunk\n     * @param {ChunkSizeOptions} options options object\n     * @returns {number} total size of the chunk or false if the chunk can't be integrated\n     */\n\n  }, {\n    key: \"integratedSize\",\n    value: function integratedSize(otherChunk, options) {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.integratedSize\", \"DEP_WEBPACK_CHUNK_INTEGRATED_SIZE\");\n      return chunkGraph.getIntegratedChunksSize(this, otherChunk, options);\n    }\n    /**\n     * @param {ModuleFilterPredicate} filterFn function used to filter modules\n     * @returns {ChunkModuleMaps} module map information\n     */\n\n  }, {\n    key: \"getChunkModuleMaps\",\n    value: function getChunkModuleMaps(filterFn) {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.getChunkModuleMaps\", \"DEP_WEBPACK_CHUNK_GET_CHUNK_MODULE_MAPS\");\n      /** @type {Record<string|number, (string|number)[]>} */\n\n      var chunkModuleIdMap = Object.create(null);\n      /** @type {Record<string|number, string>} */\n\n      var chunkModuleHashMap = Object.create(null);\n\n      var _iterator = _createForOfIteratorHelper(this.getAllAsyncChunks()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var asyncChunk = _step.value;\n\n          /** @type {(string|number)[]} */\n          var array = void 0;\n\n          var _iterator2 = _createForOfIteratorHelper(chunkGraph.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(chunkGraph))),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _module = _step2.value;\n\n              if (filterFn(_module)) {\n                if (array === undefined) {\n                  array = [];\n                  chunkModuleIdMap[asyncChunk.id] = array;\n                }\n\n                var moduleId = chunkGraph.getModuleId(_module);\n                array.push(moduleId);\n                chunkModuleHashMap[moduleId] = chunkGraph.getRenderedModuleHash(_module, undefined);\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return {\n        id: chunkModuleIdMap,\n        hash: chunkModuleHashMap\n      };\n    }\n    /**\n     * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\n     * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\n     * @returns {boolean} return true if module exists in graph\n     */\n\n  }, {\n    key: \"hasModuleInGraph\",\n    value: function hasModuleInGraph(filterFn, filterChunkFn) {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.hasModuleInGraph\", \"DEP_WEBPACK_CHUNK_HAS_MODULE_IN_GRAPH\");\n      return chunkGraph.hasModuleInGraph(this, filterFn, filterChunkFn);\n    }\n    /**\n     * @deprecated\n     * @param {boolean} realHash whether the full hash or the rendered hash is to be used\n     * @returns {ChunkMaps} the chunk map information\n     */\n\n  }, {\n    key: \"getChunkMaps\",\n    value: function getChunkMaps(realHash) {\n      /** @type {Record<string|number, string>} */\n      var chunkHashMap = Object.create(null);\n      /** @type {Record<string|number, Record<string, string>>} */\n\n      var chunkContentHashMap = Object.create(null);\n      /** @type {Record<string|number, string>} */\n\n      var chunkNameMap = Object.create(null);\n\n      var _iterator3 = _createForOfIteratorHelper(this.getAllAsyncChunks()),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var chunk = _step3.value;\n          chunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;\n\n          for (var _i = 0, _Object$keys = Object.keys(chunk.contentHash); _i < _Object$keys.length; _i++) {\n            var key = _Object$keys[_i];\n\n            if (!chunkContentHashMap[key]) {\n              chunkContentHashMap[key] = Object.create(null);\n            }\n\n            chunkContentHashMap[key][chunk.id] = chunk.contentHash[key];\n          }\n\n          if (chunk.name) {\n            chunkNameMap[chunk.id] = chunk.name;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return {\n        hash: chunkHashMap,\n        contentHash: chunkContentHashMap,\n        name: chunkNameMap\n      };\n    } // BACKWARD-COMPAT END\n\n    /**\n     * @returns {boolean} whether or not the Chunk will have a runtime\n     */\n\n  }, {\n    key: \"hasRuntime\",\n    value: function hasRuntime() {\n      var _iterator4 = _createForOfIteratorHelper(this._groups),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var chunkGroup = _step4.value;\n\n          if (chunkGroup instanceof Entrypoint && chunkGroup.getRuntimeChunk() === this) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return false;\n    }\n    /**\n     * @returns {boolean} whether or not this chunk can be an initial chunk\n     */\n\n  }, {\n    key: \"canBeInitial\",\n    value: function canBeInitial() {\n      var _iterator5 = _createForOfIteratorHelper(this._groups),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var chunkGroup = _step5.value;\n          if (chunkGroup.isInitial()) return true;\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return false;\n    }\n    /**\n     * @returns {boolean} whether this chunk can only be an initial chunk\n     */\n\n  }, {\n    key: \"isOnlyInitial\",\n    value: function isOnlyInitial() {\n      if (this._groups.size <= 0) return false;\n\n      var _iterator6 = _createForOfIteratorHelper(this._groups),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var chunkGroup = _step6.value;\n          if (!chunkGroup.isInitial()) return false;\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      return true;\n    }\n    /**\n     * @returns {EntryOptions | undefined} the entry options for this chunk\n     */\n\n  }, {\n    key: \"getEntryOptions\",\n    value: function getEntryOptions() {\n      var _iterator7 = _createForOfIteratorHelper(this._groups),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var chunkGroup = _step7.value;\n\n          if (chunkGroup instanceof Entrypoint) {\n            return chunkGroup.options;\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      return undefined;\n    }\n    /**\n     * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addGroup\",\n    value: function addGroup(chunkGroup) {\n      this._groups.add(chunkGroup);\n    }\n    /**\n     * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from\n     * @returns {void}\n     */\n\n  }, {\n    key: \"removeGroup\",\n    value: function removeGroup(chunkGroup) {\n      this._groups.delete(chunkGroup);\n    }\n    /**\n     * @param {ChunkGroup} chunkGroup the chunkGroup to check\n     * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup\n     */\n\n  }, {\n    key: \"isInGroup\",\n    value: function isInGroup(chunkGroup) {\n      return this._groups.has(chunkGroup);\n    }\n    /**\n     * @returns {number} the amount of groups that the said chunk is in\n     */\n\n  }, {\n    key: \"getNumberOfGroups\",\n    value: function getNumberOfGroups() {\n      return this._groups.size;\n    }\n    /**\n     * @returns {Iterable<ChunkGroup>} the chunkGroups that the said chunk is referenced in\n     */\n\n  }, {\n    key: \"groupsIterable\",\n    get: function get() {\n      this._groups.sort();\n\n      return this._groups;\n    }\n    /**\n     * @returns {void}\n     */\n\n  }, {\n    key: \"disconnectFromGroups\",\n    value: function disconnectFromGroups() {\n      var _iterator8 = _createForOfIteratorHelper(this._groups),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var chunkGroup = _step8.value;\n          chunkGroup.removeChunk(this);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n    /**\n     * @param {Chunk} newChunk the new chunk that will be split out of\n     * @returns {void}\n     */\n\n  }, {\n    key: \"split\",\n    value: function split(newChunk) {\n      var _iterator9 = _createForOfIteratorHelper(this._groups),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var chunkGroup = _step9.value;\n          chunkGroup.insertChunk(newChunk, this);\n          newChunk.addGroup(chunkGroup);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      var _iterator10 = _createForOfIteratorHelper(this.idNameHints),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var idHint = _step10.value;\n          newChunk.idNameHints.add(idHint);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      newChunk.runtime = mergeRuntime(newChunk.runtime, this.runtime);\n    }\n    /**\n     * @param {Hash} hash hash (will be modified)\n     * @param {ChunkGraph} chunkGraph the chunk graph\n     * @returns {void}\n     */\n\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash, chunkGraph) {\n      hash.update(\"\".concat(this.id, \" \").concat(this.ids ? this.ids.join() : \"\", \" \").concat(this.name || \"\", \" \"));\n      var xor = new StringXor();\n\n      var _iterator11 = _createForOfIteratorHelper(chunkGraph.getChunkModulesIterable(this)),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var m = _step11.value;\n          xor.add(chunkGraph.getModuleHash(m, this.runtime));\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n\n      xor.updateHash(hash);\n      var entryModules = chunkGraph.getChunkEntryModulesWithChunkGroupIterable(this);\n\n      var _iterator12 = _createForOfIteratorHelper(entryModules),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var _step12$value = _slicedToArray(_step12.value, 2),\n              _m = _step12$value[0],\n              chunkGroup = _step12$value[1];\n\n          hash.update(\"entry\".concat(chunkGraph.getModuleId(_m)).concat(chunkGroup.id));\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n    }\n    /**\n     * @returns {Set<Chunk>} a set of all the async chunks\n     */\n\n  }, {\n    key: \"getAllAsyncChunks\",\n    value: function getAllAsyncChunks() {\n      var queue = new Set();\n      var chunks = new Set();\n      var initialChunks = intersect(Array.from(this.groupsIterable, function (g) {\n        return new Set(g.chunks);\n      }));\n      var initialQueue = new Set(this.groupsIterable);\n\n      var _iterator13 = _createForOfIteratorHelper(initialQueue),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var chunkGroup = _step13.value;\n\n          var _iterator15 = _createForOfIteratorHelper(chunkGroup.childrenIterable),\n              _step15;\n\n          try {\n            for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n              var child = _step15.value;\n\n              if (child instanceof Entrypoint) {\n                initialQueue.add(child);\n              } else {\n                queue.add(child);\n              }\n            }\n          } catch (err) {\n            _iterator15.e(err);\n          } finally {\n            _iterator15.f();\n          }\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n\n      var _iterator14 = _createForOfIteratorHelper(queue),\n          _step14;\n\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var _chunkGroup = _step14.value;\n\n          var _iterator16 = _createForOfIteratorHelper(_chunkGroup.chunks),\n              _step16;\n\n          try {\n            for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n              var chunk = _step16.value;\n\n              if (!initialChunks.has(chunk)) {\n                chunks.add(chunk);\n              }\n            }\n          } catch (err) {\n            _iterator16.e(err);\n          } finally {\n            _iterator16.f();\n          }\n\n          var _iterator17 = _createForOfIteratorHelper(_chunkGroup.childrenIterable),\n              _step17;\n\n          try {\n            for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n              var _child = _step17.value;\n              queue.add(_child);\n            }\n          } catch (err) {\n            _iterator17.e(err);\n          } finally {\n            _iterator17.f();\n          }\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n\n      return chunks;\n    }\n    /**\n     * @returns {Set<Chunk>} a set of all the initial chunks (including itself)\n     */\n\n  }, {\n    key: \"getAllInitialChunks\",\n    value: function getAllInitialChunks() {\n      var chunks = new Set();\n      var queue = new Set(this.groupsIterable);\n\n      var _iterator18 = _createForOfIteratorHelper(queue),\n          _step18;\n\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var group = _step18.value;\n\n          if (group.isInitial()) {\n            var _iterator19 = _createForOfIteratorHelper(group.chunks),\n                _step19;\n\n            try {\n              for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                var c = _step19.value;\n                chunks.add(c);\n              }\n            } catch (err) {\n              _iterator19.e(err);\n            } finally {\n              _iterator19.f();\n            }\n\n            var _iterator20 = _createForOfIteratorHelper(group.childrenIterable),\n                _step20;\n\n            try {\n              for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n                var g = _step20.value;\n                queue.add(g);\n              }\n            } catch (err) {\n              _iterator20.e(err);\n            } finally {\n              _iterator20.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n\n      return chunks;\n    }\n    /**\n     * @returns {Set<Chunk>} a set of all the referenced chunks (including itself)\n     */\n\n  }, {\n    key: \"getAllReferencedChunks\",\n    value: function getAllReferencedChunks() {\n      var queue = new Set(this.groupsIterable);\n      var chunks = new Set();\n\n      var _iterator21 = _createForOfIteratorHelper(queue),\n          _step21;\n\n      try {\n        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n          var chunkGroup = _step21.value;\n\n          var _iterator22 = _createForOfIteratorHelper(chunkGroup.chunks),\n              _step22;\n\n          try {\n            for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n              var chunk = _step22.value;\n              chunks.add(chunk);\n            }\n          } catch (err) {\n            _iterator22.e(err);\n          } finally {\n            _iterator22.f();\n          }\n\n          var _iterator23 = _createForOfIteratorHelper(chunkGroup.childrenIterable),\n              _step23;\n\n          try {\n            for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n              var child = _step23.value;\n              queue.add(child);\n            }\n          } catch (err) {\n            _iterator23.e(err);\n          } finally {\n            _iterator23.f();\n          }\n        }\n      } catch (err) {\n        _iterator21.e(err);\n      } finally {\n        _iterator21.f();\n      }\n\n      return chunks;\n    }\n    /**\n     * @returns {Set<Entrypoint>} a set of all the referenced entrypoints\n     */\n\n  }, {\n    key: \"getAllReferencedAsyncEntrypoints\",\n    value: function getAllReferencedAsyncEntrypoints() {\n      var queue = new Set(this.groupsIterable);\n      var entrypoints = new Set();\n\n      var _iterator24 = _createForOfIteratorHelper(queue),\n          _step24;\n\n      try {\n        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n          var chunkGroup = _step24.value;\n\n          var _iterator25 = _createForOfIteratorHelper(chunkGroup.asyncEntrypointsIterable),\n              _step25;\n\n          try {\n            for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n              var entrypoint = _step25.value;\n              entrypoints.add(entrypoint);\n            }\n          } catch (err) {\n            _iterator25.e(err);\n          } finally {\n            _iterator25.f();\n          }\n\n          var _iterator26 = _createForOfIteratorHelper(chunkGroup.childrenIterable),\n              _step26;\n\n          try {\n            for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n              var child = _step26.value;\n              queue.add(child);\n            }\n          } catch (err) {\n            _iterator26.e(err);\n          } finally {\n            _iterator26.f();\n          }\n        }\n      } catch (err) {\n        _iterator24.e(err);\n      } finally {\n        _iterator24.f();\n      }\n\n      return entrypoints;\n    }\n    /**\n     * @returns {boolean} true, if the chunk references async chunks\n     */\n\n  }, {\n    key: \"hasAsyncChunks\",\n    value: function hasAsyncChunks() {\n      var queue = new Set();\n      var initialChunks = intersect(Array.from(this.groupsIterable, function (g) {\n        return new Set(g.chunks);\n      }));\n\n      var _iterator27 = _createForOfIteratorHelper(this.groupsIterable),\n          _step27;\n\n      try {\n        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n          var chunkGroup = _step27.value;\n\n          var _iterator29 = _createForOfIteratorHelper(chunkGroup.childrenIterable),\n              _step29;\n\n          try {\n            for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n              var child = _step29.value;\n              queue.add(child);\n            }\n          } catch (err) {\n            _iterator29.e(err);\n          } finally {\n            _iterator29.f();\n          }\n        }\n      } catch (err) {\n        _iterator27.e(err);\n      } finally {\n        _iterator27.f();\n      }\n\n      var _iterator28 = _createForOfIteratorHelper(queue),\n          _step28;\n\n      try {\n        for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n          var _chunkGroup2 = _step28.value;\n\n          var _iterator30 = _createForOfIteratorHelper(_chunkGroup2.chunks),\n              _step30;\n\n          try {\n            for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n              var chunk = _step30.value;\n\n              if (!initialChunks.has(chunk)) {\n                return true;\n              }\n            }\n          } catch (err) {\n            _iterator30.e(err);\n          } finally {\n            _iterator30.f();\n          }\n\n          var _iterator31 = _createForOfIteratorHelper(_chunkGroup2.childrenIterable),\n              _step31;\n\n          try {\n            for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n              var _child2 = _step31.value;\n              queue.add(_child2);\n            }\n          } catch (err) {\n            _iterator31.e(err);\n          } finally {\n            _iterator31.f();\n          }\n        }\n      } catch (err) {\n        _iterator28.e(err);\n      } finally {\n        _iterator28.f();\n      }\n\n      return false;\n    }\n    /**\n     * @param {ChunkGraph} chunkGraph the chunk graph\n     * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\n     * @returns {Record<string, (string | number)[]>} a record object of names to lists of child ids(?)\n     */\n\n  }, {\n    key: \"getChildIdsByOrders\",\n    value: function getChildIdsByOrders(chunkGraph, filterFn) {\n      /** @type {Map<string, {order: number, group: ChunkGroup}[]>} */\n      var lists = new Map();\n\n      var _iterator32 = _createForOfIteratorHelper(this.groupsIterable),\n          _step32;\n\n      try {\n        for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n          var group = _step32.value;\n\n          if (group.chunks[group.chunks.length - 1] === this) {\n            var _iterator34 = _createForOfIteratorHelper(group.childrenIterable),\n                _step34;\n\n            try {\n              for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n                var childGroup = _step34.value;\n\n                for (var _i2 = 0, _Object$keys2 = Object.keys(childGroup.options); _i2 < _Object$keys2.length; _i2++) {\n                  var key = _Object$keys2[_i2];\n\n                  if (key.endsWith(\"Order\")) {\n                    var name = key.substr(0, key.length - \"Order\".length);\n                    var list = lists.get(name);\n\n                    if (list === undefined) {\n                      list = [];\n                      lists.set(name, list);\n                    }\n\n                    list.push({\n                      order: childGroup.options[key],\n                      group: childGroup\n                    });\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator34.e(err);\n            } finally {\n              _iterator34.f();\n            }\n          }\n        }\n        /** @type {Record<string, (string | number)[]>} */\n\n      } catch (err) {\n        _iterator32.e(err);\n      } finally {\n        _iterator32.f();\n      }\n\n      var result = Object.create(null);\n\n      var _iterator33 = _createForOfIteratorHelper(lists),\n          _step33;\n\n      try {\n        for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n          var _step33$value = _slicedToArray(_step33.value, 2),\n              _name = _step33$value[0],\n              _list = _step33$value[1];\n\n          _list.sort(function (a, b) {\n            var cmp = b.order - a.order;\n            if (cmp !== 0) return cmp;\n            return a.group.compareTo(chunkGraph, b.group);\n          });\n          /** @type {Set<string | number>} */\n\n\n          var chunkIdSet = new Set();\n\n          var _iterator35 = _createForOfIteratorHelper(_list),\n              _step35;\n\n          try {\n            for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {\n              var item = _step35.value;\n\n              var _iterator36 = _createForOfIteratorHelper(item.group.chunks),\n                  _step36;\n\n              try {\n                for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {\n                  var chunk = _step36.value;\n                  if (filterFn && !filterFn(chunk, chunkGraph)) continue;\n                  chunkIdSet.add(chunk.id);\n                }\n              } catch (err) {\n                _iterator36.e(err);\n              } finally {\n                _iterator36.f();\n              }\n            }\n          } catch (err) {\n            _iterator35.e(err);\n          } finally {\n            _iterator35.f();\n          }\n\n          if (chunkIdSet.size > 0) {\n            result[_name] = Array.from(chunkIdSet);\n          }\n        }\n      } catch (err) {\n        _iterator33.e(err);\n      } finally {\n        _iterator33.f();\n      }\n\n      return result;\n    }\n    /**\n     * @param {ChunkGraph} chunkGraph the chunk graph\n     * @param {string} type option name\n     * @returns {{ onChunks: Chunk[], chunks: Set<Chunk> }[]} referenced chunks for a specific type\n     */\n\n  }, {\n    key: \"getChildrenOfTypeInOrder\",\n    value: function getChildrenOfTypeInOrder(chunkGraph, type) {\n      var list = [];\n\n      var _iterator37 = _createForOfIteratorHelper(this.groupsIterable),\n          _step37;\n\n      try {\n        for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {\n          var _group = _step37.value;\n\n          var _iterator39 = _createForOfIteratorHelper(_group.childrenIterable),\n              _step39;\n\n          try {\n            for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {\n              var _childGroup = _step39.value;\n              var order = _childGroup.options[type];\n              if (order === undefined) continue;\n              list.push({\n                order: order,\n                group: _group,\n                childGroup: _childGroup\n              });\n            }\n          } catch (err) {\n            _iterator39.e(err);\n          } finally {\n            _iterator39.f();\n          }\n        }\n      } catch (err) {\n        _iterator37.e(err);\n      } finally {\n        _iterator37.f();\n      }\n\n      if (list.length === 0) return undefined;\n      list.sort(function (a, b) {\n        var cmp = b.order - a.order;\n        if (cmp !== 0) return cmp;\n        return a.group.compareTo(chunkGraph, b.group);\n      });\n      var result = [];\n      var lastEntry;\n\n      for (var _i3 = 0, _list2 = list; _i3 < _list2.length; _i3++) {\n        var _list2$_i = _list2[_i3],\n            group = _list2$_i.group,\n            childGroup = _list2$_i.childGroup;\n\n        if (lastEntry && lastEntry.onChunks === group.chunks) {\n          var _iterator38 = _createForOfIteratorHelper(childGroup.chunks),\n              _step38;\n\n          try {\n            for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {\n              var chunk = _step38.value;\n              lastEntry.chunks.add(chunk);\n            }\n          } catch (err) {\n            _iterator38.e(err);\n          } finally {\n            _iterator38.f();\n          }\n        } else {\n          result.push(lastEntry = {\n            onChunks: group.chunks,\n            chunks: new Set(childGroup.chunks)\n          });\n        }\n      }\n\n      return result;\n    }\n    /**\n     * @param {ChunkGraph} chunkGraph the chunk graph\n     * @param {boolean=} includeDirectChildren include direct children (by default only children of async children are included)\n     * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\n     * @returns {Record<string|number, Record<string, (string | number)[]>>} a record object of names to lists of child ids(?) by chunk id\n     */\n\n  }, {\n    key: \"getChildIdsByOrdersMap\",\n    value: function getChildIdsByOrdersMap(chunkGraph, includeDirectChildren, filterFn) {\n      /** @type {Record<string|number, Record<string, (string | number)[]>>} */\n      var chunkMaps = Object.create(null);\n      /**\n       * @param {Chunk} chunk a chunk\n       * @returns {void}\n       */\n\n      var addChildIdsByOrdersToMap = function addChildIdsByOrdersToMap(chunk) {\n        var data = chunk.getChildIdsByOrders(chunkGraph, filterFn);\n\n        for (var _i4 = 0, _Object$keys3 = Object.keys(data); _i4 < _Object$keys3.length; _i4++) {\n          var key = _Object$keys3[_i4];\n          var chunkMap = chunkMaps[key];\n\n          if (chunkMap === undefined) {\n            chunkMaps[key] = chunkMap = Object.create(null);\n          }\n\n          chunkMap[chunk.id] = data[key];\n        }\n      };\n\n      if (includeDirectChildren) {\n        /** @type {Set<Chunk>} */\n        var chunks = new Set();\n\n        var _iterator40 = _createForOfIteratorHelper(this.groupsIterable),\n            _step40;\n\n        try {\n          for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {\n            var chunkGroup = _step40.value;\n\n            var _iterator42 = _createForOfIteratorHelper(chunkGroup.chunks),\n                _step42;\n\n            try {\n              for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {\n                var chunk = _step42.value;\n                chunks.add(chunk);\n              }\n            } catch (err) {\n              _iterator42.e(err);\n            } finally {\n              _iterator42.f();\n            }\n          }\n        } catch (err) {\n          _iterator40.e(err);\n        } finally {\n          _iterator40.f();\n        }\n\n        var _iterator41 = _createForOfIteratorHelper(chunks),\n            _step41;\n\n        try {\n          for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {\n            var _chunk = _step41.value;\n            addChildIdsByOrdersToMap(_chunk);\n          }\n        } catch (err) {\n          _iterator41.e(err);\n        } finally {\n          _iterator41.f();\n        }\n      }\n\n      var _iterator43 = _createForOfIteratorHelper(this.getAllAsyncChunks()),\n          _step43;\n\n      try {\n        for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {\n          var _chunk2 = _step43.value;\n          addChildIdsByOrdersToMap(_chunk2);\n        }\n      } catch (err) {\n        _iterator43.e(err);\n      } finally {\n        _iterator43.f();\n      }\n\n      return chunkMaps;\n    }\n  }]);\n\n  return Chunk;\n}();\n\nmodule.exports = Chunk;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/Chunk.js"],"names":["ChunkGraph","require","Entrypoint","intersect","SortableSet","StringXor","compareModulesByIdentifier","compareChunkGroupsByIndex","compareModulesById","createArrayToSetDeprecationSet","mergeRuntime","ChunkFilesSet","debugId","Chunk","name","backCompat","id","ids","idNameHints","preventIntegration","filenameTemplate","undefined","cssFilenameTemplate","_groups","runtime","files","Set","auxiliaryFiles","rendered","hash","contentHash","Object","create","renderedHash","chunkReason","extraAsync","entryModules","Array","from","getChunkGraphForChunk","getChunkEntryModulesIterable","length","Error","getNumberOfEntryModules","module","chunkGraph","isModuleInChunk","connectChunkAndModule","disconnectChunkAndModule","getNumberOfChunkModules","getOrderedChunkModulesIterable","otherChunk","compareChunks","getChunkModules","disconnectChunk","disconnectFromGroups","canChunksBeIntegrated","integrateChunks","getChunkModulesSize","options","getChunkSize","getIntegratedChunksSize","filterFn","chunkModuleIdMap","chunkModuleHashMap","getAllAsyncChunks","asyncChunk","array","moduleId","getModuleId","push","getRenderedModuleHash","filterChunkFn","hasModuleInGraph","realHash","chunkHashMap","chunkContentHashMap","chunkNameMap","chunk","keys","key","chunkGroup","getRuntimeChunk","isInitial","size","add","delete","has","sort","removeChunk","newChunk","insertChunk","addGroup","idHint","update","join","xor","getChunkModulesIterable","m","getModuleHash","updateHash","getChunkEntryModulesWithChunkGroupIterable","queue","chunks","initialChunks","groupsIterable","g","initialQueue","childrenIterable","child","group","c","entrypoints","asyncEntrypointsIterable","entrypoint","lists","Map","childGroup","endsWith","substr","list","get","set","order","result","a","b","cmp","compareTo","chunkIdSet","item","type","lastEntry","onChunks","includeDirectChildren","chunkMaps","addChildIdsByOrdersToMap","data","getChildIdsByOrders","chunkMap","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst ChunkGraph = require(\"./ChunkGraph\");\nconst Entrypoint = require(\"./Entrypoint\");\nconst { intersect } = require(\"./util/SetHelpers\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst StringXor = require(\"./util/StringXor\");\nconst {\n\tcompareModulesByIdentifier,\n\tcompareChunkGroupsByIndex,\n\tcompareModulesById\n} = require(\"./util/comparators\");\nconst { createArrayToSetDeprecationSet } = require(\"./util/deprecation\");\nconst { mergeRuntime } = require(\"./util/runtime\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./ChunkGraph\").ChunkFilterPredicate} ChunkFilterPredicate */\n/** @typedef {import(\"./ChunkGraph\").ChunkSizeOptions} ChunkSizeOptions */\n/** @typedef {import(\"./ChunkGraph\").ModuleFilterPredicate} ModuleFilterPredicate */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"./Compilation\").PathData} PathData */\n/** @typedef {import(\"./Entrypoint\").EntryOptions} EntryOptions */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\nconst ChunkFilesSet = createArrayToSetDeprecationSet(\"chunk.files\");\n\n/**\n * @typedef {Object} WithId an object who has an id property *\n * @property {string | number} id the id of the object\n */\n\n/**\n * @deprecated\n * @typedef {Object} ChunkMaps\n * @property {Record<string|number, string>} hash\n * @property {Record<string|number, Record<string, string>>} contentHash\n * @property {Record<string|number, string>} name\n */\n\n/**\n * @deprecated\n * @typedef {Object} ChunkModuleMaps\n * @property {Record<string|number, (string|number)[]>} id\n * @property {Record<string|number, string>} hash\n */\n\nlet debugId = 1000;\n\n/**\n * A Chunk is a unit of encapsulation for Modules.\n * Chunks are \"rendered\" into bundles that get emitted when the build completes.\n */\nclass Chunk {\n\t/**\n\t * @param {string=} name of chunk being created, is optional (for subclasses)\n\t * @param {boolean} backCompat enable backward-compatibility\n\t */\n\tconstructor(name, backCompat = true) {\n\t\t/** @type {number | string | null} */\n\t\tthis.id = null;\n\t\t/** @type {(number|string)[] | null} */\n\t\tthis.ids = null;\n\t\t/** @type {number} */\n\t\tthis.debugId = debugId++;\n\t\t/** @type {string} */\n\t\tthis.name = name;\n\t\t/** @type {SortableSet<string>} */\n\t\tthis.idNameHints = new SortableSet();\n\t\t/** @type {boolean} */\n\t\tthis.preventIntegration = false;\n\t\t/** @type {(string | function(PathData, AssetInfo=): string)?} */\n\t\tthis.filenameTemplate = undefined;\n\t\t/** @type {(string | function(PathData, AssetInfo=): string)?} */\n\t\tthis.cssFilenameTemplate = undefined;\n\t\t/** @private @type {SortableSet<ChunkGroup>} */\n\t\tthis._groups = new SortableSet(undefined, compareChunkGroupsByIndex);\n\t\t/** @type {RuntimeSpec} */\n\t\tthis.runtime = undefined;\n\t\t/** @type {Set<string>} */\n\t\tthis.files = backCompat ? new ChunkFilesSet() : new Set();\n\t\t/** @type {Set<string>} */\n\t\tthis.auxiliaryFiles = new Set();\n\t\t/** @type {boolean} */\n\t\tthis.rendered = false;\n\t\t/** @type {string=} */\n\t\tthis.hash = undefined;\n\t\t/** @type {Record<string, string>} */\n\t\tthis.contentHash = Object.create(null);\n\t\t/** @type {string=} */\n\t\tthis.renderedHash = undefined;\n\t\t/** @type {string=} */\n\t\tthis.chunkReason = undefined;\n\t\t/** @type {boolean} */\n\t\tthis.extraAsync = false;\n\t}\n\n\t// TODO remove in webpack 6\n\t// BACKWARD-COMPAT START\n\tget entryModule() {\n\t\tconst entryModules = Array.from(\n\t\t\tChunkGraph.getChunkGraphForChunk(\n\t\t\t\tthis,\n\t\t\t\t\"Chunk.entryModule\",\n\t\t\t\t\"DEP_WEBPACK_CHUNK_ENTRY_MODULE\"\n\t\t\t).getChunkEntryModulesIterable(this)\n\t\t);\n\t\tif (entryModules.length === 0) {\n\t\t\treturn undefined;\n\t\t} else if (entryModules.length === 1) {\n\t\t\treturn entryModules[0];\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t\"Module.entryModule: Multiple entry modules are not supported by the deprecated API (Use the new ChunkGroup API)\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {boolean} true, if the chunk contains an entry module\n\t */\n\thasEntryModule() {\n\t\treturn (\n\t\t\tChunkGraph.getChunkGraphForChunk(\n\t\t\t\tthis,\n\t\t\t\t\"Chunk.hasEntryModule\",\n\t\t\t\t\"DEP_WEBPACK_CHUNK_HAS_ENTRY_MODULE\"\n\t\t\t).getNumberOfEntryModules(this) > 0\n\t\t);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {boolean} true, if the chunk could be added\n\t */\n\taddModule(module) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.addModule\",\n\t\t\t\"DEP_WEBPACK_CHUNK_ADD_MODULE\"\n\t\t);\n\t\tif (chunkGraph.isModuleInChunk(module, this)) return false;\n\t\tchunkGraph.connectChunkAndModule(this, module);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tremoveModule(module) {\n\t\tChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.removeModule\",\n\t\t\t\"DEP_WEBPACK_CHUNK_REMOVE_MODULE\"\n\t\t).disconnectChunkAndModule(this, module);\n\t}\n\n\t/**\n\t * @returns {number} the number of module which are contained in this chunk\n\t */\n\tgetNumberOfModules() {\n\t\treturn ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.getNumberOfModules\",\n\t\t\t\"DEP_WEBPACK_CHUNK_GET_NUMBER_OF_MODULES\"\n\t\t).getNumberOfChunkModules(this);\n\t}\n\n\tget modulesIterable() {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.modulesIterable\",\n\t\t\t\"DEP_WEBPACK_CHUNK_MODULES_ITERABLE\"\n\t\t);\n\t\treturn chunkGraph.getOrderedChunkModulesIterable(\n\t\t\tthis,\n\t\t\tcompareModulesByIdentifier\n\t\t);\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the chunk to compare with\n\t * @returns {-1|0|1} the comparison result\n\t */\n\tcompareTo(otherChunk) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.compareTo\",\n\t\t\t\"DEP_WEBPACK_CHUNK_COMPARE_TO\"\n\t\t);\n\t\treturn chunkGraph.compareChunks(this, otherChunk);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {boolean} true, if the chunk contains the module\n\t */\n\tcontainsModule(module) {\n\t\treturn ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.containsModule\",\n\t\t\t\"DEP_WEBPACK_CHUNK_CONTAINS_MODULE\"\n\t\t).isModuleInChunk(module, this);\n\t}\n\n\t/**\n\t * @returns {Module[]} the modules for this chunk\n\t */\n\tgetModules() {\n\t\treturn ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.getModules\",\n\t\t\t\"DEP_WEBPACK_CHUNK_GET_MODULES\"\n\t\t).getChunkModules(this);\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tremove() {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.remove\",\n\t\t\t\"DEP_WEBPACK_CHUNK_REMOVE\"\n\t\t);\n\t\tchunkGraph.disconnectChunk(this);\n\t\tthis.disconnectFromGroups();\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {Chunk} otherChunk the target chunk\n\t * @returns {void}\n\t */\n\tmoveModule(module, otherChunk) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.moveModule\",\n\t\t\t\"DEP_WEBPACK_CHUNK_MOVE_MODULE\"\n\t\t);\n\t\tchunkGraph.disconnectChunkAndModule(this, module);\n\t\tchunkGraph.connectChunkAndModule(otherChunk, module);\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the other chunk\n\t * @returns {boolean} true, if the specified chunk has been integrated\n\t */\n\tintegrate(otherChunk) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.integrate\",\n\t\t\t\"DEP_WEBPACK_CHUNK_INTEGRATE\"\n\t\t);\n\t\tif (chunkGraph.canChunksBeIntegrated(this, otherChunk)) {\n\t\t\tchunkGraph.integrateChunks(this, otherChunk);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the other chunk\n\t * @returns {boolean} true, if chunks could be integrated\n\t */\n\tcanBeIntegrated(otherChunk) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.canBeIntegrated\",\n\t\t\t\"DEP_WEBPACK_CHUNK_CAN_BE_INTEGRATED\"\n\t\t);\n\t\treturn chunkGraph.canChunksBeIntegrated(this, otherChunk);\n\t}\n\n\t/**\n\t * @returns {boolean} true, if this chunk contains no module\n\t */\n\tisEmpty() {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.isEmpty\",\n\t\t\t\"DEP_WEBPACK_CHUNK_IS_EMPTY\"\n\t\t);\n\t\treturn chunkGraph.getNumberOfChunkModules(this) === 0;\n\t}\n\n\t/**\n\t * @returns {number} total size of all modules in this chunk\n\t */\n\tmodulesSize() {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.modulesSize\",\n\t\t\t\"DEP_WEBPACK_CHUNK_MODULES_SIZE\"\n\t\t);\n\t\treturn chunkGraph.getChunkModulesSize(this);\n\t}\n\n\t/**\n\t * @param {ChunkSizeOptions} options options object\n\t * @returns {number} total size of this chunk\n\t */\n\tsize(options = {}) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.size\",\n\t\t\t\"DEP_WEBPACK_CHUNK_SIZE\"\n\t\t);\n\t\treturn chunkGraph.getChunkSize(this, options);\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the other chunk\n\t * @param {ChunkSizeOptions} options options object\n\t * @returns {number} total size of the chunk or false if the chunk can't be integrated\n\t */\n\tintegratedSize(otherChunk, options) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.integratedSize\",\n\t\t\t\"DEP_WEBPACK_CHUNK_INTEGRATED_SIZE\"\n\t\t);\n\t\treturn chunkGraph.getIntegratedChunksSize(this, otherChunk, options);\n\t}\n\n\t/**\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\n\t * @returns {ChunkModuleMaps} module map information\n\t */\n\tgetChunkModuleMaps(filterFn) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.getChunkModuleMaps\",\n\t\t\t\"DEP_WEBPACK_CHUNK_GET_CHUNK_MODULE_MAPS\"\n\t\t);\n\t\t/** @type {Record<string|number, (string|number)[]>} */\n\t\tconst chunkModuleIdMap = Object.create(null);\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkModuleHashMap = Object.create(null);\n\n\t\tfor (const asyncChunk of this.getAllAsyncChunks()) {\n\t\t\t/** @type {(string|number)[]} */\n\t\t\tlet array;\n\t\t\tfor (const module of chunkGraph.getOrderedChunkModulesIterable(\n\t\t\t\tasyncChunk,\n\t\t\t\tcompareModulesById(chunkGraph)\n\t\t\t)) {\n\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\tchunkModuleIdMap[asyncChunk.id] = array;\n\t\t\t\t\t}\n\t\t\t\t\tconst moduleId = chunkGraph.getModuleId(module);\n\t\t\t\t\tarray.push(moduleId);\n\t\t\t\t\tchunkModuleHashMap[moduleId] = chunkGraph.getRenderedModuleHash(\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tundefined\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tid: chunkModuleIdMap,\n\t\t\thash: chunkModuleHashMap\n\t\t};\n\t}\n\n\t/**\n\t * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\n\t * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\n\t * @returns {boolean} return true if module exists in graph\n\t */\n\thasModuleInGraph(filterFn, filterChunkFn) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.hasModuleInGraph\",\n\t\t\t\"DEP_WEBPACK_CHUNK_HAS_MODULE_IN_GRAPH\"\n\t\t);\n\t\treturn chunkGraph.hasModuleInGraph(this, filterFn, filterChunkFn);\n\t}\n\n\t/**\n\t * @deprecated\n\t * @param {boolean} realHash whether the full hash or the rendered hash is to be used\n\t * @returns {ChunkMaps} the chunk map information\n\t */\n\tgetChunkMaps(realHash) {\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkHashMap = Object.create(null);\n\t\t/** @type {Record<string|number, Record<string, string>>} */\n\t\tconst chunkContentHashMap = Object.create(null);\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkNameMap = Object.create(null);\n\n\t\tfor (const chunk of this.getAllAsyncChunks()) {\n\t\t\tchunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;\n\t\t\tfor (const key of Object.keys(chunk.contentHash)) {\n\t\t\t\tif (!chunkContentHashMap[key]) {\n\t\t\t\t\tchunkContentHashMap[key] = Object.create(null);\n\t\t\t\t}\n\t\t\t\tchunkContentHashMap[key][chunk.id] = chunk.contentHash[key];\n\t\t\t}\n\t\t\tif (chunk.name) {\n\t\t\t\tchunkNameMap[chunk.id] = chunk.name;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\thash: chunkHashMap,\n\t\t\tcontentHash: chunkContentHashMap,\n\t\t\tname: chunkNameMap\n\t\t};\n\t}\n\t// BACKWARD-COMPAT END\n\n\t/**\n\t * @returns {boolean} whether or not the Chunk will have a runtime\n\t */\n\thasRuntime() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (\n\t\t\t\tchunkGroup instanceof Entrypoint &&\n\t\t\t\tchunkGroup.getRuntimeChunk() === this\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {boolean} whether or not this chunk can be an initial chunk\n\t */\n\tcanBeInitial() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (chunkGroup.isInitial()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {boolean} whether this chunk can only be an initial chunk\n\t */\n\tisOnlyInitial() {\n\t\tif (this._groups.size <= 0) return false;\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (!chunkGroup.isInitial()) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @returns {EntryOptions | undefined} the entry options for this chunk\n\t */\n\tgetEntryOptions() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (chunkGroup instanceof Entrypoint) {\n\t\t\t\treturn chunkGroup.options;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added\n\t * @returns {void}\n\t */\n\taddGroup(chunkGroup) {\n\t\tthis._groups.add(chunkGroup);\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from\n\t * @returns {void}\n\t */\n\tremoveGroup(chunkGroup) {\n\t\tthis._groups.delete(chunkGroup);\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup to check\n\t * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup\n\t */\n\tisInGroup(chunkGroup) {\n\t\treturn this._groups.has(chunkGroup);\n\t}\n\n\t/**\n\t * @returns {number} the amount of groups that the said chunk is in\n\t */\n\tgetNumberOfGroups() {\n\t\treturn this._groups.size;\n\t}\n\n\t/**\n\t * @returns {Iterable<ChunkGroup>} the chunkGroups that the said chunk is referenced in\n\t */\n\tget groupsIterable() {\n\t\tthis._groups.sort();\n\t\treturn this._groups;\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tdisconnectFromGroups() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tchunkGroup.removeChunk(this);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} newChunk the new chunk that will be split out of\n\t * @returns {void}\n\t */\n\tsplit(newChunk) {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tchunkGroup.insertChunk(newChunk, this);\n\t\t\tnewChunk.addGroup(chunkGroup);\n\t\t}\n\t\tfor (const idHint of this.idNameHints) {\n\t\t\tnewChunk.idNameHints.add(idHint);\n\t\t}\n\t\tnewChunk.runtime = mergeRuntime(newChunk.runtime, this.runtime);\n\t}\n\n\t/**\n\t * @param {Hash} hash hash (will be modified)\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @returns {void}\n\t */\n\tupdateHash(hash, chunkGraph) {\n\t\thash.update(\n\t\t\t`${this.id} ${this.ids ? this.ids.join() : \"\"} ${this.name || \"\"} `\n\t\t);\n\t\tconst xor = new StringXor();\n\t\tfor (const m of chunkGraph.getChunkModulesIterable(this)) {\n\t\t\txor.add(chunkGraph.getModuleHash(m, this.runtime));\n\t\t}\n\t\txor.updateHash(hash);\n\t\tconst entryModules =\n\t\t\tchunkGraph.getChunkEntryModulesWithChunkGroupIterable(this);\n\t\tfor (const [m, chunkGroup] of entryModules) {\n\t\t\thash.update(`entry${chunkGraph.getModuleId(m)}${chunkGroup.id}`);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {Set<Chunk>} a set of all the async chunks\n\t */\n\tgetAllAsyncChunks() {\n\t\tconst queue = new Set();\n\t\tconst chunks = new Set();\n\n\t\tconst initialChunks = intersect(\n\t\t\tArray.from(this.groupsIterable, g => new Set(g.chunks))\n\t\t);\n\n\t\tconst initialQueue = new Set(this.groupsIterable);\n\n\t\tfor (const chunkGroup of initialQueue) {\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tif (child instanceof Entrypoint) {\n\t\t\t\t\tinitialQueue.add(child);\n\t\t\t\t} else {\n\t\t\t\t\tqueue.add(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tif (!initialChunks.has(chunk)) {\n\t\t\t\t\tchunks.add(chunk);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn chunks;\n\t}\n\n\t/**\n\t * @returns {Set<Chunk>} a set of all the initial chunks (including itself)\n\t */\n\tgetAllInitialChunks() {\n\t\tconst chunks = new Set();\n\t\tconst queue = new Set(this.groupsIterable);\n\t\tfor (const group of queue) {\n\t\t\tif (group.isInitial()) {\n\t\t\t\tfor (const c of group.chunks) chunks.add(c);\n\t\t\t\tfor (const g of group.childrenIterable) queue.add(g);\n\t\t\t}\n\t\t}\n\t\treturn chunks;\n\t}\n\n\t/**\n\t * @returns {Set<Chunk>} a set of all the referenced chunks (including itself)\n\t */\n\tgetAllReferencedChunks() {\n\t\tconst queue = new Set(this.groupsIterable);\n\t\tconst chunks = new Set();\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tchunks.add(chunk);\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn chunks;\n\t}\n\n\t/**\n\t * @returns {Set<Entrypoint>} a set of all the referenced entrypoints\n\t */\n\tgetAllReferencedAsyncEntrypoints() {\n\t\tconst queue = new Set(this.groupsIterable);\n\t\tconst entrypoints = new Set();\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const entrypoint of chunkGroup.asyncEntrypointsIterable) {\n\t\t\t\tentrypoints.add(entrypoint);\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn entrypoints;\n\t}\n\n\t/**\n\t * @returns {boolean} true, if the chunk references async chunks\n\t */\n\thasAsyncChunks() {\n\t\tconst queue = new Set();\n\n\t\tconst initialChunks = intersect(\n\t\t\tArray.from(this.groupsIterable, g => new Set(g.chunks))\n\t\t);\n\n\t\tfor (const chunkGroup of this.groupsIterable) {\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tif (!initialChunks.has(chunk)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\n\t * @returns {Record<string, (string | number)[]>} a record object of names to lists of child ids(?)\n\t */\n\tgetChildIdsByOrders(chunkGraph, filterFn) {\n\t\t/** @type {Map<string, {order: number, group: ChunkGroup}[]>} */\n\t\tconst lists = new Map();\n\t\tfor (const group of this.groupsIterable) {\n\t\t\tif (group.chunks[group.chunks.length - 1] === this) {\n\t\t\t\tfor (const childGroup of group.childrenIterable) {\n\t\t\t\t\tfor (const key of Object.keys(childGroup.options)) {\n\t\t\t\t\t\tif (key.endsWith(\"Order\")) {\n\t\t\t\t\t\t\tconst name = key.substr(0, key.length - \"Order\".length);\n\t\t\t\t\t\t\tlet list = lists.get(name);\n\t\t\t\t\t\t\tif (list === undefined) {\n\t\t\t\t\t\t\t\tlist = [];\n\t\t\t\t\t\t\t\tlists.set(name, list);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlist.push({\n\t\t\t\t\t\t\t\torder: childGroup.options[key],\n\t\t\t\t\t\t\t\tgroup: childGroup\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/** @type {Record<string, (string | number)[]>} */\n\t\tconst result = Object.create(null);\n\t\tfor (const [name, list] of lists) {\n\t\t\tlist.sort((a, b) => {\n\t\t\t\tconst cmp = b.order - a.order;\n\t\t\t\tif (cmp !== 0) return cmp;\n\t\t\t\treturn a.group.compareTo(chunkGraph, b.group);\n\t\t\t});\n\t\t\t/** @type {Set<string | number>} */\n\t\t\tconst chunkIdSet = new Set();\n\t\t\tfor (const item of list) {\n\t\t\t\tfor (const chunk of item.group.chunks) {\n\t\t\t\t\tif (filterFn && !filterFn(chunk, chunkGraph)) continue;\n\t\t\t\t\tchunkIdSet.add(chunk.id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chunkIdSet.size > 0) {\n\t\t\t\tresult[name] = Array.from(chunkIdSet);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {string} type option name\n\t * @returns {{ onChunks: Chunk[], chunks: Set<Chunk> }[]} referenced chunks for a specific type\n\t */\n\tgetChildrenOfTypeInOrder(chunkGraph, type) {\n\t\tconst list = [];\n\t\tfor (const group of this.groupsIterable) {\n\t\t\tfor (const childGroup of group.childrenIterable) {\n\t\t\t\tconst order = childGroup.options[type];\n\t\t\t\tif (order === undefined) continue;\n\t\t\t\tlist.push({\n\t\t\t\t\torder,\n\t\t\t\t\tgroup,\n\t\t\t\t\tchildGroup\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (list.length === 0) return undefined;\n\t\tlist.sort((a, b) => {\n\t\t\tconst cmp = b.order - a.order;\n\t\t\tif (cmp !== 0) return cmp;\n\t\t\treturn a.group.compareTo(chunkGraph, b.group);\n\t\t});\n\t\tconst result = [];\n\t\tlet lastEntry;\n\t\tfor (const { group, childGroup } of list) {\n\t\t\tif (lastEntry && lastEntry.onChunks === group.chunks) {\n\t\t\t\tfor (const chunk of childGroup.chunks) {\n\t\t\t\t\tlastEntry.chunks.add(chunk);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult.push(\n\t\t\t\t\t(lastEntry = {\n\t\t\t\t\t\tonChunks: group.chunks,\n\t\t\t\t\t\tchunks: new Set(childGroup.chunks)\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {boolean=} includeDirectChildren include direct children (by default only children of async children are included)\n\t * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\n\t * @returns {Record<string|number, Record<string, (string | number)[]>>} a record object of names to lists of child ids(?) by chunk id\n\t */\n\tgetChildIdsByOrdersMap(chunkGraph, includeDirectChildren, filterFn) {\n\t\t/** @type {Record<string|number, Record<string, (string | number)[]>>} */\n\t\tconst chunkMaps = Object.create(null);\n\n\t\t/**\n\t\t * @param {Chunk} chunk a chunk\n\t\t * @returns {void}\n\t\t */\n\t\tconst addChildIdsByOrdersToMap = chunk => {\n\t\t\tconst data = chunk.getChildIdsByOrders(chunkGraph, filterFn);\n\t\t\tfor (const key of Object.keys(data)) {\n\t\t\t\tlet chunkMap = chunkMaps[key];\n\t\t\t\tif (chunkMap === undefined) {\n\t\t\t\t\tchunkMaps[key] = chunkMap = Object.create(null);\n\t\t\t\t}\n\t\t\t\tchunkMap[chunk.id] = data[key];\n\t\t\t}\n\t\t};\n\n\t\tif (includeDirectChildren) {\n\t\t\t/** @type {Set<Chunk>} */\n\t\t\tconst chunks = new Set();\n\t\t\tfor (const chunkGroup of this.groupsIterable) {\n\t\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\t\tchunks.add(chunk);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const chunk of chunks) {\n\t\t\t\taddChildIdsByOrdersToMap(chunk);\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunk of this.getAllAsyncChunks()) {\n\t\t\taddChildIdsByOrdersToMap(chunk);\n\t\t}\n\n\t\treturn chunkMaps;\n\t}\n}\n\nmodule.exports = Chunk;\n"]},"metadata":{},"sourceType":"script"}