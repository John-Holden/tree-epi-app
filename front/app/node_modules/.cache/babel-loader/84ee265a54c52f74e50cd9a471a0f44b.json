{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar SortableSet = require(\"./SortableSet\");\n/** @typedef {import(\"../Compilation\")} Compilation */\n\n/** @typedef {import(\"../Entrypoint\").EntryOptions} EntryOptions */\n\n/** @typedef {string | SortableSet<string> | undefined} RuntimeSpec */\n\n/** @typedef {RuntimeSpec | boolean} RuntimeCondition */\n\n/**\n * @param {Compilation} compilation the compilation\n * @param {string} name name of the entry\n * @param {EntryOptions=} options optionally already received entry options\n * @returns {RuntimeSpec} runtime\n */\n\n\nexports.getEntryRuntime = function (compilation, name, options) {\n  var dependOn;\n  var runtime;\n\n  if (options) {\n    dependOn = options.dependOn;\n    runtime = options.runtime;\n  } else {\n    var entry = compilation.entries.get(name);\n    if (!entry) return name;\n    var _entry$options = entry.options;\n    dependOn = _entry$options.dependOn;\n    runtime = _entry$options.runtime;\n  }\n\n  if (dependOn) {\n    /** @type {RuntimeSpec} */\n    var result = undefined;\n    var queue = new Set(dependOn);\n\n    var _iterator = _createForOfIteratorHelper(queue),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _name = _step.value;\n        var dep = compilation.entries.get(_name);\n        if (!dep) continue;\n        var _dep$options = dep.options,\n            _dependOn = _dep$options.dependOn,\n            _runtime = _dep$options.runtime;\n\n        if (_dependOn) {\n          var _iterator2 = _createForOfIteratorHelper(_dependOn),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _name2 = _step2.value;\n              queue.add(_name2);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        } else {\n          result = mergeRuntimeOwned(result, _runtime || _name);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return result || name;\n  } else {\n    return runtime || name;\n  }\n};\n/**\n * @param {RuntimeSpec} runtime runtime\n * @param {function(string): void} fn functor\n * @param {boolean} deterministicOrder enforce a deterministic order\n * @returns {void}\n */\n\n\nexports.forEachRuntime = function (runtime, fn) {\n  var deterministicOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (runtime === undefined) {\n    fn(undefined);\n  } else if (typeof runtime === \"string\") {\n    fn(runtime);\n  } else {\n    if (deterministicOrder) runtime.sort();\n\n    var _iterator3 = _createForOfIteratorHelper(runtime),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var r = _step3.value;\n        fn(r);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n};\n\nvar getRuntimesKey = function getRuntimesKey(set) {\n  set.sort();\n  return Array.from(set).join(\"\\n\");\n};\n/**\n * @param {RuntimeSpec} runtime runtime(s)\n * @returns {string} key of runtimes\n */\n\n\nvar getRuntimeKey = function getRuntimeKey(runtime) {\n  if (runtime === undefined) return \"*\";\n  if (typeof runtime === \"string\") return runtime;\n  return runtime.getFromUnorderedCache(getRuntimesKey);\n};\n\nexports.getRuntimeKey = getRuntimeKey;\n/**\n * @param {string} key key of runtimes\n * @returns {RuntimeSpec} runtime(s)\n */\n\nvar keyToRuntime = function keyToRuntime(key) {\n  if (key === \"*\") return undefined;\n  var items = key.split(\"\\n\");\n  if (items.length === 1) return items[0];\n  return new SortableSet(items);\n};\n\nexports.keyToRuntime = keyToRuntime;\n\nvar getRuntimesString = function getRuntimesString(set) {\n  set.sort();\n  return Array.from(set).join(\"+\");\n};\n/**\n * @param {RuntimeSpec} runtime runtime(s)\n * @returns {string} readable version\n */\n\n\nvar runtimeToString = function runtimeToString(runtime) {\n  if (runtime === undefined) return \"*\";\n  if (typeof runtime === \"string\") return runtime;\n  return runtime.getFromUnorderedCache(getRuntimesString);\n};\n\nexports.runtimeToString = runtimeToString;\n/**\n * @param {RuntimeCondition} runtimeCondition runtime condition\n * @returns {string} readable version\n */\n\nexports.runtimeConditionToString = function (runtimeCondition) {\n  if (runtimeCondition === true) return \"true\";\n  if (runtimeCondition === false) return \"false\";\n  return runtimeToString(runtimeCondition);\n};\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {boolean} true, when they are equal\n */\n\n\nvar runtimeEqual = function runtimeEqual(a, b) {\n  if (a === b) {\n    return true;\n  } else if (a === undefined || b === undefined || typeof a === \"string\" || typeof b === \"string\") {\n    return false;\n  } else if (a.size !== b.size) {\n    return false;\n  } else {\n    a.sort();\n    b.sort();\n    var aIt = a[Symbol.iterator]();\n    var bIt = b[Symbol.iterator]();\n\n    for (;;) {\n      var aV = aIt.next();\n      if (aV.done) return true;\n      var bV = bIt.next();\n      if (aV.value !== bV.value) return false;\n    }\n  }\n};\n\nexports.runtimeEqual = runtimeEqual;\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {-1|0|1} compare\n */\n\nexports.compareRuntime = function (a, b) {\n  if (a === b) {\n    return 0;\n  } else if (a === undefined) {\n    return -1;\n  } else if (b === undefined) {\n    return 1;\n  } else {\n    var aKey = getRuntimeKey(a);\n    var bKey = getRuntimeKey(b);\n    if (aKey < bKey) return -1;\n    if (aKey > bKey) return 1;\n    return 0;\n  }\n};\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\n\n\nvar mergeRuntime = function mergeRuntime(a, b) {\n  if (a === undefined) {\n    return b;\n  } else if (b === undefined) {\n    return a;\n  } else if (a === b) {\n    return a;\n  } else if (typeof a === \"string\") {\n    if (typeof b === \"string\") {\n      var set = new SortableSet();\n      set.add(a);\n      set.add(b);\n      return set;\n    } else if (b.has(a)) {\n      return b;\n    } else {\n      var _set = new SortableSet(b);\n\n      _set.add(a);\n\n      return _set;\n    }\n  } else {\n    if (typeof b === \"string\") {\n      if (a.has(b)) return a;\n\n      var _set2 = new SortableSet(a);\n\n      _set2.add(b);\n\n      return _set2;\n    } else {\n      var _set3 = new SortableSet(a);\n\n      var _iterator4 = _createForOfIteratorHelper(b),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var item = _step4.value;\n\n          _set3.add(item);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      if (_set3.size === a.size) return a;\n      return _set3;\n    }\n  }\n};\n\nexports.mergeRuntime = mergeRuntime;\n/**\n * @param {RuntimeCondition} a first\n * @param {RuntimeCondition} b second\n * @param {RuntimeSpec} runtime full runtime\n * @returns {RuntimeCondition} result\n */\n\nexports.mergeRuntimeCondition = function (a, b, runtime) {\n  if (a === false) return b;\n  if (b === false) return a;\n  if (a === true || b === true) return true;\n  var merged = mergeRuntime(a, b);\n  if (merged === undefined) return undefined;\n\n  if (typeof merged === \"string\") {\n    if (typeof runtime === \"string\" && merged === runtime) return true;\n    return merged;\n  }\n\n  if (typeof runtime === \"string\" || runtime === undefined) return merged;\n  if (merged.size === runtime.size) return true;\n  return merged;\n};\n/**\n * @param {RuntimeSpec | true} a first\n * @param {RuntimeSpec | true} b second\n * @param {RuntimeSpec} runtime full runtime\n * @returns {RuntimeSpec | true} result\n */\n\n\nexports.mergeRuntimeConditionNonFalse = function (a, b, runtime) {\n  if (a === true || b === true) return true;\n  var merged = mergeRuntime(a, b);\n  if (merged === undefined) return undefined;\n\n  if (typeof merged === \"string\") {\n    if (typeof runtime === \"string\" && merged === runtime) return true;\n    return merged;\n  }\n\n  if (typeof runtime === \"string\" || runtime === undefined) return merged;\n  if (merged.size === runtime.size) return true;\n  return merged;\n};\n/**\n * @param {RuntimeSpec} a first (may be modified)\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\n\n\nvar mergeRuntimeOwned = function mergeRuntimeOwned(a, b) {\n  if (b === undefined) {\n    return a;\n  } else if (a === b) {\n    return a;\n  } else if (a === undefined) {\n    if (typeof b === \"string\") {\n      return b;\n    } else {\n      return new SortableSet(b);\n    }\n  } else if (typeof a === \"string\") {\n    if (typeof b === \"string\") {\n      var set = new SortableSet();\n      set.add(a);\n      set.add(b);\n      return set;\n    } else {\n      var _set4 = new SortableSet(b);\n\n      _set4.add(a);\n\n      return _set4;\n    }\n  } else {\n    if (typeof b === \"string\") {\n      a.add(b);\n      return a;\n    } else {\n      var _iterator5 = _createForOfIteratorHelper(b),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var item = _step5.value;\n          a.add(item);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return a;\n    }\n  }\n};\n\nexports.mergeRuntimeOwned = mergeRuntimeOwned;\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\n\nexports.intersectRuntime = function (a, b) {\n  if (a === undefined) {\n    return b;\n  } else if (b === undefined) {\n    return a;\n  } else if (a === b) {\n    return a;\n  } else if (typeof a === \"string\") {\n    if (typeof b === \"string\") {\n      return undefined;\n    } else if (b.has(a)) {\n      return a;\n    } else {\n      return undefined;\n    }\n  } else {\n    if (typeof b === \"string\") {\n      if (a.has(b)) return b;\n      return undefined;\n    } else {\n      var set = new SortableSet();\n\n      var _iterator6 = _createForOfIteratorHelper(b),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _item = _step6.value;\n          if (a.has(_item)) set.add(_item);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      if (set.size === 0) return undefined;\n\n      if (set.size === 1) {\n        var _iterator7 = _createForOfIteratorHelper(set),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var item = _step7.value;\n            return item;\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      }\n\n      return set;\n    }\n  }\n};\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} result\n */\n\n\nvar subtractRuntime = function subtractRuntime(a, b) {\n  if (a === undefined) {\n    return undefined;\n  } else if (b === undefined) {\n    return a;\n  } else if (a === b) {\n    return undefined;\n  } else if (typeof a === \"string\") {\n    if (typeof b === \"string\") {\n      return a;\n    } else if (b.has(a)) {\n      return undefined;\n    } else {\n      return a;\n    }\n  } else {\n    if (typeof b === \"string\") {\n      if (!a.has(b)) return a;\n\n      if (a.size === 2) {\n        var _iterator8 = _createForOfIteratorHelper(a),\n            _step8;\n\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var item = _step8.value;\n            if (item !== b) return item;\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n      }\n\n      var set = new SortableSet(a);\n      set.delete(b);\n    } else {\n      var _set5 = new SortableSet();\n\n      var _iterator9 = _createForOfIteratorHelper(a),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var _item3 = _step9.value;\n          if (!b.has(_item3)) _set5.add(_item3);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      if (_set5.size === 0) return undefined;\n\n      if (_set5.size === 1) {\n        var _iterator10 = _createForOfIteratorHelper(_set5),\n            _step10;\n\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var _item2 = _step10.value;\n            return _item2;\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n      }\n\n      return _set5;\n    }\n  }\n};\n\nexports.subtractRuntime = subtractRuntime;\n/**\n * @param {RuntimeCondition} a first\n * @param {RuntimeCondition} b second\n * @param {RuntimeSpec} runtime runtime\n * @returns {RuntimeCondition} result\n */\n\nexports.subtractRuntimeCondition = function (a, b, runtime) {\n  if (b === true) return false;\n  if (b === false) return a;\n  if (a === false) return false;\n  var result = subtractRuntime(a === true ? runtime : a, b);\n  return result === undefined ? false : result;\n};\n/**\n * @param {RuntimeSpec} runtime runtime\n * @param {function(RuntimeSpec): boolean} filter filter function\n * @returns {boolean | RuntimeSpec} true/false if filter is constant for all runtimes, otherwise runtimes that are active\n */\n\n\nexports.filterRuntime = function (runtime, filter) {\n  if (runtime === undefined) return filter(undefined);\n  if (typeof runtime === \"string\") return filter(runtime);\n  var some = false;\n  var every = true;\n  var result = undefined;\n\n  var _iterator11 = _createForOfIteratorHelper(runtime),\n      _step11;\n\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var r = _step11.value;\n      var v = filter(r);\n\n      if (v) {\n        some = true;\n        result = mergeRuntimeOwned(result, r);\n      } else {\n        every = false;\n      }\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n\n  if (!some) return false;\n  if (every) return true;\n  return result;\n};\n/**\n * @template T\n */\n\n\nvar RuntimeSpecMap = /*#__PURE__*/function () {\n  /**\n   * @param {RuntimeSpecMap<T>=} clone copy form this\n   */\n  function RuntimeSpecMap(clone) {\n    _classCallCheck(this, RuntimeSpecMap);\n\n    this._mode = clone ? clone._mode : 0; // 0 = empty, 1 = single entry, 2 = map\n\n    /** @type {RuntimeSpec} */\n\n    this._singleRuntime = clone ? clone._singleRuntime : undefined;\n    /** @type {T} */\n\n    this._singleValue = clone ? clone._singleValue : undefined;\n    /** @type {Map<string, T> | undefined} */\n\n    this._map = clone && clone._map ? new Map(clone._map) : undefined;\n  }\n  /**\n   * @param {RuntimeSpec} runtime the runtimes\n   * @returns {T} value\n   */\n\n\n  _createClass(RuntimeSpecMap, [{\n    key: \"get\",\n    value: function get(runtime) {\n      switch (this._mode) {\n        case 0:\n          return undefined;\n\n        case 1:\n          return runtimeEqual(this._singleRuntime, runtime) ? this._singleValue : undefined;\n\n        default:\n          return this._map.get(getRuntimeKey(runtime));\n      }\n    }\n    /**\n     * @param {RuntimeSpec} runtime the runtimes\n     * @returns {boolean} true, when the runtime is stored\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(runtime) {\n      switch (this._mode) {\n        case 0:\n          return false;\n\n        case 1:\n          return runtimeEqual(this._singleRuntime, runtime);\n\n        default:\n          return this._map.has(getRuntimeKey(runtime));\n      }\n    }\n  }, {\n    key: \"set\",\n    value: function set(runtime, value) {\n      switch (this._mode) {\n        case 0:\n          this._mode = 1;\n          this._singleRuntime = runtime;\n          this._singleValue = value;\n          break;\n\n        case 1:\n          if (runtimeEqual(this._singleRuntime, runtime)) {\n            this._singleValue = value;\n            break;\n          }\n\n          this._mode = 2;\n          this._map = new Map();\n\n          this._map.set(getRuntimeKey(this._singleRuntime), this._singleValue);\n\n          this._singleRuntime = undefined;\n          this._singleValue = undefined;\n\n        /* falls through */\n\n        default:\n          this._map.set(getRuntimeKey(runtime), value);\n\n      }\n    }\n  }, {\n    key: \"provide\",\n    value: function provide(runtime, computer) {\n      switch (this._mode) {\n        case 0:\n          this._mode = 1;\n          this._singleRuntime = runtime;\n          return this._singleValue = computer();\n\n        case 1:\n          {\n            if (runtimeEqual(this._singleRuntime, runtime)) {\n              return this._singleValue;\n            }\n\n            this._mode = 2;\n            this._map = new Map();\n\n            this._map.set(getRuntimeKey(this._singleRuntime), this._singleValue);\n\n            this._singleRuntime = undefined;\n            this._singleValue = undefined;\n            var newValue = computer();\n\n            this._map.set(getRuntimeKey(runtime), newValue);\n\n            return newValue;\n          }\n\n        default:\n          {\n            var key = getRuntimeKey(runtime);\n\n            var value = this._map.get(key);\n\n            if (value !== undefined) return value;\n\n            var _newValue = computer();\n\n            this._map.set(key, _newValue);\n\n            return _newValue;\n          }\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(runtime) {\n      switch (this._mode) {\n        case 0:\n          return;\n\n        case 1:\n          if (runtimeEqual(this._singleRuntime, runtime)) {\n            this._mode = 0;\n            this._singleRuntime = undefined;\n            this._singleValue = undefined;\n          }\n\n          return;\n\n        default:\n          this._map.delete(getRuntimeKey(runtime));\n\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(runtime, fn) {\n      switch (this._mode) {\n        case 0:\n          throw new Error(\"runtime passed to update must exist\");\n\n        case 1:\n          {\n            if (runtimeEqual(this._singleRuntime, runtime)) {\n              this._singleValue = fn(this._singleValue);\n              break;\n            }\n\n            var newValue = fn(undefined);\n\n            if (newValue !== undefined) {\n              this._mode = 2;\n              this._map = new Map();\n\n              this._map.set(getRuntimeKey(this._singleRuntime), this._singleValue);\n\n              this._singleRuntime = undefined;\n              this._singleValue = undefined;\n\n              this._map.set(getRuntimeKey(runtime), newValue);\n            }\n\n            break;\n          }\n\n        default:\n          {\n            var key = getRuntimeKey(runtime);\n\n            var oldValue = this._map.get(key);\n\n            var _newValue2 = fn(oldValue);\n\n            if (_newValue2 !== oldValue) this._map.set(key, _newValue2);\n          }\n      }\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      switch (this._mode) {\n        case 0:\n          return [];\n\n        case 1:\n          return [this._singleRuntime];\n\n        default:\n          return Array.from(this._map.keys(), keyToRuntime);\n      }\n    }\n  }, {\n    key: \"values\",\n    value: function values() {\n      switch (this._mode) {\n        case 0:\n          return [][Symbol.iterator]();\n\n        case 1:\n          return [this._singleValue][Symbol.iterator]();\n\n        default:\n          return this._map.values();\n      }\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      if (this._mode <= 1) return this._mode;\n      return this._map.size;\n    }\n  }]);\n\n  return RuntimeSpecMap;\n}();\n\nexports.RuntimeSpecMap = RuntimeSpecMap;\n\nvar RuntimeSpecSet = /*#__PURE__*/function (_Symbol$iterator) {\n  function RuntimeSpecSet(iterable) {\n    _classCallCheck(this, RuntimeSpecSet);\n\n    /** @type {Map<string, RuntimeSpec>} */\n    this._map = new Map();\n\n    if (iterable) {\n      var _iterator12 = _createForOfIteratorHelper(iterable),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var item = _step12.value;\n          this.add(item);\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n    }\n  }\n\n  _createClass(RuntimeSpecSet, [{\n    key: \"add\",\n    value: function add(runtime) {\n      this._map.set(getRuntimeKey(runtime), runtime);\n    }\n  }, {\n    key: \"has\",\n    value: function has(runtime) {\n      return this._map.has(getRuntimeKey(runtime));\n    }\n  }, {\n    key: _Symbol$iterator,\n    value: function value() {\n      return this._map.values();\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._map.size;\n    }\n  }]);\n\n  return RuntimeSpecSet;\n}(Symbol.iterator);\n\nexports.RuntimeSpecSet = RuntimeSpecSet;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/util/runtime.js"],"names":["SortableSet","require","exports","getEntryRuntime","compilation","name","options","dependOn","runtime","entry","entries","get","result","undefined","queue","Set","dep","add","mergeRuntimeOwned","forEachRuntime","fn","deterministicOrder","sort","r","getRuntimesKey","set","Array","from","join","getRuntimeKey","getFromUnorderedCache","keyToRuntime","key","items","split","length","getRuntimesString","runtimeToString","runtimeConditionToString","runtimeCondition","runtimeEqual","a","b","size","aIt","Symbol","iterator","bIt","aV","next","done","bV","value","compareRuntime","aKey","bKey","mergeRuntime","has","item","mergeRuntimeCondition","merged","mergeRuntimeConditionNonFalse","intersectRuntime","subtractRuntime","delete","subtractRuntimeCondition","filterRuntime","filter","some","every","v","RuntimeSpecMap","clone","_mode","_singleRuntime","_singleValue","_map","Map","computer","newValue","Error","oldValue","keys","values","RuntimeSpecSet","iterable"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;;;;;;;AAEA,IAAMA,WAAW,GAAGC,OAAO,CAAC,eAAD,CAA3B;AAEA;;AACA;;AAEA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACAC,OAAO,CAACC,eAAR,GAA0B,UAACC,WAAD,EAAcC,IAAd,EAAoBC,OAApB,EAAgC;AACzD,MAAIC,QAAJ;AACA,MAAIC,OAAJ;;AACA,MAAIF,OAAJ,EAAa;AACTC,IAAAA,QADS,GACaD,OADb,CACTC,QADS;AACCC,IAAAA,OADD,GACaF,OADb,CACCE,OADD;AAEZ,GAFD,MAEO;AACN,QAAMC,KAAK,GAAGL,WAAW,CAACM,OAAZ,CAAoBC,GAApB,CAAwBN,IAAxB,CAAd;AACA,QAAI,CAACI,KAAL,EAAY,OAAOJ,IAAP;AAFN,yBAGmBI,KAAK,CAACH,OAHzB;AAGHC,IAAAA,QAHG,kBAGHA,QAHG;AAGOC,IAAAA,OAHP,kBAGOA,OAHP;AAIN;;AACD,MAAID,QAAJ,EAAc;AACb;AACA,QAAIK,MAAM,GAAGC,SAAb;AACA,QAAMC,KAAK,GAAG,IAAIC,GAAJ,CAAQR,QAAR,CAAd;;AAHa,+CAIMO,KAJN;AAAA;;AAAA;AAIb,0DAA0B;AAAA,YAAfT,KAAe;AACzB,YAAMW,GAAG,GAAGZ,WAAW,CAACM,OAAZ,CAAoBC,GAApB,CAAwBN,KAAxB,CAAZ;AACA,YAAI,CAACW,GAAL,EAAU;AACV,2BAA8BA,GAAG,CAACV,OAAlC;AAAA,YAAQC,SAAR,gBAAQA,QAAR;AAAA,YAAkBC,QAAlB,gBAAkBA,OAAlB;;AACA,YAAID,SAAJ,EAAc;AAAA,sDACMA,SADN;AAAA;;AAAA;AACb,mEAA6B;AAAA,kBAAlBF,MAAkB;AAC5BS,cAAAA,KAAK,CAACG,GAAN,CAAUZ,MAAV;AACA;AAHY;AAAA;AAAA;AAAA;AAAA;AAIb,SAJD,MAIO;AACNO,UAAAA,MAAM,GAAGM,iBAAiB,CAACN,MAAD,EAASJ,QAAO,IAAIH,KAApB,CAA1B;AACA;AACD;AAfY;AAAA;AAAA;AAAA;AAAA;;AAgBb,WAAOO,MAAM,IAAIP,IAAjB;AACA,GAjBD,MAiBO;AACN,WAAOG,OAAO,IAAIH,IAAlB;AACA;AACD,CA9BD;AAgCA;AACA;AACA;AACA;AACA;AACA;;;AACAH,OAAO,CAACiB,cAAR,GAAyB,UAACX,OAAD,EAAUY,EAAV,EAA6C;AAAA,MAA/BC,kBAA+B,uEAAV,KAAU;;AACrE,MAAIb,OAAO,KAAKK,SAAhB,EAA2B;AAC1BO,IAAAA,EAAE,CAACP,SAAD,CAAF;AACA,GAFD,MAEO,IAAI,OAAOL,OAAP,KAAmB,QAAvB,EAAiC;AACvCY,IAAAA,EAAE,CAACZ,OAAD,CAAF;AACA,GAFM,MAEA;AACN,QAAIa,kBAAJ,EAAwBb,OAAO,CAACc,IAAR;;AADlB,gDAEUd,OAFV;AAAA;;AAAA;AAEN,6DAAyB;AAAA,YAAde,CAAc;AACxBH,QAAAA,EAAE,CAACG,CAAD,CAAF;AACA;AAJK;AAAA;AAAA;AAAA;AAAA;AAKN;AACD,CAXD;;AAaA,IAAMC,cAAc,GAAG,SAAjBA,cAAiB,CAAAC,GAAG,EAAI;AAC7BA,EAAAA,GAAG,CAACH,IAAJ;AACA,SAAOI,KAAK,CAACC,IAAN,CAAWF,GAAX,EAAgBG,IAAhB,CAAqB,IAArB,CAAP;AACA,CAHD;AAKA;AACA;AACA;AACA;;;AACA,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAAArB,OAAO,EAAI;AAChC,MAAIA,OAAO,KAAKK,SAAhB,EAA2B,OAAO,GAAP;AAC3B,MAAI,OAAOL,OAAP,KAAmB,QAAvB,EAAiC,OAAOA,OAAP;AACjC,SAAOA,OAAO,CAACsB,qBAAR,CAA8BN,cAA9B,CAAP;AACA,CAJD;;AAKAtB,OAAO,CAAC2B,aAAR,GAAwBA,aAAxB;AAEA;AACA;AACA;AACA;;AACA,IAAME,YAAY,GAAG,SAAfA,YAAe,CAAAC,GAAG,EAAI;AAC3B,MAAIA,GAAG,KAAK,GAAZ,EAAiB,OAAOnB,SAAP;AACjB,MAAMoB,KAAK,GAAGD,GAAG,CAACE,KAAJ,CAAU,IAAV,CAAd;AACA,MAAID,KAAK,CAACE,MAAN,KAAiB,CAArB,EAAwB,OAAOF,KAAK,CAAC,CAAD,CAAZ;AACxB,SAAO,IAAIjC,WAAJ,CAAgBiC,KAAhB,CAAP;AACA,CALD;;AAMA/B,OAAO,CAAC6B,YAAR,GAAuBA,YAAvB;;AAEA,IAAMK,iBAAiB,GAAG,SAApBA,iBAAoB,CAAAX,GAAG,EAAI;AAChCA,EAAAA,GAAG,CAACH,IAAJ;AACA,SAAOI,KAAK,CAACC,IAAN,CAAWF,GAAX,EAAgBG,IAAhB,CAAqB,GAArB,CAAP;AACA,CAHD;AAKA;AACA;AACA;AACA;;;AACA,IAAMS,eAAe,GAAG,SAAlBA,eAAkB,CAAA7B,OAAO,EAAI;AAClC,MAAIA,OAAO,KAAKK,SAAhB,EAA2B,OAAO,GAAP;AAC3B,MAAI,OAAOL,OAAP,KAAmB,QAAvB,EAAiC,OAAOA,OAAP;AACjC,SAAOA,OAAO,CAACsB,qBAAR,CAA8BM,iBAA9B,CAAP;AACA,CAJD;;AAKAlC,OAAO,CAACmC,eAAR,GAA0BA,eAA1B;AAEA;AACA;AACA;AACA;;AACAnC,OAAO,CAACoC,wBAAR,GAAmC,UAAAC,gBAAgB,EAAI;AACtD,MAAIA,gBAAgB,KAAK,IAAzB,EAA+B,OAAO,MAAP;AAC/B,MAAIA,gBAAgB,KAAK,KAAzB,EAAgC,OAAO,OAAP;AAChC,SAAOF,eAAe,CAACE,gBAAD,CAAtB;AACA,CAJD;AAMA;AACA;AACA;AACA;AACA;;;AACA,IAAMC,YAAY,GAAG,SAAfA,YAAe,CAACC,CAAD,EAAIC,CAAJ,EAAU;AAC9B,MAAID,CAAC,KAAKC,CAAV,EAAa;AACZ,WAAO,IAAP;AACA,GAFD,MAEO,IACND,CAAC,KAAK5B,SAAN,IACA6B,CAAC,KAAK7B,SADN,IAEA,OAAO4B,CAAP,KAAa,QAFb,IAGA,OAAOC,CAAP,KAAa,QAJP,EAKL;AACD,WAAO,KAAP;AACA,GAPM,MAOA,IAAID,CAAC,CAACE,IAAF,KAAWD,CAAC,CAACC,IAAjB,EAAuB;AAC7B,WAAO,KAAP;AACA,GAFM,MAEA;AACNF,IAAAA,CAAC,CAACnB,IAAF;AACAoB,IAAAA,CAAC,CAACpB,IAAF;AACA,QAAMsB,GAAG,GAAGH,CAAC,CAACI,MAAM,CAACC,QAAR,CAAD,EAAZ;AACA,QAAMC,GAAG,GAAGL,CAAC,CAACG,MAAM,CAACC,QAAR,CAAD,EAAZ;;AACA,aAAS;AACR,UAAME,EAAE,GAAGJ,GAAG,CAACK,IAAJ,EAAX;AACA,UAAID,EAAE,CAACE,IAAP,EAAa,OAAO,IAAP;AACb,UAAMC,EAAE,GAAGJ,GAAG,CAACE,IAAJ,EAAX;AACA,UAAID,EAAE,CAACI,KAAH,KAAaD,EAAE,CAACC,KAApB,EAA2B,OAAO,KAAP;AAC3B;AACD;AACD,CAxBD;;AAyBAlD,OAAO,CAACsC,YAAR,GAAuBA,YAAvB;AAEA;AACA;AACA;AACA;AACA;;AACAtC,OAAO,CAACmD,cAAR,GAAyB,UAACZ,CAAD,EAAIC,CAAJ,EAAU;AAClC,MAAID,CAAC,KAAKC,CAAV,EAAa;AACZ,WAAO,CAAP;AACA,GAFD,MAEO,IAAID,CAAC,KAAK5B,SAAV,EAAqB;AAC3B,WAAO,CAAC,CAAR;AACA,GAFM,MAEA,IAAI6B,CAAC,KAAK7B,SAAV,EAAqB;AAC3B,WAAO,CAAP;AACA,GAFM,MAEA;AACN,QAAMyC,IAAI,GAAGzB,aAAa,CAACY,CAAD,CAA1B;AACA,QAAMc,IAAI,GAAG1B,aAAa,CAACa,CAAD,CAA1B;AACA,QAAIY,IAAI,GAAGC,IAAX,EAAiB,OAAO,CAAC,CAAR;AACjB,QAAID,IAAI,GAAGC,IAAX,EAAiB,OAAO,CAAP;AACjB,WAAO,CAAP;AACA;AACD,CAdD;AAgBA;AACA;AACA;AACA;AACA;;;AACA,IAAMC,YAAY,GAAG,SAAfA,YAAe,CAACf,CAAD,EAAIC,CAAJ,EAAU;AAC9B,MAAID,CAAC,KAAK5B,SAAV,EAAqB;AACpB,WAAO6B,CAAP;AACA,GAFD,MAEO,IAAIA,CAAC,KAAK7B,SAAV,EAAqB;AAC3B,WAAO4B,CAAP;AACA,GAFM,MAEA,IAAIA,CAAC,KAAKC,CAAV,EAAa;AACnB,WAAOD,CAAP;AACA,GAFM,MAEA,IAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B;AACjC,QAAI,OAAOC,CAAP,KAAa,QAAjB,EAA2B;AAC1B,UAAMjB,GAAG,GAAG,IAAIzB,WAAJ,EAAZ;AACAyB,MAAAA,GAAG,CAACR,GAAJ,CAAQwB,CAAR;AACAhB,MAAAA,GAAG,CAACR,GAAJ,CAAQyB,CAAR;AACA,aAAOjB,GAAP;AACA,KALD,MAKO,IAAIiB,CAAC,CAACe,GAAF,CAAMhB,CAAN,CAAJ,EAAc;AACpB,aAAOC,CAAP;AACA,KAFM,MAEA;AACN,UAAMjB,IAAG,GAAG,IAAIzB,WAAJ,CAAgB0C,CAAhB,CAAZ;;AACAjB,MAAAA,IAAG,CAACR,GAAJ,CAAQwB,CAAR;;AACA,aAAOhB,IAAP;AACA;AACD,GAbM,MAaA;AACN,QAAI,OAAOiB,CAAP,KAAa,QAAjB,EAA2B;AAC1B,UAAID,CAAC,CAACgB,GAAF,CAAMf,CAAN,CAAJ,EAAc,OAAOD,CAAP;;AACd,UAAMhB,KAAG,GAAG,IAAIzB,WAAJ,CAAgByC,CAAhB,CAAZ;;AACAhB,MAAAA,KAAG,CAACR,GAAJ,CAAQyB,CAAR;;AACA,aAAOjB,KAAP;AACA,KALD,MAKO;AACN,UAAMA,KAAG,GAAG,IAAIzB,WAAJ,CAAgByC,CAAhB,CAAZ;;AADM,kDAEaC,CAFb;AAAA;;AAAA;AAEN;AAAA,cAAWgB,IAAX;;AAAsBjC,UAAAA,KAAG,CAACR,GAAJ,CAAQyC,IAAR;AAAtB;AAFM;AAAA;AAAA;AAAA;AAAA;;AAGN,UAAIjC,KAAG,CAACkB,IAAJ,KAAaF,CAAC,CAACE,IAAnB,EAAyB,OAAOF,CAAP;AACzB,aAAOhB,KAAP;AACA;AACD;AACD,CAjCD;;AAkCAvB,OAAO,CAACsD,YAAR,GAAuBA,YAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACAtD,OAAO,CAACyD,qBAAR,GAAgC,UAAClB,CAAD,EAAIC,CAAJ,EAAOlC,OAAP,EAAmB;AAClD,MAAIiC,CAAC,KAAK,KAAV,EAAiB,OAAOC,CAAP;AACjB,MAAIA,CAAC,KAAK,KAAV,EAAiB,OAAOD,CAAP;AACjB,MAAIA,CAAC,KAAK,IAAN,IAAcC,CAAC,KAAK,IAAxB,EAA8B,OAAO,IAAP;AAC9B,MAAMkB,MAAM,GAAGJ,YAAY,CAACf,CAAD,EAAIC,CAAJ,CAA3B;AACA,MAAIkB,MAAM,KAAK/C,SAAf,EAA0B,OAAOA,SAAP;;AAC1B,MAAI,OAAO+C,MAAP,KAAkB,QAAtB,EAAgC;AAC/B,QAAI,OAAOpD,OAAP,KAAmB,QAAnB,IAA+BoD,MAAM,KAAKpD,OAA9C,EAAuD,OAAO,IAAP;AACvD,WAAOoD,MAAP;AACA;;AACD,MAAI,OAAOpD,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,KAAKK,SAA/C,EAA0D,OAAO+C,MAAP;AAC1D,MAAIA,MAAM,CAACjB,IAAP,KAAgBnC,OAAO,CAACmC,IAA5B,EAAkC,OAAO,IAAP;AAClC,SAAOiB,MAAP;AACA,CAbD;AAeA;AACA;AACA;AACA;AACA;AACA;;;AACA1D,OAAO,CAAC2D,6BAAR,GAAwC,UAACpB,CAAD,EAAIC,CAAJ,EAAOlC,OAAP,EAAmB;AAC1D,MAAIiC,CAAC,KAAK,IAAN,IAAcC,CAAC,KAAK,IAAxB,EAA8B,OAAO,IAAP;AAC9B,MAAMkB,MAAM,GAAGJ,YAAY,CAACf,CAAD,EAAIC,CAAJ,CAA3B;AACA,MAAIkB,MAAM,KAAK/C,SAAf,EAA0B,OAAOA,SAAP;;AAC1B,MAAI,OAAO+C,MAAP,KAAkB,QAAtB,EAAgC;AAC/B,QAAI,OAAOpD,OAAP,KAAmB,QAAnB,IAA+BoD,MAAM,KAAKpD,OAA9C,EAAuD,OAAO,IAAP;AACvD,WAAOoD,MAAP;AACA;;AACD,MAAI,OAAOpD,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,KAAKK,SAA/C,EAA0D,OAAO+C,MAAP;AAC1D,MAAIA,MAAM,CAACjB,IAAP,KAAgBnC,OAAO,CAACmC,IAA5B,EAAkC,OAAO,IAAP;AAClC,SAAOiB,MAAP;AACA,CAXD;AAaA;AACA;AACA;AACA;AACA;;;AACA,IAAM1C,iBAAiB,GAAG,SAApBA,iBAAoB,CAACuB,CAAD,EAAIC,CAAJ,EAAU;AACnC,MAAIA,CAAC,KAAK7B,SAAV,EAAqB;AACpB,WAAO4B,CAAP;AACA,GAFD,MAEO,IAAIA,CAAC,KAAKC,CAAV,EAAa;AACnB,WAAOD,CAAP;AACA,GAFM,MAEA,IAAIA,CAAC,KAAK5B,SAAV,EAAqB;AAC3B,QAAI,OAAO6B,CAAP,KAAa,QAAjB,EAA2B;AAC1B,aAAOA,CAAP;AACA,KAFD,MAEO;AACN,aAAO,IAAI1C,WAAJ,CAAgB0C,CAAhB,CAAP;AACA;AACD,GANM,MAMA,IAAI,OAAOD,CAAP,KAAa,QAAjB,EAA2B;AACjC,QAAI,OAAOC,CAAP,KAAa,QAAjB,EAA2B;AAC1B,UAAMjB,GAAG,GAAG,IAAIzB,WAAJ,EAAZ;AACAyB,MAAAA,GAAG,CAACR,GAAJ,CAAQwB,CAAR;AACAhB,MAAAA,GAAG,CAACR,GAAJ,CAAQyB,CAAR;AACA,aAAOjB,GAAP;AACA,KALD,MAKO;AACN,UAAMA,KAAG,GAAG,IAAIzB,WAAJ,CAAgB0C,CAAhB,CAAZ;;AACAjB,MAAAA,KAAG,CAACR,GAAJ,CAAQwB,CAAR;;AACA,aAAOhB,KAAP;AACA;AACD,GAXM,MAWA;AACN,QAAI,OAAOiB,CAAP,KAAa,QAAjB,EAA2B;AAC1BD,MAAAA,CAAC,CAACxB,GAAF,CAAMyB,CAAN;AACA,aAAOD,CAAP;AACA,KAHD,MAGO;AAAA,kDACaC,CADb;AAAA;;AAAA;AACN;AAAA,cAAWgB,IAAX;AAAsBjB,UAAAA,CAAC,CAACxB,GAAF,CAAMyC,IAAN;AAAtB;AADM;AAAA;AAAA;AAAA;AAAA;;AAEN,aAAOjB,CAAP;AACA;AACD;AACD,CA/BD;;AAgCAvC,OAAO,CAACgB,iBAAR,GAA4BA,iBAA5B;AAEA;AACA;AACA;AACA;AACA;;AACAhB,OAAO,CAAC4D,gBAAR,GAA2B,UAACrB,CAAD,EAAIC,CAAJ,EAAU;AACpC,MAAID,CAAC,KAAK5B,SAAV,EAAqB;AACpB,WAAO6B,CAAP;AACA,GAFD,MAEO,IAAIA,CAAC,KAAK7B,SAAV,EAAqB;AAC3B,WAAO4B,CAAP;AACA,GAFM,MAEA,IAAIA,CAAC,KAAKC,CAAV,EAAa;AACnB,WAAOD,CAAP;AACA,GAFM,MAEA,IAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B;AACjC,QAAI,OAAOC,CAAP,KAAa,QAAjB,EAA2B;AAC1B,aAAO7B,SAAP;AACA,KAFD,MAEO,IAAI6B,CAAC,CAACe,GAAF,CAAMhB,CAAN,CAAJ,EAAc;AACpB,aAAOA,CAAP;AACA,KAFM,MAEA;AACN,aAAO5B,SAAP;AACA;AACD,GARM,MAQA;AACN,QAAI,OAAO6B,CAAP,KAAa,QAAjB,EAA2B;AAC1B,UAAID,CAAC,CAACgB,GAAF,CAAMf,CAAN,CAAJ,EAAc,OAAOA,CAAP;AACd,aAAO7B,SAAP;AACA,KAHD,MAGO;AACN,UAAMY,GAAG,GAAG,IAAIzB,WAAJ,EAAZ;;AADM,kDAEa0C,CAFb;AAAA;;AAAA;AAEN,+DAAsB;AAAA,cAAXgB,KAAW;AACrB,cAAIjB,CAAC,CAACgB,GAAF,CAAMC,KAAN,CAAJ,EAAiBjC,GAAG,CAACR,GAAJ,CAAQyC,KAAR;AACjB;AAJK;AAAA;AAAA;AAAA;AAAA;;AAKN,UAAIjC,GAAG,CAACkB,IAAJ,KAAa,CAAjB,EAAoB,OAAO9B,SAAP;;AACpB,UAAIY,GAAG,CAACkB,IAAJ,KAAa,CAAjB;AAAA,oDAAuClB,GAAvC;AAAA;;AAAA;AAAoB;AAAA,gBAAWiC,IAAX;AAAwB,mBAAOA,IAAP;AAAxB;AAApB;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA,aAAOjC,GAAP;AACA;AACD;AACD,CA7BD;AA+BA;AACA;AACA;AACA;AACA;;;AACA,IAAMsC,eAAe,GAAG,SAAlBA,eAAkB,CAACtB,CAAD,EAAIC,CAAJ,EAAU;AACjC,MAAID,CAAC,KAAK5B,SAAV,EAAqB;AACpB,WAAOA,SAAP;AACA,GAFD,MAEO,IAAI6B,CAAC,KAAK7B,SAAV,EAAqB;AAC3B,WAAO4B,CAAP;AACA,GAFM,MAEA,IAAIA,CAAC,KAAKC,CAAV,EAAa;AACnB,WAAO7B,SAAP;AACA,GAFM,MAEA,IAAI,OAAO4B,CAAP,KAAa,QAAjB,EAA2B;AACjC,QAAI,OAAOC,CAAP,KAAa,QAAjB,EAA2B;AAC1B,aAAOD,CAAP;AACA,KAFD,MAEO,IAAIC,CAAC,CAACe,GAAF,CAAMhB,CAAN,CAAJ,EAAc;AACpB,aAAO5B,SAAP;AACA,KAFM,MAEA;AACN,aAAO4B,CAAP;AACA;AACD,GARM,MAQA;AACN,QAAI,OAAOC,CAAP,KAAa,QAAjB,EAA2B;AAC1B,UAAI,CAACD,CAAC,CAACgB,GAAF,CAAMf,CAAN,CAAL,EAAe,OAAOD,CAAP;;AACf,UAAIA,CAAC,CAACE,IAAF,KAAW,CAAf,EAAkB;AAAA,oDACEF,CADF;AAAA;;AAAA;AACjB,iEAAsB;AAAA,gBAAXiB,IAAW;AACrB,gBAAIA,IAAI,KAAKhB,CAAb,EAAgB,OAAOgB,IAAP;AAChB;AAHgB;AAAA;AAAA;AAAA;AAAA;AAIjB;;AACD,UAAMjC,GAAG,GAAG,IAAIzB,WAAJ,CAAgByC,CAAhB,CAAZ;AACAhB,MAAAA,GAAG,CAACuC,MAAJ,CAAWtB,CAAX;AACA,KATD,MASO;AACN,UAAMjB,KAAG,GAAG,IAAIzB,WAAJ,EAAZ;;AADM,kDAEayC,CAFb;AAAA;;AAAA;AAEN,+DAAsB;AAAA,cAAXiB,MAAW;AACrB,cAAI,CAAChB,CAAC,CAACe,GAAF,CAAMC,MAAN,CAAL,EAAkBjC,KAAG,CAACR,GAAJ,CAAQyC,MAAR;AAClB;AAJK;AAAA;AAAA;AAAA;AAAA;;AAKN,UAAIjC,KAAG,CAACkB,IAAJ,KAAa,CAAjB,EAAoB,OAAO9B,SAAP;;AACpB,UAAIY,KAAG,CAACkB,IAAJ,KAAa,CAAjB;AAAA,qDAAuClB,KAAvC;AAAA;;AAAA;AAAoB;AAAA,gBAAWiC,MAAX;AAAwB,mBAAOA,MAAP;AAAxB;AAApB;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA,aAAOjC,KAAP;AACA;AACD;AACD,CAnCD;;AAoCAvB,OAAO,CAAC6D,eAAR,GAA0BA,eAA1B;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA7D,OAAO,CAAC+D,wBAAR,GAAmC,UAACxB,CAAD,EAAIC,CAAJ,EAAOlC,OAAP,EAAmB;AACrD,MAAIkC,CAAC,KAAK,IAAV,EAAgB,OAAO,KAAP;AAChB,MAAIA,CAAC,KAAK,KAAV,EAAiB,OAAOD,CAAP;AACjB,MAAIA,CAAC,KAAK,KAAV,EAAiB,OAAO,KAAP;AACjB,MAAM7B,MAAM,GAAGmD,eAAe,CAACtB,CAAC,KAAK,IAAN,GAAajC,OAAb,GAAuBiC,CAAxB,EAA2BC,CAA3B,CAA9B;AACA,SAAO9B,MAAM,KAAKC,SAAX,GAAuB,KAAvB,GAA+BD,MAAtC;AACA,CAND;AAQA;AACA;AACA;AACA;AACA;;;AACAV,OAAO,CAACgE,aAAR,GAAwB,UAAC1D,OAAD,EAAU2D,MAAV,EAAqB;AAC5C,MAAI3D,OAAO,KAAKK,SAAhB,EAA2B,OAAOsD,MAAM,CAACtD,SAAD,CAAb;AAC3B,MAAI,OAAOL,OAAP,KAAmB,QAAvB,EAAiC,OAAO2D,MAAM,CAAC3D,OAAD,CAAb;AACjC,MAAI4D,IAAI,GAAG,KAAX;AACA,MAAIC,KAAK,GAAG,IAAZ;AACA,MAAIzD,MAAM,GAAGC,SAAb;;AAL4C,+CAM5BL,OAN4B;AAAA;;AAAA;AAM5C,8DAAyB;AAAA,UAAde,CAAc;AACxB,UAAM+C,CAAC,GAAGH,MAAM,CAAC5C,CAAD,CAAhB;;AACA,UAAI+C,CAAJ,EAAO;AACNF,QAAAA,IAAI,GAAG,IAAP;AACAxD,QAAAA,MAAM,GAAGM,iBAAiB,CAACN,MAAD,EAASW,CAAT,CAA1B;AACA,OAHD,MAGO;AACN8C,QAAAA,KAAK,GAAG,KAAR;AACA;AACD;AAd2C;AAAA;AAAA;AAAA;AAAA;;AAe5C,MAAI,CAACD,IAAL,EAAW,OAAO,KAAP;AACX,MAAIC,KAAJ,EAAW,OAAO,IAAP;AACX,SAAOzD,MAAP;AACA,CAlBD;AAoBA;AACA;AACA;;;IACM2D,c;AACL;AACD;AACA;AACC,0BAAYC,KAAZ,EAAmB;AAAA;;AAClB,SAAKC,KAAL,GAAaD,KAAK,GAAGA,KAAK,CAACC,KAAT,GAAiB,CAAnC,CADkB,CACoB;;AACtC;;AACA,SAAKC,cAAL,GAAsBF,KAAK,GAAGA,KAAK,CAACE,cAAT,GAA0B7D,SAArD;AACA;;AACA,SAAK8D,YAAL,GAAoBH,KAAK,GAAGA,KAAK,CAACG,YAAT,GAAwB9D,SAAjD;AACA;;AACA,SAAK+D,IAAL,GAAYJ,KAAK,IAAIA,KAAK,CAACI,IAAf,GAAsB,IAAIC,GAAJ,CAAQL,KAAK,CAACI,IAAd,CAAtB,GAA4C/D,SAAxD;AACA;AAED;AACD;AACA;AACA;;;;;WACC,aAAIL,OAAJ,EAAa;AACZ,cAAQ,KAAKiE,KAAb;AACC,aAAK,CAAL;AACC,iBAAO5D,SAAP;;AACD,aAAK,CAAL;AACC,iBAAO2B,YAAY,CAAC,KAAKkC,cAAN,EAAsBlE,OAAtB,CAAZ,GACJ,KAAKmE,YADD,GAEJ9D,SAFH;;AAGD;AACC,iBAAO,KAAK+D,IAAL,CAAUjE,GAAV,CAAckB,aAAa,CAACrB,OAAD,CAA3B,CAAP;AARF;AAUA;AAED;AACD;AACA;AACA;;;;WACC,aAAIA,OAAJ,EAAa;AACZ,cAAQ,KAAKiE,KAAb;AACC,aAAK,CAAL;AACC,iBAAO,KAAP;;AACD,aAAK,CAAL;AACC,iBAAOjC,YAAY,CAAC,KAAKkC,cAAN,EAAsBlE,OAAtB,CAAnB;;AACD;AACC,iBAAO,KAAKoE,IAAL,CAAUnB,GAAV,CAAc5B,aAAa,CAACrB,OAAD,CAA3B,CAAP;AANF;AAQA;;;WAED,aAAIA,OAAJ,EAAa4C,KAAb,EAAoB;AACnB,cAAQ,KAAKqB,KAAb;AACC,aAAK,CAAL;AACC,eAAKA,KAAL,GAAa,CAAb;AACA,eAAKC,cAAL,GAAsBlE,OAAtB;AACA,eAAKmE,YAAL,GAAoBvB,KAApB;AACA;;AACD,aAAK,CAAL;AACC,cAAIZ,YAAY,CAAC,KAAKkC,cAAN,EAAsBlE,OAAtB,CAAhB,EAAgD;AAC/C,iBAAKmE,YAAL,GAAoBvB,KAApB;AACA;AACA;;AACD,eAAKqB,KAAL,GAAa,CAAb;AACA,eAAKG,IAAL,GAAY,IAAIC,GAAJ,EAAZ;;AACA,eAAKD,IAAL,CAAUnD,GAAV,CAAcI,aAAa,CAAC,KAAK6C,cAAN,CAA3B,EAAkD,KAAKC,YAAvD;;AACA,eAAKD,cAAL,GAAsB7D,SAAtB;AACA,eAAK8D,YAAL,GAAoB9D,SAApB;;AACD;;AACA;AACC,eAAK+D,IAAL,CAAUnD,GAAV,CAAcI,aAAa,CAACrB,OAAD,CAA3B,EAAsC4C,KAAtC;;AAlBF;AAoBA;;;WAED,iBAAQ5C,OAAR,EAAiBsE,QAAjB,EAA2B;AAC1B,cAAQ,KAAKL,KAAb;AACC,aAAK,CAAL;AACC,eAAKA,KAAL,GAAa,CAAb;AACA,eAAKC,cAAL,GAAsBlE,OAAtB;AACA,iBAAQ,KAAKmE,YAAL,GAAoBG,QAAQ,EAApC;;AACD,aAAK,CAAL;AAAQ;AACP,gBAAItC,YAAY,CAAC,KAAKkC,cAAN,EAAsBlE,OAAtB,CAAhB,EAAgD;AAC/C,qBAAO,KAAKmE,YAAZ;AACA;;AACD,iBAAKF,KAAL,GAAa,CAAb;AACA,iBAAKG,IAAL,GAAY,IAAIC,GAAJ,EAAZ;;AACA,iBAAKD,IAAL,CAAUnD,GAAV,CAAcI,aAAa,CAAC,KAAK6C,cAAN,CAA3B,EAAkD,KAAKC,YAAvD;;AACA,iBAAKD,cAAL,GAAsB7D,SAAtB;AACA,iBAAK8D,YAAL,GAAoB9D,SAApB;AACA,gBAAMkE,QAAQ,GAAGD,QAAQ,EAAzB;;AACA,iBAAKF,IAAL,CAAUnD,GAAV,CAAcI,aAAa,CAACrB,OAAD,CAA3B,EAAsCuE,QAAtC;;AACA,mBAAOA,QAAP;AACA;;AACD;AAAS;AACR,gBAAM/C,GAAG,GAAGH,aAAa,CAACrB,OAAD,CAAzB;;AACA,gBAAM4C,KAAK,GAAG,KAAKwB,IAAL,CAAUjE,GAAV,CAAcqB,GAAd,CAAd;;AACA,gBAAIoB,KAAK,KAAKvC,SAAd,EAAyB,OAAOuC,KAAP;;AACzB,gBAAM2B,SAAQ,GAAGD,QAAQ,EAAzB;;AACA,iBAAKF,IAAL,CAAUnD,GAAV,CAAcO,GAAd,EAAmB+C,SAAnB;;AACA,mBAAOA,SAAP;AACA;AAzBF;AA2BA;;;WAED,iBAAOvE,OAAP,EAAgB;AACf,cAAQ,KAAKiE,KAAb;AACC,aAAK,CAAL;AACC;;AACD,aAAK,CAAL;AACC,cAAIjC,YAAY,CAAC,KAAKkC,cAAN,EAAsBlE,OAAtB,CAAhB,EAAgD;AAC/C,iBAAKiE,KAAL,GAAa,CAAb;AACA,iBAAKC,cAAL,GAAsB7D,SAAtB;AACA,iBAAK8D,YAAL,GAAoB9D,SAApB;AACA;;AACD;;AACD;AACC,eAAK+D,IAAL,CAAUZ,MAAV,CAAiBnC,aAAa,CAACrB,OAAD,CAA9B;;AAXF;AAaA;;;WAED,gBAAOA,OAAP,EAAgBY,EAAhB,EAAoB;AACnB,cAAQ,KAAKqD,KAAb;AACC,aAAK,CAAL;AACC,gBAAM,IAAIO,KAAJ,CAAU,qCAAV,CAAN;;AACD,aAAK,CAAL;AAAQ;AACP,gBAAIxC,YAAY,CAAC,KAAKkC,cAAN,EAAsBlE,OAAtB,CAAhB,EAAgD;AAC/C,mBAAKmE,YAAL,GAAoBvD,EAAE,CAAC,KAAKuD,YAAN,CAAtB;AACA;AACA;;AACD,gBAAMI,QAAQ,GAAG3D,EAAE,CAACP,SAAD,CAAnB;;AACA,gBAAIkE,QAAQ,KAAKlE,SAAjB,EAA4B;AAC3B,mBAAK4D,KAAL,GAAa,CAAb;AACA,mBAAKG,IAAL,GAAY,IAAIC,GAAJ,EAAZ;;AACA,mBAAKD,IAAL,CAAUnD,GAAV,CAAcI,aAAa,CAAC,KAAK6C,cAAN,CAA3B,EAAkD,KAAKC,YAAvD;;AACA,mBAAKD,cAAL,GAAsB7D,SAAtB;AACA,mBAAK8D,YAAL,GAAoB9D,SAApB;;AACA,mBAAK+D,IAAL,CAAUnD,GAAV,CAAcI,aAAa,CAACrB,OAAD,CAA3B,EAAsCuE,QAAtC;AACA;;AACD;AACA;;AACD;AAAS;AACR,gBAAM/C,GAAG,GAAGH,aAAa,CAACrB,OAAD,CAAzB;;AACA,gBAAMyE,QAAQ,GAAG,KAAKL,IAAL,CAAUjE,GAAV,CAAcqB,GAAd,CAAjB;;AACA,gBAAM+C,UAAQ,GAAG3D,EAAE,CAAC6D,QAAD,CAAnB;;AACA,gBAAIF,UAAQ,KAAKE,QAAjB,EAA2B,KAAKL,IAAL,CAAUnD,GAAV,CAAcO,GAAd,EAAmB+C,UAAnB;AAC3B;AAxBF;AA0BA;;;WAED,gBAAO;AACN,cAAQ,KAAKN,KAAb;AACC,aAAK,CAAL;AACC,iBAAO,EAAP;;AACD,aAAK,CAAL;AACC,iBAAO,CAAC,KAAKC,cAAN,CAAP;;AACD;AACC,iBAAOhD,KAAK,CAACC,IAAN,CAAW,KAAKiD,IAAL,CAAUM,IAAV,EAAX,EAA6BnD,YAA7B,CAAP;AANF;AAQA;;;WAED,kBAAS;AACR,cAAQ,KAAK0C,KAAb;AACC,aAAK,CAAL;AACC,iBAAO,GAAG5B,MAAM,CAACC,QAAV,GAAP;;AACD,aAAK,CAAL;AACC,iBAAO,CAAC,KAAK6B,YAAN,EAAoB9B,MAAM,CAACC,QAA3B,GAAP;;AACD;AACC,iBAAO,KAAK8B,IAAL,CAAUO,MAAV,EAAP;AANF;AAQA;;;SAED,eAAW;AACV,UAAI,KAAKV,KAAL,IAAc,CAAlB,EAAqB,OAAO,KAAKA,KAAZ;AACrB,aAAO,KAAKG,IAAL,CAAUjC,IAAjB;AACA;;;;;;AAGFzC,OAAO,CAACqE,cAAR,GAAyBA,cAAzB;;IAEMa,c;AACL,0BAAYC,QAAZ,EAAsB;AAAA;;AACrB;AACA,SAAKT,IAAL,GAAY,IAAIC,GAAJ,EAAZ;;AACA,QAAIQ,QAAJ,EAAc;AAAA,mDACMA,QADN;AAAA;;AAAA;AACb,kEAA6B;AAAA,cAAlB3B,IAAkB;AAC5B,eAAKzC,GAAL,CAASyC,IAAT;AACA;AAHY;AAAA;AAAA;AAAA;AAAA;AAIb;AACD;;;;WAED,aAAIlD,OAAJ,EAAa;AACZ,WAAKoE,IAAL,CAAUnD,GAAV,CAAcI,aAAa,CAACrB,OAAD,CAA3B,EAAsCA,OAAtC;AACA;;;WAED,aAAIA,OAAJ,EAAa;AACZ,aAAO,KAAKoE,IAAL,CAAUnB,GAAV,CAAc5B,aAAa,CAACrB,OAAD,CAA3B,CAAP;AACA;;;WAED,iBAAoB;AACnB,aAAO,KAAKoE,IAAL,CAAUO,MAAV,EAAP;AACA;;;SAED,eAAW;AACV,aAAO,KAAKP,IAAL,CAAUjC,IAAjB;AACA;;;;EANAE,MAAM,CAACC,Q;;AAST5C,OAAO,CAACkF,cAAR,GAAyBA,cAAzB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst SortableSet = require(\"./SortableSet\");\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Entrypoint\").EntryOptions} EntryOptions */\n\n/** @typedef {string | SortableSet<string> | undefined} RuntimeSpec */\n/** @typedef {RuntimeSpec | boolean} RuntimeCondition */\n\n/**\n * @param {Compilation} compilation the compilation\n * @param {string} name name of the entry\n * @param {EntryOptions=} options optionally already received entry options\n * @returns {RuntimeSpec} runtime\n */\nexports.getEntryRuntime = (compilation, name, options) => {\n\tlet dependOn;\n\tlet runtime;\n\tif (options) {\n\t\t({ dependOn, runtime } = options);\n\t} else {\n\t\tconst entry = compilation.entries.get(name);\n\t\tif (!entry) return name;\n\t\t({ dependOn, runtime } = entry.options);\n\t}\n\tif (dependOn) {\n\t\t/** @type {RuntimeSpec} */\n\t\tlet result = undefined;\n\t\tconst queue = new Set(dependOn);\n\t\tfor (const name of queue) {\n\t\t\tconst dep = compilation.entries.get(name);\n\t\t\tif (!dep) continue;\n\t\t\tconst { dependOn, runtime } = dep.options;\n\t\t\tif (dependOn) {\n\t\t\t\tfor (const name of dependOn) {\n\t\t\t\t\tqueue.add(name);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult = mergeRuntimeOwned(result, runtime || name);\n\t\t\t}\n\t\t}\n\t\treturn result || name;\n\t} else {\n\t\treturn runtime || name;\n\t}\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime\n * @param {function(string): void} fn functor\n * @param {boolean} deterministicOrder enforce a deterministic order\n * @returns {void}\n */\nexports.forEachRuntime = (runtime, fn, deterministicOrder = false) => {\n\tif (runtime === undefined) {\n\t\tfn(undefined);\n\t} else if (typeof runtime === \"string\") {\n\t\tfn(runtime);\n\t} else {\n\t\tif (deterministicOrder) runtime.sort();\n\t\tfor (const r of runtime) {\n\t\t\tfn(r);\n\t\t}\n\t}\n};\n\nconst getRuntimesKey = set => {\n\tset.sort();\n\treturn Array.from(set).join(\"\\n\");\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime(s)\n * @returns {string} key of runtimes\n */\nconst getRuntimeKey = runtime => {\n\tif (runtime === undefined) return \"*\";\n\tif (typeof runtime === \"string\") return runtime;\n\treturn runtime.getFromUnorderedCache(getRuntimesKey);\n};\nexports.getRuntimeKey = getRuntimeKey;\n\n/**\n * @param {string} key key of runtimes\n * @returns {RuntimeSpec} runtime(s)\n */\nconst keyToRuntime = key => {\n\tif (key === \"*\") return undefined;\n\tconst items = key.split(\"\\n\");\n\tif (items.length === 1) return items[0];\n\treturn new SortableSet(items);\n};\nexports.keyToRuntime = keyToRuntime;\n\nconst getRuntimesString = set => {\n\tset.sort();\n\treturn Array.from(set).join(\"+\");\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime(s)\n * @returns {string} readable version\n */\nconst runtimeToString = runtime => {\n\tif (runtime === undefined) return \"*\";\n\tif (typeof runtime === \"string\") return runtime;\n\treturn runtime.getFromUnorderedCache(getRuntimesString);\n};\nexports.runtimeToString = runtimeToString;\n\n/**\n * @param {RuntimeCondition} runtimeCondition runtime condition\n * @returns {string} readable version\n */\nexports.runtimeConditionToString = runtimeCondition => {\n\tif (runtimeCondition === true) return \"true\";\n\tif (runtimeCondition === false) return \"false\";\n\treturn runtimeToString(runtimeCondition);\n};\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {boolean} true, when they are equal\n */\nconst runtimeEqual = (a, b) => {\n\tif (a === b) {\n\t\treturn true;\n\t} else if (\n\t\ta === undefined ||\n\t\tb === undefined ||\n\t\ttypeof a === \"string\" ||\n\t\ttypeof b === \"string\"\n\t) {\n\t\treturn false;\n\t} else if (a.size !== b.size) {\n\t\treturn false;\n\t} else {\n\t\ta.sort();\n\t\tb.sort();\n\t\tconst aIt = a[Symbol.iterator]();\n\t\tconst bIt = b[Symbol.iterator]();\n\t\tfor (;;) {\n\t\t\tconst aV = aIt.next();\n\t\t\tif (aV.done) return true;\n\t\t\tconst bV = bIt.next();\n\t\t\tif (aV.value !== bV.value) return false;\n\t\t}\n\t}\n};\nexports.runtimeEqual = runtimeEqual;\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {-1|0|1} compare\n */\nexports.compareRuntime = (a, b) => {\n\tif (a === b) {\n\t\treturn 0;\n\t} else if (a === undefined) {\n\t\treturn -1;\n\t} else if (b === undefined) {\n\t\treturn 1;\n\t} else {\n\t\tconst aKey = getRuntimeKey(a);\n\t\tconst bKey = getRuntimeKey(b);\n\t\tif (aKey < bKey) return -1;\n\t\tif (aKey > bKey) return 1;\n\t\treturn 0;\n\t}\n};\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\nconst mergeRuntime = (a, b) => {\n\tif (a === undefined) {\n\t\treturn b;\n\t} else if (b === undefined) {\n\t\treturn a;\n\t} else if (a === b) {\n\t\treturn a;\n\t} else if (typeof a === \"string\") {\n\t\tif (typeof b === \"string\") {\n\t\t\tconst set = new SortableSet();\n\t\t\tset.add(a);\n\t\t\tset.add(b);\n\t\t\treturn set;\n\t\t} else if (b.has(a)) {\n\t\t\treturn b;\n\t\t} else {\n\t\t\tconst set = new SortableSet(b);\n\t\t\tset.add(a);\n\t\t\treturn set;\n\t\t}\n\t} else {\n\t\tif (typeof b === \"string\") {\n\t\t\tif (a.has(b)) return a;\n\t\t\tconst set = new SortableSet(a);\n\t\t\tset.add(b);\n\t\t\treturn set;\n\t\t} else {\n\t\t\tconst set = new SortableSet(a);\n\t\t\tfor (const item of b) set.add(item);\n\t\t\tif (set.size === a.size) return a;\n\t\t\treturn set;\n\t\t}\n\t}\n};\nexports.mergeRuntime = mergeRuntime;\n\n/**\n * @param {RuntimeCondition} a first\n * @param {RuntimeCondition} b second\n * @param {RuntimeSpec} runtime full runtime\n * @returns {RuntimeCondition} result\n */\nexports.mergeRuntimeCondition = (a, b, runtime) => {\n\tif (a === false) return b;\n\tif (b === false) return a;\n\tif (a === true || b === true) return true;\n\tconst merged = mergeRuntime(a, b);\n\tif (merged === undefined) return undefined;\n\tif (typeof merged === \"string\") {\n\t\tif (typeof runtime === \"string\" && merged === runtime) return true;\n\t\treturn merged;\n\t}\n\tif (typeof runtime === \"string\" || runtime === undefined) return merged;\n\tif (merged.size === runtime.size) return true;\n\treturn merged;\n};\n\n/**\n * @param {RuntimeSpec | true} a first\n * @param {RuntimeSpec | true} b second\n * @param {RuntimeSpec} runtime full runtime\n * @returns {RuntimeSpec | true} result\n */\nexports.mergeRuntimeConditionNonFalse = (a, b, runtime) => {\n\tif (a === true || b === true) return true;\n\tconst merged = mergeRuntime(a, b);\n\tif (merged === undefined) return undefined;\n\tif (typeof merged === \"string\") {\n\t\tif (typeof runtime === \"string\" && merged === runtime) return true;\n\t\treturn merged;\n\t}\n\tif (typeof runtime === \"string\" || runtime === undefined) return merged;\n\tif (merged.size === runtime.size) return true;\n\treturn merged;\n};\n\n/**\n * @param {RuntimeSpec} a first (may be modified)\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\nconst mergeRuntimeOwned = (a, b) => {\n\tif (b === undefined) {\n\t\treturn a;\n\t} else if (a === b) {\n\t\treturn a;\n\t} else if (a === undefined) {\n\t\tif (typeof b === \"string\") {\n\t\t\treturn b;\n\t\t} else {\n\t\t\treturn new SortableSet(b);\n\t\t}\n\t} else if (typeof a === \"string\") {\n\t\tif (typeof b === \"string\") {\n\t\t\tconst set = new SortableSet();\n\t\t\tset.add(a);\n\t\t\tset.add(b);\n\t\t\treturn set;\n\t\t} else {\n\t\t\tconst set = new SortableSet(b);\n\t\t\tset.add(a);\n\t\t\treturn set;\n\t\t}\n\t} else {\n\t\tif (typeof b === \"string\") {\n\t\t\ta.add(b);\n\t\t\treturn a;\n\t\t} else {\n\t\t\tfor (const item of b) a.add(item);\n\t\t\treturn a;\n\t\t}\n\t}\n};\nexports.mergeRuntimeOwned = mergeRuntimeOwned;\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\nexports.intersectRuntime = (a, b) => {\n\tif (a === undefined) {\n\t\treturn b;\n\t} else if (b === undefined) {\n\t\treturn a;\n\t} else if (a === b) {\n\t\treturn a;\n\t} else if (typeof a === \"string\") {\n\t\tif (typeof b === \"string\") {\n\t\t\treturn undefined;\n\t\t} else if (b.has(a)) {\n\t\t\treturn a;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t} else {\n\t\tif (typeof b === \"string\") {\n\t\t\tif (a.has(b)) return b;\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst set = new SortableSet();\n\t\t\tfor (const item of b) {\n\t\t\t\tif (a.has(item)) set.add(item);\n\t\t\t}\n\t\t\tif (set.size === 0) return undefined;\n\t\t\tif (set.size === 1) for (const item of set) return item;\n\t\t\treturn set;\n\t\t}\n\t}\n};\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} result\n */\nconst subtractRuntime = (a, b) => {\n\tif (a === undefined) {\n\t\treturn undefined;\n\t} else if (b === undefined) {\n\t\treturn a;\n\t} else if (a === b) {\n\t\treturn undefined;\n\t} else if (typeof a === \"string\") {\n\t\tif (typeof b === \"string\") {\n\t\t\treturn a;\n\t\t} else if (b.has(a)) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\treturn a;\n\t\t}\n\t} else {\n\t\tif (typeof b === \"string\") {\n\t\t\tif (!a.has(b)) return a;\n\t\t\tif (a.size === 2) {\n\t\t\t\tfor (const item of a) {\n\t\t\t\t\tif (item !== b) return item;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst set = new SortableSet(a);\n\t\t\tset.delete(b);\n\t\t} else {\n\t\t\tconst set = new SortableSet();\n\t\t\tfor (const item of a) {\n\t\t\t\tif (!b.has(item)) set.add(item);\n\t\t\t}\n\t\t\tif (set.size === 0) return undefined;\n\t\t\tif (set.size === 1) for (const item of set) return item;\n\t\t\treturn set;\n\t\t}\n\t}\n};\nexports.subtractRuntime = subtractRuntime;\n\n/**\n * @param {RuntimeCondition} a first\n * @param {RuntimeCondition} b second\n * @param {RuntimeSpec} runtime runtime\n * @returns {RuntimeCondition} result\n */\nexports.subtractRuntimeCondition = (a, b, runtime) => {\n\tif (b === true) return false;\n\tif (b === false) return a;\n\tif (a === false) return false;\n\tconst result = subtractRuntime(a === true ? runtime : a, b);\n\treturn result === undefined ? false : result;\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime\n * @param {function(RuntimeSpec): boolean} filter filter function\n * @returns {boolean | RuntimeSpec} true/false if filter is constant for all runtimes, otherwise runtimes that are active\n */\nexports.filterRuntime = (runtime, filter) => {\n\tif (runtime === undefined) return filter(undefined);\n\tif (typeof runtime === \"string\") return filter(runtime);\n\tlet some = false;\n\tlet every = true;\n\tlet result = undefined;\n\tfor (const r of runtime) {\n\t\tconst v = filter(r);\n\t\tif (v) {\n\t\t\tsome = true;\n\t\t\tresult = mergeRuntimeOwned(result, r);\n\t\t} else {\n\t\t\tevery = false;\n\t\t}\n\t}\n\tif (!some) return false;\n\tif (every) return true;\n\treturn result;\n};\n\n/**\n * @template T\n */\nclass RuntimeSpecMap {\n\t/**\n\t * @param {RuntimeSpecMap<T>=} clone copy form this\n\t */\n\tconstructor(clone) {\n\t\tthis._mode = clone ? clone._mode : 0; // 0 = empty, 1 = single entry, 2 = map\n\t\t/** @type {RuntimeSpec} */\n\t\tthis._singleRuntime = clone ? clone._singleRuntime : undefined;\n\t\t/** @type {T} */\n\t\tthis._singleValue = clone ? clone._singleValue : undefined;\n\t\t/** @type {Map<string, T> | undefined} */\n\t\tthis._map = clone && clone._map ? new Map(clone._map) : undefined;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtimes\n\t * @returns {T} value\n\t */\n\tget(runtime) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\treturn undefined;\n\t\t\tcase 1:\n\t\t\t\treturn runtimeEqual(this._singleRuntime, runtime)\n\t\t\t\t\t? this._singleValue\n\t\t\t\t\t: undefined;\n\t\t\tdefault:\n\t\t\t\treturn this._map.get(getRuntimeKey(runtime));\n\t\t}\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtimes\n\t * @returns {boolean} true, when the runtime is stored\n\t */\n\thas(runtime) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\treturn false;\n\t\t\tcase 1:\n\t\t\t\treturn runtimeEqual(this._singleRuntime, runtime);\n\t\t\tdefault:\n\t\t\t\treturn this._map.has(getRuntimeKey(runtime));\n\t\t}\n\t}\n\n\tset(runtime, value) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\tthis._mode = 1;\n\t\t\t\tthis._singleRuntime = runtime;\n\t\t\t\tthis._singleValue = value;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (runtimeEqual(this._singleRuntime, runtime)) {\n\t\t\t\t\tthis._singleValue = value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis._mode = 2;\n\t\t\t\tthis._map = new Map();\n\t\t\t\tthis._map.set(getRuntimeKey(this._singleRuntime), this._singleValue);\n\t\t\t\tthis._singleRuntime = undefined;\n\t\t\t\tthis._singleValue = undefined;\n\t\t\t/* falls through */\n\t\t\tdefault:\n\t\t\t\tthis._map.set(getRuntimeKey(runtime), value);\n\t\t}\n\t}\n\n\tprovide(runtime, computer) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\tthis._mode = 1;\n\t\t\t\tthis._singleRuntime = runtime;\n\t\t\t\treturn (this._singleValue = computer());\n\t\t\tcase 1: {\n\t\t\t\tif (runtimeEqual(this._singleRuntime, runtime)) {\n\t\t\t\t\treturn this._singleValue;\n\t\t\t\t}\n\t\t\t\tthis._mode = 2;\n\t\t\t\tthis._map = new Map();\n\t\t\t\tthis._map.set(getRuntimeKey(this._singleRuntime), this._singleValue);\n\t\t\t\tthis._singleRuntime = undefined;\n\t\t\t\tthis._singleValue = undefined;\n\t\t\t\tconst newValue = computer();\n\t\t\t\tthis._map.set(getRuntimeKey(runtime), newValue);\n\t\t\t\treturn newValue;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tconst key = getRuntimeKey(runtime);\n\t\t\t\tconst value = this._map.get(key);\n\t\t\t\tif (value !== undefined) return value;\n\t\t\t\tconst newValue = computer();\n\t\t\t\tthis._map.set(key, newValue);\n\t\t\t\treturn newValue;\n\t\t\t}\n\t\t}\n\t}\n\n\tdelete(runtime) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\treturn;\n\t\t\tcase 1:\n\t\t\t\tif (runtimeEqual(this._singleRuntime, runtime)) {\n\t\t\t\t\tthis._mode = 0;\n\t\t\t\t\tthis._singleRuntime = undefined;\n\t\t\t\t\tthis._singleValue = undefined;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\tdefault:\n\t\t\t\tthis._map.delete(getRuntimeKey(runtime));\n\t\t}\n\t}\n\n\tupdate(runtime, fn) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\tthrow new Error(\"runtime passed to update must exist\");\n\t\t\tcase 1: {\n\t\t\t\tif (runtimeEqual(this._singleRuntime, runtime)) {\n\t\t\t\t\tthis._singleValue = fn(this._singleValue);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst newValue = fn(undefined);\n\t\t\t\tif (newValue !== undefined) {\n\t\t\t\t\tthis._mode = 2;\n\t\t\t\t\tthis._map = new Map();\n\t\t\t\t\tthis._map.set(getRuntimeKey(this._singleRuntime), this._singleValue);\n\t\t\t\t\tthis._singleRuntime = undefined;\n\t\t\t\t\tthis._singleValue = undefined;\n\t\t\t\t\tthis._map.set(getRuntimeKey(runtime), newValue);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tconst key = getRuntimeKey(runtime);\n\t\t\t\tconst oldValue = this._map.get(key);\n\t\t\t\tconst newValue = fn(oldValue);\n\t\t\t\tif (newValue !== oldValue) this._map.set(key, newValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tkeys() {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\treturn [];\n\t\t\tcase 1:\n\t\t\t\treturn [this._singleRuntime];\n\t\t\tdefault:\n\t\t\t\treturn Array.from(this._map.keys(), keyToRuntime);\n\t\t}\n\t}\n\n\tvalues() {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\treturn [][Symbol.iterator]();\n\t\t\tcase 1:\n\t\t\t\treturn [this._singleValue][Symbol.iterator]();\n\t\t\tdefault:\n\t\t\t\treturn this._map.values();\n\t\t}\n\t}\n\n\tget size() {\n\t\tif (this._mode <= 1) return this._mode;\n\t\treturn this._map.size;\n\t}\n}\n\nexports.RuntimeSpecMap = RuntimeSpecMap;\n\nclass RuntimeSpecSet {\n\tconstructor(iterable) {\n\t\t/** @type {Map<string, RuntimeSpec>} */\n\t\tthis._map = new Map();\n\t\tif (iterable) {\n\t\t\tfor (const item of iterable) {\n\t\t\t\tthis.add(item);\n\t\t\t}\n\t\t}\n\t}\n\n\tadd(runtime) {\n\t\tthis._map.set(getRuntimeKey(runtime), runtime);\n\t}\n\n\thas(runtime) {\n\t\treturn this._map.has(getRuntimeKey(runtime));\n\t}\n\n\t[Symbol.iterator]() {\n\t\treturn this._map.values();\n\t}\n\n\tget size() {\n\t\treturn this._map.size;\n\t}\n}\n\nexports.RuntimeSpecSet = RuntimeSpecSet;\n"]},"metadata":{},"sourceType":"script"}