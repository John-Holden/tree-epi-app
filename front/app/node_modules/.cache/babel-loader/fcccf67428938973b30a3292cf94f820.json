{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/**\n * intersect creates Set containing the intersection of elements between all sets\n * @template T\n * @param {Set<T>[]} sets an array of sets being checked for shared elements\n * @returns {Set<T>} returns a new Set containing the intersecting items\n */\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar intersect = function intersect(sets) {\n  if (sets.length === 0) return new Set();\n  if (sets.length === 1) return new Set(sets[0]);\n  var minSize = Infinity;\n  var minIndex = -1;\n\n  for (var i = 0; i < sets.length; i++) {\n    var size = sets[i].size;\n\n    if (size < minSize) {\n      minIndex = i;\n      minSize = size;\n    }\n  }\n\n  var current = new Set(sets[minIndex]);\n\n  for (var _i = 0; _i < sets.length; _i++) {\n    if (_i === minIndex) continue;\n    var set = sets[_i];\n\n    var _iterator = _createForOfIteratorHelper(current),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var item = _step.value;\n\n        if (!set.has(item)) {\n          current.delete(item);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return current;\n};\n/**\n * Checks if a set is the subset of another set\n * @template T\n * @param {Set<T>} bigSet a Set which contains the original elements to compare against\n * @param {Set<T>} smallSet the set whose elements might be contained inside of bigSet\n * @returns {boolean} returns true if smallSet contains all elements inside of the bigSet\n */\n\n\nvar isSubset = function isSubset(bigSet, smallSet) {\n  if (bigSet.size < smallSet.size) return false;\n\n  var _iterator2 = _createForOfIteratorHelper(smallSet),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var item = _step2.value;\n      if (!bigSet.has(item)) return false;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return true;\n};\n/**\n * @template T\n * @param {Set<T>} set a set\n * @param {function(T): boolean} fn selector function\n * @returns {T | undefined} found item\n */\n\n\nvar find = function find(set, fn) {\n  var _iterator3 = _createForOfIteratorHelper(set),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var item = _step3.value;\n      if (fn(item)) return item;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n};\n/**\n * @template T\n * @param {Set<T>} set a set\n * @returns {T | undefined} first item\n */\n\n\nvar first = function first(set) {\n  var entry = set.values().next();\n  return entry.done ? undefined : entry.value;\n};\n/**\n * @template T\n * @param {Set<T>} a first\n * @param {Set<T>} b second\n * @returns {Set<T>} combined set, may be identical to a or b\n */\n\n\nvar combine = function combine(a, b) {\n  if (b.size === 0) return a;\n  if (a.size === 0) return b;\n  var set = new Set(a);\n\n  var _iterator4 = _createForOfIteratorHelper(b),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var item = _step4.value;\n      set.add(item);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return set;\n};\n\nexports.intersect = intersect;\nexports.isSubset = isSubset;\nexports.find = find;\nexports.first = first;\nexports.combine = combine;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/util/SetHelpers.js"],"names":["intersect","sets","length","Set","minSize","Infinity","minIndex","i","size","current","set","item","has","delete","isSubset","bigSet","smallSet","find","fn","first","entry","values","next","done","undefined","value","combine","a","b","add","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/**\n * intersect creates Set containing the intersection of elements between all sets\n * @template T\n * @param {Set<T>[]} sets an array of sets being checked for shared elements\n * @returns {Set<T>} returns a new Set containing the intersecting items\n */\nconst intersect = sets => {\n\tif (sets.length === 0) return new Set();\n\tif (sets.length === 1) return new Set(sets[0]);\n\tlet minSize = Infinity;\n\tlet minIndex = -1;\n\tfor (let i = 0; i < sets.length; i++) {\n\t\tconst size = sets[i].size;\n\t\tif (size < minSize) {\n\t\t\tminIndex = i;\n\t\t\tminSize = size;\n\t\t}\n\t}\n\tconst current = new Set(sets[minIndex]);\n\tfor (let i = 0; i < sets.length; i++) {\n\t\tif (i === minIndex) continue;\n\t\tconst set = sets[i];\n\t\tfor (const item of current) {\n\t\t\tif (!set.has(item)) {\n\t\t\t\tcurrent.delete(item);\n\t\t\t}\n\t\t}\n\t}\n\treturn current;\n};\n\n/**\n * Checks if a set is the subset of another set\n * @template T\n * @param {Set<T>} bigSet a Set which contains the original elements to compare against\n * @param {Set<T>} smallSet the set whose elements might be contained inside of bigSet\n * @returns {boolean} returns true if smallSet contains all elements inside of the bigSet\n */\nconst isSubset = (bigSet, smallSet) => {\n\tif (bigSet.size < smallSet.size) return false;\n\tfor (const item of smallSet) {\n\t\tif (!bigSet.has(item)) return false;\n\t}\n\treturn true;\n};\n\n/**\n * @template T\n * @param {Set<T>} set a set\n * @param {function(T): boolean} fn selector function\n * @returns {T | undefined} found item\n */\nconst find = (set, fn) => {\n\tfor (const item of set) {\n\t\tif (fn(item)) return item;\n\t}\n};\n\n/**\n * @template T\n * @param {Set<T>} set a set\n * @returns {T | undefined} first item\n */\nconst first = set => {\n\tconst entry = set.values().next();\n\treturn entry.done ? undefined : entry.value;\n};\n\n/**\n * @template T\n * @param {Set<T>} a first\n * @param {Set<T>} b second\n * @returns {Set<T>} combined set, may be identical to a or b\n */\nconst combine = (a, b) => {\n\tif (b.size === 0) return a;\n\tif (a.size === 0) return b;\n\tconst set = new Set(a);\n\tfor (const item of b) set.add(item);\n\treturn set;\n};\n\nexports.intersect = intersect;\nexports.isSubset = isSubset;\nexports.find = find;\nexports.first = first;\nexports.combine = combine;\n"]},"metadata":{},"sourceType":"script"}