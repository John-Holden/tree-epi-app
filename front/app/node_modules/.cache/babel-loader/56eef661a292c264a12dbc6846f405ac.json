{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _defineProperty = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar RuntimeGlobals = require(\"../RuntimeGlobals\");\n\nvar RuntimeModule = require(\"../RuntimeModule\");\n\nvar Template = require(\"../Template\");\n\nvar _require = require(\"../util/SetHelpers\"),\n    first = _require.first;\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n\n/** @typedef {import(\"../Compilation\").PathData} PathData */\n\n/** @typedef {function(PathData, AssetInfo=): string} FilenameFunction */\n\n\nvar GetChunkFilenameRuntimeModule = /*#__PURE__*/function (_RuntimeModule) {\n  _inherits(GetChunkFilenameRuntimeModule, _RuntimeModule);\n\n  var _super = _createSuper(GetChunkFilenameRuntimeModule);\n\n  /**\n   * @param {string} contentType the contentType to use the content hash for\n   * @param {string} name kind of filename\n   * @param {string} global function name to be assigned\n   * @param {function(Chunk): string | FilenameFunction} getFilenameForChunk functor to get the filename or function\n   * @param {boolean} allChunks when false, only async chunks are included\n   */\n  function GetChunkFilenameRuntimeModule(contentType, name, global, getFilenameForChunk, allChunks) {\n    var _this;\n\n    _classCallCheck(this, GetChunkFilenameRuntimeModule);\n\n    _this = _super.call(this, \"get \".concat(name, \" chunk filename\"));\n    _this.contentType = contentType;\n    _this.global = global;\n    _this.getFilenameForChunk = getFilenameForChunk;\n    _this.allChunks = allChunks;\n    _this.dependentHash = true;\n    return _this;\n  }\n  /**\n   * @returns {string} runtime code\n   */\n\n\n  _createClass(GetChunkFilenameRuntimeModule, [{\n    key: \"generate\",\n    value: function generate() {\n      var global = this.global,\n          chunk = this.chunk,\n          chunkGraph = this.chunkGraph,\n          contentType = this.contentType,\n          getFilenameForChunk = this.getFilenameForChunk,\n          allChunks = this.allChunks,\n          compilation = this.compilation;\n      var runtimeTemplate = compilation.runtimeTemplate;\n      /** @type {Map<string | FilenameFunction, Set<Chunk>>} */\n\n      var chunkFilenames = new Map();\n      var maxChunks = 0;\n      /** @type {string} */\n\n      var dynamicFilename;\n      /**\n       * @param {Chunk} c the chunk\n       * @returns {void}\n       */\n\n      var addChunk = function addChunk(c) {\n        var chunkFilename = getFilenameForChunk(c);\n\n        if (chunkFilename) {\n          var set = chunkFilenames.get(chunkFilename);\n\n          if (set === undefined) {\n            chunkFilenames.set(chunkFilename, set = new Set());\n          }\n\n          set.add(c);\n\n          if (typeof chunkFilename === \"string\") {\n            if (set.size < maxChunks) return;\n\n            if (set.size === maxChunks) {\n              if (chunkFilename.length < dynamicFilename.length) return;\n\n              if (chunkFilename.length === dynamicFilename.length) {\n                if (chunkFilename < dynamicFilename) return;\n              }\n            }\n\n            maxChunks = set.size;\n            dynamicFilename = chunkFilename;\n          }\n        }\n      };\n      /** @type {string[]} */\n\n\n      var includedChunksMessages = [];\n\n      if (allChunks) {\n        includedChunksMessages.push(\"all chunks\");\n\n        var _iterator = _createForOfIteratorHelper(chunk.getAllReferencedChunks()),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var c = _step.value;\n            addChunk(c);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        includedChunksMessages.push(\"async chunks\");\n\n        var _iterator2 = _createForOfIteratorHelper(chunk.getAllAsyncChunks()),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _c2 = _step2.value;\n            addChunk(_c2);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        var includeEntries = chunkGraph.getTreeRuntimeRequirements(chunk).has(RuntimeGlobals.ensureChunkIncludeEntries);\n\n        if (includeEntries) {\n          includedChunksMessages.push(\"sibling chunks for the entrypoint\");\n\n          var _iterator3 = _createForOfIteratorHelper(chunkGraph.getChunkEntryDependentChunksIterable(chunk)),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _c = _step3.value;\n              addChunk(_c);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      }\n\n      var _iterator4 = _createForOfIteratorHelper(chunk.getAllReferencedAsyncEntrypoints()),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var entrypoint = _step4.value;\n          addChunk(entrypoint.chunks[entrypoint.chunks.length - 1]);\n        }\n        /** @type {Map<string, Set<string | number>>} */\n\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      var staticUrls = new Map();\n      /** @type {Set<Chunk>} */\n\n      var dynamicUrlChunks = new Set();\n      /**\n       * @param {Chunk} c the chunk\n       * @param {string | FilenameFunction} chunkFilename the filename template for the chunk\n       * @returns {void}\n       */\n\n      var addStaticUrl = function addStaticUrl(c, chunkFilename) {\n        /**\n         * @param {string | number} value a value\n         * @returns {string} string to put in quotes\n         */\n        var unquotedStringify = function unquotedStringify(value) {\n          var str = \"\".concat(value);\n\n          if (str.length >= 5 && str === \"\".concat(c.id)) {\n            // This is shorter and generates the same result\n            return '\" + chunkId + \"';\n          }\n\n          var s = JSON.stringify(str);\n          return s.slice(1, s.length - 1);\n        };\n\n        var unquotedStringifyWithLength = function unquotedStringifyWithLength(value) {\n          return function (length) {\n            return unquotedStringify(\"\".concat(value).slice(0, length));\n          };\n        };\n\n        var chunkFilenameValue = typeof chunkFilename === \"function\" ? JSON.stringify(chunkFilename({\n          chunk: c,\n          contentHashType: contentType\n        })) : JSON.stringify(chunkFilename);\n        var staticChunkFilename = compilation.getPath(chunkFilenameValue, {\n          hash: \"\\\" + \".concat(RuntimeGlobals.getFullHash, \"() + \\\"\"),\n          hashWithLength: function hashWithLength(length) {\n            return \"\\\" + \".concat(RuntimeGlobals.getFullHash, \"().slice(0, \").concat(length, \") + \\\"\");\n          },\n          chunk: {\n            id: unquotedStringify(c.id),\n            hash: unquotedStringify(c.renderedHash),\n            hashWithLength: unquotedStringifyWithLength(c.renderedHash),\n            name: unquotedStringify(c.name || c.id),\n            contentHash: _defineProperty({}, contentType, unquotedStringify(c.contentHash[contentType])),\n            contentHashWithLength: _defineProperty({}, contentType, unquotedStringifyWithLength(c.contentHash[contentType]))\n          },\n          contentHashType: contentType\n        });\n        var set = staticUrls.get(staticChunkFilename);\n\n        if (set === undefined) {\n          staticUrls.set(staticChunkFilename, set = new Set());\n        }\n\n        set.add(c.id);\n      };\n\n      var _iterator5 = _createForOfIteratorHelper(chunkFilenames),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n              filename = _step5$value[0],\n              chunks = _step5$value[1];\n\n          if (filename !== dynamicFilename) {\n            var _iterator7 = _createForOfIteratorHelper(chunks),\n                _step7;\n\n            try {\n              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                var _c4 = _step7.value;\n                addStaticUrl(_c4, filename);\n              }\n            } catch (err) {\n              _iterator7.e(err);\n            } finally {\n              _iterator7.f();\n            }\n          } else {\n            var _iterator8 = _createForOfIteratorHelper(chunks),\n                _step8;\n\n            try {\n              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                var _c5 = _step8.value;\n                dynamicUrlChunks.add(_c5);\n              }\n            } catch (err) {\n              _iterator8.e(err);\n            } finally {\n              _iterator8.f();\n            }\n          }\n        }\n        /**\n         * @param {function(Chunk): string | number} fn function from chunk to value\n         * @returns {string} code with static mapping of results of fn\n         */\n\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      var createMap = function createMap(fn) {\n        var obj = {};\n        var useId = false;\n        var lastKey;\n        var entries = 0;\n\n        var _iterator6 = _createForOfIteratorHelper(dynamicUrlChunks),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var _c3 = _step6.value;\n            var value = fn(_c3);\n\n            if (value === _c3.id) {\n              useId = true;\n            } else {\n              obj[_c3.id] = value;\n              lastKey = _c3.id;\n              entries++;\n            }\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n\n        if (entries === 0) return \"chunkId\";\n\n        if (entries === 1) {\n          return useId ? \"(chunkId === \".concat(JSON.stringify(lastKey), \" ? \").concat(JSON.stringify(obj[lastKey]), \" : chunkId)\") : JSON.stringify(obj[lastKey]);\n        }\n\n        return useId ? \"(\".concat(JSON.stringify(obj), \"[chunkId] || chunkId)\") : \"\".concat(JSON.stringify(obj), \"[chunkId]\");\n      };\n      /**\n       * @param {function(Chunk): string | number} fn function from chunk to value\n       * @returns {string} code with static mapping of results of fn for including in quoted string\n       */\n\n\n      var mapExpr = function mapExpr(fn) {\n        return \"\\\" + \".concat(createMap(fn), \" + \\\"\");\n      };\n      /**\n       * @param {function(Chunk): string | number} fn function from chunk to value\n       * @returns {function(number): string} function which generates code with static mapping of results of fn for including in quoted string for specific length\n       */\n\n\n      var mapExprWithLength = function mapExprWithLength(fn) {\n        return function (length) {\n          return \"\\\" + \".concat(createMap(function (c) {\n            return \"\".concat(fn(c)).slice(0, length);\n          }), \" + \\\"\");\n        };\n      };\n\n      var url = dynamicFilename && compilation.getPath(JSON.stringify(dynamicFilename), {\n        hash: \"\\\" + \".concat(RuntimeGlobals.getFullHash, \"() + \\\"\"),\n        hashWithLength: function hashWithLength(length) {\n          return \"\\\" + \".concat(RuntimeGlobals.getFullHash, \"().slice(0, \").concat(length, \") + \\\"\");\n        },\n        chunk: {\n          id: \"\\\" + chunkId + \\\"\",\n          hash: mapExpr(function (c) {\n            return c.renderedHash;\n          }),\n          hashWithLength: mapExprWithLength(function (c) {\n            return c.renderedHash;\n          }),\n          name: mapExpr(function (c) {\n            return c.name || c.id;\n          }),\n          contentHash: _defineProperty({}, contentType, mapExpr(function (c) {\n            return c.contentHash[contentType];\n          })),\n          contentHashWithLength: _defineProperty({}, contentType, mapExprWithLength(function (c) {\n            return c.contentHash[contentType];\n          }))\n        },\n        contentHashType: contentType\n      });\n      return Template.asString([\"// This function allow to reference \".concat(includedChunksMessages.join(\" and \")), \"\".concat(global, \" = \").concat(runtimeTemplate.basicFunction(\"chunkId\", staticUrls.size > 0 ? [\"// return url for filenames not based on template\", // it minimizes to `x===1?\"...\":x===2?\"...\":\"...\"`\n      Template.asString(Array.from(staticUrls, function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            url = _ref2[0],\n            ids = _ref2[1];\n\n        var condition = ids.size === 1 ? \"chunkId === \".concat(JSON.stringify(first(ids))) : \"{\".concat(Array.from(ids, function (id) {\n          return \"\".concat(JSON.stringify(id), \":1\");\n        }).join(\",\"), \"}[chunkId]\");\n        return \"if (\".concat(condition, \") return \").concat(url, \";\");\n      })), \"// return url for filenames based on template\", \"return \".concat(url, \";\")] : [\"// return url for filenames based on template\", \"return \".concat(url, \";\")]), \";\")]);\n    }\n  }]);\n\n  return GetChunkFilenameRuntimeModule;\n}(RuntimeModule);\n\nmodule.exports = GetChunkFilenameRuntimeModule;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/runtime/GetChunkFilenameRuntimeModule.js"],"names":["RuntimeGlobals","require","RuntimeModule","Template","first","GetChunkFilenameRuntimeModule","contentType","name","global","getFilenameForChunk","allChunks","dependentHash","chunk","chunkGraph","compilation","runtimeTemplate","chunkFilenames","Map","maxChunks","dynamicFilename","addChunk","c","chunkFilename","set","get","undefined","Set","add","size","length","includedChunksMessages","push","getAllReferencedChunks","getAllAsyncChunks","includeEntries","getTreeRuntimeRequirements","has","ensureChunkIncludeEntries","getChunkEntryDependentChunksIterable","getAllReferencedAsyncEntrypoints","entrypoint","chunks","staticUrls","dynamicUrlChunks","addStaticUrl","unquotedStringify","value","str","id","s","JSON","stringify","slice","unquotedStringifyWithLength","chunkFilenameValue","contentHashType","staticChunkFilename","getPath","hash","getFullHash","hashWithLength","renderedHash","contentHash","contentHashWithLength","filename","createMap","fn","obj","useId","lastKey","entries","mapExpr","mapExprWithLength","url","asString","join","basicFunction","Array","from","ids","condition","module","exports"],"mappings":"AAAA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;AAEA,IAAMA,cAAc,GAAGC,OAAO,CAAC,mBAAD,CAA9B;;AACA,IAAMC,aAAa,GAAGD,OAAO,CAAC,kBAAD,CAA7B;;AACA,IAAME,QAAQ,GAAGF,OAAO,CAAC,aAAD,CAAxB;;AACA,eAAkBA,OAAO,CAAC,oBAAD,CAAzB;AAAA,IAAQG,KAAR,YAAQA,KAAR;AAEA;;AACA;;AACA;;AACA;;AAEA;;;IAEMC,6B;;;;;AACL;AACD;AACA;AACA;AACA;AACA;AACA;AACC,yCAAYC,WAAZ,EAAyBC,IAAzB,EAA+BC,MAA/B,EAAuCC,mBAAvC,EAA4DC,SAA5D,EAAuE;AAAA;;AAAA;;AACtE,4CAAaH,IAAb;AACA,UAAKD,WAAL,GAAmBA,WAAnB;AACA,UAAKE,MAAL,GAAcA,MAAd;AACA,UAAKC,mBAAL,GAA2BA,mBAA3B;AACA,UAAKC,SAAL,GAAiBA,SAAjB;AACA,UAAKC,aAAL,GAAqB,IAArB;AANsE;AAOtE;AAED;AACD;AACA;;;;;WACC,oBAAW;AACV,UACCH,MADD,GAQI,IARJ,CACCA,MADD;AAAA,UAECI,KAFD,GAQI,IARJ,CAECA,KAFD;AAAA,UAGCC,UAHD,GAQI,IARJ,CAGCA,UAHD;AAAA,UAICP,WAJD,GAQI,IARJ,CAICA,WAJD;AAAA,UAKCG,mBALD,GAQI,IARJ,CAKCA,mBALD;AAAA,UAMCC,SAND,GAQI,IARJ,CAMCA,SAND;AAAA,UAOCI,WAPD,GAQI,IARJ,CAOCA,WAPD;AASA,UAAQC,eAAR,GAA4BD,WAA5B,CAAQC,eAAR;AAEA;;AACA,UAAMC,cAAc,GAAG,IAAIC,GAAJ,EAAvB;AACA,UAAIC,SAAS,GAAG,CAAhB;AACA;;AACA,UAAIC,eAAJ;AAEA;AACF;AACA;AACA;;AACE,UAAMC,QAAQ,GAAG,SAAXA,QAAW,CAAAC,CAAC,EAAI;AACrB,YAAMC,aAAa,GAAGb,mBAAmB,CAACY,CAAD,CAAzC;;AACA,YAAIC,aAAJ,EAAmB;AAClB,cAAIC,GAAG,GAAGP,cAAc,CAACQ,GAAf,CAAmBF,aAAnB,CAAV;;AACA,cAAIC,GAAG,KAAKE,SAAZ,EAAuB;AACtBT,YAAAA,cAAc,CAACO,GAAf,CAAmBD,aAAnB,EAAmCC,GAAG,GAAG,IAAIG,GAAJ,EAAzC;AACA;;AACDH,UAAAA,GAAG,CAACI,GAAJ,CAAQN,CAAR;;AACA,cAAI,OAAOC,aAAP,KAAyB,QAA7B,EAAuC;AACtC,gBAAIC,GAAG,CAACK,IAAJ,GAAWV,SAAf,EAA0B;;AAC1B,gBAAIK,GAAG,CAACK,IAAJ,KAAaV,SAAjB,EAA4B;AAC3B,kBAAII,aAAa,CAACO,MAAd,GAAuBV,eAAe,CAACU,MAA3C,EAAmD;;AACnD,kBAAIP,aAAa,CAACO,MAAd,KAAyBV,eAAe,CAACU,MAA7C,EAAqD;AACpD,oBAAIP,aAAa,GAAGH,eAApB,EAAqC;AACrC;AACD;;AACDD,YAAAA,SAAS,GAAGK,GAAG,CAACK,IAAhB;AACAT,YAAAA,eAAe,GAAGG,aAAlB;AACA;AACD;AACD,OApBD;AAsBA;;;AACA,UAAMQ,sBAAsB,GAAG,EAA/B;;AACA,UAAIpB,SAAJ,EAAe;AACdoB,QAAAA,sBAAsB,CAACC,IAAvB,CAA4B,YAA5B;;AADc,mDAEEnB,KAAK,CAACoB,sBAAN,EAFF;AAAA;;AAAA;AAEd,8DAAgD;AAAA,gBAArCX,CAAqC;AAC/CD,YAAAA,QAAQ,CAACC,CAAD,CAAR;AACA;AAJa;AAAA;AAAA;AAAA;AAAA;AAKd,OALD,MAKO;AACNS,QAAAA,sBAAsB,CAACC,IAAvB,CAA4B,cAA5B;;AADM,oDAEUnB,KAAK,CAACqB,iBAAN,EAFV;AAAA;;AAAA;AAEN,iEAA2C;AAAA,gBAAhCZ,GAAgC;AAC1CD,YAAAA,QAAQ,CAACC,GAAD,CAAR;AACA;AAJK;AAAA;AAAA;AAAA;AAAA;;AAKN,YAAMa,cAAc,GAAGrB,UAAU,CAC/BsB,0BADqB,CACMvB,KADN,EAErBwB,GAFqB,CAEjBpC,cAAc,CAACqC,yBAFE,CAAvB;;AAGA,YAAIH,cAAJ,EAAoB;AACnBJ,UAAAA,sBAAsB,CAACC,IAAvB,CAA4B,mCAA5B;;AADmB,sDAEHlB,UAAU,CAACyB,oCAAX,CACf1B,KADe,CAFG;AAAA;;AAAA;AAEnB,mEAEG;AAAA,kBAFQS,EAER;AACFD,cAAAA,QAAQ,CAACC,EAAD,CAAR;AACA;AANkB;AAAA;AAAA;AAAA;AAAA;AAOnB;AACD;;AAnES,kDAoEeT,KAAK,CAAC2B,gCAAN,EApEf;AAAA;;AAAA;AAoEV,+DAAmE;AAAA,cAAxDC,UAAwD;AAClEpB,UAAAA,QAAQ,CAACoB,UAAU,CAACC,MAAX,CAAkBD,UAAU,CAACC,MAAX,CAAkBZ,MAAlB,GAA2B,CAA7C,CAAD,CAAR;AACA;AAED;;AAxEU;AAAA;AAAA;AAAA;AAAA;;AAyEV,UAAMa,UAAU,GAAG,IAAIzB,GAAJ,EAAnB;AACA;;AACA,UAAM0B,gBAAgB,GAAG,IAAIjB,GAAJ,EAAzB;AAEA;AACF;AACA;AACA;AACA;;AACE,UAAMkB,YAAY,GAAG,SAAfA,YAAe,CAACvB,CAAD,EAAIC,aAAJ,EAAsB;AAC1C;AACH;AACA;AACA;AACG,YAAMuB,iBAAiB,GAAG,SAApBA,iBAAoB,CAAAC,KAAK,EAAI;AAClC,cAAMC,GAAG,aAAMD,KAAN,CAAT;;AACA,cAAIC,GAAG,CAAClB,MAAJ,IAAc,CAAd,IAAmBkB,GAAG,eAAQ1B,CAAC,CAAC2B,EAAV,CAA1B,EAA0C;AACzC;AACA,mBAAO,iBAAP;AACA;;AACD,cAAMC,CAAC,GAAGC,IAAI,CAACC,SAAL,CAAeJ,GAAf,CAAV;AACA,iBAAOE,CAAC,CAACG,KAAF,CAAQ,CAAR,EAAWH,CAAC,CAACpB,MAAF,GAAW,CAAtB,CAAP;AACA,SARD;;AASA,YAAMwB,2BAA2B,GAAG,SAA9BA,2BAA8B,CAAAP,KAAK;AAAA,iBAAI,UAAAjB,MAAM;AAAA,mBAClDgB,iBAAiB,CAAC,UAAGC,KAAH,EAAWM,KAAX,CAAiB,CAAjB,EAAoBvB,MAApB,CAAD,CADiC;AAAA,WAAV;AAAA,SAAzC;;AAEA,YAAMyB,kBAAkB,GACvB,OAAOhC,aAAP,KAAyB,UAAzB,GACG4B,IAAI,CAACC,SAAL,CACA7B,aAAa,CAAC;AACbV,UAAAA,KAAK,EAAES,CADM;AAEbkC,UAAAA,eAAe,EAAEjD;AAFJ,SAAD,CADb,CADH,GAOG4C,IAAI,CAACC,SAAL,CAAe7B,aAAf,CARJ;AASA,YAAMkC,mBAAmB,GAAG1C,WAAW,CAAC2C,OAAZ,CAAoBH,kBAApB,EAAwC;AACnEI,UAAAA,IAAI,iBAAS1D,cAAc,CAAC2D,WAAxB,YAD+D;AAEnEC,UAAAA,cAAc,EAAE,wBAAA/B,MAAM;AAAA,kCACd7B,cAAc,CAAC2D,WADD,yBAC2B9B,MAD3B;AAAA,WAF6C;AAInEjB,UAAAA,KAAK,EAAE;AACNoC,YAAAA,EAAE,EAAEH,iBAAiB,CAACxB,CAAC,CAAC2B,EAAH,CADf;AAENU,YAAAA,IAAI,EAAEb,iBAAiB,CAACxB,CAAC,CAACwC,YAAH,CAFjB;AAGND,YAAAA,cAAc,EAAEP,2BAA2B,CAAChC,CAAC,CAACwC,YAAH,CAHrC;AAINtD,YAAAA,IAAI,EAAEsC,iBAAiB,CAACxB,CAAC,CAACd,IAAF,IAAUc,CAAC,CAAC2B,EAAb,CAJjB;AAKNc,YAAAA,WAAW,sBACTxD,WADS,EACKuC,iBAAiB,CAACxB,CAAC,CAACyC,WAAF,CAAcxD,WAAd,CAAD,CADtB,CALL;AAQNyD,YAAAA,qBAAqB,sBACnBzD,WADmB,EACL+C,2BAA2B,CACzChC,CAAC,CAACyC,WAAF,CAAcxD,WAAd,CADyC,CADtB;AARf,WAJ4D;AAkBnEiD,UAAAA,eAAe,EAAEjD;AAlBkD,SAAxC,CAA5B;AAoBA,YAAIiB,GAAG,GAAGmB,UAAU,CAAClB,GAAX,CAAegC,mBAAf,CAAV;;AACA,YAAIjC,GAAG,KAAKE,SAAZ,EAAuB;AACtBiB,UAAAA,UAAU,CAACnB,GAAX,CAAeiC,mBAAf,EAAqCjC,GAAG,GAAG,IAAIG,GAAJ,EAA3C;AACA;;AACDH,QAAAA,GAAG,CAACI,GAAJ,CAAQN,CAAC,CAAC2B,EAAV;AACA,OAlDD;;AAlFU,kDAsIuBhC,cAtIvB;AAAA;;AAAA;AAsIV,+DAAiD;AAAA;AAAA,cAArCgD,QAAqC;AAAA,cAA3BvB,MAA2B;;AAChD,cAAIuB,QAAQ,KAAK7C,eAAjB,EAAkC;AAAA,wDACjBsB,MADiB;AAAA;;AAAA;AACjC;AAAA,oBAAWpB,GAAX;AAAwBuB,gBAAAA,YAAY,CAACvB,GAAD,EAAI2C,QAAJ,CAAZ;AAAxB;AADiC;AAAA;AAAA;AAAA;AAAA;AAEjC,WAFD,MAEO;AAAA,wDACUvB,MADV;AAAA;;AAAA;AACN;AAAA,oBAAWpB,GAAX;AAAwBsB,gBAAAA,gBAAgB,CAAChB,GAAjB,CAAqBN,GAArB;AAAxB;AADM;AAAA;AAAA;AAAA;AAAA;AAEN;AACD;AAED;AACF;AACA;AACA;;AAjJY;AAAA;AAAA;AAAA;AAAA;;AAkJV,UAAM4C,SAAS,GAAG,SAAZA,SAAY,CAAAC,EAAE,EAAI;AACvB,YAAMC,GAAG,GAAG,EAAZ;AACA,YAAIC,KAAK,GAAG,KAAZ;AACA,YAAIC,OAAJ;AACA,YAAIC,OAAO,GAAG,CAAd;;AAJuB,oDAKP3B,gBALO;AAAA;;AAAA;AAKvB,iEAAkC;AAAA,gBAAvBtB,GAAuB;AACjC,gBAAMyB,KAAK,GAAGoB,EAAE,CAAC7C,GAAD,CAAhB;;AACA,gBAAIyB,KAAK,KAAKzB,GAAC,CAAC2B,EAAhB,EAAoB;AACnBoB,cAAAA,KAAK,GAAG,IAAR;AACA,aAFD,MAEO;AACND,cAAAA,GAAG,CAAC9C,GAAC,CAAC2B,EAAH,CAAH,GAAYF,KAAZ;AACAuB,cAAAA,OAAO,GAAGhD,GAAC,CAAC2B,EAAZ;AACAsB,cAAAA,OAAO;AACP;AACD;AAdsB;AAAA;AAAA;AAAA;AAAA;;AAevB,YAAIA,OAAO,KAAK,CAAhB,EAAmB,OAAO,SAAP;;AACnB,YAAIA,OAAO,KAAK,CAAhB,EAAmB;AAClB,iBAAOF,KAAK,0BACOlB,IAAI,CAACC,SAAL,CAAekB,OAAf,CADP,gBACoCnB,IAAI,CAACC,SAAL,CAC7CgB,GAAG,CAACE,OAAD,CAD0C,CADpC,mBAITnB,IAAI,CAACC,SAAL,CAAegB,GAAG,CAACE,OAAD,CAAlB,CAJH;AAKA;;AACD,eAAOD,KAAK,cACLlB,IAAI,CAACC,SAAL,CAAegB,GAAf,CADK,uCAENjB,IAAI,CAACC,SAAL,CAAegB,GAAf,CAFM,cAAZ;AAGA,OA1BD;AA4BA;AACF;AACA;AACA;;;AACE,UAAMI,OAAO,GAAG,SAAVA,OAAU,CAAAL,EAAE,EAAI;AACrB,8BAAcD,SAAS,CAACC,EAAD,CAAvB;AACA,OAFD;AAIA;AACF;AACA;AACA;;;AACE,UAAMM,iBAAiB,GAAG,SAApBA,iBAAoB,CAAAN,EAAE;AAAA,eAAI,UAAArC,MAAM,EAAI;AACzC,gCAAcoC,SAAS,CAAC,UAAA5C,CAAC;AAAA,mBAAI,UAAG6C,EAAE,CAAC7C,CAAD,CAAL,EAAW+B,KAAX,CAAiB,CAAjB,EAAoBvB,MAApB,CAAJ;AAAA,WAAF,CAAvB;AACA,SAF2B;AAAA,OAA5B;;AAIA,UAAM4C,GAAG,GACRtD,eAAe,IACfL,WAAW,CAAC2C,OAAZ,CAAoBP,IAAI,CAACC,SAAL,CAAehC,eAAf,CAApB,EAAqD;AACpDuC,QAAAA,IAAI,iBAAS1D,cAAc,CAAC2D,WAAxB,YADgD;AAEpDC,QAAAA,cAAc,EAAE,wBAAA/B,MAAM;AAAA,gCACd7B,cAAc,CAAC2D,WADD,yBAC2B9B,MAD3B;AAAA,SAF8B;AAIpDjB,QAAAA,KAAK,EAAE;AACNoC,UAAAA,EAAE,qBADI;AAENU,UAAAA,IAAI,EAAEa,OAAO,CAAC,UAAAlD,CAAC;AAAA,mBAAIA,CAAC,CAACwC,YAAN;AAAA,WAAF,CAFP;AAGND,UAAAA,cAAc,EAAEY,iBAAiB,CAAC,UAAAnD,CAAC;AAAA,mBAAIA,CAAC,CAACwC,YAAN;AAAA,WAAF,CAH3B;AAINtD,UAAAA,IAAI,EAAEgE,OAAO,CAAC,UAAAlD,CAAC;AAAA,mBAAIA,CAAC,CAACd,IAAF,IAAUc,CAAC,CAAC2B,EAAhB;AAAA,WAAF,CAJP;AAKNc,UAAAA,WAAW,sBACTxD,WADS,EACKiE,OAAO,CAAC,UAAAlD,CAAC;AAAA,mBAAIA,CAAC,CAACyC,WAAF,CAAcxD,WAAd,CAAJ;AAAA,WAAF,CADZ,CALL;AAQNyD,UAAAA,qBAAqB,sBACnBzD,WADmB,EACLkE,iBAAiB,CAAC,UAAAnD,CAAC;AAAA,mBAAIA,CAAC,CAACyC,WAAF,CAAcxD,WAAd,CAAJ;AAAA,WAAF,CADZ;AARf,SAJ6C;AAgBpDiD,QAAAA,eAAe,EAAEjD;AAhBmC,OAArD,CAFD;AAqBA,aAAOH,QAAQ,CAACuE,QAAT,CAAkB,+CACe5C,sBAAsB,CAAC6C,IAAvB,CACtC,OADsC,CADf,aAIrBnE,MAJqB,gBAITO,eAAe,CAAC6D,aAAhB,CACd,SADc,EAGdlC,UAAU,CAACd,IAAX,GAAkB,CAAlB,GACG,CACA,mDADA,EAEA;AACAzB,MAAAA,QAAQ,CAACuE,QAAT,CACCG,KAAK,CAACC,IAAN,CAAWpC,UAAX,EAAuB,gBAAgB;AAAA;AAAA,YAAd+B,GAAc;AAAA,YAATM,GAAS;;AACtC,YAAMC,SAAS,GACdD,GAAG,CAACnD,IAAJ,KAAa,CAAb,yBACkBsB,IAAI,CAACC,SAAL,CAAe/C,KAAK,CAAC2E,GAAD,CAApB,CADlB,eAEOF,KAAK,CAACC,IAAN,CACJC,GADI,EAEJ,UAAA/B,EAAE;AAAA,2BAAOE,IAAI,CAACC,SAAL,CAAeH,EAAf,CAAP;AAAA,SAFE,EAGF2B,IAHE,CAGG,GAHH,CAFP,eADD;AAOA,6BAAcK,SAAd,sBAAmCP,GAAnC;AACA,OATD,CADD,CAHA,EAeA,+CAfA,mBAgBUA,GAhBV,OADH,GAmBG,CAAC,+CAAD,mBAA4DA,GAA5D,OAtBW,CAJS,OAAlB,CAAP;AA6BA;;;;EApQ0CvE,a;;AAuQ5C+E,MAAM,CAACC,OAAP,GAAiB7E,6BAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst RuntimeModule = require(\"../RuntimeModule\");\nconst Template = require(\"../Template\");\nconst { first } = require(\"../util/SetHelpers\");\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compilation\").PathData} PathData */\n\n/** @typedef {function(PathData, AssetInfo=): string} FilenameFunction */\n\nclass GetChunkFilenameRuntimeModule extends RuntimeModule {\n\t/**\n\t * @param {string} contentType the contentType to use the content hash for\n\t * @param {string} name kind of filename\n\t * @param {string} global function name to be assigned\n\t * @param {function(Chunk): string | FilenameFunction} getFilenameForChunk functor to get the filename or function\n\t * @param {boolean} allChunks when false, only async chunks are included\n\t */\n\tconstructor(contentType, name, global, getFilenameForChunk, allChunks) {\n\t\tsuper(`get ${name} chunk filename`);\n\t\tthis.contentType = contentType;\n\t\tthis.global = global;\n\t\tthis.getFilenameForChunk = getFilenameForChunk;\n\t\tthis.allChunks = allChunks;\n\t\tthis.dependentHash = true;\n\t}\n\n\t/**\n\t * @returns {string} runtime code\n\t */\n\tgenerate() {\n\t\tconst {\n\t\t\tglobal,\n\t\t\tchunk,\n\t\t\tchunkGraph,\n\t\t\tcontentType,\n\t\t\tgetFilenameForChunk,\n\t\t\tallChunks,\n\t\t\tcompilation\n\t\t} = this;\n\t\tconst { runtimeTemplate } = compilation;\n\n\t\t/** @type {Map<string | FilenameFunction, Set<Chunk>>} */\n\t\tconst chunkFilenames = new Map();\n\t\tlet maxChunks = 0;\n\t\t/** @type {string} */\n\t\tlet dynamicFilename;\n\n\t\t/**\n\t\t * @param {Chunk} c the chunk\n\t\t * @returns {void}\n\t\t */\n\t\tconst addChunk = c => {\n\t\t\tconst chunkFilename = getFilenameForChunk(c);\n\t\t\tif (chunkFilename) {\n\t\t\t\tlet set = chunkFilenames.get(chunkFilename);\n\t\t\t\tif (set === undefined) {\n\t\t\t\t\tchunkFilenames.set(chunkFilename, (set = new Set()));\n\t\t\t\t}\n\t\t\t\tset.add(c);\n\t\t\t\tif (typeof chunkFilename === \"string\") {\n\t\t\t\t\tif (set.size < maxChunks) return;\n\t\t\t\t\tif (set.size === maxChunks) {\n\t\t\t\t\t\tif (chunkFilename.length < dynamicFilename.length) return;\n\t\t\t\t\t\tif (chunkFilename.length === dynamicFilename.length) {\n\t\t\t\t\t\t\tif (chunkFilename < dynamicFilename) return;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmaxChunks = set.size;\n\t\t\t\t\tdynamicFilename = chunkFilename;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/** @type {string[]} */\n\t\tconst includedChunksMessages = [];\n\t\tif (allChunks) {\n\t\t\tincludedChunksMessages.push(\"all chunks\");\n\t\t\tfor (const c of chunk.getAllReferencedChunks()) {\n\t\t\t\taddChunk(c);\n\t\t\t}\n\t\t} else {\n\t\t\tincludedChunksMessages.push(\"async chunks\");\n\t\t\tfor (const c of chunk.getAllAsyncChunks()) {\n\t\t\t\taddChunk(c);\n\t\t\t}\n\t\t\tconst includeEntries = chunkGraph\n\t\t\t\t.getTreeRuntimeRequirements(chunk)\n\t\t\t\t.has(RuntimeGlobals.ensureChunkIncludeEntries);\n\t\t\tif (includeEntries) {\n\t\t\t\tincludedChunksMessages.push(\"sibling chunks for the entrypoint\");\n\t\t\t\tfor (const c of chunkGraph.getChunkEntryDependentChunksIterable(\n\t\t\t\t\tchunk\n\t\t\t\t)) {\n\t\t\t\t\taddChunk(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const entrypoint of chunk.getAllReferencedAsyncEntrypoints()) {\n\t\t\taddChunk(entrypoint.chunks[entrypoint.chunks.length - 1]);\n\t\t}\n\n\t\t/** @type {Map<string, Set<string | number>>} */\n\t\tconst staticUrls = new Map();\n\t\t/** @type {Set<Chunk>} */\n\t\tconst dynamicUrlChunks = new Set();\n\n\t\t/**\n\t\t * @param {Chunk} c the chunk\n\t\t * @param {string | FilenameFunction} chunkFilename the filename template for the chunk\n\t\t * @returns {void}\n\t\t */\n\t\tconst addStaticUrl = (c, chunkFilename) => {\n\t\t\t/**\n\t\t\t * @param {string | number} value a value\n\t\t\t * @returns {string} string to put in quotes\n\t\t\t */\n\t\t\tconst unquotedStringify = value => {\n\t\t\t\tconst str = `${value}`;\n\t\t\t\tif (str.length >= 5 && str === `${c.id}`) {\n\t\t\t\t\t// This is shorter and generates the same result\n\t\t\t\t\treturn '\" + chunkId + \"';\n\t\t\t\t}\n\t\t\t\tconst s = JSON.stringify(str);\n\t\t\t\treturn s.slice(1, s.length - 1);\n\t\t\t};\n\t\t\tconst unquotedStringifyWithLength = value => length =>\n\t\t\t\tunquotedStringify(`${value}`.slice(0, length));\n\t\t\tconst chunkFilenameValue =\n\t\t\t\ttypeof chunkFilename === \"function\"\n\t\t\t\t\t? JSON.stringify(\n\t\t\t\t\t\t\tchunkFilename({\n\t\t\t\t\t\t\t\tchunk: c,\n\t\t\t\t\t\t\t\tcontentHashType: contentType\n\t\t\t\t\t\t\t})\n\t\t\t\t\t  )\n\t\t\t\t\t: JSON.stringify(chunkFilename);\n\t\t\tconst staticChunkFilename = compilation.getPath(chunkFilenameValue, {\n\t\t\t\thash: `\" + ${RuntimeGlobals.getFullHash}() + \"`,\n\t\t\t\thashWithLength: length =>\n\t\t\t\t\t`\" + ${RuntimeGlobals.getFullHash}().slice(0, ${length}) + \"`,\n\t\t\t\tchunk: {\n\t\t\t\t\tid: unquotedStringify(c.id),\n\t\t\t\t\thash: unquotedStringify(c.renderedHash),\n\t\t\t\t\thashWithLength: unquotedStringifyWithLength(c.renderedHash),\n\t\t\t\t\tname: unquotedStringify(c.name || c.id),\n\t\t\t\t\tcontentHash: {\n\t\t\t\t\t\t[contentType]: unquotedStringify(c.contentHash[contentType])\n\t\t\t\t\t},\n\t\t\t\t\tcontentHashWithLength: {\n\t\t\t\t\t\t[contentType]: unquotedStringifyWithLength(\n\t\t\t\t\t\t\tc.contentHash[contentType]\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tcontentHashType: contentType\n\t\t\t});\n\t\t\tlet set = staticUrls.get(staticChunkFilename);\n\t\t\tif (set === undefined) {\n\t\t\t\tstaticUrls.set(staticChunkFilename, (set = new Set()));\n\t\t\t}\n\t\t\tset.add(c.id);\n\t\t};\n\n\t\tfor (const [filename, chunks] of chunkFilenames) {\n\t\t\tif (filename !== dynamicFilename) {\n\t\t\t\tfor (const c of chunks) addStaticUrl(c, filename);\n\t\t\t} else {\n\t\t\t\tfor (const c of chunks) dynamicUrlChunks.add(c);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {function(Chunk): string | number} fn function from chunk to value\n\t\t * @returns {string} code with static mapping of results of fn\n\t\t */\n\t\tconst createMap = fn => {\n\t\t\tconst obj = {};\n\t\t\tlet useId = false;\n\t\t\tlet lastKey;\n\t\t\tlet entries = 0;\n\t\t\tfor (const c of dynamicUrlChunks) {\n\t\t\t\tconst value = fn(c);\n\t\t\t\tif (value === c.id) {\n\t\t\t\t\tuseId = true;\n\t\t\t\t} else {\n\t\t\t\t\tobj[c.id] = value;\n\t\t\t\t\tlastKey = c.id;\n\t\t\t\t\tentries++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (entries === 0) return \"chunkId\";\n\t\t\tif (entries === 1) {\n\t\t\t\treturn useId\n\t\t\t\t\t? `(chunkId === ${JSON.stringify(lastKey)} ? ${JSON.stringify(\n\t\t\t\t\t\t\tobj[lastKey]\n\t\t\t\t\t  )} : chunkId)`\n\t\t\t\t\t: JSON.stringify(obj[lastKey]);\n\t\t\t}\n\t\t\treturn useId\n\t\t\t\t? `(${JSON.stringify(obj)}[chunkId] || chunkId)`\n\t\t\t\t: `${JSON.stringify(obj)}[chunkId]`;\n\t\t};\n\n\t\t/**\n\t\t * @param {function(Chunk): string | number} fn function from chunk to value\n\t\t * @returns {string} code with static mapping of results of fn for including in quoted string\n\t\t */\n\t\tconst mapExpr = fn => {\n\t\t\treturn `\" + ${createMap(fn)} + \"`;\n\t\t};\n\n\t\t/**\n\t\t * @param {function(Chunk): string | number} fn function from chunk to value\n\t\t * @returns {function(number): string} function which generates code with static mapping of results of fn for including in quoted string for specific length\n\t\t */\n\t\tconst mapExprWithLength = fn => length => {\n\t\t\treturn `\" + ${createMap(c => `${fn(c)}`.slice(0, length))} + \"`;\n\t\t};\n\n\t\tconst url =\n\t\t\tdynamicFilename &&\n\t\t\tcompilation.getPath(JSON.stringify(dynamicFilename), {\n\t\t\t\thash: `\" + ${RuntimeGlobals.getFullHash}() + \"`,\n\t\t\t\thashWithLength: length =>\n\t\t\t\t\t`\" + ${RuntimeGlobals.getFullHash}().slice(0, ${length}) + \"`,\n\t\t\t\tchunk: {\n\t\t\t\t\tid: `\" + chunkId + \"`,\n\t\t\t\t\thash: mapExpr(c => c.renderedHash),\n\t\t\t\t\thashWithLength: mapExprWithLength(c => c.renderedHash),\n\t\t\t\t\tname: mapExpr(c => c.name || c.id),\n\t\t\t\t\tcontentHash: {\n\t\t\t\t\t\t[contentType]: mapExpr(c => c.contentHash[contentType])\n\t\t\t\t\t},\n\t\t\t\t\tcontentHashWithLength: {\n\t\t\t\t\t\t[contentType]: mapExprWithLength(c => c.contentHash[contentType])\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tcontentHashType: contentType\n\t\t\t});\n\n\t\treturn Template.asString([\n\t\t\t`// This function allow to reference ${includedChunksMessages.join(\n\t\t\t\t\" and \"\n\t\t\t)}`,\n\t\t\t`${global} = ${runtimeTemplate.basicFunction(\n\t\t\t\t\"chunkId\",\n\n\t\t\t\tstaticUrls.size > 0\n\t\t\t\t\t? [\n\t\t\t\t\t\t\t\"// return url for filenames not based on template\",\n\t\t\t\t\t\t\t// it minimizes to `x===1?\"...\":x===2?\"...\":\"...\"`\n\t\t\t\t\t\t\tTemplate.asString(\n\t\t\t\t\t\t\t\tArray.from(staticUrls, ([url, ids]) => {\n\t\t\t\t\t\t\t\t\tconst condition =\n\t\t\t\t\t\t\t\t\t\tids.size === 1\n\t\t\t\t\t\t\t\t\t\t\t? `chunkId === ${JSON.stringify(first(ids))}`\n\t\t\t\t\t\t\t\t\t\t\t: `{${Array.from(\n\t\t\t\t\t\t\t\t\t\t\t\t\tids,\n\t\t\t\t\t\t\t\t\t\t\t\t\tid => `${JSON.stringify(id)}:1`\n\t\t\t\t\t\t\t\t\t\t\t  ).join(\",\")}}[chunkId]`;\n\t\t\t\t\t\t\t\t\treturn `if (${condition}) return ${url};`;\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\"// return url for filenames based on template\",\n\t\t\t\t\t\t\t`return ${url};`\n\t\t\t\t\t  ]\n\t\t\t\t\t: [\"// return url for filenames based on template\", `return ${url};`]\n\t\t\t)};`\n\t\t]);\n\t}\n}\n\nmodule.exports = GetChunkFilenameRuntimeModule;\n"]},"metadata":{},"sourceType":"script"}