{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _objectSpread = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar Chunk = require(\"../Chunk\");\n\nvar _require = require(\"../OptimizationStages\"),\n    STAGE_ADVANCED = _require.STAGE_ADVANCED;\n\nvar WebpackError = require(\"../WebpackError\");\n\nvar _require2 = require(\"../ids/IdHelpers\"),\n    requestToId = _require2.requestToId;\n\nvar _require3 = require(\"../util/SetHelpers\"),\n    isSubset = _require3.isSubset;\n\nvar SortableSet = require(\"../util/SortableSet\");\n\nvar _require4 = require(\"../util/comparators\"),\n    compareModulesByIdentifier = _require4.compareModulesByIdentifier,\n    compareIterables = _require4.compareIterables;\n\nvar createHash = require(\"../util/createHash\");\n\nvar deterministicGrouping = require(\"../util/deterministicGrouping\");\n\nvar _require5 = require(\"../util/identifier\"),\n    makePathsRelative = _require5.makePathsRelative;\n\nvar memoize = require(\"../util/memoize\");\n\nvar MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksCacheGroup} OptimizationSplitChunksCacheGroup */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksGetCacheGroups} OptimizationSplitChunksGetCacheGroups */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksOptions} OptimizationSplitChunksOptions */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksSizes} OptimizationSplitChunksSizes */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").Output} OutputOptions */\n\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n\n/** @typedef {import(\"../Compilation\").PathData} PathData */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n\n/** @typedef {Record<string, number>} SplitChunksSizes */\n\n/**\n * @callback ChunkFilterFunction\n * @param {Chunk} chunk\n * @returns {boolean}\n */\n\n/**\n * @callback CombineSizeFunction\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\n\n/**\n * @typedef {Object} CacheGroupSource\n * @property {string=} key\n * @property {number=} priority\n * @property {GetName=} getName\n * @property {ChunkFilterFunction=} chunksFilter\n * @property {boolean=} enforce\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {number=} minChunks\n * @property {number=} maxAsyncRequests\n * @property {number=} maxInitialRequests\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\n * @property {string=} idHint\n * @property {string} automaticNameDelimiter\n * @property {boolean=} reuseExistingChunk\n * @property {boolean=} usedExports\n */\n\n/**\n * @typedef {Object} CacheGroup\n * @property {string} key\n * @property {number=} priority\n * @property {GetName=} getName\n * @property {ChunkFilterFunction=} chunksFilter\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {number=} minChunks\n * @property {number=} maxAsyncRequests\n * @property {number=} maxInitialRequests\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\n * @property {string=} idHint\n * @property {string} automaticNameDelimiter\n * @property {boolean} reuseExistingChunk\n * @property {boolean} usedExports\n * @property {boolean} _validateSize\n * @property {boolean} _validateRemainingSize\n * @property {SplitChunksSizes} _minSizeForMaxSize\n * @property {boolean} _conditionalEnforce\n */\n\n/**\n * @typedef {Object} FallbackCacheGroup\n * @property {ChunkFilterFunction} chunksFilter\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {string} automaticNameDelimiter\n */\n\n/**\n * @typedef {Object} CacheGroupsContext\n * @property {ModuleGraph} moduleGraph\n * @property {ChunkGraph} chunkGraph\n */\n\n/**\n * @callback GetCacheGroups\n * @param {Module} module\n * @param {CacheGroupsContext} context\n * @returns {CacheGroupSource[]}\n */\n\n/**\n * @callback GetName\n * @param {Module=} module\n * @param {Chunk[]=} chunks\n * @param {string=} key\n * @returns {string=}\n */\n\n/**\n * @typedef {Object} SplitChunksOptions\n * @property {ChunkFilterFunction} chunksFilter\n * @property {string[]} defaultSizeTypes\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxInitialSize\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {number} minChunks\n * @property {number} maxAsyncRequests\n * @property {number} maxInitialRequests\n * @property {boolean} hidePathInfo\n * @property {string | function(PathData, AssetInfo=): string} filename\n * @property {string} automaticNameDelimiter\n * @property {GetCacheGroups} getCacheGroups\n * @property {GetName} getName\n * @property {boolean} usedExports\n * @property {FallbackCacheGroup} fallbackCacheGroup\n */\n\n/**\n * @typedef {Object} ChunksInfoItem\n * @property {SortableSet<Module>} modules\n * @property {CacheGroup} cacheGroup\n * @property {number} cacheGroupIndex\n * @property {string} name\n * @property {Record<string, number>} sizes\n * @property {Set<Chunk>} chunks\n * @property {Set<Chunk>} reuseableChunks\n * @property {Set<bigint | Chunk>} chunksKeys\n */\n\n\nvar defaultGetName =\n/** @type {GetName} */\nfunction defaultGetName() {};\n\nvar deterministicGroupingForModules =\n/** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */\ndeterministicGrouping;\n/** @type {WeakMap<Module, string>} */\n\nvar getKeyCache = new WeakMap();\n/**\n * @param {string} name a filename to hash\n * @param {OutputOptions} outputOptions hash function used\n * @returns {string} hashed filename\n */\n\nvar hashFilename = function hashFilename(name, outputOptions) {\n  var digest =\n  /** @type {string} */\n  createHash(outputOptions.hashFunction).update(name).digest(outputOptions.hashDigest);\n  return digest.slice(0, 8);\n};\n/**\n * @param {Chunk} chunk the chunk\n * @returns {number} the number of requests\n */\n\n\nvar getRequests = function getRequests(chunk) {\n  var requests = 0;\n\n  var _iterator = _createForOfIteratorHelper(chunk.groupsIterable),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var chunkGroup = _step.value;\n      requests = Math.max(requests, chunkGroup.chunks.length);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return requests;\n};\n\nvar mapObject = function mapObject(obj, fn) {\n  var newObj = Object.create(null);\n\n  for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    newObj[key] = fn(obj[key], key);\n  }\n\n  return newObj;\n};\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\n\n\nvar isOverlap = function isOverlap(a, b) {\n  var _iterator2 = _createForOfIteratorHelper(a),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var item = _step2.value;\n      if (b.has(item)) return true;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return false;\n};\n\nvar compareModuleIterables = compareIterables(compareModulesByIdentifier);\n/**\n * @param {ChunksInfoItem} a item\n * @param {ChunksInfoItem} b item\n * @returns {number} compare result\n */\n\nvar compareEntries = function compareEntries(a, b) {\n  // 1. by priority\n  var diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n  if (diffPriority) return diffPriority; // 2. by number of chunks\n\n  var diffCount = a.chunks.size - b.chunks.size;\n  if (diffCount) return diffCount; // 3. by size reduction\n\n  var aSizeReduce = totalSize(a.sizes) * (a.chunks.size - 1);\n  var bSizeReduce = totalSize(b.sizes) * (b.chunks.size - 1);\n  var diffSizeReduce = aSizeReduce - bSizeReduce;\n  if (diffSizeReduce) return diffSizeReduce; // 4. by cache group index\n\n  var indexDiff = b.cacheGroupIndex - a.cacheGroupIndex;\n  if (indexDiff) return indexDiff; // 5. by number of modules (to be able to compare by identifier)\n\n  var modulesA = a.modules;\n  var modulesB = b.modules;\n  var diff = modulesA.size - modulesB.size;\n  if (diff) return diff; // 6. by module identifiers\n\n  modulesA.sort();\n  modulesB.sort();\n  return compareModuleIterables(modulesA, modulesB);\n};\n\nvar INITIAL_CHUNK_FILTER = function INITIAL_CHUNK_FILTER(chunk) {\n  return chunk.canBeInitial();\n};\n\nvar ASYNC_CHUNK_FILTER = function ASYNC_CHUNK_FILTER(chunk) {\n  return !chunk.canBeInitial();\n};\n\nvar ALL_CHUNK_FILTER = function ALL_CHUNK_FILTER(chunk) {\n  return true;\n};\n/**\n * @param {OptimizationSplitChunksSizes} value the sizes\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {SplitChunksSizes} normalized representation\n */\n\n\nvar normalizeSizes = function normalizeSizes(value, defaultSizeTypes) {\n  if (typeof value === \"number\") {\n    /** @type {Record<string, number>} */\n    var o = {};\n\n    var _iterator3 = _createForOfIteratorHelper(defaultSizeTypes),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var sizeType = _step3.value;\n        o[sizeType] = value;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return o;\n  } else if (typeof value === \"object\" && value !== null) {\n    return _objectSpread({}, value);\n  } else {\n    return {};\n  }\n};\n/**\n * @param {...SplitChunksSizes} sizes the sizes\n * @returns {SplitChunksSizes} the merged sizes\n */\n\n\nvar mergeSizes = function mergeSizes() {\n  /** @type {SplitChunksSizes} */\n  var merged = {};\n\n  for (var i = arguments.length - 1; i >= 0; i--) {\n    merged = Object.assign(merged, i < 0 || arguments.length <= i ? undefined : arguments[i]);\n  }\n\n  return merged;\n};\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @returns {boolean} true, if there are sizes > 0\n */\n\n\nvar hasNonZeroSizes = function hasNonZeroSizes(sizes) {\n  for (var _i2 = 0, _Object$keys2 = Object.keys(sizes); _i2 < _Object$keys2.length; _i2++) {\n    var key = _Object$keys2[_i2];\n    if (sizes[key] > 0) return true;\n  }\n\n  return false;\n};\n/**\n * @param {SplitChunksSizes} a first sizes\n * @param {SplitChunksSizes} b second sizes\n * @param {CombineSizeFunction} combine a function to combine sizes\n * @returns {SplitChunksSizes} the combine sizes\n */\n\n\nvar combineSizes = function combineSizes(a, b, combine) {\n  var aKeys = new Set(Object.keys(a));\n  var bKeys = new Set(Object.keys(b));\n  /** @type {SplitChunksSizes} */\n\n  var result = {};\n\n  var _iterator4 = _createForOfIteratorHelper(aKeys),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var key = _step4.value;\n\n      if (bKeys.has(key)) {\n        result[key] = combine(a[key], b[key]);\n      } else {\n        result[key] = a[key];\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  var _iterator5 = _createForOfIteratorHelper(bKeys),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var _key = _step5.value;\n\n      if (!aKeys.has(_key)) {\n        result[_key] = b[_key];\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return result;\n};\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSize the min sizes\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSize`\n */\n\n\nvar checkMinSize = function checkMinSize(sizes, minSize) {\n  for (var _i3 = 0, _Object$keys3 = Object.keys(minSize); _i3 < _Object$keys3.length; _i3++) {\n    var key = _Object$keys3[_i3];\n    var size = sizes[key];\n    if (size === undefined || size === 0) continue;\n    if (size < minSize[key]) return false;\n  }\n\n  return true;\n};\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSizeReduction the min sizes\n * @param {number} chunkCount number of chunks\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSizeReduction`\n */\n\n\nvar checkMinSizeReduction = function checkMinSizeReduction(sizes, minSizeReduction, chunkCount) {\n  for (var _i4 = 0, _Object$keys4 = Object.keys(minSizeReduction); _i4 < _Object$keys4.length; _i4++) {\n    var key = _Object$keys4[_i4];\n    var size = sizes[key];\n    if (size === undefined || size === 0) continue;\n    if (size * chunkCount < minSizeReduction[key]) return false;\n  }\n\n  return true;\n};\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSize the min sizes\n * @returns {undefined | string[]} list of size types that are below min size\n */\n\n\nvar getViolatingMinSizes = function getViolatingMinSizes(sizes, minSize) {\n  var list;\n\n  for (var _i5 = 0, _Object$keys5 = Object.keys(minSize); _i5 < _Object$keys5.length; _i5++) {\n    var key = _Object$keys5[_i5];\n    var size = sizes[key];\n    if (size === undefined || size === 0) continue;\n\n    if (size < minSize[key]) {\n      if (list === undefined) list = [key];else list.push(key);\n    }\n  }\n\n  return list;\n};\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @returns {number} the total size\n */\n\n\nvar totalSize = function totalSize(sizes) {\n  var size = 0;\n\n  for (var _i6 = 0, _Object$keys6 = Object.keys(sizes); _i6 < _Object$keys6.length; _i6++) {\n    var key = _Object$keys6[_i6];\n    size += sizes[key];\n  }\n\n  return size;\n};\n/**\n * @param {false|string|Function} name the chunk name\n * @returns {GetName} a function to get the name of the chunk\n */\n\n\nvar normalizeName = function normalizeName(name) {\n  if (typeof name === \"string\") {\n    return function () {\n      return name;\n    };\n  }\n\n  if (typeof name === \"function\") {\n    return (\n      /** @type {GetName} */\n      name\n    );\n  }\n};\n/**\n * @param {OptimizationSplitChunksCacheGroup[\"chunks\"]} chunks the chunk filter option\n * @returns {ChunkFilterFunction} the chunk filter function\n */\n\n\nvar normalizeChunksFilter = function normalizeChunksFilter(chunks) {\n  if (chunks === \"initial\") {\n    return INITIAL_CHUNK_FILTER;\n  }\n\n  if (chunks === \"async\") {\n    return ASYNC_CHUNK_FILTER;\n  }\n\n  if (chunks === \"all\") {\n    return ALL_CHUNK_FILTER;\n  }\n\n  if (typeof chunks === \"function\") {\n    return chunks;\n  }\n};\n/**\n * @param {GetCacheGroups | Record<string, false|string|RegExp|OptimizationSplitChunksGetCacheGroups|OptimizationSplitChunksCacheGroup>} cacheGroups the cache group options\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {GetCacheGroups} a function to get the cache groups\n */\n\n\nvar normalizeCacheGroups = function normalizeCacheGroups(cacheGroups, defaultSizeTypes) {\n  if (typeof cacheGroups === \"function\") {\n    return cacheGroups;\n  }\n\n  if (typeof cacheGroups === \"object\" && cacheGroups !== null) {\n    /** @type {(function(Module, CacheGroupsContext, CacheGroupSource[]): void)[]} */\n    var handlers = [];\n\n    var _loop = function _loop() {\n      var key = _Object$keys7[_i7];\n      var option = cacheGroups[key];\n\n      if (option === false) {\n        return \"continue\";\n      }\n\n      if (typeof option === \"string\" || option instanceof RegExp) {\n        var source = createCacheGroupSource({}, key, defaultSizeTypes);\n        handlers.push(function (module, context, results) {\n          if (checkTest(option, module, context)) {\n            results.push(source);\n          }\n        });\n      } else if (typeof option === \"function\") {\n        var cache = new WeakMap();\n        handlers.push(function (module, context, results) {\n          var result = option(module);\n\n          if (result) {\n            var groups = Array.isArray(result) ? result : [result];\n\n            var _iterator6 = _createForOfIteratorHelper(groups),\n                _step6;\n\n            try {\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                var group = _step6.value;\n                var cachedSource = cache.get(group);\n\n                if (cachedSource !== undefined) {\n                  results.push(cachedSource);\n                } else {\n                  var _source = createCacheGroupSource(group, key, defaultSizeTypes);\n\n                  cache.set(group, _source);\n                  results.push(_source);\n                }\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n          }\n        });\n      } else {\n        var _source2 = createCacheGroupSource(option, key, defaultSizeTypes);\n\n        handlers.push(function (module, context, results) {\n          if (checkTest(option.test, module, context) && checkModuleType(option.type, module) && checkModuleLayer(option.layer, module)) {\n            results.push(_source2);\n          }\n        });\n      }\n    };\n\n    for (var _i7 = 0, _Object$keys7 = Object.keys(cacheGroups); _i7 < _Object$keys7.length; _i7++) {\n      var _ret = _loop();\n\n      if (_ret === \"continue\") continue;\n    }\n    /**\n     * @param {Module} module the current module\n     * @param {CacheGroupsContext} context the current context\n     * @returns {CacheGroupSource[]} the matching cache groups\n     */\n\n\n    var fn = function fn(module, context) {\n      /** @type {CacheGroupSource[]} */\n      var results = [];\n\n      var _iterator7 = _createForOfIteratorHelper(handlers),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _fn = _step7.value;\n\n          _fn(module, context, results);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      return results;\n    };\n\n    return fn;\n  }\n\n  return function () {\n    return null;\n  };\n};\n/**\n * @param {undefined|boolean|string|RegExp|Function} test test option\n * @param {Module} module the module\n * @param {CacheGroupsContext} context context object\n * @returns {boolean} true, if the module should be selected\n */\n\n\nvar checkTest = function checkTest(test, module, context) {\n  if (test === undefined) return true;\n\n  if (typeof test === \"function\") {\n    return test(module, context);\n  }\n\n  if (typeof test === \"boolean\") return test;\n\n  if (typeof test === \"string\") {\n    var name = module.nameForCondition();\n    return name && name.startsWith(test);\n  }\n\n  if (test instanceof RegExp) {\n    var _name = module.nameForCondition();\n\n    return _name && test.test(_name);\n  }\n\n  return false;\n};\n/**\n * @param {undefined|string|RegExp|Function} test type option\n * @param {Module} module the module\n * @returns {boolean} true, if the module should be selected\n */\n\n\nvar checkModuleType = function checkModuleType(test, module) {\n  if (test === undefined) return true;\n\n  if (typeof test === \"function\") {\n    return test(module.type);\n  }\n\n  if (typeof test === \"string\") {\n    var type = module.type;\n    return test === type;\n  }\n\n  if (test instanceof RegExp) {\n    var _type = module.type;\n    return test.test(_type);\n  }\n\n  return false;\n};\n/**\n * @param {undefined|string|RegExp|Function} test type option\n * @param {Module} module the module\n * @returns {boolean} true, if the module should be selected\n */\n\n\nvar checkModuleLayer = function checkModuleLayer(test, module) {\n  if (test === undefined) return true;\n\n  if (typeof test === \"function\") {\n    return test(module.layer);\n  }\n\n  if (typeof test === \"string\") {\n    var layer = module.layer;\n    return test === \"\" ? !layer : layer && layer.startsWith(test);\n  }\n\n  if (test instanceof RegExp) {\n    var _layer = module.layer;\n    return test.test(_layer);\n  }\n\n  return false;\n};\n/**\n * @param {OptimizationSplitChunksCacheGroup} options the group options\n * @param {string} key key of cache group\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {CacheGroupSource} the normalized cached group\n */\n\n\nvar createCacheGroupSource = function createCacheGroupSource(options, key, defaultSizeTypes) {\n  var minSize = normalizeSizes(options.minSize, defaultSizeTypes);\n  var minSizeReduction = normalizeSizes(options.minSizeReduction, defaultSizeTypes);\n  var maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\n  return {\n    key: key,\n    priority: options.priority,\n    getName: normalizeName(options.name),\n    chunksFilter: normalizeChunksFilter(options.chunks),\n    enforce: options.enforce,\n    minSize: minSize,\n    minSizeReduction: minSizeReduction,\n    minRemainingSize: mergeSizes(normalizeSizes(options.minRemainingSize, defaultSizeTypes), minSize),\n    enforceSizeThreshold: normalizeSizes(options.enforceSizeThreshold, defaultSizeTypes),\n    maxAsyncSize: mergeSizes(normalizeSizes(options.maxAsyncSize, defaultSizeTypes), maxSize),\n    maxInitialSize: mergeSizes(normalizeSizes(options.maxInitialSize, defaultSizeTypes), maxSize),\n    minChunks: options.minChunks,\n    maxAsyncRequests: options.maxAsyncRequests,\n    maxInitialRequests: options.maxInitialRequests,\n    filename: options.filename,\n    idHint: options.idHint,\n    automaticNameDelimiter: options.automaticNameDelimiter,\n    reuseExistingChunk: options.reuseExistingChunk,\n    usedExports: options.usedExports\n  };\n};\n\nmodule.exports = /*#__PURE__*/function () {\n  /**\n   * @param {OptimizationSplitChunksOptions=} options plugin options\n   */\n  function SplitChunksPlugin() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, SplitChunksPlugin);\n\n    var defaultSizeTypes = options.defaultSizeTypes || [\"javascript\", \"unknown\"];\n    var fallbackCacheGroup = options.fallbackCacheGroup || {};\n    var minSize = normalizeSizes(options.minSize, defaultSizeTypes);\n    var minSizeReduction = normalizeSizes(options.minSizeReduction, defaultSizeTypes);\n    var maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\n    /** @type {SplitChunksOptions} */\n\n    this.options = {\n      chunksFilter: normalizeChunksFilter(options.chunks || \"all\"),\n      defaultSizeTypes: defaultSizeTypes,\n      minSize: minSize,\n      minSizeReduction: minSizeReduction,\n      minRemainingSize: mergeSizes(normalizeSizes(options.minRemainingSize, defaultSizeTypes), minSize),\n      enforceSizeThreshold: normalizeSizes(options.enforceSizeThreshold, defaultSizeTypes),\n      maxAsyncSize: mergeSizes(normalizeSizes(options.maxAsyncSize, defaultSizeTypes), maxSize),\n      maxInitialSize: mergeSizes(normalizeSizes(options.maxInitialSize, defaultSizeTypes), maxSize),\n      minChunks: options.minChunks || 1,\n      maxAsyncRequests: options.maxAsyncRequests || 1,\n      maxInitialRequests: options.maxInitialRequests || 1,\n      hidePathInfo: options.hidePathInfo || false,\n      filename: options.filename || undefined,\n      getCacheGroups: normalizeCacheGroups(options.cacheGroups, defaultSizeTypes),\n      getName: options.name ? normalizeName(options.name) : defaultGetName,\n      automaticNameDelimiter: options.automaticNameDelimiter,\n      usedExports: options.usedExports,\n      fallbackCacheGroup: {\n        chunksFilter: normalizeChunksFilter(fallbackCacheGroup.chunks || options.chunks || \"all\"),\n        minSize: mergeSizes(normalizeSizes(fallbackCacheGroup.minSize, defaultSizeTypes), minSize),\n        maxAsyncSize: mergeSizes(normalizeSizes(fallbackCacheGroup.maxAsyncSize, defaultSizeTypes), normalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes), normalizeSizes(options.maxAsyncSize, defaultSizeTypes), normalizeSizes(options.maxSize, defaultSizeTypes)),\n        maxInitialSize: mergeSizes(normalizeSizes(fallbackCacheGroup.maxInitialSize, defaultSizeTypes), normalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes), normalizeSizes(options.maxInitialSize, defaultSizeTypes), normalizeSizes(options.maxSize, defaultSizeTypes)),\n        automaticNameDelimiter: fallbackCacheGroup.automaticNameDelimiter || options.automaticNameDelimiter || \"~\"\n      }\n    };\n    /** @type {WeakMap<CacheGroupSource, CacheGroup>} */\n\n    this._cacheGroupCache = new WeakMap();\n  }\n  /**\n   * @param {CacheGroupSource} cacheGroupSource source\n   * @returns {CacheGroup} the cache group (cached)\n   */\n\n\n  _createClass(SplitChunksPlugin, [{\n    key: \"_getCacheGroup\",\n    value: function _getCacheGroup(cacheGroupSource) {\n      var cacheEntry = this._cacheGroupCache.get(cacheGroupSource);\n\n      if (cacheEntry !== undefined) return cacheEntry;\n      var minSize = mergeSizes(cacheGroupSource.minSize, cacheGroupSource.enforce ? undefined : this.options.minSize);\n      var minSizeReduction = mergeSizes(cacheGroupSource.minSizeReduction, cacheGroupSource.enforce ? undefined : this.options.minSizeReduction);\n      var minRemainingSize = mergeSizes(cacheGroupSource.minRemainingSize, cacheGroupSource.enforce ? undefined : this.options.minRemainingSize);\n      var enforceSizeThreshold = mergeSizes(cacheGroupSource.enforceSizeThreshold, cacheGroupSource.enforce ? undefined : this.options.enforceSizeThreshold);\n      var cacheGroup = {\n        key: cacheGroupSource.key,\n        priority: cacheGroupSource.priority || 0,\n        chunksFilter: cacheGroupSource.chunksFilter || this.options.chunksFilter,\n        minSize: minSize,\n        minSizeReduction: minSizeReduction,\n        minRemainingSize: minRemainingSize,\n        enforceSizeThreshold: enforceSizeThreshold,\n        maxAsyncSize: mergeSizes(cacheGroupSource.maxAsyncSize, cacheGroupSource.enforce ? undefined : this.options.maxAsyncSize),\n        maxInitialSize: mergeSizes(cacheGroupSource.maxInitialSize, cacheGroupSource.enforce ? undefined : this.options.maxInitialSize),\n        minChunks: cacheGroupSource.minChunks !== undefined ? cacheGroupSource.minChunks : cacheGroupSource.enforce ? 1 : this.options.minChunks,\n        maxAsyncRequests: cacheGroupSource.maxAsyncRequests !== undefined ? cacheGroupSource.maxAsyncRequests : cacheGroupSource.enforce ? Infinity : this.options.maxAsyncRequests,\n        maxInitialRequests: cacheGroupSource.maxInitialRequests !== undefined ? cacheGroupSource.maxInitialRequests : cacheGroupSource.enforce ? Infinity : this.options.maxInitialRequests,\n        getName: cacheGroupSource.getName !== undefined ? cacheGroupSource.getName : this.options.getName,\n        usedExports: cacheGroupSource.usedExports !== undefined ? cacheGroupSource.usedExports : this.options.usedExports,\n        filename: cacheGroupSource.filename !== undefined ? cacheGroupSource.filename : this.options.filename,\n        automaticNameDelimiter: cacheGroupSource.automaticNameDelimiter !== undefined ? cacheGroupSource.automaticNameDelimiter : this.options.automaticNameDelimiter,\n        idHint: cacheGroupSource.idHint !== undefined ? cacheGroupSource.idHint : cacheGroupSource.key,\n        reuseExistingChunk: cacheGroupSource.reuseExistingChunk || false,\n        _validateSize: hasNonZeroSizes(minSize),\n        _validateRemainingSize: hasNonZeroSizes(minRemainingSize),\n        _minSizeForMaxSize: mergeSizes(cacheGroupSource.minSize, this.options.minSize),\n        _conditionalEnforce: hasNonZeroSizes(enforceSizeThreshold)\n      };\n\n      this._cacheGroupCache.set(cacheGroupSource, cacheGroup);\n\n      return cacheGroup;\n    }\n    /**\n     * Apply the plugin\n     * @param {Compiler} compiler the compiler instance\n     * @returns {void}\n     */\n\n  }, {\n    key: \"apply\",\n    value: function apply(compiler) {\n      var _this = this;\n\n      var cachedMakePathsRelative = makePathsRelative.bindContextCache(compiler.context, compiler.root);\n      compiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", function (compilation) {\n        var logger = compilation.getLogger(\"webpack.SplitChunksPlugin\");\n        var alreadyOptimized = false;\n        compilation.hooks.unseal.tap(\"SplitChunksPlugin\", function () {\n          alreadyOptimized = false;\n        });\n        compilation.hooks.optimizeChunks.tap({\n          name: \"SplitChunksPlugin\",\n          stage: STAGE_ADVANCED\n        }, function (chunks) {\n          if (alreadyOptimized) return;\n          alreadyOptimized = true;\n          logger.time(\"prepare\");\n          var chunkGraph = compilation.chunkGraph;\n          var moduleGraph = compilation.moduleGraph; // Give each selected chunk an index (to create strings from chunks)\n\n          /** @type {Map<Chunk, bigint>} */\n\n          var chunkIndexMap = new Map();\n          var ZERO = BigInt(\"0\");\n          var ONE = BigInt(\"1\");\n          var START = ONE << BigInt(\"31\");\n          var index = START;\n\n          var _iterator8 = _createForOfIteratorHelper(chunks),\n              _step8;\n\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var _chunk8 = _step8.value;\n              chunkIndexMap.set(_chunk8, index | BigInt(Math.random() * 0x7fffffff | 0));\n              index = index << ONE;\n            }\n            /**\n             * @param {Iterable<Chunk>} chunks list of chunks\n             * @returns {bigint | Chunk} key of the chunks\n             */\n\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n\n          var getKey = function getKey(chunks) {\n            var iterator = chunks[Symbol.iterator]();\n            var result = iterator.next();\n            if (result.done) return ZERO;\n            var first = result.value;\n            result = iterator.next();\n            if (result.done) return first;\n            var key = chunkIndexMap.get(first) | chunkIndexMap.get(result.value);\n\n            while (!(result = iterator.next()).done) {\n              var raw = chunkIndexMap.get(result.value);\n              key = key ^ raw;\n            }\n\n            return key;\n          };\n\n          var keyToString = function keyToString(key) {\n            if (typeof key === \"bigint\") return key.toString(16);\n            return chunkIndexMap.get(key).toString(16);\n          };\n\n          var getChunkSetsInGraph = memoize(function () {\n            /** @type {Map<bigint, Set<Chunk>>} */\n            var chunkSetsInGraph = new Map();\n            /** @type {Set<Chunk>} */\n\n            var singleChunkSets = new Set();\n\n            var _iterator9 = _createForOfIteratorHelper(compilation.modules),\n                _step9;\n\n            try {\n              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                var _module = _step9.value;\n\n                var _chunks = chunkGraph.getModuleChunksIterable(_module);\n\n                var chunksKey = getKey(_chunks);\n\n                if (typeof chunksKey === \"bigint\") {\n                  if (!chunkSetsInGraph.has(chunksKey)) {\n                    chunkSetsInGraph.set(chunksKey, new Set(_chunks));\n                  }\n                } else {\n                  singleChunkSets.add(chunksKey);\n                }\n              }\n            } catch (err) {\n              _iterator9.e(err);\n            } finally {\n              _iterator9.f();\n            }\n\n            return {\n              chunkSetsInGraph: chunkSetsInGraph,\n              singleChunkSets: singleChunkSets\n            };\n          });\n          /**\n           * @param {Module} module the module\n           * @returns {Iterable<Chunk[]>} groups of chunks with equal exports\n           */\n\n          var groupChunksByExports = function groupChunksByExports(module) {\n            var exportsInfo = moduleGraph.getExportsInfo(module);\n            var groupedByUsedExports = new Map();\n\n            var _iterator10 = _createForOfIteratorHelper(chunkGraph.getModuleChunksIterable(module)),\n                _step10;\n\n            try {\n              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                var chunk = _step10.value;\n                var key = exportsInfo.getUsageKey(chunk.runtime);\n                var list = groupedByUsedExports.get(key);\n\n                if (list !== undefined) {\n                  list.push(chunk);\n                } else {\n                  groupedByUsedExports.set(key, [chunk]);\n                }\n              }\n            } catch (err) {\n              _iterator10.e(err);\n            } finally {\n              _iterator10.f();\n            }\n\n            return groupedByUsedExports.values();\n          };\n          /** @type {Map<Module, Iterable<Chunk[]>>} */\n\n\n          var groupedByExportsMap = new Map();\n          var getExportsChunkSetsInGraph = memoize(function () {\n            /** @type {Map<bigint, Set<Chunk>>} */\n            var chunkSetsInGraph = new Map();\n            /** @type {Set<Chunk>} */\n\n            var singleChunkSets = new Set();\n\n            var _iterator11 = _createForOfIteratorHelper(compilation.modules),\n                _step11;\n\n            try {\n              for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                var _module2 = _step11.value;\n                var groupedChunks = Array.from(groupChunksByExports(_module2));\n                groupedByExportsMap.set(_module2, groupedChunks);\n\n                for (var _i8 = 0, _groupedChunks = groupedChunks; _i8 < _groupedChunks.length; _i8++) {\n                  var _chunks2 = _groupedChunks[_i8];\n\n                  if (_chunks2.length === 1) {\n                    singleChunkSets.add(_chunks2[0]);\n                  } else {\n                    var chunksKey =\n                    /** @type {bigint} */\n                    getKey(_chunks2);\n\n                    if (!chunkSetsInGraph.has(chunksKey)) {\n                      chunkSetsInGraph.set(chunksKey, new Set(_chunks2));\n                    }\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator11.e(err);\n            } finally {\n              _iterator11.f();\n            }\n\n            return {\n              chunkSetsInGraph: chunkSetsInGraph,\n              singleChunkSets: singleChunkSets\n            };\n          }); // group these set of chunks by count\n          // to allow to check less sets via isSubset\n          // (only smaller sets can be subset)\n\n          var groupChunkSetsByCount = function groupChunkSetsByCount(chunkSets) {\n            /** @type {Map<number, Array<Set<Chunk>>>} */\n            var chunkSetsByCount = new Map();\n\n            var _iterator12 = _createForOfIteratorHelper(chunkSets),\n                _step12;\n\n            try {\n              for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                var chunksSet = _step12.value;\n                var count = chunksSet.size;\n                var array = chunkSetsByCount.get(count);\n\n                if (array === undefined) {\n                  array = [];\n                  chunkSetsByCount.set(count, array);\n                }\n\n                array.push(chunksSet);\n              }\n            } catch (err) {\n              _iterator12.e(err);\n            } finally {\n              _iterator12.f();\n            }\n\n            return chunkSetsByCount;\n          };\n\n          var getChunkSetsByCount = memoize(function () {\n            return groupChunkSetsByCount(getChunkSetsInGraph().chunkSetsInGraph.values());\n          });\n          var getExportsChunkSetsByCount = memoize(function () {\n            return groupChunkSetsByCount(getExportsChunkSetsInGraph().chunkSetsInGraph.values());\n          }); // Create a list of possible combinations\n\n          var createGetCombinations = function createGetCombinations(chunkSets, singleChunkSets, chunkSetsByCount) {\n            /** @type {Map<bigint | Chunk, (Set<Chunk> | Chunk)[]>} */\n            var combinationsCache = new Map();\n            return function (key) {\n              var cacheEntry = combinationsCache.get(key);\n              if (cacheEntry !== undefined) return cacheEntry;\n\n              if (key instanceof Chunk) {\n                var result = [key];\n                combinationsCache.set(key, result);\n                return result;\n              }\n\n              var chunksSet = chunkSets.get(key);\n              /** @type {(Set<Chunk> | Chunk)[]} */\n\n              var array = [chunksSet];\n\n              var _iterator13 = _createForOfIteratorHelper(chunkSetsByCount),\n                  _step13;\n\n              try {\n                for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n                  var _step13$value = _slicedToArray(_step13.value, 2),\n                      count = _step13$value[0],\n                      setArray = _step13$value[1];\n\n                  // \"equal\" is not needed because they would have been merge in the first step\n                  if (count < chunksSet.size) {\n                    var _iterator15 = _createForOfIteratorHelper(setArray),\n                        _step15;\n\n                    try {\n                      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n                        var set = _step15.value;\n\n                        if (isSubset(chunksSet, set)) {\n                          array.push(set);\n                        }\n                      }\n                    } catch (err) {\n                      _iterator15.e(err);\n                    } finally {\n                      _iterator15.f();\n                    }\n                  }\n                }\n              } catch (err) {\n                _iterator13.e(err);\n              } finally {\n                _iterator13.f();\n              }\n\n              var _iterator14 = _createForOfIteratorHelper(singleChunkSets),\n                  _step14;\n\n              try {\n                for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n                  var chunk = _step14.value;\n\n                  if (chunksSet.has(chunk)) {\n                    array.push(chunk);\n                  }\n                }\n              } catch (err) {\n                _iterator14.e(err);\n              } finally {\n                _iterator14.f();\n              }\n\n              combinationsCache.set(key, array);\n              return array;\n            };\n          };\n\n          var getCombinationsFactory = memoize(function () {\n            var _getChunkSetsInGraph = getChunkSetsInGraph(),\n                chunkSetsInGraph = _getChunkSetsInGraph.chunkSetsInGraph,\n                singleChunkSets = _getChunkSetsInGraph.singleChunkSets;\n\n            return createGetCombinations(chunkSetsInGraph, singleChunkSets, getChunkSetsByCount());\n          });\n\n          var getCombinations = function getCombinations(key) {\n            return getCombinationsFactory()(key);\n          };\n\n          var getExportsCombinationsFactory = memoize(function () {\n            var _getExportsChunkSetsI = getExportsChunkSetsInGraph(),\n                chunkSetsInGraph = _getExportsChunkSetsI.chunkSetsInGraph,\n                singleChunkSets = _getExportsChunkSetsI.singleChunkSets;\n\n            return createGetCombinations(chunkSetsInGraph, singleChunkSets, getExportsChunkSetsByCount());\n          });\n\n          var getExportsCombinations = function getExportsCombinations(key) {\n            return getExportsCombinationsFactory()(key);\n          };\n          /**\n           * @typedef {Object} SelectedChunksResult\n           * @property {Chunk[]} chunks the list of chunks\n           * @property {bigint | Chunk} key a key of the list\n           */\n\n          /** @type {WeakMap<Set<Chunk> | Chunk, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n\n\n          var selectedChunksCacheByChunksSet = new WeakMap();\n          /**\n           * get list and key by applying the filter function to the list\n           * It is cached for performance reasons\n           * @param {Set<Chunk> | Chunk} chunks list of chunks\n           * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n           * @returns {SelectedChunksResult} list and key\n           */\n\n          var getSelectedChunks = function getSelectedChunks(chunks, chunkFilter) {\n            var entry = selectedChunksCacheByChunksSet.get(chunks);\n\n            if (entry === undefined) {\n              entry = new WeakMap();\n              selectedChunksCacheByChunksSet.set(chunks, entry);\n            }\n            /** @type {SelectedChunksResult} */\n\n\n            var entry2 = entry.get(chunkFilter);\n\n            if (entry2 === undefined) {\n              /** @type {Chunk[]} */\n              var selectedChunks = [];\n\n              if (chunks instanceof Chunk) {\n                if (chunkFilter(chunks)) selectedChunks.push(chunks);\n              } else {\n                var _iterator16 = _createForOfIteratorHelper(chunks),\n                    _step16;\n\n                try {\n                  for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n                    var chunk = _step16.value;\n                    if (chunkFilter(chunk)) selectedChunks.push(chunk);\n                  }\n                } catch (err) {\n                  _iterator16.e(err);\n                } finally {\n                  _iterator16.f();\n                }\n              }\n\n              entry2 = {\n                chunks: selectedChunks,\n                key: getKey(selectedChunks)\n              };\n              entry.set(chunkFilter, entry2);\n            }\n\n            return entry2;\n          };\n          /** @type {Map<string, boolean>} */\n\n\n          var alreadyValidatedParents = new Map();\n          /** @type {Set<string>} */\n\n          var alreadyReportedErrors = new Set(); // Map a list of chunks to a list of modules\n          // For the key the chunk \"index\" is used, the value is a SortableSet of modules\n\n          /** @type {Map<string, ChunksInfoItem>} */\n\n          var chunksInfoMap = new Map();\n          /**\n           * @param {CacheGroup} cacheGroup the current cache group\n           * @param {number} cacheGroupIndex the index of the cache group of ordering\n           * @param {Chunk[]} selectedChunks chunks selected for this module\n           * @param {bigint | Chunk} selectedChunksKey a key of selectedChunks\n           * @param {Module} module the current module\n           * @returns {void}\n           */\n\n          var addModuleToChunksInfoMap = function addModuleToChunksInfoMap(cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module) {\n            // Break if minimum number of chunks is not reached\n            if (selectedChunks.length < cacheGroup.minChunks) return; // Determine name for split chunk\n\n            var name = cacheGroup.getName(module, selectedChunks, cacheGroup.key); // Check if the name is ok\n\n            var existingChunk = compilation.namedChunks.get(name);\n\n            if (existingChunk) {\n              var parentValidationKey = \"\".concat(name, \"|\").concat(typeof selectedChunksKey === \"bigint\" ? selectedChunksKey : selectedChunksKey.debugId);\n              var valid = alreadyValidatedParents.get(parentValidationKey);\n              if (valid === false) return;\n\n              if (valid === undefined) {\n                // Module can only be moved into the existing chunk if the existing chunk\n                // is a parent of all selected chunks\n                var isInAllParents = true;\n                /** @type {Set<ChunkGroup>} */\n\n                var queue = new Set();\n\n                var _iterator17 = _createForOfIteratorHelper(selectedChunks),\n                    _step17;\n\n                try {\n                  for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n                    var chunk = _step17.value;\n\n                    var _iterator19 = _createForOfIteratorHelper(chunk.groupsIterable),\n                        _step19;\n\n                    try {\n                      for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                        var group = _step19.value;\n                        queue.add(group);\n                      }\n                    } catch (err) {\n                      _iterator19.e(err);\n                    } finally {\n                      _iterator19.f();\n                    }\n                  }\n                } catch (err) {\n                  _iterator17.e(err);\n                } finally {\n                  _iterator17.f();\n                }\n\n                var _iterator18 = _createForOfIteratorHelper(queue),\n                    _step18;\n\n                try {\n                  for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n                    var _group = _step18.value;\n                    if (existingChunk.isInGroup(_group)) continue;\n                    var hasParent = false;\n\n                    var _iterator20 = _createForOfIteratorHelper(_group.parentsIterable),\n                        _step20;\n\n                    try {\n                      for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n                        var parent = _step20.value;\n                        hasParent = true;\n                        queue.add(parent);\n                      }\n                    } catch (err) {\n                      _iterator20.e(err);\n                    } finally {\n                      _iterator20.f();\n                    }\n\n                    if (!hasParent) {\n                      isInAllParents = false;\n                    }\n                  }\n                } catch (err) {\n                  _iterator18.e(err);\n                } finally {\n                  _iterator18.f();\n                }\n\n                var _valid = isInAllParents;\n                alreadyValidatedParents.set(parentValidationKey, _valid);\n\n                if (!_valid) {\n                  if (!alreadyReportedErrors.has(name)) {\n                    alreadyReportedErrors.add(name);\n                    compilation.errors.push(new WebpackError(\"SplitChunksPlugin\\n\" + \"Cache group \\\"\".concat(cacheGroup.key, \"\\\" conflicts with existing chunk.\\n\") + \"Both have the same name \\\"\".concat(name, \"\\\" and existing chunk is not a parent of the selected modules.\\n\") + \"Use a different name for the cache group or make sure that the existing chunk is a parent (e. g. via dependOn).\\n\" + 'HINT: You can omit \"name\" to automatically create a name.\\n' + \"BREAKING CHANGE: webpack < 5 used to allow to use an entrypoint as splitChunk. \" + \"This is no longer allowed when the entrypoint is not a parent of the selected modules.\\n\" + \"Remove this entrypoint and add modules to cache group's 'test' instead. \" + \"If you need modules to be evaluated on startup, add them to the existing entrypoints (make them arrays). \" + \"See migration guide of more info.\"));\n                  }\n\n                  return;\n                }\n              }\n            } // Create key for maps\n            // When it has a name we use the name as key\n            // Otherwise we create the key from chunks and cache group key\n            // This automatically merges equal names\n\n\n            var key = cacheGroup.key + (name ? \" name:\".concat(name) : \" chunks:\".concat(keyToString(selectedChunksKey))); // Add module to maps\n\n            var info = chunksInfoMap.get(key);\n\n            if (info === undefined) {\n              chunksInfoMap.set(key, info = {\n                modules: new SortableSet(undefined, compareModulesByIdentifier),\n                cacheGroup: cacheGroup,\n                cacheGroupIndex: cacheGroupIndex,\n                name: name,\n                sizes: {},\n                chunks: new Set(),\n                reuseableChunks: new Set(),\n                chunksKeys: new Set()\n              });\n            }\n\n            var oldSize = info.modules.size;\n            info.modules.add(module);\n\n            if (info.modules.size !== oldSize) {\n              var _iterator21 = _createForOfIteratorHelper(module.getSourceTypes()),\n                  _step21;\n\n              try {\n                for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n                  var type = _step21.value;\n                  info.sizes[type] = (info.sizes[type] || 0) + module.size(type);\n                }\n              } catch (err) {\n                _iterator21.e(err);\n              } finally {\n                _iterator21.f();\n              }\n            }\n\n            var oldChunksKeysSize = info.chunksKeys.size;\n            info.chunksKeys.add(selectedChunksKey);\n\n            if (oldChunksKeysSize !== info.chunksKeys.size) {\n              var _iterator22 = _createForOfIteratorHelper(selectedChunks),\n                  _step22;\n\n              try {\n                for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n                  var _chunk = _step22.value;\n                  info.chunks.add(_chunk);\n                }\n              } catch (err) {\n                _iterator22.e(err);\n              } finally {\n                _iterator22.f();\n              }\n            }\n          };\n\n          var context = {\n            moduleGraph: moduleGraph,\n            chunkGraph: chunkGraph\n          };\n          logger.timeEnd(\"prepare\");\n          logger.time(\"modules\"); // Walk through all modules\n\n          var _iterator23 = _createForOfIteratorHelper(compilation.modules),\n              _step23;\n\n          try {\n            var _loop4 = function _loop4() {\n              var module = _step23.value;\n\n              // Get cache group\n              var cacheGroups = _this.options.getCacheGroups(module, context);\n\n              if (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n                return \"continue\";\n              } // Prepare some values (usedExports = false)\n\n\n              var getCombs = memoize(function () {\n                var chunks = chunkGraph.getModuleChunksIterable(module);\n                var chunksKey = getKey(chunks);\n                return getCombinations(chunksKey);\n              }); // Prepare some values (usedExports = true)\n\n              var getCombsByUsedExports = memoize(function () {\n                // fill the groupedByExportsMap\n                getExportsChunkSetsInGraph();\n                /** @type {Set<Set<Chunk> | Chunk>} */\n\n                var set = new Set();\n                var groupedByUsedExports = groupedByExportsMap.get(module);\n\n                var _iterator46 = _createForOfIteratorHelper(groupedByUsedExports),\n                    _step46;\n\n                try {\n                  for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {\n                    var _chunks3 = _step46.value;\n                    var chunksKey = getKey(_chunks3);\n\n                    var _iterator47 = _createForOfIteratorHelper(getExportsCombinations(chunksKey)),\n                        _step47;\n\n                    try {\n                      for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {\n                        var comb = _step47.value;\n                        set.add(comb);\n                      }\n                    } catch (err) {\n                      _iterator47.e(err);\n                    } finally {\n                      _iterator47.f();\n                    }\n                  }\n                } catch (err) {\n                  _iterator46.e(err);\n                } finally {\n                  _iterator46.f();\n                }\n\n                return set;\n              });\n              var cacheGroupIndex = 0;\n\n              var _iterator48 = _createForOfIteratorHelper(cacheGroups),\n                  _step48;\n\n              try {\n                for (_iterator48.s(); !(_step48 = _iterator48.n()).done;) {\n                  var cacheGroupSource = _step48.value;\n\n                  var cacheGroup = _this._getCacheGroup(cacheGroupSource);\n\n                  var combs = cacheGroup.usedExports ? getCombsByUsedExports() : getCombs(); // For all combination of chunk selection\n\n                  var _iterator49 = _createForOfIteratorHelper(combs),\n                      _step49;\n\n                  try {\n                    for (_iterator49.s(); !(_step49 = _iterator49.n()).done;) {\n                      var chunkCombination = _step49.value;\n                      // Break if minimum number of chunks is not reached\n                      var count = chunkCombination instanceof Chunk ? 1 : chunkCombination.size;\n                      if (count < cacheGroup.minChunks) continue; // Select chunks by configuration\n\n                      var _getSelectedChunks = getSelectedChunks(chunkCombination, cacheGroup.chunksFilter),\n                          selectedChunks = _getSelectedChunks.chunks,\n                          selectedChunksKey = _getSelectedChunks.key;\n\n                      addModuleToChunksInfoMap(cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module);\n                    }\n                  } catch (err) {\n                    _iterator49.e(err);\n                  } finally {\n                    _iterator49.f();\n                  }\n\n                  cacheGroupIndex++;\n                }\n              } catch (err) {\n                _iterator48.e(err);\n              } finally {\n                _iterator48.f();\n              }\n            };\n\n            for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n              var _ret3 = _loop4();\n\n              if (_ret3 === \"continue\") continue;\n            }\n          } catch (err) {\n            _iterator23.e(err);\n          } finally {\n            _iterator23.f();\n          }\n\n          logger.timeEnd(\"modules\");\n          logger.time(\"queue\");\n          /**\n           * @param {ChunksInfoItem} info entry\n           * @param {string[]} sourceTypes source types to be removed\n           */\n\n          var removeModulesWithSourceType = function removeModulesWithSourceType(info, sourceTypes) {\n            var _iterator24 = _createForOfIteratorHelper(info.modules),\n                _step24;\n\n            try {\n              var _loop2 = function _loop2() {\n                var module = _step24.value;\n                var types = module.getSourceTypes();\n\n                if (sourceTypes.some(function (type) {\n                  return types.has(type);\n                })) {\n                  info.modules.delete(module);\n\n                  var _iterator25 = _createForOfIteratorHelper(types),\n                      _step25;\n\n                  try {\n                    for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n                      var type = _step25.value;\n                      info.sizes[type] -= module.size(type);\n                    }\n                  } catch (err) {\n                    _iterator25.e(err);\n                  } finally {\n                    _iterator25.f();\n                  }\n                }\n              };\n\n              for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n                _loop2();\n              }\n            } catch (err) {\n              _iterator24.e(err);\n            } finally {\n              _iterator24.f();\n            }\n          };\n          /**\n           * @param {ChunksInfoItem} info entry\n           * @returns {boolean} true, if entry become empty\n           */\n\n\n          var removeMinSizeViolatingModules = function removeMinSizeViolatingModules(info) {\n            if (!info.cacheGroup._validateSize) return false;\n            var violatingSizes = getViolatingMinSizes(info.sizes, info.cacheGroup.minSize);\n            if (violatingSizes === undefined) return false;\n            removeModulesWithSourceType(info, violatingSizes);\n            return info.modules.size === 0;\n          }; // Filter items were size < minSize\n\n\n          var _iterator26 = _createForOfIteratorHelper(chunksInfoMap),\n              _step26;\n\n          try {\n            for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n              var _step26$value = _slicedToArray(_step26.value, 2),\n                  _key7 = _step26$value[0],\n                  _info2 = _step26$value[1];\n\n              if (removeMinSizeViolatingModules(_info2)) {\n                chunksInfoMap.delete(_key7);\n              } else if (!checkMinSizeReduction(_info2.sizes, _info2.cacheGroup.minSizeReduction, _info2.chunks.size)) {\n                chunksInfoMap.delete(_key7);\n              }\n            }\n            /**\n             * @typedef {Object} MaxSizeQueueItem\n             * @property {SplitChunksSizes} minSize\n             * @property {SplitChunksSizes} maxAsyncSize\n             * @property {SplitChunksSizes} maxInitialSize\n             * @property {string} automaticNameDelimiter\n             * @property {string[]} keys\n             */\n\n            /** @type {Map<Chunk, MaxSizeQueueItem>} */\n\n          } catch (err) {\n            _iterator26.e(err);\n          } finally {\n            _iterator26.f();\n          }\n\n          var maxSizeQueueMap = new Map();\n\n          while (chunksInfoMap.size > 0) {\n            // Find best matching entry\n            var bestEntryKey = void 0;\n            var bestEntry = void 0;\n\n            var _iterator27 = _createForOfIteratorHelper(chunksInfoMap),\n                _step27;\n\n            try {\n              for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n                var pair = _step27.value;\n                var key = pair[0];\n                var info = pair[1];\n\n                if (bestEntry === undefined || compareEntries(bestEntry, info) < 0) {\n                  bestEntry = info;\n                  bestEntryKey = key;\n                }\n              }\n            } catch (err) {\n              _iterator27.e(err);\n            } finally {\n              _iterator27.f();\n            }\n\n            var item = bestEntry;\n            chunksInfoMap.delete(bestEntryKey);\n            var chunkName = item.name; // Variable for the new chunk (lazy created)\n\n            /** @type {Chunk} */\n\n            var newChunk = void 0; // When no chunk name, check if we can reuse a chunk instead of creating a new one\n\n            var isExistingChunk = false;\n            var isReusedWithAllModules = false;\n\n            if (chunkName) {\n              var chunkByName = compilation.namedChunks.get(chunkName);\n\n              if (chunkByName !== undefined) {\n                newChunk = chunkByName;\n                var oldSize = item.chunks.size;\n                item.chunks.delete(newChunk);\n                isExistingChunk = item.chunks.size !== oldSize;\n              }\n            } else if (item.cacheGroup.reuseExistingChunk) {\n              var _iterator28 = _createForOfIteratorHelper(item.chunks),\n                  _step28;\n\n              try {\n                outer: for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n                  var chunk = _step28.value;\n\n                  if (chunkGraph.getNumberOfChunkModules(chunk) !== item.modules.size) {\n                    continue;\n                  }\n\n                  if (item.chunks.size > 1 && chunkGraph.getNumberOfEntryModules(chunk) > 0) {\n                    continue;\n                  }\n\n                  var _iterator29 = _createForOfIteratorHelper(item.modules),\n                      _step29;\n\n                  try {\n                    for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n                      var _module3 = _step29.value;\n\n                      if (!chunkGraph.isModuleInChunk(_module3, chunk)) {\n                        continue outer;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator29.e(err);\n                  } finally {\n                    _iterator29.f();\n                  }\n\n                  if (!newChunk || !newChunk.name) {\n                    newChunk = chunk;\n                  } else if (chunk.name && chunk.name.length < newChunk.name.length) {\n                    newChunk = chunk;\n                  } else if (chunk.name && chunk.name.length === newChunk.name.length && chunk.name < newChunk.name) {\n                    newChunk = chunk;\n                  }\n                }\n              } catch (err) {\n                _iterator28.e(err);\n              } finally {\n                _iterator28.f();\n              }\n\n              if (newChunk) {\n                item.chunks.delete(newChunk);\n                chunkName = undefined;\n                isExistingChunk = true;\n                isReusedWithAllModules = true;\n              }\n            }\n\n            var enforced = item.cacheGroup._conditionalEnforce && checkMinSize(item.sizes, item.cacheGroup.enforceSizeThreshold);\n            var usedChunks = new Set(item.chunks); // Check if maxRequests condition can be fulfilled\n\n            if (!enforced && (Number.isFinite(item.cacheGroup.maxInitialRequests) || Number.isFinite(item.cacheGroup.maxAsyncRequests))) {\n              var _iterator30 = _createForOfIteratorHelper(usedChunks),\n                  _step30;\n\n              try {\n                for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n                  var _chunk2 = _step30.value;\n                  // respect max requests\n                  var maxRequests = _chunk2.isOnlyInitial() ? item.cacheGroup.maxInitialRequests : _chunk2.canBeInitial() ? Math.min(item.cacheGroup.maxInitialRequests, item.cacheGroup.maxAsyncRequests) : item.cacheGroup.maxAsyncRequests;\n\n                  if (isFinite(maxRequests) && getRequests(_chunk2) >= maxRequests) {\n                    usedChunks.delete(_chunk2);\n                  }\n                }\n              } catch (err) {\n                _iterator30.e(err);\n              } finally {\n                _iterator30.f();\n              }\n            }\n\n            var _iterator31 = _createForOfIteratorHelper(usedChunks),\n                _step31;\n\n            try {\n              outer: for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n                var _chunk6 = _step31.value;\n\n                var _iterator41 = _createForOfIteratorHelper(item.modules),\n                    _step41;\n\n                try {\n                  for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {\n                    var _module8 = _step41.value;\n                    if (chunkGraph.isModuleInChunk(_module8, _chunk6)) continue outer;\n                  }\n                } catch (err) {\n                  _iterator41.e(err);\n                } finally {\n                  _iterator41.f();\n                }\n\n                usedChunks.delete(_chunk6);\n              }\n            } catch (err) {\n              _iterator31.e(err);\n            } finally {\n              _iterator31.f();\n            } // Were some (invalid) chunks removed from usedChunks?\n            // => readd all modules to the queue, as things could have been changed\n\n\n            if (usedChunks.size < item.chunks.size) {\n              if (isExistingChunk) usedChunks.add(newChunk);\n\n              if (usedChunks.size >= item.cacheGroup.minChunks) {\n                var chunksArr = Array.from(usedChunks);\n\n                var _iterator32 = _createForOfIteratorHelper(item.modules),\n                    _step32;\n\n                try {\n                  for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n                    var _module4 = _step32.value;\n                    addModuleToChunksInfoMap(item.cacheGroup, item.cacheGroupIndex, chunksArr, getKey(usedChunks), _module4);\n                  }\n                } catch (err) {\n                  _iterator32.e(err);\n                } finally {\n                  _iterator32.f();\n                }\n              }\n\n              continue;\n            } // Validate minRemainingSize constraint when a single chunk is left over\n\n\n            if (!enforced && item.cacheGroup._validateRemainingSize && usedChunks.size === 1) {\n              var _usedChunks = _slicedToArray(usedChunks, 1),\n                  _chunk3 = _usedChunks[0];\n\n              var chunkSizes = Object.create(null);\n\n              var _iterator33 = _createForOfIteratorHelper(chunkGraph.getChunkModulesIterable(_chunk3)),\n                  _step33;\n\n              try {\n                for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n                  var _module5 = _step33.value;\n\n                  if (!item.modules.has(_module5)) {\n                    var _iterator34 = _createForOfIteratorHelper(_module5.getSourceTypes()),\n                        _step34;\n\n                    try {\n                      for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n                        var type = _step34.value;\n                        chunkSizes[type] = (chunkSizes[type] || 0) + _module5.size(type);\n                      }\n                    } catch (err) {\n                      _iterator34.e(err);\n                    } finally {\n                      _iterator34.f();\n                    }\n                  }\n                }\n              } catch (err) {\n                _iterator33.e(err);\n              } finally {\n                _iterator33.f();\n              }\n\n              var violatingSizes = getViolatingMinSizes(chunkSizes, item.cacheGroup.minRemainingSize);\n\n              if (violatingSizes !== undefined) {\n                var oldModulesSize = item.modules.size;\n                removeModulesWithSourceType(item, violatingSizes);\n\n                if (item.modules.size > 0 && item.modules.size !== oldModulesSize) {\n                  // queue this item again to be processed again\n                  // without violating modules\n                  chunksInfoMap.set(bestEntryKey, item);\n                }\n\n                continue;\n              }\n            } // Create the new chunk if not reusing one\n\n\n            if (newChunk === undefined) {\n              newChunk = compilation.addChunk(chunkName);\n            } // Walk through all chunks\n\n\n            var _iterator35 = _createForOfIteratorHelper(usedChunks),\n                _step35;\n\n            try {\n              for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {\n                var _chunk7 = _step35.value;\n\n                // Add graph connections for splitted chunk\n                _chunk7.split(newChunk);\n              } // Add a note to the chunk\n\n            } catch (err) {\n              _iterator35.e(err);\n            } finally {\n              _iterator35.f();\n            }\n\n            newChunk.chunkReason = (newChunk.chunkReason ? newChunk.chunkReason + \", \" : \"\") + (isReusedWithAllModules ? \"reused as split chunk\" : \"split chunk\");\n\n            if (item.cacheGroup.key) {\n              newChunk.chunkReason += \" (cache group: \".concat(item.cacheGroup.key, \")\");\n            }\n\n            if (chunkName) {\n              newChunk.chunkReason += \" (name: \".concat(chunkName, \")\");\n            }\n\n            if (item.cacheGroup.filename) {\n              newChunk.filenameTemplate = item.cacheGroup.filename;\n            }\n\n            if (item.cacheGroup.idHint) {\n              newChunk.idNameHints.add(item.cacheGroup.idHint);\n            }\n\n            if (!isReusedWithAllModules) {\n              // Add all modules to the new chunk\n              var _iterator36 = _createForOfIteratorHelper(item.modules),\n                  _step36;\n\n              try {\n                for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {\n                  var _module6 = _step36.value;\n                  if (!_module6.chunkCondition(newChunk, compilation)) continue; // Add module to new chunk\n\n                  chunkGraph.connectChunkAndModule(newChunk, _module6); // Remove module from used chunks\n\n                  var _iterator37 = _createForOfIteratorHelper(usedChunks),\n                      _step37;\n\n                  try {\n                    for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {\n                      var _chunk4 = _step37.value;\n                      chunkGraph.disconnectChunkAndModule(_chunk4, _module6);\n                    }\n                  } catch (err) {\n                    _iterator37.e(err);\n                  } finally {\n                    _iterator37.f();\n                  }\n                }\n              } catch (err) {\n                _iterator36.e(err);\n              } finally {\n                _iterator36.f();\n              }\n            } else {\n              // Remove all modules from used chunks\n              var _iterator38 = _createForOfIteratorHelper(item.modules),\n                  _step38;\n\n              try {\n                for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {\n                  var _module7 = _step38.value;\n\n                  var _iterator39 = _createForOfIteratorHelper(usedChunks),\n                      _step39;\n\n                  try {\n                    for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {\n                      var _chunk5 = _step39.value;\n                      chunkGraph.disconnectChunkAndModule(_chunk5, _module7);\n                    }\n                  } catch (err) {\n                    _iterator39.e(err);\n                  } finally {\n                    _iterator39.f();\n                  }\n                }\n              } catch (err) {\n                _iterator38.e(err);\n              } finally {\n                _iterator38.f();\n              }\n            }\n\n            if (Object.keys(item.cacheGroup.maxAsyncSize).length > 0 || Object.keys(item.cacheGroup.maxInitialSize).length > 0) {\n              var oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n              maxSizeQueueMap.set(newChunk, {\n                minSize: oldMaxSizeSettings ? combineSizes(oldMaxSizeSettings.minSize, item.cacheGroup._minSizeForMaxSize, Math.max) : item.cacheGroup.minSize,\n                maxAsyncSize: oldMaxSizeSettings ? combineSizes(oldMaxSizeSettings.maxAsyncSize, item.cacheGroup.maxAsyncSize, Math.min) : item.cacheGroup.maxAsyncSize,\n                maxInitialSize: oldMaxSizeSettings ? combineSizes(oldMaxSizeSettings.maxInitialSize, item.cacheGroup.maxInitialSize, Math.min) : item.cacheGroup.maxInitialSize,\n                automaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n                keys: oldMaxSizeSettings ? oldMaxSizeSettings.keys.concat(item.cacheGroup.key) : [item.cacheGroup.key]\n              });\n            } // remove all modules from other entries and update size\n\n\n            var _iterator40 = _createForOfIteratorHelper(chunksInfoMap),\n                _step40;\n\n            try {\n              for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {\n                var _step40$value = _slicedToArray(_step40.value, 2),\n                    _key2 = _step40$value[0],\n                    _info = _step40$value[1];\n\n                if (isOverlap(_info.chunks, usedChunks)) {\n                  // update modules and total size\n                  // may remove it from the map when < minSize\n                  var updated = false;\n\n                  var _iterator42 = _createForOfIteratorHelper(item.modules),\n                      _step42;\n\n                  try {\n                    for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {\n                      var _module9 = _step42.value;\n\n                      if (_info.modules.has(_module9)) {\n                        // remove module\n                        _info.modules.delete(_module9); // update size\n\n\n                        var _iterator43 = _createForOfIteratorHelper(_module9.getSourceTypes()),\n                            _step43;\n\n                        try {\n                          for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {\n                            var _key3 = _step43.value;\n                            _info.sizes[_key3] -= _module9.size(_key3);\n                          }\n                        } catch (err) {\n                          _iterator43.e(err);\n                        } finally {\n                          _iterator43.f();\n                        }\n\n                        updated = true;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator42.e(err);\n                  } finally {\n                    _iterator42.f();\n                  }\n\n                  if (updated) {\n                    if (_info.modules.size === 0) {\n                      chunksInfoMap.delete(_key2);\n                      continue;\n                    }\n\n                    if (removeMinSizeViolatingModules(_info) || !checkMinSizeReduction(_info.sizes, _info.cacheGroup.minSizeReduction, _info.chunks.size)) {\n                      chunksInfoMap.delete(_key2);\n                      continue;\n                    }\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator40.e(err);\n            } finally {\n              _iterator40.f();\n            }\n          }\n\n          logger.timeEnd(\"queue\");\n          logger.time(\"maxSize\");\n          /** @type {Set<string>} */\n\n          var incorrectMinMaxSizeSet = new Set();\n          var outputOptions = compilation.outputOptions; // Make sure that maxSize is fulfilled\n\n          var fallbackCacheGroup = _this.options.fallbackCacheGroup;\n\n          var _loop3 = function _loop3() {\n            var chunk = _Array$from[_i9];\n            var chunkConfig = maxSizeQueueMap.get(chunk);\n\n            var _ref = chunkConfig || fallbackCacheGroup,\n                minSize = _ref.minSize,\n                maxAsyncSize = _ref.maxAsyncSize,\n                maxInitialSize = _ref.maxInitialSize,\n                automaticNameDelimiter = _ref.automaticNameDelimiter;\n\n            if (!chunkConfig && !fallbackCacheGroup.chunksFilter(chunk)) return \"continue\";\n            /** @type {SplitChunksSizes} */\n\n            var maxSize = void 0;\n\n            if (chunk.isOnlyInitial()) {\n              maxSize = maxInitialSize;\n            } else if (chunk.canBeInitial()) {\n              maxSize = combineSizes(maxAsyncSize, maxInitialSize, Math.min);\n            } else {\n              maxSize = maxAsyncSize;\n            }\n\n            if (Object.keys(maxSize).length === 0) {\n              return \"continue\";\n            }\n\n            for (var _i10 = 0, _Object$keys8 = Object.keys(maxSize); _i10 < _Object$keys8.length; _i10++) {\n              var _key4 = _Object$keys8[_i10];\n              var maxSizeValue = maxSize[_key4];\n              var minSizeValue = minSize[_key4];\n\n              if (typeof minSizeValue === \"number\" && minSizeValue > maxSizeValue) {\n                var keys = chunkConfig && chunkConfig.keys;\n                var warningKey = \"\".concat(keys && keys.join(), \" \").concat(minSizeValue, \" \").concat(maxSizeValue);\n\n                if (!incorrectMinMaxSizeSet.has(warningKey)) {\n                  incorrectMinMaxSizeSet.add(warningKey);\n                  compilation.warnings.push(new MinMaxSizeWarning(keys, minSizeValue, maxSizeValue));\n                }\n              }\n            }\n\n            var results = deterministicGroupingForModules({\n              minSize: minSize,\n              maxSize: mapObject(maxSize, function (value, key) {\n                var minSizeValue = minSize[key];\n                return typeof minSizeValue === \"number\" ? Math.max(value, minSizeValue) : value;\n              }),\n              items: chunkGraph.getChunkModulesIterable(chunk),\n              getKey: function getKey(module) {\n                var cache = getKeyCache.get(module);\n                if (cache !== undefined) return cache;\n                var ident = cachedMakePathsRelative(module.identifier());\n                var nameForCondition = module.nameForCondition && module.nameForCondition();\n                var name = nameForCondition ? cachedMakePathsRelative(nameForCondition) : ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n                var fullKey = name + automaticNameDelimiter + hashFilename(ident, outputOptions);\n                var key = requestToId(fullKey);\n                getKeyCache.set(module, key);\n                return key;\n              },\n              getSize: function getSize(module) {\n                var size = Object.create(null);\n\n                var _iterator44 = _createForOfIteratorHelper(module.getSourceTypes()),\n                    _step44;\n\n                try {\n                  for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {\n                    var _key5 = _step44.value;\n                    size[_key5] = module.size(_key5);\n                  }\n                } catch (err) {\n                  _iterator44.e(err);\n                } finally {\n                  _iterator44.f();\n                }\n\n                return size;\n              }\n            });\n\n            if (results.length <= 1) {\n              return \"continue\";\n            }\n\n            for (var i = 0; i < results.length; i++) {\n              var group = results[i];\n\n              var _key6 = _this.options.hidePathInfo ? hashFilename(group.key, outputOptions) : group.key;\n\n              var name = chunk.name ? chunk.name + automaticNameDelimiter + _key6 : null;\n\n              if (name && name.length > 100) {\n                name = name.slice(0, 100) + automaticNameDelimiter + hashFilename(name, outputOptions);\n              }\n\n              if (i !== results.length - 1) {\n                var newPart = compilation.addChunk(name);\n                chunk.split(newPart);\n                newPart.chunkReason = chunk.chunkReason; // Add all modules to the new chunk\n\n                var _iterator45 = _createForOfIteratorHelper(group.items),\n                    _step45;\n\n                try {\n                  for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {\n                    var _module10 = _step45.value;\n\n                    if (!_module10.chunkCondition(newPart, compilation)) {\n                      continue;\n                    } // Add module to new chunk\n\n\n                    chunkGraph.connectChunkAndModule(newPart, _module10); // Remove module from used chunks\n\n                    chunkGraph.disconnectChunkAndModule(chunk, _module10);\n                  }\n                } catch (err) {\n                  _iterator45.e(err);\n                } finally {\n                  _iterator45.f();\n                }\n              } else {\n                // change the chunk to be a part\n                chunk.name = name;\n              }\n            }\n          };\n\n          for (var _i9 = 0, _Array$from = Array.from(compilation.chunks); _i9 < _Array$from.length; _i9++) {\n            var _ret2 = _loop3();\n\n            if (_ret2 === \"continue\") continue;\n          }\n\n          logger.timeEnd(\"maxSize\");\n        });\n      });\n    }\n  }]);\n\n  return SplitChunksPlugin;\n}();","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/optimize/SplitChunksPlugin.js"],"names":["Chunk","require","STAGE_ADVANCED","WebpackError","requestToId","isSubset","SortableSet","compareModulesByIdentifier","compareIterables","createHash","deterministicGrouping","makePathsRelative","memoize","MinMaxSizeWarning","defaultGetName","deterministicGroupingForModules","getKeyCache","WeakMap","hashFilename","name","outputOptions","digest","hashFunction","update","hashDigest","slice","getRequests","chunk","requests","groupsIterable","chunkGroup","Math","max","chunks","length","mapObject","obj","fn","newObj","Object","create","keys","key","isOverlap","a","b","item","has","compareModuleIterables","compareEntries","diffPriority","cacheGroup","priority","diffCount","size","aSizeReduce","totalSize","sizes","bSizeReduce","diffSizeReduce","indexDiff","cacheGroupIndex","modulesA","modules","modulesB","diff","sort","INITIAL_CHUNK_FILTER","canBeInitial","ASYNC_CHUNK_FILTER","ALL_CHUNK_FILTER","normalizeSizes","value","defaultSizeTypes","o","sizeType","mergeSizes","merged","i","assign","hasNonZeroSizes","combineSizes","combine","aKeys","Set","bKeys","result","checkMinSize","minSize","undefined","checkMinSizeReduction","minSizeReduction","chunkCount","getViolatingMinSizes","list","push","normalizeName","normalizeChunksFilter","normalizeCacheGroups","cacheGroups","handlers","option","RegExp","source","createCacheGroupSource","module","context","results","checkTest","cache","groups","Array","isArray","group","cachedSource","get","set","test","checkModuleType","type","checkModuleLayer","layer","nameForCondition","startsWith","options","maxSize","getName","chunksFilter","enforce","minRemainingSize","enforceSizeThreshold","maxAsyncSize","maxInitialSize","minChunks","maxAsyncRequests","maxInitialRequests","filename","idHint","automaticNameDelimiter","reuseExistingChunk","usedExports","exports","fallbackCacheGroup","hidePathInfo","getCacheGroups","_cacheGroupCache","cacheGroupSource","cacheEntry","Infinity","_validateSize","_validateRemainingSize","_minSizeForMaxSize","_conditionalEnforce","compiler","cachedMakePathsRelative","bindContextCache","root","hooks","thisCompilation","tap","compilation","logger","getLogger","alreadyOptimized","unseal","optimizeChunks","stage","time","chunkGraph","moduleGraph","chunkIndexMap","Map","ZERO","BigInt","ONE","START","index","random","getKey","iterator","Symbol","next","done","first","raw","keyToString","toString","getChunkSetsInGraph","chunkSetsInGraph","singleChunkSets","getModuleChunksIterable","chunksKey","add","groupChunksByExports","exportsInfo","getExportsInfo","groupedByUsedExports","getUsageKey","runtime","values","groupedByExportsMap","getExportsChunkSetsInGraph","groupedChunks","from","groupChunkSetsByCount","chunkSets","chunkSetsByCount","chunksSet","count","array","getChunkSetsByCount","getExportsChunkSetsByCount","createGetCombinations","combinationsCache","setArray","getCombinationsFactory","getCombinations","getExportsCombinationsFactory","getExportsCombinations","selectedChunksCacheByChunksSet","getSelectedChunks","chunkFilter","entry","entry2","selectedChunks","alreadyValidatedParents","alreadyReportedErrors","chunksInfoMap","addModuleToChunksInfoMap","selectedChunksKey","existingChunk","namedChunks","parentValidationKey","debugId","valid","isInAllParents","queue","isInGroup","hasParent","parentsIterable","parent","errors","info","reuseableChunks","chunksKeys","oldSize","getSourceTypes","oldChunksKeysSize","timeEnd","getCombs","getCombsByUsedExports","comb","_getCacheGroup","combs","chunkCombination","removeModulesWithSourceType","sourceTypes","types","some","delete","removeMinSizeViolatingModules","violatingSizes","maxSizeQueueMap","bestEntryKey","bestEntry","pair","chunkName","newChunk","isExistingChunk","isReusedWithAllModules","chunkByName","outer","getNumberOfChunkModules","getNumberOfEntryModules","isModuleInChunk","enforced","usedChunks","Number","isFinite","maxRequests","isOnlyInitial","min","chunksArr","chunkSizes","getChunkModulesIterable","oldModulesSize","addChunk","split","chunkReason","filenameTemplate","idNameHints","chunkCondition","connectChunkAndModule","disconnectChunkAndModule","oldMaxSizeSettings","concat","updated","incorrectMinMaxSizeSet","chunkConfig","maxSizeValue","minSizeValue","warningKey","join","warnings","items","ident","identifier","replace","fullKey","getSize","newPart"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Chunk = require(\"../Chunk\");\nconst { STAGE_ADVANCED } = require(\"../OptimizationStages\");\nconst WebpackError = require(\"../WebpackError\");\nconst { requestToId } = require(\"../ids/IdHelpers\");\nconst { isSubset } = require(\"../util/SetHelpers\");\nconst SortableSet = require(\"../util/SortableSet\");\nconst {\n\tcompareModulesByIdentifier,\n\tcompareIterables\n} = require(\"../util/comparators\");\nconst createHash = require(\"../util/createHash\");\nconst deterministicGrouping = require(\"../util/deterministicGrouping\");\nconst { makePathsRelative } = require(\"../util/identifier\");\nconst memoize = require(\"../util/memoize\");\nconst MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksCacheGroup} OptimizationSplitChunksCacheGroup */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksGetCacheGroups} OptimizationSplitChunksGetCacheGroups */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksOptions} OptimizationSplitChunksOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksSizes} OptimizationSplitChunksSizes */\n/** @typedef {import(\"../../declarations/WebpackOptions\").Output} OutputOptions */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compilation\").PathData} PathData */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n\n/** @typedef {Record<string, number>} SplitChunksSizes */\n\n/**\n * @callback ChunkFilterFunction\n * @param {Chunk} chunk\n * @returns {boolean}\n */\n\n/**\n * @callback CombineSizeFunction\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\n\n/**\n * @typedef {Object} CacheGroupSource\n * @property {string=} key\n * @property {number=} priority\n * @property {GetName=} getName\n * @property {ChunkFilterFunction=} chunksFilter\n * @property {boolean=} enforce\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {number=} minChunks\n * @property {number=} maxAsyncRequests\n * @property {number=} maxInitialRequests\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\n * @property {string=} idHint\n * @property {string} automaticNameDelimiter\n * @property {boolean=} reuseExistingChunk\n * @property {boolean=} usedExports\n */\n\n/**\n * @typedef {Object} CacheGroup\n * @property {string} key\n * @property {number=} priority\n * @property {GetName=} getName\n * @property {ChunkFilterFunction=} chunksFilter\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {number=} minChunks\n * @property {number=} maxAsyncRequests\n * @property {number=} maxInitialRequests\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\n * @property {string=} idHint\n * @property {string} automaticNameDelimiter\n * @property {boolean} reuseExistingChunk\n * @property {boolean} usedExports\n * @property {boolean} _validateSize\n * @property {boolean} _validateRemainingSize\n * @property {SplitChunksSizes} _minSizeForMaxSize\n * @property {boolean} _conditionalEnforce\n */\n\n/**\n * @typedef {Object} FallbackCacheGroup\n * @property {ChunkFilterFunction} chunksFilter\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {string} automaticNameDelimiter\n */\n\n/**\n * @typedef {Object} CacheGroupsContext\n * @property {ModuleGraph} moduleGraph\n * @property {ChunkGraph} chunkGraph\n */\n\n/**\n * @callback GetCacheGroups\n * @param {Module} module\n * @param {CacheGroupsContext} context\n * @returns {CacheGroupSource[]}\n */\n\n/**\n * @callback GetName\n * @param {Module=} module\n * @param {Chunk[]=} chunks\n * @param {string=} key\n * @returns {string=}\n */\n\n/**\n * @typedef {Object} SplitChunksOptions\n * @property {ChunkFilterFunction} chunksFilter\n * @property {string[]} defaultSizeTypes\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxInitialSize\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {number} minChunks\n * @property {number} maxAsyncRequests\n * @property {number} maxInitialRequests\n * @property {boolean} hidePathInfo\n * @property {string | function(PathData, AssetInfo=): string} filename\n * @property {string} automaticNameDelimiter\n * @property {GetCacheGroups} getCacheGroups\n * @property {GetName} getName\n * @property {boolean} usedExports\n * @property {FallbackCacheGroup} fallbackCacheGroup\n */\n\n/**\n * @typedef {Object} ChunksInfoItem\n * @property {SortableSet<Module>} modules\n * @property {CacheGroup} cacheGroup\n * @property {number} cacheGroupIndex\n * @property {string} name\n * @property {Record<string, number>} sizes\n * @property {Set<Chunk>} chunks\n * @property {Set<Chunk>} reuseableChunks\n * @property {Set<bigint | Chunk>} chunksKeys\n */\n\nconst defaultGetName = /** @type {GetName} */ (() => {});\n\nconst deterministicGroupingForModules =\n\t/** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */ (\n\t\tdeterministicGrouping\n\t);\n\n/** @type {WeakMap<Module, string>} */\nconst getKeyCache = new WeakMap();\n\n/**\n * @param {string} name a filename to hash\n * @param {OutputOptions} outputOptions hash function used\n * @returns {string} hashed filename\n */\nconst hashFilename = (name, outputOptions) => {\n\tconst digest = /** @type {string} */ (\n\t\tcreateHash(outputOptions.hashFunction)\n\t\t\t.update(name)\n\t\t\t.digest(outputOptions.hashDigest)\n\t);\n\treturn digest.slice(0, 8);\n};\n\n/**\n * @param {Chunk} chunk the chunk\n * @returns {number} the number of requests\n */\nconst getRequests = chunk => {\n\tlet requests = 0;\n\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\trequests = Math.max(requests, chunkGroup.chunks.length);\n\t}\n\treturn requests;\n};\n\nconst mapObject = (obj, fn) => {\n\tconst newObj = Object.create(null);\n\tfor (const key of Object.keys(obj)) {\n\t\tnewObj[key] = fn(obj[key], key);\n\t}\n\treturn newObj;\n};\n\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\nconst isOverlap = (a, b) => {\n\tfor (const item of a) {\n\t\tif (b.has(item)) return true;\n\t}\n\treturn false;\n};\n\nconst compareModuleIterables = compareIterables(compareModulesByIdentifier);\n\n/**\n * @param {ChunksInfoItem} a item\n * @param {ChunksInfoItem} b item\n * @returns {number} compare result\n */\nconst compareEntries = (a, b) => {\n\t// 1. by priority\n\tconst diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n\tif (diffPriority) return diffPriority;\n\t// 2. by number of chunks\n\tconst diffCount = a.chunks.size - b.chunks.size;\n\tif (diffCount) return diffCount;\n\t// 3. by size reduction\n\tconst aSizeReduce = totalSize(a.sizes) * (a.chunks.size - 1);\n\tconst bSizeReduce = totalSize(b.sizes) * (b.chunks.size - 1);\n\tconst diffSizeReduce = aSizeReduce - bSizeReduce;\n\tif (diffSizeReduce) return diffSizeReduce;\n\t// 4. by cache group index\n\tconst indexDiff = b.cacheGroupIndex - a.cacheGroupIndex;\n\tif (indexDiff) return indexDiff;\n\t// 5. by number of modules (to be able to compare by identifier)\n\tconst modulesA = a.modules;\n\tconst modulesB = b.modules;\n\tconst diff = modulesA.size - modulesB.size;\n\tif (diff) return diff;\n\t// 6. by module identifiers\n\tmodulesA.sort();\n\tmodulesB.sort();\n\treturn compareModuleIterables(modulesA, modulesB);\n};\n\nconst INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial();\nconst ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial();\nconst ALL_CHUNK_FILTER = chunk => true;\n\n/**\n * @param {OptimizationSplitChunksSizes} value the sizes\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {SplitChunksSizes} normalized representation\n */\nconst normalizeSizes = (value, defaultSizeTypes) => {\n\tif (typeof value === \"number\") {\n\t\t/** @type {Record<string, number>} */\n\t\tconst o = {};\n\t\tfor (const sizeType of defaultSizeTypes) o[sizeType] = value;\n\t\treturn o;\n\t} else if (typeof value === \"object\" && value !== null) {\n\t\treturn { ...value };\n\t} else {\n\t\treturn {};\n\t}\n};\n\n/**\n * @param {...SplitChunksSizes} sizes the sizes\n * @returns {SplitChunksSizes} the merged sizes\n */\nconst mergeSizes = (...sizes) => {\n\t/** @type {SplitChunksSizes} */\n\tlet merged = {};\n\tfor (let i = sizes.length - 1; i >= 0; i--) {\n\t\tmerged = Object.assign(merged, sizes[i]);\n\t}\n\treturn merged;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @returns {boolean} true, if there are sizes > 0\n */\nconst hasNonZeroSizes = sizes => {\n\tfor (const key of Object.keys(sizes)) {\n\t\tif (sizes[key] > 0) return true;\n\t}\n\treturn false;\n};\n\n/**\n * @param {SplitChunksSizes} a first sizes\n * @param {SplitChunksSizes} b second sizes\n * @param {CombineSizeFunction} combine a function to combine sizes\n * @returns {SplitChunksSizes} the combine sizes\n */\nconst combineSizes = (a, b, combine) => {\n\tconst aKeys = new Set(Object.keys(a));\n\tconst bKeys = new Set(Object.keys(b));\n\t/** @type {SplitChunksSizes} */\n\tconst result = {};\n\tfor (const key of aKeys) {\n\t\tif (bKeys.has(key)) {\n\t\t\tresult[key] = combine(a[key], b[key]);\n\t\t} else {\n\t\t\tresult[key] = a[key];\n\t\t}\n\t}\n\tfor (const key of bKeys) {\n\t\tif (!aKeys.has(key)) {\n\t\t\tresult[key] = b[key];\n\t\t}\n\t}\n\treturn result;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSize the min sizes\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSize`\n */\nconst checkMinSize = (sizes, minSize) => {\n\tfor (const key of Object.keys(minSize)) {\n\t\tconst size = sizes[key];\n\t\tif (size === undefined || size === 0) continue;\n\t\tif (size < minSize[key]) return false;\n\t}\n\treturn true;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSizeReduction the min sizes\n * @param {number} chunkCount number of chunks\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSizeReduction`\n */\nconst checkMinSizeReduction = (sizes, minSizeReduction, chunkCount) => {\n\tfor (const key of Object.keys(minSizeReduction)) {\n\t\tconst size = sizes[key];\n\t\tif (size === undefined || size === 0) continue;\n\t\tif (size * chunkCount < minSizeReduction[key]) return false;\n\t}\n\treturn true;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSize the min sizes\n * @returns {undefined | string[]} list of size types that are below min size\n */\nconst getViolatingMinSizes = (sizes, minSize) => {\n\tlet list;\n\tfor (const key of Object.keys(minSize)) {\n\t\tconst size = sizes[key];\n\t\tif (size === undefined || size === 0) continue;\n\t\tif (size < minSize[key]) {\n\t\t\tif (list === undefined) list = [key];\n\t\t\telse list.push(key);\n\t\t}\n\t}\n\treturn list;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @returns {number} the total size\n */\nconst totalSize = sizes => {\n\tlet size = 0;\n\tfor (const key of Object.keys(sizes)) {\n\t\tsize += sizes[key];\n\t}\n\treturn size;\n};\n\n/**\n * @param {false|string|Function} name the chunk name\n * @returns {GetName} a function to get the name of the chunk\n */\nconst normalizeName = name => {\n\tif (typeof name === \"string\") {\n\t\treturn () => name;\n\t}\n\tif (typeof name === \"function\") {\n\t\treturn /** @type {GetName} */ (name);\n\t}\n};\n\n/**\n * @param {OptimizationSplitChunksCacheGroup[\"chunks\"]} chunks the chunk filter option\n * @returns {ChunkFilterFunction} the chunk filter function\n */\nconst normalizeChunksFilter = chunks => {\n\tif (chunks === \"initial\") {\n\t\treturn INITIAL_CHUNK_FILTER;\n\t}\n\tif (chunks === \"async\") {\n\t\treturn ASYNC_CHUNK_FILTER;\n\t}\n\tif (chunks === \"all\") {\n\t\treturn ALL_CHUNK_FILTER;\n\t}\n\tif (typeof chunks === \"function\") {\n\t\treturn chunks;\n\t}\n};\n\n/**\n * @param {GetCacheGroups | Record<string, false|string|RegExp|OptimizationSplitChunksGetCacheGroups|OptimizationSplitChunksCacheGroup>} cacheGroups the cache group options\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {GetCacheGroups} a function to get the cache groups\n */\nconst normalizeCacheGroups = (cacheGroups, defaultSizeTypes) => {\n\tif (typeof cacheGroups === \"function\") {\n\t\treturn cacheGroups;\n\t}\n\tif (typeof cacheGroups === \"object\" && cacheGroups !== null) {\n\t\t/** @type {(function(Module, CacheGroupsContext, CacheGroupSource[]): void)[]} */\n\t\tconst handlers = [];\n\t\tfor (const key of Object.keys(cacheGroups)) {\n\t\t\tconst option = cacheGroups[key];\n\t\t\tif (option === false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (typeof option === \"string\" || option instanceof RegExp) {\n\t\t\t\tconst source = createCacheGroupSource({}, key, defaultSizeTypes);\n\t\t\t\thandlers.push((module, context, results) => {\n\t\t\t\t\tif (checkTest(option, module, context)) {\n\t\t\t\t\t\tresults.push(source);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (typeof option === \"function\") {\n\t\t\t\tconst cache = new WeakMap();\n\t\t\t\thandlers.push((module, context, results) => {\n\t\t\t\t\tconst result = option(module);\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tconst groups = Array.isArray(result) ? result : [result];\n\t\t\t\t\t\tfor (const group of groups) {\n\t\t\t\t\t\t\tconst cachedSource = cache.get(group);\n\t\t\t\t\t\t\tif (cachedSource !== undefined) {\n\t\t\t\t\t\t\t\tresults.push(cachedSource);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst source = createCacheGroupSource(\n\t\t\t\t\t\t\t\t\tgroup,\n\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\tdefaultSizeTypes\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcache.set(group, source);\n\t\t\t\t\t\t\t\tresults.push(source);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst source = createCacheGroupSource(option, key, defaultSizeTypes);\n\t\t\t\thandlers.push((module, context, results) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tcheckTest(option.test, module, context) &&\n\t\t\t\t\t\tcheckModuleType(option.type, module) &&\n\t\t\t\t\t\tcheckModuleLayer(option.layer, module)\n\t\t\t\t\t) {\n\t\t\t\t\t\tresults.push(source);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * @param {Module} module the current module\n\t\t * @param {CacheGroupsContext} context the current context\n\t\t * @returns {CacheGroupSource[]} the matching cache groups\n\t\t */\n\t\tconst fn = (module, context) => {\n\t\t\t/** @type {CacheGroupSource[]} */\n\t\t\tlet results = [];\n\t\t\tfor (const fn of handlers) {\n\t\t\t\tfn(module, context, results);\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\t\treturn fn;\n\t}\n\treturn () => null;\n};\n\n/**\n * @param {undefined|boolean|string|RegExp|Function} test test option\n * @param {Module} module the module\n * @param {CacheGroupsContext} context context object\n * @returns {boolean} true, if the module should be selected\n */\nconst checkTest = (test, module, context) => {\n\tif (test === undefined) return true;\n\tif (typeof test === \"function\") {\n\t\treturn test(module, context);\n\t}\n\tif (typeof test === \"boolean\") return test;\n\tif (typeof test === \"string\") {\n\t\tconst name = module.nameForCondition();\n\t\treturn name && name.startsWith(test);\n\t}\n\tif (test instanceof RegExp) {\n\t\tconst name = module.nameForCondition();\n\t\treturn name && test.test(name);\n\t}\n\treturn false;\n};\n\n/**\n * @param {undefined|string|RegExp|Function} test type option\n * @param {Module} module the module\n * @returns {boolean} true, if the module should be selected\n */\nconst checkModuleType = (test, module) => {\n\tif (test === undefined) return true;\n\tif (typeof test === \"function\") {\n\t\treturn test(module.type);\n\t}\n\tif (typeof test === \"string\") {\n\t\tconst type = module.type;\n\t\treturn test === type;\n\t}\n\tif (test instanceof RegExp) {\n\t\tconst type = module.type;\n\t\treturn test.test(type);\n\t}\n\treturn false;\n};\n\n/**\n * @param {undefined|string|RegExp|Function} test type option\n * @param {Module} module the module\n * @returns {boolean} true, if the module should be selected\n */\nconst checkModuleLayer = (test, module) => {\n\tif (test === undefined) return true;\n\tif (typeof test === \"function\") {\n\t\treturn test(module.layer);\n\t}\n\tif (typeof test === \"string\") {\n\t\tconst layer = module.layer;\n\t\treturn test === \"\" ? !layer : layer && layer.startsWith(test);\n\t}\n\tif (test instanceof RegExp) {\n\t\tconst layer = module.layer;\n\t\treturn test.test(layer);\n\t}\n\treturn false;\n};\n\n/**\n * @param {OptimizationSplitChunksCacheGroup} options the group options\n * @param {string} key key of cache group\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {CacheGroupSource} the normalized cached group\n */\nconst createCacheGroupSource = (options, key, defaultSizeTypes) => {\n\tconst minSize = normalizeSizes(options.minSize, defaultSizeTypes);\n\tconst minSizeReduction = normalizeSizes(\n\t\toptions.minSizeReduction,\n\t\tdefaultSizeTypes\n\t);\n\tconst maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\n\treturn {\n\t\tkey,\n\t\tpriority: options.priority,\n\t\tgetName: normalizeName(options.name),\n\t\tchunksFilter: normalizeChunksFilter(options.chunks),\n\t\tenforce: options.enforce,\n\t\tminSize,\n\t\tminSizeReduction,\n\t\tminRemainingSize: mergeSizes(\n\t\t\tnormalizeSizes(options.minRemainingSize, defaultSizeTypes),\n\t\t\tminSize\n\t\t),\n\t\tenforceSizeThreshold: normalizeSizes(\n\t\t\toptions.enforceSizeThreshold,\n\t\t\tdefaultSizeTypes\n\t\t),\n\t\tmaxAsyncSize: mergeSizes(\n\t\t\tnormalizeSizes(options.maxAsyncSize, defaultSizeTypes),\n\t\t\tmaxSize\n\t\t),\n\t\tmaxInitialSize: mergeSizes(\n\t\t\tnormalizeSizes(options.maxInitialSize, defaultSizeTypes),\n\t\t\tmaxSize\n\t\t),\n\t\tminChunks: options.minChunks,\n\t\tmaxAsyncRequests: options.maxAsyncRequests,\n\t\tmaxInitialRequests: options.maxInitialRequests,\n\t\tfilename: options.filename,\n\t\tidHint: options.idHint,\n\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\n\t\treuseExistingChunk: options.reuseExistingChunk,\n\t\tusedExports: options.usedExports\n\t};\n};\n\nmodule.exports = class SplitChunksPlugin {\n\t/**\n\t * @param {OptimizationSplitChunksOptions=} options plugin options\n\t */\n\tconstructor(options = {}) {\n\t\tconst defaultSizeTypes = options.defaultSizeTypes || [\n\t\t\t\"javascript\",\n\t\t\t\"unknown\"\n\t\t];\n\t\tconst fallbackCacheGroup = options.fallbackCacheGroup || {};\n\t\tconst minSize = normalizeSizes(options.minSize, defaultSizeTypes);\n\t\tconst minSizeReduction = normalizeSizes(\n\t\t\toptions.minSizeReduction,\n\t\t\tdefaultSizeTypes\n\t\t);\n\t\tconst maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\n\n\t\t/** @type {SplitChunksOptions} */\n\t\tthis.options = {\n\t\t\tchunksFilter: normalizeChunksFilter(options.chunks || \"all\"),\n\t\t\tdefaultSizeTypes,\n\t\t\tminSize,\n\t\t\tminSizeReduction,\n\t\t\tminRemainingSize: mergeSizes(\n\t\t\t\tnormalizeSizes(options.minRemainingSize, defaultSizeTypes),\n\t\t\t\tminSize\n\t\t\t),\n\t\t\tenforceSizeThreshold: normalizeSizes(\n\t\t\t\toptions.enforceSizeThreshold,\n\t\t\t\tdefaultSizeTypes\n\t\t\t),\n\t\t\tmaxAsyncSize: mergeSizes(\n\t\t\t\tnormalizeSizes(options.maxAsyncSize, defaultSizeTypes),\n\t\t\t\tmaxSize\n\t\t\t),\n\t\t\tmaxInitialSize: mergeSizes(\n\t\t\t\tnormalizeSizes(options.maxInitialSize, defaultSizeTypes),\n\t\t\t\tmaxSize\n\t\t\t),\n\t\t\tminChunks: options.minChunks || 1,\n\t\t\tmaxAsyncRequests: options.maxAsyncRequests || 1,\n\t\t\tmaxInitialRequests: options.maxInitialRequests || 1,\n\t\t\thidePathInfo: options.hidePathInfo || false,\n\t\t\tfilename: options.filename || undefined,\n\t\t\tgetCacheGroups: normalizeCacheGroups(\n\t\t\t\toptions.cacheGroups,\n\t\t\t\tdefaultSizeTypes\n\t\t\t),\n\t\t\tgetName: options.name ? normalizeName(options.name) : defaultGetName,\n\t\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\n\t\t\tusedExports: options.usedExports,\n\t\t\tfallbackCacheGroup: {\n\t\t\t\tchunksFilter: normalizeChunksFilter(\n\t\t\t\t\tfallbackCacheGroup.chunks || options.chunks || \"all\"\n\t\t\t\t),\n\t\t\t\tminSize: mergeSizes(\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.minSize, defaultSizeTypes),\n\t\t\t\t\tminSize\n\t\t\t\t),\n\t\t\t\tmaxAsyncSize: mergeSizes(\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxAsyncSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(options.maxAsyncSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(options.maxSize, defaultSizeTypes)\n\t\t\t\t),\n\t\t\t\tmaxInitialSize: mergeSizes(\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxInitialSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(options.maxInitialSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(options.maxSize, defaultSizeTypes)\n\t\t\t\t),\n\t\t\t\tautomaticNameDelimiter:\n\t\t\t\t\tfallbackCacheGroup.automaticNameDelimiter ||\n\t\t\t\t\toptions.automaticNameDelimiter ||\n\t\t\t\t\t\"~\"\n\t\t\t}\n\t\t};\n\n\t\t/** @type {WeakMap<CacheGroupSource, CacheGroup>} */\n\t\tthis._cacheGroupCache = new WeakMap();\n\t}\n\n\t/**\n\t * @param {CacheGroupSource} cacheGroupSource source\n\t * @returns {CacheGroup} the cache group (cached)\n\t */\n\t_getCacheGroup(cacheGroupSource) {\n\t\tconst cacheEntry = this._cacheGroupCache.get(cacheGroupSource);\n\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\tconst minSize = mergeSizes(\n\t\t\tcacheGroupSource.minSize,\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.minSize\n\t\t);\n\t\tconst minSizeReduction = mergeSizes(\n\t\t\tcacheGroupSource.minSizeReduction,\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.minSizeReduction\n\t\t);\n\t\tconst minRemainingSize = mergeSizes(\n\t\t\tcacheGroupSource.minRemainingSize,\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.minRemainingSize\n\t\t);\n\t\tconst enforceSizeThreshold = mergeSizes(\n\t\t\tcacheGroupSource.enforceSizeThreshold,\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.enforceSizeThreshold\n\t\t);\n\t\tconst cacheGroup = {\n\t\t\tkey: cacheGroupSource.key,\n\t\t\tpriority: cacheGroupSource.priority || 0,\n\t\t\tchunksFilter: cacheGroupSource.chunksFilter || this.options.chunksFilter,\n\t\t\tminSize,\n\t\t\tminSizeReduction,\n\t\t\tminRemainingSize,\n\t\t\tenforceSizeThreshold,\n\t\t\tmaxAsyncSize: mergeSizes(\n\t\t\t\tcacheGroupSource.maxAsyncSize,\n\t\t\t\tcacheGroupSource.enforce ? undefined : this.options.maxAsyncSize\n\t\t\t),\n\t\t\tmaxInitialSize: mergeSizes(\n\t\t\t\tcacheGroupSource.maxInitialSize,\n\t\t\t\tcacheGroupSource.enforce ? undefined : this.options.maxInitialSize\n\t\t\t),\n\t\t\tminChunks:\n\t\t\t\tcacheGroupSource.minChunks !== undefined\n\t\t\t\t\t? cacheGroupSource.minChunks\n\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t? 1\n\t\t\t\t\t: this.options.minChunks,\n\t\t\tmaxAsyncRequests:\n\t\t\t\tcacheGroupSource.maxAsyncRequests !== undefined\n\t\t\t\t\t? cacheGroupSource.maxAsyncRequests\n\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t? Infinity\n\t\t\t\t\t: this.options.maxAsyncRequests,\n\t\t\tmaxInitialRequests:\n\t\t\t\tcacheGroupSource.maxInitialRequests !== undefined\n\t\t\t\t\t? cacheGroupSource.maxInitialRequests\n\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t? Infinity\n\t\t\t\t\t: this.options.maxInitialRequests,\n\t\t\tgetName:\n\t\t\t\tcacheGroupSource.getName !== undefined\n\t\t\t\t\t? cacheGroupSource.getName\n\t\t\t\t\t: this.options.getName,\n\t\t\tusedExports:\n\t\t\t\tcacheGroupSource.usedExports !== undefined\n\t\t\t\t\t? cacheGroupSource.usedExports\n\t\t\t\t\t: this.options.usedExports,\n\t\t\tfilename:\n\t\t\t\tcacheGroupSource.filename !== undefined\n\t\t\t\t\t? cacheGroupSource.filename\n\t\t\t\t\t: this.options.filename,\n\t\t\tautomaticNameDelimiter:\n\t\t\t\tcacheGroupSource.automaticNameDelimiter !== undefined\n\t\t\t\t\t? cacheGroupSource.automaticNameDelimiter\n\t\t\t\t\t: this.options.automaticNameDelimiter,\n\t\t\tidHint:\n\t\t\t\tcacheGroupSource.idHint !== undefined\n\t\t\t\t\t? cacheGroupSource.idHint\n\t\t\t\t\t: cacheGroupSource.key,\n\t\t\treuseExistingChunk: cacheGroupSource.reuseExistingChunk || false,\n\t\t\t_validateSize: hasNonZeroSizes(minSize),\n\t\t\t_validateRemainingSize: hasNonZeroSizes(minRemainingSize),\n\t\t\t_minSizeForMaxSize: mergeSizes(\n\t\t\t\tcacheGroupSource.minSize,\n\t\t\t\tthis.options.minSize\n\t\t\t),\n\t\t\t_conditionalEnforce: hasNonZeroSizes(enforceSizeThreshold)\n\t\t};\n\t\tthis._cacheGroupCache.set(cacheGroupSource, cacheGroup);\n\t\treturn cacheGroup;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst cachedMakePathsRelative = makePathsRelative.bindContextCache(\n\t\t\tcompiler.context,\n\t\t\tcompiler.root\n\t\t);\n\t\tcompiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", compilation => {\n\t\t\tconst logger = compilation.getLogger(\"webpack.SplitChunksPlugin\");\n\t\t\tlet alreadyOptimized = false;\n\t\t\tcompilation.hooks.unseal.tap(\"SplitChunksPlugin\", () => {\n\t\t\t\talreadyOptimized = false;\n\t\t\t});\n\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t{\n\t\t\t\t\tname: \"SplitChunksPlugin\",\n\t\t\t\t\tstage: STAGE_ADVANCED\n\t\t\t\t},\n\t\t\t\tchunks => {\n\t\t\t\t\tif (alreadyOptimized) return;\n\t\t\t\t\talreadyOptimized = true;\n\t\t\t\t\tlogger.time(\"prepare\");\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\t\t\t// Give each selected chunk an index (to create strings from chunks)\n\t\t\t\t\t/** @type {Map<Chunk, bigint>} */\n\t\t\t\t\tconst chunkIndexMap = new Map();\n\t\t\t\t\tconst ZERO = BigInt(\"0\");\n\t\t\t\t\tconst ONE = BigInt(\"1\");\n\t\t\t\t\tconst START = ONE << BigInt(\"31\");\n\t\t\t\t\tlet index = START;\n\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\tchunkIndexMap.set(\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tindex | BigInt((Math.random() * 0x7fffffff) | 0)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tindex = index << ONE;\n\t\t\t\t\t}\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Iterable<Chunk>} chunks list of chunks\n\t\t\t\t\t * @returns {bigint | Chunk} key of the chunks\n\t\t\t\t\t */\n\t\t\t\t\tconst getKey = chunks => {\n\t\t\t\t\t\tconst iterator = chunks[Symbol.iterator]();\n\t\t\t\t\t\tlet result = iterator.next();\n\t\t\t\t\t\tif (result.done) return ZERO;\n\t\t\t\t\t\tconst first = result.value;\n\t\t\t\t\t\tresult = iterator.next();\n\t\t\t\t\t\tif (result.done) return first;\n\t\t\t\t\t\tlet key =\n\t\t\t\t\t\t\tchunkIndexMap.get(first) | chunkIndexMap.get(result.value);\n\t\t\t\t\t\twhile (!(result = iterator.next()).done) {\n\t\t\t\t\t\t\tconst raw = chunkIndexMap.get(result.value);\n\t\t\t\t\t\t\tkey = key ^ raw;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn key;\n\t\t\t\t\t};\n\t\t\t\t\tconst keyToString = key => {\n\t\t\t\t\t\tif (typeof key === \"bigint\") return key.toString(16);\n\t\t\t\t\t\treturn chunkIndexMap.get(key).toString(16);\n\t\t\t\t\t};\n\n\t\t\t\t\tconst getChunkSetsInGraph = memoize(() => {\n\t\t\t\t\t\t/** @type {Map<bigint, Set<Chunk>>} */\n\t\t\t\t\t\tconst chunkSetsInGraph = new Map();\n\t\t\t\t\t\t/** @type {Set<Chunk>} */\n\t\t\t\t\t\tconst singleChunkSets = new Set();\n\t\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t\tconst chunks = chunkGraph.getModuleChunksIterable(module);\n\t\t\t\t\t\t\tconst chunksKey = getKey(chunks);\n\t\t\t\t\t\t\tif (typeof chunksKey === \"bigint\") {\n\t\t\t\t\t\t\t\tif (!chunkSetsInGraph.has(chunksKey)) {\n\t\t\t\t\t\t\t\t\tchunkSetsInGraph.set(chunksKey, new Set(chunks));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsingleChunkSets.add(chunksKey);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn { chunkSetsInGraph, singleChunkSets };\n\t\t\t\t\t});\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Module} module the module\n\t\t\t\t\t * @returns {Iterable<Chunk[]>} groups of chunks with equal exports\n\t\t\t\t\t */\n\t\t\t\t\tconst groupChunksByExports = module => {\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\tconst groupedByUsedExports = new Map();\n\t\t\t\t\t\tfor (const chunk of chunkGraph.getModuleChunksIterable(module)) {\n\t\t\t\t\t\t\tconst key = exportsInfo.getUsageKey(chunk.runtime);\n\t\t\t\t\t\t\tconst list = groupedByUsedExports.get(key);\n\t\t\t\t\t\t\tif (list !== undefined) {\n\t\t\t\t\t\t\t\tlist.push(chunk);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgroupedByUsedExports.set(key, [chunk]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn groupedByUsedExports.values();\n\t\t\t\t\t};\n\n\t\t\t\t\t/** @type {Map<Module, Iterable<Chunk[]>>} */\n\t\t\t\t\tconst groupedByExportsMap = new Map();\n\n\t\t\t\t\tconst getExportsChunkSetsInGraph = memoize(() => {\n\t\t\t\t\t\t/** @type {Map<bigint, Set<Chunk>>} */\n\t\t\t\t\t\tconst chunkSetsInGraph = new Map();\n\t\t\t\t\t\t/** @type {Set<Chunk>} */\n\t\t\t\t\t\tconst singleChunkSets = new Set();\n\t\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t\tconst groupedChunks = Array.from(groupChunksByExports(module));\n\t\t\t\t\t\t\tgroupedByExportsMap.set(module, groupedChunks);\n\t\t\t\t\t\t\tfor (const chunks of groupedChunks) {\n\t\t\t\t\t\t\t\tif (chunks.length === 1) {\n\t\t\t\t\t\t\t\t\tsingleChunkSets.add(chunks[0]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst chunksKey = /** @type {bigint} */ (getKey(chunks));\n\t\t\t\t\t\t\t\t\tif (!chunkSetsInGraph.has(chunksKey)) {\n\t\t\t\t\t\t\t\t\t\tchunkSetsInGraph.set(chunksKey, new Set(chunks));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn { chunkSetsInGraph, singleChunkSets };\n\t\t\t\t\t});\n\n\t\t\t\t\t// group these set of chunks by count\n\t\t\t\t\t// to allow to check less sets via isSubset\n\t\t\t\t\t// (only smaller sets can be subset)\n\t\t\t\t\tconst groupChunkSetsByCount = chunkSets => {\n\t\t\t\t\t\t/** @type {Map<number, Array<Set<Chunk>>>} */\n\t\t\t\t\t\tconst chunkSetsByCount = new Map();\n\t\t\t\t\t\tfor (const chunksSet of chunkSets) {\n\t\t\t\t\t\t\tconst count = chunksSet.size;\n\t\t\t\t\t\t\tlet array = chunkSetsByCount.get(count);\n\t\t\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\t\t\tchunkSetsByCount.set(count, array);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tarray.push(chunksSet);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn chunkSetsByCount;\n\t\t\t\t\t};\n\t\t\t\t\tconst getChunkSetsByCount = memoize(() =>\n\t\t\t\t\t\tgroupChunkSetsByCount(\n\t\t\t\t\t\t\tgetChunkSetsInGraph().chunkSetsInGraph.values()\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\tconst getExportsChunkSetsByCount = memoize(() =>\n\t\t\t\t\t\tgroupChunkSetsByCount(\n\t\t\t\t\t\t\tgetExportsChunkSetsInGraph().chunkSetsInGraph.values()\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\t// Create a list of possible combinations\n\t\t\t\t\tconst createGetCombinations = (\n\t\t\t\t\t\tchunkSets,\n\t\t\t\t\t\tsingleChunkSets,\n\t\t\t\t\t\tchunkSetsByCount\n\t\t\t\t\t) => {\n\t\t\t\t\t\t/** @type {Map<bigint | Chunk, (Set<Chunk> | Chunk)[]>} */\n\t\t\t\t\t\tconst combinationsCache = new Map();\n\n\t\t\t\t\t\treturn key => {\n\t\t\t\t\t\t\tconst cacheEntry = combinationsCache.get(key);\n\t\t\t\t\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\t\t\t\t\tif (key instanceof Chunk) {\n\t\t\t\t\t\t\t\tconst result = [key];\n\t\t\t\t\t\t\t\tcombinationsCache.set(key, result);\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst chunksSet = chunkSets.get(key);\n\t\t\t\t\t\t\t/** @type {(Set<Chunk> | Chunk)[]} */\n\t\t\t\t\t\t\tconst array = [chunksSet];\n\t\t\t\t\t\t\tfor (const [count, setArray] of chunkSetsByCount) {\n\t\t\t\t\t\t\t\t// \"equal\" is not needed because they would have been merge in the first step\n\t\t\t\t\t\t\t\tif (count < chunksSet.size) {\n\t\t\t\t\t\t\t\t\tfor (const set of setArray) {\n\t\t\t\t\t\t\t\t\t\tif (isSubset(chunksSet, set)) {\n\t\t\t\t\t\t\t\t\t\t\tarray.push(set);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const chunk of singleChunkSets) {\n\t\t\t\t\t\t\t\tif (chunksSet.has(chunk)) {\n\t\t\t\t\t\t\t\t\tarray.push(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcombinationsCache.set(key, array);\n\t\t\t\t\t\t\treturn array;\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\n\t\t\t\t\tconst getCombinationsFactory = memoize(() => {\n\t\t\t\t\t\tconst { chunkSetsInGraph, singleChunkSets } = getChunkSetsInGraph();\n\t\t\t\t\t\treturn createGetCombinations(\n\t\t\t\t\t\t\tchunkSetsInGraph,\n\t\t\t\t\t\t\tsingleChunkSets,\n\t\t\t\t\t\t\tgetChunkSetsByCount()\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\tconst getCombinations = key => getCombinationsFactory()(key);\n\n\t\t\t\t\tconst getExportsCombinationsFactory = memoize(() => {\n\t\t\t\t\t\tconst { chunkSetsInGraph, singleChunkSets } =\n\t\t\t\t\t\t\tgetExportsChunkSetsInGraph();\n\t\t\t\t\t\treturn createGetCombinations(\n\t\t\t\t\t\t\tchunkSetsInGraph,\n\t\t\t\t\t\t\tsingleChunkSets,\n\t\t\t\t\t\t\tgetExportsChunkSetsByCount()\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\tconst getExportsCombinations = key =>\n\t\t\t\t\t\tgetExportsCombinationsFactory()(key);\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {Object} SelectedChunksResult\n\t\t\t\t\t * @property {Chunk[]} chunks the list of chunks\n\t\t\t\t\t * @property {bigint | Chunk} key a key of the list\n\t\t\t\t\t */\n\n\t\t\t\t\t/** @type {WeakMap<Set<Chunk> | Chunk, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n\t\t\t\t\tconst selectedChunksCacheByChunksSet = new WeakMap();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * get list and key by applying the filter function to the list\n\t\t\t\t\t * It is cached for performance reasons\n\t\t\t\t\t * @param {Set<Chunk> | Chunk} chunks list of chunks\n\t\t\t\t\t * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n\t\t\t\t\t * @returns {SelectedChunksResult} list and key\n\t\t\t\t\t */\n\t\t\t\t\tconst getSelectedChunks = (chunks, chunkFilter) => {\n\t\t\t\t\t\tlet entry = selectedChunksCacheByChunksSet.get(chunks);\n\t\t\t\t\t\tif (entry === undefined) {\n\t\t\t\t\t\t\tentry = new WeakMap();\n\t\t\t\t\t\t\tselectedChunksCacheByChunksSet.set(chunks, entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/** @type {SelectedChunksResult} */\n\t\t\t\t\t\tlet entry2 = entry.get(chunkFilter);\n\t\t\t\t\t\tif (entry2 === undefined) {\n\t\t\t\t\t\t\t/** @type {Chunk[]} */\n\t\t\t\t\t\t\tconst selectedChunks = [];\n\t\t\t\t\t\t\tif (chunks instanceof Chunk) {\n\t\t\t\t\t\t\t\tif (chunkFilter(chunks)) selectedChunks.push(chunks);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\t\t\tif (chunkFilter(chunk)) selectedChunks.push(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tentry2 = {\n\t\t\t\t\t\t\t\tchunks: selectedChunks,\n\t\t\t\t\t\t\t\tkey: getKey(selectedChunks)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tentry.set(chunkFilter, entry2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn entry2;\n\t\t\t\t\t};\n\n\t\t\t\t\t/** @type {Map<string, boolean>} */\n\t\t\t\t\tconst alreadyValidatedParents = new Map();\n\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\tconst alreadyReportedErrors = new Set();\n\n\t\t\t\t\t// Map a list of chunks to a list of modules\n\t\t\t\t\t// For the key the chunk \"index\" is used, the value is a SortableSet of modules\n\t\t\t\t\t/** @type {Map<string, ChunksInfoItem>} */\n\t\t\t\t\tconst chunksInfoMap = new Map();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {CacheGroup} cacheGroup the current cache group\n\t\t\t\t\t * @param {number} cacheGroupIndex the index of the cache group of ordering\n\t\t\t\t\t * @param {Chunk[]} selectedChunks chunks selected for this module\n\t\t\t\t\t * @param {bigint | Chunk} selectedChunksKey a key of selectedChunks\n\t\t\t\t\t * @param {Module} module the current module\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst addModuleToChunksInfoMap = (\n\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\tselectedChunksKey,\n\t\t\t\t\t\tmodule\n\t\t\t\t\t) => {\n\t\t\t\t\t\t// Break if minimum number of chunks is not reached\n\t\t\t\t\t\tif (selectedChunks.length < cacheGroup.minChunks) return;\n\t\t\t\t\t\t// Determine name for split chunk\n\t\t\t\t\t\tconst name = cacheGroup.getName(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\t\tcacheGroup.key\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// Check if the name is ok\n\t\t\t\t\t\tconst existingChunk = compilation.namedChunks.get(name);\n\t\t\t\t\t\tif (existingChunk) {\n\t\t\t\t\t\t\tconst parentValidationKey = `${name}|${\n\t\t\t\t\t\t\t\ttypeof selectedChunksKey === \"bigint\"\n\t\t\t\t\t\t\t\t\t? selectedChunksKey\n\t\t\t\t\t\t\t\t\t: selectedChunksKey.debugId\n\t\t\t\t\t\t\t}`;\n\t\t\t\t\t\t\tconst valid = alreadyValidatedParents.get(parentValidationKey);\n\t\t\t\t\t\t\tif (valid === false) return;\n\t\t\t\t\t\t\tif (valid === undefined) {\n\t\t\t\t\t\t\t\t// Module can only be moved into the existing chunk if the existing chunk\n\t\t\t\t\t\t\t\t// is a parent of all selected chunks\n\t\t\t\t\t\t\t\tlet isInAllParents = true;\n\t\t\t\t\t\t\t\t/** @type {Set<ChunkGroup>} */\n\t\t\t\t\t\t\t\tconst queue = new Set();\n\t\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\t\tfor (const group of chunk.groupsIterable) {\n\t\t\t\t\t\t\t\t\t\tqueue.add(group);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const group of queue) {\n\t\t\t\t\t\t\t\t\tif (existingChunk.isInGroup(group)) continue;\n\t\t\t\t\t\t\t\t\tlet hasParent = false;\n\t\t\t\t\t\t\t\t\tfor (const parent of group.parentsIterable) {\n\t\t\t\t\t\t\t\t\t\thasParent = true;\n\t\t\t\t\t\t\t\t\t\tqueue.add(parent);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!hasParent) {\n\t\t\t\t\t\t\t\t\t\tisInAllParents = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst valid = isInAllParents;\n\t\t\t\t\t\t\t\talreadyValidatedParents.set(parentValidationKey, valid);\n\t\t\t\t\t\t\t\tif (!valid) {\n\t\t\t\t\t\t\t\t\tif (!alreadyReportedErrors.has(name)) {\n\t\t\t\t\t\t\t\t\t\talreadyReportedErrors.add(name);\n\t\t\t\t\t\t\t\t\t\tcompilation.errors.push(\n\t\t\t\t\t\t\t\t\t\t\tnew WebpackError(\n\t\t\t\t\t\t\t\t\t\t\t\t\"SplitChunksPlugin\\n\" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t`Cache group \"${cacheGroup.key}\" conflicts with existing chunk.\\n` +\n\t\t\t\t\t\t\t\t\t\t\t\t\t`Both have the same name \"${name}\" and existing chunk is not a parent of the selected modules.\\n` +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Use a different name for the cache group or make sure that the existing chunk is a parent (e. g. via dependOn).\\n\" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t'HINT: You can omit \"name\" to automatically create a name.\\n' +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"BREAKING CHANGE: webpack < 5 used to allow to use an entrypoint as splitChunk. \" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"This is no longer allowed when the entrypoint is not a parent of the selected modules.\\n\" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Remove this entrypoint and add modules to cache group's 'test' instead. \" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"If you need modules to be evaluated on startup, add them to the existing entrypoints (make them arrays). \" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"See migration guide of more info.\"\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Create key for maps\n\t\t\t\t\t\t// When it has a name we use the name as key\n\t\t\t\t\t\t// Otherwise we create the key from chunks and cache group key\n\t\t\t\t\t\t// This automatically merges equal names\n\t\t\t\t\t\tconst key =\n\t\t\t\t\t\t\tcacheGroup.key +\n\t\t\t\t\t\t\t(name\n\t\t\t\t\t\t\t\t? ` name:${name}`\n\t\t\t\t\t\t\t\t: ` chunks:${keyToString(selectedChunksKey)}`);\n\t\t\t\t\t\t// Add module to maps\n\t\t\t\t\t\tlet info = chunksInfoMap.get(key);\n\t\t\t\t\t\tif (info === undefined) {\n\t\t\t\t\t\t\tchunksInfoMap.set(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t(info = {\n\t\t\t\t\t\t\t\t\tmodules: new SortableSet(\n\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t\tcompareModulesByIdentifier\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\t\tsizes: {},\n\t\t\t\t\t\t\t\t\tchunks: new Set(),\n\t\t\t\t\t\t\t\t\treuseableChunks: new Set(),\n\t\t\t\t\t\t\t\t\tchunksKeys: new Set()\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst oldSize = info.modules.size;\n\t\t\t\t\t\tinfo.modules.add(module);\n\t\t\t\t\t\tif (info.modules.size !== oldSize) {\n\t\t\t\t\t\t\tfor (const type of module.getSourceTypes()) {\n\t\t\t\t\t\t\t\tinfo.sizes[type] = (info.sizes[type] || 0) + module.size(type);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst oldChunksKeysSize = info.chunksKeys.size;\n\t\t\t\t\t\tinfo.chunksKeys.add(selectedChunksKey);\n\t\t\t\t\t\tif (oldChunksKeysSize !== info.chunksKeys.size) {\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\tinfo.chunks.add(chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tconst context = {\n\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\tchunkGraph\n\t\t\t\t\t};\n\n\t\t\t\t\tlogger.timeEnd(\"prepare\");\n\n\t\t\t\t\tlogger.time(\"modules\");\n\n\t\t\t\t\t// Walk through all modules\n\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t// Get cache group\n\t\t\t\t\t\tlet cacheGroups = this.options.getCacheGroups(module, context);\n\t\t\t\t\t\tif (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Prepare some values (usedExports = false)\n\t\t\t\t\t\tconst getCombs = memoize(() => {\n\t\t\t\t\t\t\tconst chunks = chunkGraph.getModuleChunksIterable(module);\n\t\t\t\t\t\t\tconst chunksKey = getKey(chunks);\n\t\t\t\t\t\t\treturn getCombinations(chunksKey);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Prepare some values (usedExports = true)\n\t\t\t\t\t\tconst getCombsByUsedExports = memoize(() => {\n\t\t\t\t\t\t\t// fill the groupedByExportsMap\n\t\t\t\t\t\t\tgetExportsChunkSetsInGraph();\n\t\t\t\t\t\t\t/** @type {Set<Set<Chunk> | Chunk>} */\n\t\t\t\t\t\t\tconst set = new Set();\n\t\t\t\t\t\t\tconst groupedByUsedExports = groupedByExportsMap.get(module);\n\t\t\t\t\t\t\tfor (const chunks of groupedByUsedExports) {\n\t\t\t\t\t\t\t\tconst chunksKey = getKey(chunks);\n\t\t\t\t\t\t\t\tfor (const comb of getExportsCombinations(chunksKey))\n\t\t\t\t\t\t\t\t\tset.add(comb);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn set;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tlet cacheGroupIndex = 0;\n\t\t\t\t\t\tfor (const cacheGroupSource of cacheGroups) {\n\t\t\t\t\t\t\tconst cacheGroup = this._getCacheGroup(cacheGroupSource);\n\n\t\t\t\t\t\t\tconst combs = cacheGroup.usedExports\n\t\t\t\t\t\t\t\t? getCombsByUsedExports()\n\t\t\t\t\t\t\t\t: getCombs();\n\t\t\t\t\t\t\t// For all combination of chunk selection\n\t\t\t\t\t\t\tfor (const chunkCombination of combs) {\n\t\t\t\t\t\t\t\t// Break if minimum number of chunks is not reached\n\t\t\t\t\t\t\t\tconst count =\n\t\t\t\t\t\t\t\t\tchunkCombination instanceof Chunk ? 1 : chunkCombination.size;\n\t\t\t\t\t\t\t\tif (count < cacheGroup.minChunks) continue;\n\t\t\t\t\t\t\t\t// Select chunks by configuration\n\t\t\t\t\t\t\t\tconst { chunks: selectedChunks, key: selectedChunksKey } =\n\t\t\t\t\t\t\t\t\tgetSelectedChunks(chunkCombination, cacheGroup.chunksFilter);\n\n\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\n\t\t\t\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\t\t\t\tselectedChunksKey,\n\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcacheGroupIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlogger.timeEnd(\"modules\");\n\n\t\t\t\t\tlogger.time(\"queue\");\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {ChunksInfoItem} info entry\n\t\t\t\t\t * @param {string[]} sourceTypes source types to be removed\n\t\t\t\t\t */\n\t\t\t\t\tconst removeModulesWithSourceType = (info, sourceTypes) => {\n\t\t\t\t\t\tfor (const module of info.modules) {\n\t\t\t\t\t\t\tconst types = module.getSourceTypes();\n\t\t\t\t\t\t\tif (sourceTypes.some(type => types.has(type))) {\n\t\t\t\t\t\t\t\tinfo.modules.delete(module);\n\t\t\t\t\t\t\t\tfor (const type of types) {\n\t\t\t\t\t\t\t\t\tinfo.sizes[type] -= module.size(type);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {ChunksInfoItem} info entry\n\t\t\t\t\t * @returns {boolean} true, if entry become empty\n\t\t\t\t\t */\n\t\t\t\t\tconst removeMinSizeViolatingModules = info => {\n\t\t\t\t\t\tif (!info.cacheGroup._validateSize) return false;\n\t\t\t\t\t\tconst violatingSizes = getViolatingMinSizes(\n\t\t\t\t\t\t\tinfo.sizes,\n\t\t\t\t\t\t\tinfo.cacheGroup.minSize\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (violatingSizes === undefined) return false;\n\t\t\t\t\t\tremoveModulesWithSourceType(info, violatingSizes);\n\t\t\t\t\t\treturn info.modules.size === 0;\n\t\t\t\t\t};\n\n\t\t\t\t\t// Filter items were size < minSize\n\t\t\t\t\tfor (const [key, info] of chunksInfoMap) {\n\t\t\t\t\t\tif (removeMinSizeViolatingModules(info)) {\n\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t!checkMinSizeReduction(\n\t\t\t\t\t\t\t\tinfo.sizes,\n\t\t\t\t\t\t\t\tinfo.cacheGroup.minSizeReduction,\n\t\t\t\t\t\t\t\tinfo.chunks.size\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {Object} MaxSizeQueueItem\n\t\t\t\t\t * @property {SplitChunksSizes} minSize\n\t\t\t\t\t * @property {SplitChunksSizes} maxAsyncSize\n\t\t\t\t\t * @property {SplitChunksSizes} maxInitialSize\n\t\t\t\t\t * @property {string} automaticNameDelimiter\n\t\t\t\t\t * @property {string[]} keys\n\t\t\t\t\t */\n\n\t\t\t\t\t/** @type {Map<Chunk, MaxSizeQueueItem>} */\n\t\t\t\t\tconst maxSizeQueueMap = new Map();\n\n\t\t\t\t\twhile (chunksInfoMap.size > 0) {\n\t\t\t\t\t\t// Find best matching entry\n\t\t\t\t\t\tlet bestEntryKey;\n\t\t\t\t\t\tlet bestEntry;\n\t\t\t\t\t\tfor (const pair of chunksInfoMap) {\n\t\t\t\t\t\t\tconst key = pair[0];\n\t\t\t\t\t\t\tconst info = pair[1];\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tbestEntry === undefined ||\n\t\t\t\t\t\t\t\tcompareEntries(bestEntry, info) < 0\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tbestEntry = info;\n\t\t\t\t\t\t\t\tbestEntryKey = key;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst item = bestEntry;\n\t\t\t\t\t\tchunksInfoMap.delete(bestEntryKey);\n\n\t\t\t\t\t\tlet chunkName = item.name;\n\t\t\t\t\t\t// Variable for the new chunk (lazy created)\n\t\t\t\t\t\t/** @type {Chunk} */\n\t\t\t\t\t\tlet newChunk;\n\t\t\t\t\t\t// When no chunk name, check if we can reuse a chunk instead of creating a new one\n\t\t\t\t\t\tlet isExistingChunk = false;\n\t\t\t\t\t\tlet isReusedWithAllModules = false;\n\t\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\t\tconst chunkByName = compilation.namedChunks.get(chunkName);\n\t\t\t\t\t\t\tif (chunkByName !== undefined) {\n\t\t\t\t\t\t\t\tnewChunk = chunkByName;\n\t\t\t\t\t\t\t\tconst oldSize = item.chunks.size;\n\t\t\t\t\t\t\t\titem.chunks.delete(newChunk);\n\t\t\t\t\t\t\t\tisExistingChunk = item.chunks.size !== oldSize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (item.cacheGroup.reuseExistingChunk) {\n\t\t\t\t\t\t\touter: for (const chunk of item.chunks) {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(chunk) !==\n\t\t\t\t\t\t\t\t\titem.modules.size\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\titem.chunks.size > 1 &&\n\t\t\t\t\t\t\t\t\tchunkGraph.getNumberOfEntryModules(chunk) > 0\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\tif (!chunkGraph.isModuleInChunk(module, chunk)) {\n\t\t\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!newChunk || !newChunk.name) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tchunk.name &&\n\t\t\t\t\t\t\t\t\tchunk.name.length < newChunk.name.length\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tchunk.name &&\n\t\t\t\t\t\t\t\t\tchunk.name.length === newChunk.name.length &&\n\t\t\t\t\t\t\t\t\tchunk.name < newChunk.name\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (newChunk) {\n\t\t\t\t\t\t\t\titem.chunks.delete(newChunk);\n\t\t\t\t\t\t\t\tchunkName = undefined;\n\t\t\t\t\t\t\t\tisExistingChunk = true;\n\t\t\t\t\t\t\t\tisReusedWithAllModules = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst enforced =\n\t\t\t\t\t\t\titem.cacheGroup._conditionalEnforce &&\n\t\t\t\t\t\t\tcheckMinSize(item.sizes, item.cacheGroup.enforceSizeThreshold);\n\n\t\t\t\t\t\tconst usedChunks = new Set(item.chunks);\n\n\t\t\t\t\t\t// Check if maxRequests condition can be fulfilled\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!enforced &&\n\t\t\t\t\t\t\t(Number.isFinite(item.cacheGroup.maxInitialRequests) ||\n\t\t\t\t\t\t\t\tNumber.isFinite(item.cacheGroup.maxAsyncRequests))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t// respect max requests\n\t\t\t\t\t\t\t\tconst maxRequests = chunk.isOnlyInitial()\n\t\t\t\t\t\t\t\t\t? item.cacheGroup.maxInitialRequests\n\t\t\t\t\t\t\t\t\t: chunk.canBeInitial()\n\t\t\t\t\t\t\t\t\t? Math.min(\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxInitialRequests,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxAsyncRequests\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxAsyncRequests;\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tisFinite(maxRequests) &&\n\t\t\t\t\t\t\t\t\tgetRequests(chunk) >= maxRequests\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tusedChunks.delete(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\touter: for (const chunk of usedChunks) {\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tif (chunkGraph.isModuleInChunk(module, chunk)) continue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tusedChunks.delete(chunk);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Were some (invalid) chunks removed from usedChunks?\n\t\t\t\t\t\t// => readd all modules to the queue, as things could have been changed\n\t\t\t\t\t\tif (usedChunks.size < item.chunks.size) {\n\t\t\t\t\t\t\tif (isExistingChunk) usedChunks.add(newChunk);\n\t\t\t\t\t\t\tif (usedChunks.size >= item.cacheGroup.minChunks) {\n\t\t\t\t\t\t\t\tconst chunksArr = Array.from(usedChunks);\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\n\t\t\t\t\t\t\t\t\t\titem.cacheGroup,\n\t\t\t\t\t\t\t\t\t\titem.cacheGroupIndex,\n\t\t\t\t\t\t\t\t\t\tchunksArr,\n\t\t\t\t\t\t\t\t\t\tgetKey(usedChunks),\n\t\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Validate minRemainingSize constraint when a single chunk is left over\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!enforced &&\n\t\t\t\t\t\t\titem.cacheGroup._validateRemainingSize &&\n\t\t\t\t\t\t\tusedChunks.size === 1\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst [chunk] = usedChunks;\n\t\t\t\t\t\t\tlet chunkSizes = Object.create(null);\n\t\t\t\t\t\t\tfor (const module of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\t\t\t\t\t\tif (!item.modules.has(module)) {\n\t\t\t\t\t\t\t\t\tfor (const type of module.getSourceTypes()) {\n\t\t\t\t\t\t\t\t\t\tchunkSizes[type] =\n\t\t\t\t\t\t\t\t\t\t\t(chunkSizes[type] || 0) + module.size(type);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst violatingSizes = getViolatingMinSizes(\n\t\t\t\t\t\t\t\tchunkSizes,\n\t\t\t\t\t\t\t\titem.cacheGroup.minRemainingSize\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (violatingSizes !== undefined) {\n\t\t\t\t\t\t\t\tconst oldModulesSize = item.modules.size;\n\t\t\t\t\t\t\t\tremoveModulesWithSourceType(item, violatingSizes);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\titem.modules.size > 0 &&\n\t\t\t\t\t\t\t\t\titem.modules.size !== oldModulesSize\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t// queue this item again to be processed again\n\t\t\t\t\t\t\t\t\t// without violating modules\n\t\t\t\t\t\t\t\t\tchunksInfoMap.set(bestEntryKey, item);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Create the new chunk if not reusing one\n\t\t\t\t\t\tif (newChunk === undefined) {\n\t\t\t\t\t\t\tnewChunk = compilation.addChunk(chunkName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Walk through all chunks\n\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t// Add graph connections for splitted chunk\n\t\t\t\t\t\t\tchunk.split(newChunk);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add a note to the chunk\n\t\t\t\t\t\tnewChunk.chunkReason =\n\t\t\t\t\t\t\t(newChunk.chunkReason ? newChunk.chunkReason + \", \" : \"\") +\n\t\t\t\t\t\t\t(isReusedWithAllModules\n\t\t\t\t\t\t\t\t? \"reused as split chunk\"\n\t\t\t\t\t\t\t\t: \"split chunk\");\n\t\t\t\t\t\tif (item.cacheGroup.key) {\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (name: ${chunkName})`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (item.cacheGroup.filename) {\n\t\t\t\t\t\t\tnewChunk.filenameTemplate = item.cacheGroup.filename;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (item.cacheGroup.idHint) {\n\t\t\t\t\t\t\tnewChunk.idNameHints.add(item.cacheGroup.idHint);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!isReusedWithAllModules) {\n\t\t\t\t\t\t\t// Add all modules to the new chunk\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tif (!module.chunkCondition(newChunk, compilation)) continue;\n\t\t\t\t\t\t\t\t// Add module to new chunk\n\t\t\t\t\t\t\t\tchunkGraph.connectChunkAndModule(newChunk, module);\n\t\t\t\t\t\t\t\t// Remove module from used chunks\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Remove all modules from used chunks\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tObject.keys(item.cacheGroup.maxAsyncSize).length > 0 ||\n\t\t\t\t\t\t\tObject.keys(item.cacheGroup.maxInitialSize).length > 0\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n\t\t\t\t\t\t\tmaxSizeQueueMap.set(newChunk, {\n\t\t\t\t\t\t\t\tminSize: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? combineSizes(\n\t\t\t\t\t\t\t\t\t\t\toldMaxSizeSettings.minSize,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup._minSizeForMaxSize,\n\t\t\t\t\t\t\t\t\t\t\tMath.max\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.minSize,\n\t\t\t\t\t\t\t\tmaxAsyncSize: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? combineSizes(\n\t\t\t\t\t\t\t\t\t\t\toldMaxSizeSettings.maxAsyncSize,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxAsyncSize,\n\t\t\t\t\t\t\t\t\t\t\tMath.min\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxAsyncSize,\n\t\t\t\t\t\t\t\tmaxInitialSize: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? combineSizes(\n\t\t\t\t\t\t\t\t\t\t\toldMaxSizeSettings.maxInitialSize,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxInitialSize,\n\t\t\t\t\t\t\t\t\t\t\tMath.min\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxInitialSize,\n\t\t\t\t\t\t\t\tautomaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n\t\t\t\t\t\t\t\tkeys: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? oldMaxSizeSettings.keys.concat(item.cacheGroup.key)\n\t\t\t\t\t\t\t\t\t: [item.cacheGroup.key]\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// remove all modules from other entries and update size\n\t\t\t\t\t\tfor (const [key, info] of chunksInfoMap) {\n\t\t\t\t\t\t\tif (isOverlap(info.chunks, usedChunks)) {\n\t\t\t\t\t\t\t\t// update modules and total size\n\t\t\t\t\t\t\t\t// may remove it from the map when < minSize\n\t\t\t\t\t\t\t\tlet updated = false;\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\tif (info.modules.has(module)) {\n\t\t\t\t\t\t\t\t\t\t// remove module\n\t\t\t\t\t\t\t\t\t\tinfo.modules.delete(module);\n\t\t\t\t\t\t\t\t\t\t// update size\n\t\t\t\t\t\t\t\t\t\tfor (const key of module.getSourceTypes()) {\n\t\t\t\t\t\t\t\t\t\t\tinfo.sizes[key] -= module.size(key);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (updated) {\n\t\t\t\t\t\t\t\t\tif (info.modules.size === 0) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tremoveMinSizeViolatingModules(info) ||\n\t\t\t\t\t\t\t\t\t\t!checkMinSizeReduction(\n\t\t\t\t\t\t\t\t\t\t\tinfo.sizes,\n\t\t\t\t\t\t\t\t\t\t\tinfo.cacheGroup.minSizeReduction,\n\t\t\t\t\t\t\t\t\t\t\tinfo.chunks.size\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlogger.timeEnd(\"queue\");\n\n\t\t\t\t\tlogger.time(\"maxSize\");\n\n\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\tconst incorrectMinMaxSizeSet = new Set();\n\n\t\t\t\t\tconst { outputOptions } = compilation;\n\n\t\t\t\t\t// Make sure that maxSize is fulfilled\n\t\t\t\t\tconst { fallbackCacheGroup } = this.options;\n\t\t\t\t\tfor (const chunk of Array.from(compilation.chunks)) {\n\t\t\t\t\t\tconst chunkConfig = maxSizeQueueMap.get(chunk);\n\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\tminSize,\n\t\t\t\t\t\t\tmaxAsyncSize,\n\t\t\t\t\t\t\tmaxInitialSize,\n\t\t\t\t\t\t\tautomaticNameDelimiter\n\t\t\t\t\t\t} = chunkConfig || fallbackCacheGroup;\n\t\t\t\t\t\tif (!chunkConfig && !fallbackCacheGroup.chunksFilter(chunk))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t/** @type {SplitChunksSizes} */\n\t\t\t\t\t\tlet maxSize;\n\t\t\t\t\t\tif (chunk.isOnlyInitial()) {\n\t\t\t\t\t\t\tmaxSize = maxInitialSize;\n\t\t\t\t\t\t} else if (chunk.canBeInitial()) {\n\t\t\t\t\t\t\tmaxSize = combineSizes(maxAsyncSize, maxInitialSize, Math.min);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmaxSize = maxAsyncSize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (Object.keys(maxSize).length === 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const key of Object.keys(maxSize)) {\n\t\t\t\t\t\t\tconst maxSizeValue = maxSize[key];\n\t\t\t\t\t\t\tconst minSizeValue = minSize[key];\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\ttypeof minSizeValue === \"number\" &&\n\t\t\t\t\t\t\t\tminSizeValue > maxSizeValue\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst keys = chunkConfig && chunkConfig.keys;\n\t\t\t\t\t\t\t\tconst warningKey = `${\n\t\t\t\t\t\t\t\t\tkeys && keys.join()\n\t\t\t\t\t\t\t\t} ${minSizeValue} ${maxSizeValue}`;\n\t\t\t\t\t\t\t\tif (!incorrectMinMaxSizeSet.has(warningKey)) {\n\t\t\t\t\t\t\t\t\tincorrectMinMaxSizeSet.add(warningKey);\n\t\t\t\t\t\t\t\t\tcompilation.warnings.push(\n\t\t\t\t\t\t\t\t\t\tnew MinMaxSizeWarning(keys, minSizeValue, maxSizeValue)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst results = deterministicGroupingForModules({\n\t\t\t\t\t\t\tminSize,\n\t\t\t\t\t\t\tmaxSize: mapObject(maxSize, (value, key) => {\n\t\t\t\t\t\t\t\tconst minSizeValue = minSize[key];\n\t\t\t\t\t\t\t\treturn typeof minSizeValue === \"number\"\n\t\t\t\t\t\t\t\t\t? Math.max(value, minSizeValue)\n\t\t\t\t\t\t\t\t\t: value;\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\titems: chunkGraph.getChunkModulesIterable(chunk),\n\t\t\t\t\t\t\tgetKey(module) {\n\t\t\t\t\t\t\t\tconst cache = getKeyCache.get(module);\n\t\t\t\t\t\t\t\tif (cache !== undefined) return cache;\n\t\t\t\t\t\t\t\tconst ident = cachedMakePathsRelative(module.identifier());\n\t\t\t\t\t\t\t\tconst nameForCondition =\n\t\t\t\t\t\t\t\t\tmodule.nameForCondition && module.nameForCondition();\n\t\t\t\t\t\t\t\tconst name = nameForCondition\n\t\t\t\t\t\t\t\t\t? cachedMakePathsRelative(nameForCondition)\n\t\t\t\t\t\t\t\t\t: ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n\t\t\t\t\t\t\t\tconst fullKey =\n\t\t\t\t\t\t\t\t\tname +\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter +\n\t\t\t\t\t\t\t\t\thashFilename(ident, outputOptions);\n\t\t\t\t\t\t\t\tconst key = requestToId(fullKey);\n\t\t\t\t\t\t\t\tgetKeyCache.set(module, key);\n\t\t\t\t\t\t\t\treturn key;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgetSize(module) {\n\t\t\t\t\t\t\t\tconst size = Object.create(null);\n\t\t\t\t\t\t\t\tfor (const key of module.getSourceTypes()) {\n\t\t\t\t\t\t\t\t\tsize[key] = module.size(key);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn size;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (results.length <= 1) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\t\t\t\t\tconst group = results[i];\n\t\t\t\t\t\t\tconst key = this.options.hidePathInfo\n\t\t\t\t\t\t\t\t? hashFilename(group.key, outputOptions)\n\t\t\t\t\t\t\t\t: group.key;\n\t\t\t\t\t\t\tlet name = chunk.name\n\t\t\t\t\t\t\t\t? chunk.name + automaticNameDelimiter + key\n\t\t\t\t\t\t\t\t: null;\n\t\t\t\t\t\t\tif (name && name.length > 100) {\n\t\t\t\t\t\t\t\tname =\n\t\t\t\t\t\t\t\t\tname.slice(0, 100) +\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter +\n\t\t\t\t\t\t\t\t\thashFilename(name, outputOptions);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i !== results.length - 1) {\n\t\t\t\t\t\t\t\tconst newPart = compilation.addChunk(name);\n\t\t\t\t\t\t\t\tchunk.split(newPart);\n\t\t\t\t\t\t\t\tnewPart.chunkReason = chunk.chunkReason;\n\t\t\t\t\t\t\t\t// Add all modules to the new chunk\n\t\t\t\t\t\t\t\tfor (const module of group.items) {\n\t\t\t\t\t\t\t\t\tif (!module.chunkCondition(newPart, compilation)) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Add module to new chunk\n\t\t\t\t\t\t\t\t\tchunkGraph.connectChunkAndModule(newPart, module);\n\t\t\t\t\t\t\t\t\t// Remove module from used chunks\n\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// change the chunk to be a part\n\t\t\t\t\t\t\t\tchunk.name = name;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"maxSize\");\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}