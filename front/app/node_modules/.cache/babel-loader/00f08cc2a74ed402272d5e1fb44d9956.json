{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _toConsumableArray = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _slicedToArray = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _require = require(\"./util/ArrayHelpers\"),\n    equals = _require.equals;\n\nvar SortableSet = require(\"./util/SortableSet\");\n\nvar makeSerializable = require(\"./util/makeSerializable\");\n\nvar _require2 = require(\"./util/runtime\"),\n    forEachRuntime = _require2.forEachRuntime;\n/** @typedef {import(\"./Dependency\").RuntimeSpec} RuntimeSpec */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n\n/** @typedef {import(\"./ModuleGraphConnection\")} ModuleGraphConnection */\n\n/** @typedef {import(\"./util/Hash\")} Hash */\n\n/** @typedef {typeof UsageState.OnlyPropertiesUsed | typeof UsageState.NoInfo | typeof UsageState.Unknown | typeof UsageState.Used} RuntimeUsageStateType */\n\n/** @typedef {typeof UsageState.Unused | RuntimeUsageStateType} UsageStateType */\n\n\nvar UsageState = Object.freeze({\n  Unused:\n  /** @type {0} */\n  0,\n  OnlyPropertiesUsed:\n  /** @type {1} */\n  1,\n  NoInfo:\n  /** @type {2} */\n  2,\n  Unknown:\n  /** @type {3} */\n  3,\n  Used:\n  /** @type {4} */\n  4\n});\n\nvar RETURNS_TRUE = function RETURNS_TRUE() {\n  return true;\n};\n\nvar CIRCULAR = Symbol(\"circular target\");\n\nvar RestoreProvidedData = /*#__PURE__*/function () {\n  function RestoreProvidedData(exports, otherProvided, otherCanMangleProvide, otherTerminalBinding) {\n    _classCallCheck(this, RestoreProvidedData);\n\n    this.exports = exports;\n    this.otherProvided = otherProvided;\n    this.otherCanMangleProvide = otherCanMangleProvide;\n    this.otherTerminalBinding = otherTerminalBinding;\n  }\n\n  _createClass(RestoreProvidedData, [{\n    key: \"serialize\",\n    value: function serialize(_ref) {\n      var write = _ref.write;\n      write(this.exports);\n      write(this.otherProvided);\n      write(this.otherCanMangleProvide);\n      write(this.otherTerminalBinding);\n    }\n  }], [{\n    key: \"deserialize\",\n    value: function deserialize(_ref2) {\n      var read = _ref2.read;\n      return new RestoreProvidedData(read(), read(), read(), read());\n    }\n  }]);\n\n  return RestoreProvidedData;\n}();\n\nmakeSerializable(RestoreProvidedData, \"webpack/lib/ModuleGraph\", \"RestoreProvidedData\");\n\nvar ExportsInfo = /*#__PURE__*/function () {\n  function ExportsInfo() {\n    _classCallCheck(this, ExportsInfo);\n\n    /** @type {Map<string, ExportInfo>} */\n    this._exports = new Map();\n    this._otherExportsInfo = new ExportInfo(null);\n    this._sideEffectsOnlyInfo = new ExportInfo(\"*side effects only*\");\n    this._exportsAreOrdered = false;\n    /** @type {ExportsInfo=} */\n\n    this._redirectTo = undefined;\n  }\n  /**\n   * @returns {Iterable<ExportInfo>} all owned exports in any order\n   */\n\n\n  _createClass(ExportsInfo, [{\n    key: \"ownedExports\",\n    get: function get() {\n      return this._exports.values();\n    }\n    /**\n     * @returns {Iterable<ExportInfo>} all owned exports in order\n     */\n\n  }, {\n    key: \"orderedOwnedExports\",\n    get: function get() {\n      if (!this._exportsAreOrdered) {\n        this._sortExports();\n      }\n\n      return this._exports.values();\n    }\n    /**\n     * @returns {Iterable<ExportInfo>} all exports in any order\n     */\n\n  }, {\n    key: \"exports\",\n    get: function get() {\n      if (this._redirectTo !== undefined) {\n        var map = new Map(this._redirectTo._exports);\n\n        var _iterator = _createForOfIteratorHelper(this._exports),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n                key = _step$value[0],\n                value = _step$value[1];\n\n            map.set(key, value);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        return map.values();\n      }\n\n      return this._exports.values();\n    }\n    /**\n     * @returns {Iterable<ExportInfo>} all exports in order\n     */\n\n  }, {\n    key: \"orderedExports\",\n    get: function get() {\n      if (!this._exportsAreOrdered) {\n        this._sortExports();\n      }\n\n      if (this._redirectTo !== undefined) {\n        var map = new Map(Array.from(this._redirectTo.orderedExports, function (item) {\n          return [item.name, item];\n        }));\n\n        var _iterator2 = _createForOfIteratorHelper(this._exports),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _step2$value = _slicedToArray(_step2.value, 2),\n                key = _step2$value[0],\n                value = _step2$value[1];\n\n            map.set(key, value);\n          } // sorting should be pretty fast as map contains\n          // a lot of presorted items\n\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        this._sortExportsMap(map);\n\n        return map.values();\n      }\n\n      return this._exports.values();\n    }\n    /**\n     * @returns {ExportInfo} the export info of unlisted exports\n     */\n\n  }, {\n    key: \"otherExportsInfo\",\n    get: function get() {\n      if (this._redirectTo !== undefined) return this._redirectTo.otherExportsInfo;\n      return this._otherExportsInfo;\n    }\n  }, {\n    key: \"_sortExportsMap\",\n    value: function _sortExportsMap(exports) {\n      if (exports.size > 1) {\n        var namesInOrder = [];\n\n        var _iterator3 = _createForOfIteratorHelper(exports.values()),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var entry = _step3.value;\n            namesInOrder.push(entry.name);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        namesInOrder.sort();\n        var i = 0;\n\n        var _iterator4 = _createForOfIteratorHelper(exports.values()),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _entry = _step4.value;\n            var _name = namesInOrder[i];\n            if (_entry.name !== _name) break;\n            i++;\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        for (; i < namesInOrder.length; i++) {\n          var name = namesInOrder[i];\n          var correctEntry = exports.get(name);\n          exports.delete(name);\n          exports.set(name, correctEntry);\n        }\n      }\n    }\n  }, {\n    key: \"_sortExports\",\n    value: function _sortExports() {\n      this._sortExportsMap(this._exports);\n\n      this._exportsAreOrdered = true;\n    }\n  }, {\n    key: \"setRedirectNamedTo\",\n    value: function setRedirectNamedTo(exportsInfo) {\n      if (this._redirectTo === exportsInfo) return false;\n      this._redirectTo = exportsInfo;\n      return true;\n    }\n  }, {\n    key: \"setHasProvideInfo\",\n    value: function setHasProvideInfo() {\n      var _iterator5 = _createForOfIteratorHelper(this._exports.values()),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var exportInfo = _step5.value;\n\n          if (exportInfo.provided === undefined) {\n            exportInfo.provided = false;\n          }\n\n          if (exportInfo.canMangleProvide === undefined) {\n            exportInfo.canMangleProvide = true;\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      if (this._redirectTo !== undefined) {\n        this._redirectTo.setHasProvideInfo();\n      } else {\n        if (this._otherExportsInfo.provided === undefined) {\n          this._otherExportsInfo.provided = false;\n        }\n\n        if (this._otherExportsInfo.canMangleProvide === undefined) {\n          this._otherExportsInfo.canMangleProvide = true;\n        }\n      }\n    }\n  }, {\n    key: \"setHasUseInfo\",\n    value: function setHasUseInfo() {\n      var _iterator6 = _createForOfIteratorHelper(this._exports.values()),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var exportInfo = _step6.value;\n          exportInfo.setHasUseInfo();\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      this._sideEffectsOnlyInfo.setHasUseInfo();\n\n      if (this._redirectTo !== undefined) {\n        this._redirectTo.setHasUseInfo();\n      } else {\n        this._otherExportsInfo.setHasUseInfo();\n\n        if (this._otherExportsInfo.canMangleUse === undefined) {\n          this._otherExportsInfo.canMangleUse = true;\n        }\n      }\n    }\n    /**\n     * @param {string} name export name\n     * @returns {ExportInfo} export info for this name\n     */\n\n  }, {\n    key: \"getOwnExportInfo\",\n    value: function getOwnExportInfo(name) {\n      var info = this._exports.get(name);\n\n      if (info !== undefined) return info;\n      var newInfo = new ExportInfo(name, this._otherExportsInfo);\n\n      this._exports.set(name, newInfo);\n\n      this._exportsAreOrdered = false;\n      return newInfo;\n    }\n    /**\n     * @param {string} name export name\n     * @returns {ExportInfo} export info for this name\n     */\n\n  }, {\n    key: \"getExportInfo\",\n    value: function getExportInfo(name) {\n      var info = this._exports.get(name);\n\n      if (info !== undefined) return info;\n      if (this._redirectTo !== undefined) return this._redirectTo.getExportInfo(name);\n      var newInfo = new ExportInfo(name, this._otherExportsInfo);\n\n      this._exports.set(name, newInfo);\n\n      this._exportsAreOrdered = false;\n      return newInfo;\n    }\n    /**\n     * @param {string} name export name\n     * @returns {ExportInfo} export info for this name\n     */\n\n  }, {\n    key: \"getReadOnlyExportInfo\",\n    value: function getReadOnlyExportInfo(name) {\n      var info = this._exports.get(name);\n\n      if (info !== undefined) return info;\n      if (this._redirectTo !== undefined) return this._redirectTo.getReadOnlyExportInfo(name);\n      return this._otherExportsInfo;\n    }\n    /**\n     * @param {string[]} name export name\n     * @returns {ExportInfo | undefined} export info for this name\n     */\n\n  }, {\n    key: \"getReadOnlyExportInfoRecursive\",\n    value: function getReadOnlyExportInfoRecursive(name) {\n      var exportInfo = this.getReadOnlyExportInfo(name[0]);\n      if (name.length === 1) return exportInfo;\n      if (!exportInfo.exportsInfo) return undefined;\n      return exportInfo.exportsInfo.getReadOnlyExportInfoRecursive(name.slice(1));\n    }\n    /**\n     * @param {string[]=} name the export name\n     * @returns {ExportsInfo | undefined} the nested exports info\n     */\n\n  }, {\n    key: \"getNestedExportsInfo\",\n    value: function getNestedExportsInfo(name) {\n      if (Array.isArray(name) && name.length > 0) {\n        var info = this.getReadOnlyExportInfo(name[0]);\n        if (!info.exportsInfo) return undefined;\n        return info.exportsInfo.getNestedExportsInfo(name.slice(1));\n      }\n\n      return this;\n    }\n    /**\n     * @param {boolean=} canMangle true, if exports can still be mangled (defaults to false)\n     * @param {Set<string>=} excludeExports list of unaffected exports\n     * @param {any=} targetKey use this as key for the target\n     * @param {ModuleGraphConnection=} targetModule set this module as target\n     * @param {number=} priority priority\n     * @returns {boolean} true, if this call changed something\n     */\n\n  }, {\n    key: \"setUnknownExportsProvided\",\n    value: function setUnknownExportsProvided(canMangle, excludeExports, targetKey, targetModule, priority) {\n      var changed = false;\n\n      if (excludeExports) {\n        var _iterator7 = _createForOfIteratorHelper(excludeExports),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var name = _step7.value;\n            // Make sure these entries exist, so they can get different info\n            this.getExportInfo(name);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      }\n\n      var _iterator8 = _createForOfIteratorHelper(this._exports.values()),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var exportInfo = _step8.value;\n\n          if (!canMangle && exportInfo.canMangleProvide !== false) {\n            exportInfo.canMangleProvide = false;\n            changed = true;\n          }\n\n          if (excludeExports && excludeExports.has(exportInfo.name)) continue;\n\n          if (exportInfo.provided !== true && exportInfo.provided !== null) {\n            exportInfo.provided = null;\n            changed = true;\n          }\n\n          if (targetKey) {\n            exportInfo.setTarget(targetKey, targetModule, [exportInfo.name], -1);\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      if (this._redirectTo !== undefined) {\n        if (this._redirectTo.setUnknownExportsProvided(canMangle, excludeExports, targetKey, targetModule, priority)) {\n          changed = true;\n        }\n      } else {\n        if (this._otherExportsInfo.provided !== true && this._otherExportsInfo.provided !== null) {\n          this._otherExportsInfo.provided = null;\n          changed = true;\n        }\n\n        if (!canMangle && this._otherExportsInfo.canMangleProvide !== false) {\n          this._otherExportsInfo.canMangleProvide = false;\n          changed = true;\n        }\n\n        if (targetKey) {\n          this._otherExportsInfo.setTarget(targetKey, targetModule, undefined, priority);\n        }\n      }\n\n      return changed;\n    }\n    /**\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {boolean} true, when something changed\n     */\n\n  }, {\n    key: \"setUsedInUnknownWay\",\n    value: function setUsedInUnknownWay(runtime) {\n      var changed = false;\n\n      var _iterator9 = _createForOfIteratorHelper(this._exports.values()),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var exportInfo = _step9.value;\n\n          if (exportInfo.setUsedInUnknownWay(runtime)) {\n            changed = true;\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      if (this._redirectTo !== undefined) {\n        if (this._redirectTo.setUsedInUnknownWay(runtime)) {\n          changed = true;\n        }\n      } else {\n        if (this._otherExportsInfo.setUsedConditionally(function (used) {\n          return used < UsageState.Unknown;\n        }, UsageState.Unknown, runtime)) {\n          changed = true;\n        }\n\n        if (this._otherExportsInfo.canMangleUse !== false) {\n          this._otherExportsInfo.canMangleUse = false;\n          changed = true;\n        }\n      }\n\n      return changed;\n    }\n    /**\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {boolean} true, when something changed\n     */\n\n  }, {\n    key: \"setUsedWithoutInfo\",\n    value: function setUsedWithoutInfo(runtime) {\n      var changed = false;\n\n      var _iterator10 = _createForOfIteratorHelper(this._exports.values()),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var exportInfo = _step10.value;\n\n          if (exportInfo.setUsedWithoutInfo(runtime)) {\n            changed = true;\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      if (this._redirectTo !== undefined) {\n        if (this._redirectTo.setUsedWithoutInfo(runtime)) {\n          changed = true;\n        }\n      } else {\n        if (this._otherExportsInfo.setUsed(UsageState.NoInfo, runtime)) {\n          changed = true;\n        }\n\n        if (this._otherExportsInfo.canMangleUse !== false) {\n          this._otherExportsInfo.canMangleUse = false;\n          changed = true;\n        }\n      }\n\n      return changed;\n    }\n    /**\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {boolean} true, when something changed\n     */\n\n  }, {\n    key: \"setAllKnownExportsUsed\",\n    value: function setAllKnownExportsUsed(runtime) {\n      var changed = false;\n\n      var _iterator11 = _createForOfIteratorHelper(this._exports.values()),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var exportInfo = _step11.value;\n          if (!exportInfo.provided) continue;\n\n          if (exportInfo.setUsed(UsageState.Used, runtime)) {\n            changed = true;\n          }\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n\n      return changed;\n    }\n    /**\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {boolean} true, when something changed\n     */\n\n  }, {\n    key: \"setUsedForSideEffectsOnly\",\n    value: function setUsedForSideEffectsOnly(runtime) {\n      return this._sideEffectsOnlyInfo.setUsedConditionally(function (used) {\n        return used === UsageState.Unused;\n      }, UsageState.Used, runtime);\n    }\n    /**\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {boolean} true, when the module exports are used in any way\n     */\n\n  }, {\n    key: \"isUsed\",\n    value: function isUsed(runtime) {\n      if (this._redirectTo !== undefined) {\n        if (this._redirectTo.isUsed(runtime)) {\n          return true;\n        }\n      } else {\n        if (this._otherExportsInfo.getUsed(runtime) !== UsageState.Unused) {\n          return true;\n        }\n      }\n\n      var _iterator12 = _createForOfIteratorHelper(this._exports.values()),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var exportInfo = _step12.value;\n\n          if (exportInfo.getUsed(runtime) !== UsageState.Unused) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n\n      return false;\n    }\n    /**\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {boolean} true, when the module is used in any way\n     */\n\n  }, {\n    key: \"isModuleUsed\",\n    value: function isModuleUsed(runtime) {\n      if (this.isUsed(runtime)) return true;\n      if (this._sideEffectsOnlyInfo.getUsed(runtime) !== UsageState.Unused) return true;\n      return false;\n    }\n    /**\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {SortableSet<string> | boolean | null} set of used exports, or true (when namespace object is used), or false (when unused), or null (when unknown)\n     */\n\n  }, {\n    key: \"getUsedExports\",\n    value: function getUsedExports(runtime) {\n      if (!this._redirectTo !== undefined) {\n        switch (this._otherExportsInfo.getUsed(runtime)) {\n          case UsageState.NoInfo:\n            return null;\n\n          case UsageState.Unknown:\n          case UsageState.OnlyPropertiesUsed:\n          case UsageState.Used:\n            return true;\n        }\n      }\n\n      var array = [];\n      if (!this._exportsAreOrdered) this._sortExports();\n\n      var _iterator13 = _createForOfIteratorHelper(this._exports.values()),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var exportInfo = _step13.value;\n\n          switch (exportInfo.getUsed(runtime)) {\n            case UsageState.NoInfo:\n              return null;\n\n            case UsageState.Unknown:\n              return true;\n\n            case UsageState.OnlyPropertiesUsed:\n            case UsageState.Used:\n              array.push(exportInfo.name);\n          }\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n\n      if (this._redirectTo !== undefined) {\n        var inner = this._redirectTo.getUsedExports(runtime);\n\n        if (inner === null) return null;\n        if (inner === true) return true;\n\n        if (inner !== false) {\n          var _iterator14 = _createForOfIteratorHelper(inner),\n              _step14;\n\n          try {\n            for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n              var item = _step14.value;\n              array.push(item);\n            }\n          } catch (err) {\n            _iterator14.e(err);\n          } finally {\n            _iterator14.f();\n          }\n        }\n      }\n\n      if (array.length === 0) {\n        switch (this._sideEffectsOnlyInfo.getUsed(runtime)) {\n          case UsageState.NoInfo:\n            return null;\n\n          case UsageState.Unused:\n            return false;\n        }\n      }\n\n      return new SortableSet(array);\n    }\n    /**\n     * @returns {null | true | string[]} list of exports when known\n     */\n\n  }, {\n    key: \"getProvidedExports\",\n    value: function getProvidedExports() {\n      if (!this._redirectTo !== undefined) {\n        switch (this._otherExportsInfo.provided) {\n          case undefined:\n            return null;\n\n          case null:\n            return true;\n\n          case true:\n            return true;\n        }\n      }\n\n      var array = [];\n      if (!this._exportsAreOrdered) this._sortExports();\n\n      var _iterator15 = _createForOfIteratorHelper(this._exports.values()),\n          _step15;\n\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var exportInfo = _step15.value;\n\n          switch (exportInfo.provided) {\n            case undefined:\n              return null;\n\n            case null:\n              return true;\n\n            case true:\n              array.push(exportInfo.name);\n          }\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n\n      if (this._redirectTo !== undefined) {\n        var inner = this._redirectTo.getProvidedExports();\n\n        if (inner === null) return null;\n        if (inner === true) return true;\n\n        var _iterator16 = _createForOfIteratorHelper(inner),\n            _step16;\n\n        try {\n          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n            var item = _step16.value;\n\n            if (!array.includes(item)) {\n              array.push(item);\n            }\n          }\n        } catch (err) {\n          _iterator16.e(err);\n        } finally {\n          _iterator16.f();\n        }\n      }\n\n      return array;\n    }\n    /**\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {ExportInfo[]} exports that are relevant (not unused and potential provided)\n     */\n\n  }, {\n    key: \"getRelevantExports\",\n    value: function getRelevantExports(runtime) {\n      var list = [];\n\n      var _iterator17 = _createForOfIteratorHelper(this._exports.values()),\n          _step17;\n\n      try {\n        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n          var _exportInfo = _step17.value;\n\n          var used = _exportInfo.getUsed(runtime);\n\n          if (used === UsageState.Unused) continue;\n          if (_exportInfo.provided === false) continue;\n          list.push(_exportInfo);\n        }\n      } catch (err) {\n        _iterator17.e(err);\n      } finally {\n        _iterator17.f();\n      }\n\n      if (this._redirectTo !== undefined) {\n        var _iterator18 = _createForOfIteratorHelper(this._redirectTo.getRelevantExports(runtime)),\n            _step18;\n\n        try {\n          for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n            var exportInfo = _step18.value;\n            if (!this._exports.has(exportInfo.name)) list.push(exportInfo);\n          }\n        } catch (err) {\n          _iterator18.e(err);\n        } finally {\n          _iterator18.f();\n        }\n      }\n\n      if (this._otherExportsInfo.provided !== false && this._otherExportsInfo.getUsed(runtime) !== UsageState.Unused) {\n        list.push(this._otherExportsInfo);\n      }\n\n      return list;\n    }\n    /**\n     * @param {string | string[]} name the name of the export\n     * @returns {boolean | undefined | null} if the export is provided\n     */\n\n  }, {\n    key: \"isExportProvided\",\n    value: function isExportProvided(name) {\n      if (Array.isArray(name)) {\n        var _info = this.getReadOnlyExportInfo(name[0]);\n\n        if (_info.exportsInfo && name.length > 1) {\n          return _info.exportsInfo.isExportProvided(name.slice(1));\n        }\n\n        return _info.provided;\n      }\n\n      var info = this.getReadOnlyExportInfo(name);\n      return info.provided;\n    }\n    /**\n     * @param {RuntimeSpec} runtime runtime\n     * @returns {string} key representing the usage\n     */\n\n  }, {\n    key: \"getUsageKey\",\n    value: function getUsageKey(runtime) {\n      var key = [];\n\n      if (this._redirectTo !== undefined) {\n        key.push(this._redirectTo.getUsageKey(runtime));\n      } else {\n        key.push(this._otherExportsInfo.getUsed(runtime));\n      }\n\n      key.push(this._sideEffectsOnlyInfo.getUsed(runtime));\n\n      var _iterator19 = _createForOfIteratorHelper(this.orderedOwnedExports),\n          _step19;\n\n      try {\n        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n          var exportInfo = _step19.value;\n          key.push(exportInfo.getUsed(runtime));\n        }\n      } catch (err) {\n        _iterator19.e(err);\n      } finally {\n        _iterator19.f();\n      }\n\n      return key.join(\"|\");\n    }\n    /**\n     * @param {RuntimeSpec} runtimeA first runtime\n     * @param {RuntimeSpec} runtimeB second runtime\n     * @returns {boolean} true, when equally used\n     */\n\n  }, {\n    key: \"isEquallyUsed\",\n    value: function isEquallyUsed(runtimeA, runtimeB) {\n      if (this._redirectTo !== undefined) {\n        if (!this._redirectTo.isEquallyUsed(runtimeA, runtimeB)) return false;\n      } else {\n        if (this._otherExportsInfo.getUsed(runtimeA) !== this._otherExportsInfo.getUsed(runtimeB)) {\n          return false;\n        }\n      }\n\n      if (this._sideEffectsOnlyInfo.getUsed(runtimeA) !== this._sideEffectsOnlyInfo.getUsed(runtimeB)) {\n        return false;\n      }\n\n      var _iterator20 = _createForOfIteratorHelper(this.ownedExports),\n          _step20;\n\n      try {\n        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n          var exportInfo = _step20.value;\n          if (exportInfo.getUsed(runtimeA) !== exportInfo.getUsed(runtimeB)) return false;\n        }\n      } catch (err) {\n        _iterator20.e(err);\n      } finally {\n        _iterator20.f();\n      }\n\n      return true;\n    }\n    /**\n     * @param {string | string[]} name export name\n     * @param {RuntimeSpec} runtime check usage for this runtime only\n     * @returns {UsageStateType} usage status\n     */\n\n  }, {\n    key: \"getUsed\",\n    value: function getUsed(name, runtime) {\n      if (Array.isArray(name)) {\n        if (name.length === 0) return this.otherExportsInfo.getUsed(runtime);\n\n        var _info2 = this.getReadOnlyExportInfo(name[0]);\n\n        if (_info2.exportsInfo && name.length > 1) {\n          return _info2.exportsInfo.getUsed(name.slice(1), runtime);\n        }\n\n        return _info2.getUsed(runtime);\n      }\n\n      var info = this.getReadOnlyExportInfo(name);\n      return info.getUsed(runtime);\n    }\n    /**\n     * @param {string | string[]} name the export name\n     * @param {RuntimeSpec} runtime check usage for this runtime only\n     * @returns {string | string[] | false} the used name\n     */\n\n  }, {\n    key: \"getUsedName\",\n    value: function getUsedName(name, runtime) {\n      if (Array.isArray(name)) {\n        // TODO improve this\n        if (name.length === 0) {\n          if (!this.isUsed(runtime)) return false;\n          return name;\n        }\n\n        var info = this.getReadOnlyExportInfo(name[0]);\n        var x = info.getUsedName(name[0], runtime);\n        if (x === false) return false;\n        var arr = x === name[0] && name.length === 1 ? name : [x];\n\n        if (name.length === 1) {\n          return arr;\n        }\n\n        if (info.exportsInfo && info.getUsed(runtime) === UsageState.OnlyPropertiesUsed) {\n          var nested = info.exportsInfo.getUsedName(name.slice(1), runtime);\n          if (!nested) return false;\n          return arr.concat(nested);\n        } else {\n          return arr.concat(name.slice(1));\n        }\n      } else {\n        var _info3 = this.getReadOnlyExportInfo(name);\n\n        var usedName = _info3.getUsedName(name, runtime);\n\n        return usedName;\n      }\n    }\n    /**\n     * @param {Hash} hash the hash\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {void}\n     */\n\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash, runtime) {\n      this._updateHash(hash, runtime, new Set());\n    }\n    /**\n     * @param {Hash} hash the hash\n     * @param {RuntimeSpec} runtime the runtime\n     * @param {Set<ExportsInfo>} alreadyVisitedExportsInfo for circular references\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_updateHash\",\n    value: function _updateHash(hash, runtime, alreadyVisitedExportsInfo) {\n      var set = new Set(alreadyVisitedExportsInfo);\n      set.add(this);\n\n      var _iterator21 = _createForOfIteratorHelper(this.orderedExports),\n          _step21;\n\n      try {\n        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n          var exportInfo = _step21.value;\n\n          if (exportInfo.hasInfo(this._otherExportsInfo, runtime)) {\n            exportInfo._updateHash(hash, runtime, set);\n          }\n        }\n      } catch (err) {\n        _iterator21.e(err);\n      } finally {\n        _iterator21.f();\n      }\n\n      this._sideEffectsOnlyInfo._updateHash(hash, runtime, set);\n\n      this._otherExportsInfo._updateHash(hash, runtime, set);\n\n      if (this._redirectTo !== undefined) {\n        this._redirectTo._updateHash(hash, runtime, set);\n      }\n    }\n  }, {\n    key: \"getRestoreProvidedData\",\n    value: function getRestoreProvidedData() {\n      var otherProvided = this._otherExportsInfo.provided;\n      var otherCanMangleProvide = this._otherExportsInfo.canMangleProvide;\n      var otherTerminalBinding = this._otherExportsInfo.terminalBinding;\n      var exports = [];\n\n      var _iterator22 = _createForOfIteratorHelper(this.orderedExports),\n          _step22;\n\n      try {\n        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n          var exportInfo = _step22.value;\n\n          if (exportInfo.provided !== otherProvided || exportInfo.canMangleProvide !== otherCanMangleProvide || exportInfo.terminalBinding !== otherTerminalBinding || exportInfo.exportsInfoOwned) {\n            exports.push({\n              name: exportInfo.name,\n              provided: exportInfo.provided,\n              canMangleProvide: exportInfo.canMangleProvide,\n              terminalBinding: exportInfo.terminalBinding,\n              exportsInfo: exportInfo.exportsInfoOwned ? exportInfo.exportsInfo.getRestoreProvidedData() : undefined\n            });\n          }\n        }\n      } catch (err) {\n        _iterator22.e(err);\n      } finally {\n        _iterator22.f();\n      }\n\n      return new RestoreProvidedData(exports, otherProvided, otherCanMangleProvide, otherTerminalBinding);\n    }\n  }, {\n    key: \"restoreProvided\",\n    value: function restoreProvided(_ref3) {\n      var otherProvided = _ref3.otherProvided,\n          otherCanMangleProvide = _ref3.otherCanMangleProvide,\n          otherTerminalBinding = _ref3.otherTerminalBinding,\n          exports = _ref3.exports;\n      var wasEmpty = true;\n\n      var _iterator23 = _createForOfIteratorHelper(this._exports.values()),\n          _step23;\n\n      try {\n        for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n          var exportInfo = _step23.value;\n          wasEmpty = false;\n          exportInfo.provided = otherProvided;\n          exportInfo.canMangleProvide = otherCanMangleProvide;\n          exportInfo.terminalBinding = otherTerminalBinding;\n        }\n      } catch (err) {\n        _iterator23.e(err);\n      } finally {\n        _iterator23.f();\n      }\n\n      this._otherExportsInfo.provided = otherProvided;\n      this._otherExportsInfo.canMangleProvide = otherCanMangleProvide;\n      this._otherExportsInfo.terminalBinding = otherTerminalBinding;\n\n      var _iterator24 = _createForOfIteratorHelper(exports),\n          _step24;\n\n      try {\n        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n          var exp = _step24.value;\n\n          var _exportInfo2 = this.getExportInfo(exp.name);\n\n          _exportInfo2.provided = exp.provided;\n          _exportInfo2.canMangleProvide = exp.canMangleProvide;\n          _exportInfo2.terminalBinding = exp.terminalBinding;\n\n          if (exp.exportsInfo) {\n            var exportsInfo = _exportInfo2.createNestedExportsInfo();\n\n            exportsInfo.restoreProvided(exp.exportsInfo);\n          }\n        }\n      } catch (err) {\n        _iterator24.e(err);\n      } finally {\n        _iterator24.f();\n      }\n\n      if (wasEmpty) this._exportsAreOrdered = true;\n    }\n  }]);\n\n  return ExportsInfo;\n}();\n\nvar ExportInfo = /*#__PURE__*/function () {\n  /**\n   * @param {string} name the original name of the export\n   * @param {ExportInfo=} initFrom init values from this ExportInfo\n   */\n  function ExportInfo(name, initFrom) {\n    _classCallCheck(this, ExportInfo);\n\n    /** @type {string} */\n    this.name = name;\n    /** @private @type {string | null} */\n\n    this._usedName = initFrom ? initFrom._usedName : null;\n    /** @private @type {UsageStateType} */\n\n    this._globalUsed = initFrom ? initFrom._globalUsed : undefined;\n    /** @private @type {Map<string, RuntimeUsageStateType>} */\n\n    this._usedInRuntime = initFrom && initFrom._usedInRuntime ? new Map(initFrom._usedInRuntime) : undefined;\n    /** @private @type {boolean} */\n\n    this._hasUseInRuntimeInfo = initFrom ? initFrom._hasUseInRuntimeInfo : false;\n    /**\n     * true: it is provided\n     * false: it is not provided\n     * null: only the runtime knows if it is provided\n     * undefined: it was not determined if it is provided\n     * @type {boolean | null | undefined}\n     */\n\n    this.provided = initFrom ? initFrom.provided : undefined;\n    /**\n     * is the export a terminal binding that should be checked for export star conflicts\n     * @type {boolean}\n     */\n\n    this.terminalBinding = initFrom ? initFrom.terminalBinding : false;\n    /**\n     * true: it can be mangled\n     * false: is can not be mangled\n     * undefined: it was not determined if it can be mangled\n     * @type {boolean | undefined}\n     */\n\n    this.canMangleProvide = initFrom ? initFrom.canMangleProvide : undefined;\n    /**\n     * true: it can be mangled\n     * false: is can not be mangled\n     * undefined: it was not determined if it can be mangled\n     * @type {boolean | undefined}\n     */\n\n    this.canMangleUse = initFrom ? initFrom.canMangleUse : undefined;\n    /** @type {boolean} */\n\n    this.exportsInfoOwned = false;\n    /** @type {ExportsInfo=} */\n\n    this.exportsInfo = undefined;\n    /** @type {Map<any, { connection: ModuleGraphConnection | null, export: string[], priority: number }>=} */\n\n    this._target = undefined;\n\n    if (initFrom && initFrom._target) {\n      this._target = new Map();\n\n      var _iterator25 = _createForOfIteratorHelper(initFrom._target),\n          _step25;\n\n      try {\n        for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n          var _step25$value = _slicedToArray(_step25.value, 2),\n              key = _step25$value[0],\n              value = _step25$value[1];\n\n          this._target.set(key, {\n            connection: value.connection,\n            export: value.export || [name],\n            priority: value.priority\n          });\n        }\n      } catch (err) {\n        _iterator25.e(err);\n      } finally {\n        _iterator25.f();\n      }\n    }\n    /** @type {Map<any, { connection: ModuleGraphConnection | null, export: string[], priority: number }>=} */\n\n\n    this._maxTarget = undefined;\n  } // TODO webpack 5 remove\n\n  /** @private */\n\n\n  _createClass(ExportInfo, [{\n    key: \"used\",\n    get: function get() {\n      throw new Error(\"REMOVED\");\n    }\n    /** @private */\n    ,\n    set:\n    /**\n     * @private\n     * @param {*} v v\n     */\n    function set(v) {\n      throw new Error(\"REMOVED\");\n    }\n    /**\n     * @private\n     * @param {*} v v\n     */\n\n  }, {\n    key: \"usedName\",\n    get: function get() {\n      throw new Error(\"REMOVED\");\n    },\n    set: function set(v) {\n      throw new Error(\"REMOVED\");\n    }\n  }, {\n    key: \"canMangle\",\n    get: function get() {\n      switch (this.canMangleProvide) {\n        case undefined:\n          return this.canMangleUse === false ? false : undefined;\n\n        case false:\n          return false;\n\n        case true:\n          switch (this.canMangleUse) {\n            case undefined:\n              return undefined;\n\n            case false:\n              return false;\n\n            case true:\n              return true;\n          }\n\n      }\n\n      throw new Error(\"Unexpected flags for canMangle \".concat(this.canMangleProvide, \" \").concat(this.canMangleUse));\n    }\n    /**\n     * @param {RuntimeSpec} runtime only apply to this runtime\n     * @returns {boolean} true, when something changed\n     */\n\n  }, {\n    key: \"setUsedInUnknownWay\",\n    value: function setUsedInUnknownWay(runtime) {\n      var changed = false;\n\n      if (this.setUsedConditionally(function (used) {\n        return used < UsageState.Unknown;\n      }, UsageState.Unknown, runtime)) {\n        changed = true;\n      }\n\n      if (this.canMangleUse !== false) {\n        this.canMangleUse = false;\n        changed = true;\n      }\n\n      return changed;\n    }\n    /**\n     * @param {RuntimeSpec} runtime only apply to this runtime\n     * @returns {boolean} true, when something changed\n     */\n\n  }, {\n    key: \"setUsedWithoutInfo\",\n    value: function setUsedWithoutInfo(runtime) {\n      var changed = false;\n\n      if (this.setUsed(UsageState.NoInfo, runtime)) {\n        changed = true;\n      }\n\n      if (this.canMangleUse !== false) {\n        this.canMangleUse = false;\n        changed = true;\n      }\n\n      return changed;\n    }\n  }, {\n    key: \"setHasUseInfo\",\n    value: function setHasUseInfo() {\n      if (!this._hasUseInRuntimeInfo) {\n        this._hasUseInRuntimeInfo = true;\n      }\n\n      if (this.canMangleUse === undefined) {\n        this.canMangleUse = true;\n      }\n\n      if (this.exportsInfoOwned) {\n        this.exportsInfo.setHasUseInfo();\n      }\n    }\n    /**\n     * @param {function(UsageStateType): boolean} condition compare with old value\n     * @param {UsageStateType} newValue set when condition is true\n     * @param {RuntimeSpec} runtime only apply to this runtime\n     * @returns {boolean} true when something has changed\n     */\n\n  }, {\n    key: \"setUsedConditionally\",\n    value: function setUsedConditionally(condition, newValue, runtime) {\n      var _this = this;\n\n      if (runtime === undefined) {\n        if (this._globalUsed === undefined) {\n          this._globalUsed = newValue;\n          return true;\n        } else {\n          if (this._globalUsed !== newValue && condition(this._globalUsed)) {\n            this._globalUsed = newValue;\n            return true;\n          }\n        }\n      } else if (this._usedInRuntime === undefined) {\n        if (newValue !== UsageState.Unused && condition(UsageState.Unused)) {\n          this._usedInRuntime = new Map();\n          forEachRuntime(runtime, function (runtime) {\n            return _this._usedInRuntime.set(runtime, newValue);\n          });\n          return true;\n        }\n      } else {\n        var changed = false;\n        forEachRuntime(runtime, function (runtime) {\n          /** @type {UsageStateType} */\n          var oldValue = _this._usedInRuntime.get(runtime);\n\n          if (oldValue === undefined) oldValue = UsageState.Unused;\n\n          if (newValue !== oldValue && condition(oldValue)) {\n            if (newValue === UsageState.Unused) {\n              _this._usedInRuntime.delete(runtime);\n            } else {\n              _this._usedInRuntime.set(runtime, newValue);\n            }\n\n            changed = true;\n          }\n        });\n\n        if (changed) {\n          if (this._usedInRuntime.size === 0) this._usedInRuntime = undefined;\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * @param {UsageStateType} newValue new value of the used state\n     * @param {RuntimeSpec} runtime only apply to this runtime\n     * @returns {boolean} true when something has changed\n     */\n\n  }, {\n    key: \"setUsed\",\n    value: function setUsed(newValue, runtime) {\n      var _this2 = this;\n\n      if (runtime === undefined) {\n        if (this._globalUsed !== newValue) {\n          this._globalUsed = newValue;\n          return true;\n        }\n      } else if (this._usedInRuntime === undefined) {\n        if (newValue !== UsageState.Unused) {\n          this._usedInRuntime = new Map();\n          forEachRuntime(runtime, function (runtime) {\n            return _this2._usedInRuntime.set(runtime, newValue);\n          });\n          return true;\n        }\n      } else {\n        var changed = false;\n        forEachRuntime(runtime, function (runtime) {\n          /** @type {UsageStateType} */\n          var oldValue = _this2._usedInRuntime.get(runtime);\n\n          if (oldValue === undefined) oldValue = UsageState.Unused;\n\n          if (newValue !== oldValue) {\n            if (newValue === UsageState.Unused) {\n              _this2._usedInRuntime.delete(runtime);\n            } else {\n              _this2._usedInRuntime.set(runtime, newValue);\n            }\n\n            changed = true;\n          }\n        });\n\n        if (changed) {\n          if (this._usedInRuntime.size === 0) this._usedInRuntime = undefined;\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * @param {any} key the key\n     * @returns {boolean} true, if something has changed\n     */\n\n  }, {\n    key: \"unsetTarget\",\n    value: function unsetTarget(key) {\n      if (!this._target) return false;\n\n      if (this._target.delete(key)) {\n        this._maxTarget = undefined;\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * @param {any} key the key\n     * @param {ModuleGraphConnection} connection the target module if a single one\n     * @param {string[]=} exportName the exported name\n     * @param {number=} priority priority\n     * @returns {boolean} true, if something has changed\n     */\n\n  }, {\n    key: \"setTarget\",\n    value: function setTarget(key, connection, exportName) {\n      var priority = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      if (exportName) exportName = _toConsumableArray(exportName);\n\n      if (!this._target) {\n        this._target = new Map();\n\n        this._target.set(key, {\n          connection: connection,\n          export: exportName,\n          priority: priority\n        });\n\n        return true;\n      }\n\n      var oldTarget = this._target.get(key);\n\n      if (!oldTarget) {\n        if (oldTarget === null && !connection) return false;\n\n        this._target.set(key, {\n          connection: connection,\n          export: exportName,\n          priority: priority\n        });\n\n        this._maxTarget = undefined;\n        return true;\n      }\n\n      if (oldTarget.connection !== connection || oldTarget.priority !== priority || (exportName ? !oldTarget.export || !equals(oldTarget.export, exportName) : oldTarget.export)) {\n        oldTarget.connection = connection;\n        oldTarget.export = exportName;\n        oldTarget.priority = priority;\n        this._maxTarget = undefined;\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * @param {RuntimeSpec} runtime for this runtime\n     * @returns {UsageStateType} usage state\n     */\n\n  }, {\n    key: \"getUsed\",\n    value: function getUsed(runtime) {\n      if (!this._hasUseInRuntimeInfo) return UsageState.NoInfo;\n      if (this._globalUsed !== undefined) return this._globalUsed;\n\n      if (this._usedInRuntime === undefined) {\n        return UsageState.Unused;\n      } else if (typeof runtime === \"string\") {\n        var value = this._usedInRuntime.get(runtime);\n\n        return value === undefined ? UsageState.Unused : value;\n      } else if (runtime === undefined) {\n        /** @type {UsageStateType} */\n        var max = UsageState.Unused;\n\n        var _iterator26 = _createForOfIteratorHelper(this._usedInRuntime.values()),\n            _step26;\n\n        try {\n          for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n            var _value = _step26.value;\n\n            if (_value === UsageState.Used) {\n              return UsageState.Used;\n            }\n\n            if (max < _value) max = _value;\n          }\n        } catch (err) {\n          _iterator26.e(err);\n        } finally {\n          _iterator26.f();\n        }\n\n        return max;\n      } else {\n        /** @type {UsageStateType} */\n        var _max = UsageState.Unused;\n\n        var _iterator27 = _createForOfIteratorHelper(runtime),\n            _step27;\n\n        try {\n          for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n            var item = _step27.value;\n\n            var _value2 = this._usedInRuntime.get(item);\n\n            if (_value2 !== undefined) {\n              if (_value2 === UsageState.Used) {\n                return UsageState.Used;\n              }\n\n              if (_max < _value2) _max = _value2;\n            }\n          }\n        } catch (err) {\n          _iterator27.e(err);\n        } finally {\n          _iterator27.f();\n        }\n\n        return _max;\n      }\n    }\n    /**\n     * get used name\n     * @param {string | undefined} fallbackName fallback name for used exports with no name\n     * @param {RuntimeSpec} runtime check usage for this runtime only\n     * @returns {string | false} used name\n     */\n\n  }, {\n    key: \"getUsedName\",\n    value: function getUsedName(fallbackName, runtime) {\n      var _this3 = this;\n\n      if (this._hasUseInRuntimeInfo) {\n        if (this._globalUsed !== undefined) {\n          if (this._globalUsed === UsageState.Unused) return false;\n        } else {\n          if (this._usedInRuntime === undefined) return false;\n\n          if (typeof runtime === \"string\") {\n            if (!this._usedInRuntime.has(runtime)) {\n              return false;\n            }\n          } else if (runtime !== undefined) {\n            if (Array.from(runtime).every(function (runtime) {\n              return !_this3._usedInRuntime.has(runtime);\n            })) {\n              return false;\n            }\n          }\n        }\n      }\n\n      if (this._usedName !== null) return this._usedName;\n      return this.name || fallbackName;\n    }\n    /**\n     * @returns {boolean} true, when a mangled name of this export is set\n     */\n\n  }, {\n    key: \"hasUsedName\",\n    value: function hasUsedName() {\n      return this._usedName !== null;\n    }\n    /**\n     * Sets the mangled name of this export\n     * @param {string} name the new name\n     * @returns {void}\n     */\n\n  }, {\n    key: \"setUsedName\",\n    value: function setUsedName(name) {\n      this._usedName = name;\n    }\n    /**\n     * @param {ModuleGraph} moduleGraph the module graph\n     * @param {function({ module: Module, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\n     * @returns {ExportInfo | ExportsInfo | undefined} the terminal binding export(s) info if known\n     */\n\n  }, {\n    key: \"getTerminalBinding\",\n    value: function getTerminalBinding(moduleGraph) {\n      var resolveTargetFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : RETURNS_TRUE;\n      if (this.terminalBinding) return this;\n      var target = this.getTarget(moduleGraph, resolveTargetFilter);\n      if (!target) return undefined;\n      var exportsInfo = moduleGraph.getExportsInfo(target.module);\n      if (!target.export) return exportsInfo;\n      return exportsInfo.getReadOnlyExportInfoRecursive(target.export);\n    }\n  }, {\n    key: \"isReexport\",\n    value: function isReexport() {\n      return !this.terminalBinding && this._target && this._target.size > 0;\n    }\n  }, {\n    key: \"_getMaxTarget\",\n    value: function _getMaxTarget() {\n      if (this._maxTarget !== undefined) return this._maxTarget;\n      if (this._target.size <= 1) return this._maxTarget = this._target;\n      var maxPriority = -Infinity;\n      var minPriority = Infinity;\n\n      var _iterator28 = _createForOfIteratorHelper(this._target.values()),\n          _step28;\n\n      try {\n        for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n          var priority = _step28.value.priority;\n          if (maxPriority < priority) maxPriority = priority;\n          if (minPriority > priority) minPriority = priority;\n        } // This should be very common\n\n      } catch (err) {\n        _iterator28.e(err);\n      } finally {\n        _iterator28.f();\n      }\n\n      if (maxPriority === minPriority) return this._maxTarget = this._target; // This is an edge case\n\n      var map = new Map();\n\n      var _iterator29 = _createForOfIteratorHelper(this._target),\n          _step29;\n\n      try {\n        for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n          var _step29$value = _slicedToArray(_step29.value, 2),\n              key = _step29$value[0],\n              value = _step29$value[1];\n\n          if (maxPriority === value.priority) {\n            map.set(key, value);\n          }\n        }\n      } catch (err) {\n        _iterator29.e(err);\n      } finally {\n        _iterator29.f();\n      }\n\n      this._maxTarget = map;\n      return map;\n    }\n    /**\n     * @param {ModuleGraph} moduleGraph the module graph\n     * @param {function(Module): boolean} validTargetModuleFilter a valid target module\n     * @returns {{ module: Module, export: string[] | undefined } | undefined | false} the target, undefined when there is no target, false when no target is valid\n     */\n\n  }, {\n    key: \"findTarget\",\n    value: function findTarget(moduleGraph, validTargetModuleFilter) {\n      return this._findTarget(moduleGraph, validTargetModuleFilter, new Set());\n    }\n    /**\n     * @param {ModuleGraph} moduleGraph the module graph\n     * @param {function(Module): boolean} validTargetModuleFilter a valid target module\n     * @param {Set<ExportInfo> | undefined} alreadyVisited set of already visited export info to avoid circular references\n     * @returns {{ module: Module, export: string[] | undefined } | undefined | false} the target, undefined when there is no target, false when no target is valid\n     */\n\n  }, {\n    key: \"_findTarget\",\n    value: function _findTarget(moduleGraph, validTargetModuleFilter, alreadyVisited) {\n      if (!this._target || this._target.size === 0) return undefined;\n\n      var rawTarget = this._getMaxTarget().values().next().value;\n\n      if (!rawTarget) return undefined;\n      /** @type {{ module: Module, export: string[] | undefined }} */\n\n      var target = {\n        module: rawTarget.connection.module,\n        export: rawTarget.export\n      };\n\n      for (;;) {\n        if (validTargetModuleFilter(target.module)) return target;\n        var exportsInfo = moduleGraph.getExportsInfo(target.module);\n        var exportInfo = exportsInfo.getExportInfo(target.export[0]);\n        if (alreadyVisited.has(exportInfo)) return null;\n\n        var newTarget = exportInfo._findTarget(moduleGraph, validTargetModuleFilter, alreadyVisited);\n\n        if (!newTarget) return false;\n\n        if (target.export.length === 1) {\n          target = newTarget;\n        } else {\n          target = {\n            module: newTarget.module,\n            export: newTarget.export ? newTarget.export.concat(target.export.slice(1)) : target.export.slice(1)\n          };\n        }\n      }\n    }\n    /**\n     * @param {ModuleGraph} moduleGraph the module graph\n     * @param {function({ module: Module, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\n     * @returns {{ module: Module, export: string[] | undefined } | undefined} the target\n     */\n\n  }, {\n    key: \"getTarget\",\n    value: function getTarget(moduleGraph) {\n      var resolveTargetFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : RETURNS_TRUE;\n\n      var result = this._getTarget(moduleGraph, resolveTargetFilter, undefined);\n\n      if (result === CIRCULAR) return undefined;\n      return result;\n    }\n    /**\n     * @param {ModuleGraph} moduleGraph the module graph\n     * @param {function({ module: Module, connection: ModuleGraphConnection, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\n     * @param {Set<ExportInfo> | undefined} alreadyVisited set of already visited export info to avoid circular references\n     * @returns {{ module: Module, connection: ModuleGraphConnection, export: string[] | undefined } | CIRCULAR | undefined} the target\n     */\n\n  }, {\n    key: \"_getTarget\",\n    value: function _getTarget(moduleGraph, resolveTargetFilter, alreadyVisited) {\n      /**\n       * @param {{ connection: ModuleGraphConnection, export: string[] | undefined } | null} inputTarget unresolved target\n       * @param {Set<ExportInfo>} alreadyVisited set of already visited export info to avoid circular references\n       * @returns {{ module: Module, connection: ModuleGraphConnection, export: string[] | undefined } | CIRCULAR | null} resolved target\n       */\n      var resolveTarget = function resolveTarget(inputTarget, alreadyVisited) {\n        if (!inputTarget) return null;\n\n        if (!inputTarget.export) {\n          return {\n            module: inputTarget.connection.module,\n            connection: inputTarget.connection,\n            export: undefined\n          };\n        }\n        /** @type {{ module: Module, connection: ModuleGraphConnection, export: string[] | undefined }} */\n\n\n        var target = {\n          module: inputTarget.connection.module,\n          connection: inputTarget.connection,\n          export: inputTarget.export\n        };\n        if (!resolveTargetFilter(target)) return target;\n        var alreadyVisitedOwned = false;\n\n        for (;;) {\n          var exportsInfo = moduleGraph.getExportsInfo(target.module);\n          var exportInfo = exportsInfo.getExportInfo(target.export[0]);\n          if (!exportInfo) return target;\n          if (alreadyVisited.has(exportInfo)) return CIRCULAR;\n\n          var newTarget = exportInfo._getTarget(moduleGraph, resolveTargetFilter, alreadyVisited);\n\n          if (newTarget === CIRCULAR) return CIRCULAR;\n          if (!newTarget) return target;\n\n          if (target.export.length === 1) {\n            target = newTarget;\n            if (!target.export) return target;\n          } else {\n            target = {\n              module: newTarget.module,\n              connection: newTarget.connection,\n              export: newTarget.export ? newTarget.export.concat(target.export.slice(1)) : target.export.slice(1)\n            };\n          }\n\n          if (!resolveTargetFilter(target)) return target;\n\n          if (!alreadyVisitedOwned) {\n            alreadyVisited = new Set(alreadyVisited);\n            alreadyVisitedOwned = true;\n          }\n\n          alreadyVisited.add(exportInfo);\n        }\n      };\n\n      if (!this._target || this._target.size === 0) return undefined;\n      if (alreadyVisited && alreadyVisited.has(this)) return CIRCULAR;\n      var newAlreadyVisited = new Set(alreadyVisited);\n      newAlreadyVisited.add(this);\n\n      var values = this._getMaxTarget().values();\n\n      var target = resolveTarget(values.next().value, newAlreadyVisited);\n      if (target === CIRCULAR) return CIRCULAR;\n      if (target === null) return undefined;\n      var result = values.next();\n\n      while (!result.done) {\n        var t = resolveTarget(result.value, newAlreadyVisited);\n        if (t === CIRCULAR) return CIRCULAR;\n        if (t === null) return undefined;\n        if (t.module !== target.module) return undefined;\n        if (!t.export !== !target.export) return undefined;\n        if (target.export && !equals(t.export, target.export)) return undefined;\n        result = values.next();\n      }\n\n      return target;\n    }\n    /**\n     * Move the target forward as long resolveTargetFilter is fulfilled\n     * @param {ModuleGraph} moduleGraph the module graph\n     * @param {function({ module: Module, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\n     * @param {function({ module: Module, export: string[] | undefined }): ModuleGraphConnection=} updateOriginalConnection updates the original connection instead of using the target connection\n     * @returns {{ module: Module, export: string[] | undefined } | undefined} the resolved target when moved\n     */\n\n  }, {\n    key: \"moveTarget\",\n    value: function moveTarget(moduleGraph, resolveTargetFilter, updateOriginalConnection) {\n      var target = this._getTarget(moduleGraph, resolveTargetFilter, undefined);\n\n      if (target === CIRCULAR) return undefined;\n      if (!target) return undefined;\n\n      var originalTarget = this._getMaxTarget().values().next().value;\n\n      if (originalTarget.connection === target.connection && originalTarget.export === target.export) {\n        return undefined;\n      }\n\n      this._target.clear();\n\n      this._target.set(undefined, {\n        connection: updateOriginalConnection ? updateOriginalConnection(target) : target.connection,\n        export: target.export,\n        priority: 0\n      });\n\n      return target;\n    }\n  }, {\n    key: \"createNestedExportsInfo\",\n    value: function createNestedExportsInfo() {\n      if (this.exportsInfoOwned) return this.exportsInfo;\n      this.exportsInfoOwned = true;\n      var oldExportsInfo = this.exportsInfo;\n      this.exportsInfo = new ExportsInfo();\n      this.exportsInfo.setHasProvideInfo();\n\n      if (oldExportsInfo) {\n        this.exportsInfo.setRedirectNamedTo(oldExportsInfo);\n      }\n\n      return this.exportsInfo;\n    }\n  }, {\n    key: \"getNestedExportsInfo\",\n    value: function getNestedExportsInfo() {\n      return this.exportsInfo;\n    }\n  }, {\n    key: \"hasInfo\",\n    value: function hasInfo(baseInfo, runtime) {\n      return this._usedName && this._usedName !== this.name || this.provided || this.terminalBinding || this.getUsed(runtime) !== baseInfo.getUsed(runtime);\n    }\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash, runtime) {\n      this._updateHash(hash, runtime, new Set());\n    }\n  }, {\n    key: \"_updateHash\",\n    value: function _updateHash(hash, runtime, alreadyVisitedExportsInfo) {\n      hash.update(\"\".concat(this._usedName || this.name).concat(this.getUsed(runtime)).concat(this.provided).concat(this.terminalBinding));\n\n      if (this.exportsInfo && !alreadyVisitedExportsInfo.has(this.exportsInfo)) {\n        this.exportsInfo._updateHash(hash, runtime, alreadyVisitedExportsInfo);\n      }\n    }\n  }, {\n    key: \"getUsedInfo\",\n    value: function getUsedInfo() {\n      if (this._globalUsed !== undefined) {\n        switch (this._globalUsed) {\n          case UsageState.Unused:\n            return \"unused\";\n\n          case UsageState.NoInfo:\n            return \"no usage info\";\n\n          case UsageState.Unknown:\n            return \"maybe used (runtime-defined)\";\n\n          case UsageState.Used:\n            return \"used\";\n\n          case UsageState.OnlyPropertiesUsed:\n            return \"only properties used\";\n        }\n      } else if (this._usedInRuntime !== undefined) {\n        /** @type {Map<RuntimeUsageStateType, string[]>} */\n        var map = new Map();\n\n        var _iterator30 = _createForOfIteratorHelper(this._usedInRuntime),\n            _step30;\n\n        try {\n          for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n            var _step30$value = _slicedToArray(_step30.value, 2),\n                runtime = _step30$value[0],\n                used = _step30$value[1];\n\n            var list = map.get(used);\n            if (list !== undefined) list.push(runtime);else map.set(used, [runtime]);\n          }\n        } catch (err) {\n          _iterator30.e(err);\n        } finally {\n          _iterator30.f();\n        }\n\n        var specificInfo = Array.from(map, function (_ref4) {\n          var _ref5 = _slicedToArray(_ref4, 2),\n              used = _ref5[0],\n              runtimes = _ref5[1];\n\n          switch (used) {\n            case UsageState.NoInfo:\n              return \"no usage info in \".concat(runtimes.join(\", \"));\n\n            case UsageState.Unknown:\n              return \"maybe used in \".concat(runtimes.join(\", \"), \" (runtime-defined)\");\n\n            case UsageState.Used:\n              return \"used in \".concat(runtimes.join(\", \"));\n\n            case UsageState.OnlyPropertiesUsed:\n              return \"only properties used in \".concat(runtimes.join(\", \"));\n          }\n        });\n\n        if (specificInfo.length > 0) {\n          return specificInfo.join(\"; \");\n        }\n      }\n\n      return this._hasUseInRuntimeInfo ? \"unused\" : \"no usage info\";\n    }\n  }, {\n    key: \"getProvidedInfo\",\n    value: function getProvidedInfo() {\n      switch (this.provided) {\n        case undefined:\n          return \"no provided info\";\n\n        case null:\n          return \"maybe provided (runtime-defined)\";\n\n        case true:\n          return \"provided\";\n\n        case false:\n          return \"not provided\";\n      }\n    }\n  }, {\n    key: \"getRenameInfo\",\n    value: function getRenameInfo() {\n      if (this._usedName !== null && this._usedName !== this.name) {\n        return \"renamed to \".concat(JSON.stringify(this._usedName).slice(1, -1));\n      }\n\n      switch (this.canMangleProvide) {\n        case undefined:\n          switch (this.canMangleUse) {\n            case undefined:\n              return \"missing provision and use info prevents renaming\";\n\n            case false:\n              return \"usage prevents renaming (no provision info)\";\n\n            case true:\n              return \"missing provision info prevents renaming\";\n          }\n\n          break;\n\n        case true:\n          switch (this.canMangleUse) {\n            case undefined:\n              return \"missing usage info prevents renaming\";\n\n            case false:\n              return \"usage prevents renaming\";\n\n            case true:\n              return \"could be renamed\";\n          }\n\n          break;\n\n        case false:\n          switch (this.canMangleUse) {\n            case undefined:\n              return \"provision prevents renaming (no use info)\";\n\n            case false:\n              return \"usage and provision prevents renaming\";\n\n            case true:\n              return \"provision prevents renaming\";\n          }\n\n          break;\n      }\n\n      throw new Error(\"Unexpected flags for getRenameInfo \".concat(this.canMangleProvide, \" \").concat(this.canMangleUse));\n    }\n  }]);\n\n  return ExportInfo;\n}();\n\nmodule.exports = ExportsInfo;\nmodule.exports.ExportInfo = ExportInfo;\nmodule.exports.UsageState = UsageState;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/ExportsInfo.js"],"names":["require","equals","SortableSet","makeSerializable","forEachRuntime","UsageState","Object","freeze","Unused","OnlyPropertiesUsed","NoInfo","Unknown","Used","RETURNS_TRUE","CIRCULAR","Symbol","RestoreProvidedData","exports","otherProvided","otherCanMangleProvide","otherTerminalBinding","write","read","ExportsInfo","_exports","Map","_otherExportsInfo","ExportInfo","_sideEffectsOnlyInfo","_exportsAreOrdered","_redirectTo","undefined","values","_sortExports","map","key","value","set","Array","from","orderedExports","item","name","_sortExportsMap","otherExportsInfo","size","namesInOrder","entry","push","sort","i","length","correctEntry","get","delete","exportsInfo","exportInfo","provided","canMangleProvide","setHasProvideInfo","setHasUseInfo","canMangleUse","info","newInfo","getExportInfo","getReadOnlyExportInfo","getReadOnlyExportInfoRecursive","slice","isArray","getNestedExportsInfo","canMangle","excludeExports","targetKey","targetModule","priority","changed","has","setTarget","setUnknownExportsProvided","runtime","setUsedInUnknownWay","setUsedConditionally","used","setUsedWithoutInfo","setUsed","isUsed","getUsed","array","inner","getUsedExports","getProvidedExports","includes","list","getRelevantExports","isExportProvided","getUsageKey","orderedOwnedExports","join","runtimeA","runtimeB","isEquallyUsed","ownedExports","x","getUsedName","arr","nested","concat","usedName","hash","_updateHash","Set","alreadyVisitedExportsInfo","add","hasInfo","terminalBinding","exportsInfoOwned","getRestoreProvidedData","wasEmpty","exp","createNestedExportsInfo","restoreProvided","initFrom","_usedName","_globalUsed","_usedInRuntime","_hasUseInRuntimeInfo","_target","connection","export","_maxTarget","Error","v","condition","newValue","oldValue","exportName","oldTarget","max","fallbackName","every","moduleGraph","resolveTargetFilter","target","getTarget","getExportsInfo","module","maxPriority","Infinity","minPriority","validTargetModuleFilter","_findTarget","alreadyVisited","rawTarget","_getMaxTarget","next","newTarget","result","_getTarget","resolveTarget","inputTarget","alreadyVisitedOwned","newAlreadyVisited","done","t","updateOriginalConnection","originalTarget","clear","oldExportsInfo","setRedirectNamedTo","baseInfo","update","specificInfo","runtimes","JSON","stringify"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { equals } = require(\"./util/ArrayHelpers\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst makeSerializable = require(\"./util/makeSerializable\");\nconst { forEachRuntime } = require(\"./util/runtime\");\n\n/** @typedef {import(\"./Dependency\").RuntimeSpec} RuntimeSpec */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./ModuleGraphConnection\")} ModuleGraphConnection */\n/** @typedef {import(\"./util/Hash\")} Hash */\n\n/** @typedef {typeof UsageState.OnlyPropertiesUsed | typeof UsageState.NoInfo | typeof UsageState.Unknown | typeof UsageState.Used} RuntimeUsageStateType */\n/** @typedef {typeof UsageState.Unused | RuntimeUsageStateType} UsageStateType */\n\nconst UsageState = Object.freeze({\n\tUnused: /** @type {0} */ (0),\n\tOnlyPropertiesUsed: /** @type {1} */ (1),\n\tNoInfo: /** @type {2} */ (2),\n\tUnknown: /** @type {3} */ (3),\n\tUsed: /** @type {4} */ (4)\n});\n\nconst RETURNS_TRUE = () => true;\n\nconst CIRCULAR = Symbol(\"circular target\");\n\nclass RestoreProvidedData {\n\tconstructor(\n\t\texports,\n\t\totherProvided,\n\t\totherCanMangleProvide,\n\t\totherTerminalBinding\n\t) {\n\t\tthis.exports = exports;\n\t\tthis.otherProvided = otherProvided;\n\t\tthis.otherCanMangleProvide = otherCanMangleProvide;\n\t\tthis.otherTerminalBinding = otherTerminalBinding;\n\t}\n\n\tserialize({ write }) {\n\t\twrite(this.exports);\n\t\twrite(this.otherProvided);\n\t\twrite(this.otherCanMangleProvide);\n\t\twrite(this.otherTerminalBinding);\n\t}\n\n\tstatic deserialize({ read }) {\n\t\treturn new RestoreProvidedData(read(), read(), read(), read());\n\t}\n}\n\nmakeSerializable(\n\tRestoreProvidedData,\n\t\"webpack/lib/ModuleGraph\",\n\t\"RestoreProvidedData\"\n);\n\nclass ExportsInfo {\n\tconstructor() {\n\t\t/** @type {Map<string, ExportInfo>} */\n\t\tthis._exports = new Map();\n\t\tthis._otherExportsInfo = new ExportInfo(null);\n\t\tthis._sideEffectsOnlyInfo = new ExportInfo(\"*side effects only*\");\n\t\tthis._exportsAreOrdered = false;\n\t\t/** @type {ExportsInfo=} */\n\t\tthis._redirectTo = undefined;\n\t}\n\n\t/**\n\t * @returns {Iterable<ExportInfo>} all owned exports in any order\n\t */\n\tget ownedExports() {\n\t\treturn this._exports.values();\n\t}\n\n\t/**\n\t * @returns {Iterable<ExportInfo>} all owned exports in order\n\t */\n\tget orderedOwnedExports() {\n\t\tif (!this._exportsAreOrdered) {\n\t\t\tthis._sortExports();\n\t\t}\n\t\treturn this._exports.values();\n\t}\n\n\t/**\n\t * @returns {Iterable<ExportInfo>} all exports in any order\n\t */\n\tget exports() {\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tconst map = new Map(this._redirectTo._exports);\n\t\t\tfor (const [key, value] of this._exports) {\n\t\t\t\tmap.set(key, value);\n\t\t\t}\n\t\t\treturn map.values();\n\t\t}\n\t\treturn this._exports.values();\n\t}\n\n\t/**\n\t * @returns {Iterable<ExportInfo>} all exports in order\n\t */\n\tget orderedExports() {\n\t\tif (!this._exportsAreOrdered) {\n\t\t\tthis._sortExports();\n\t\t}\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tconst map = new Map(\n\t\t\t\tArray.from(this._redirectTo.orderedExports, item => [item.name, item])\n\t\t\t);\n\t\t\tfor (const [key, value] of this._exports) {\n\t\t\t\tmap.set(key, value);\n\t\t\t}\n\t\t\t// sorting should be pretty fast as map contains\n\t\t\t// a lot of presorted items\n\t\t\tthis._sortExportsMap(map);\n\t\t\treturn map.values();\n\t\t}\n\t\treturn this._exports.values();\n\t}\n\n\t/**\n\t * @returns {ExportInfo} the export info of unlisted exports\n\t */\n\tget otherExportsInfo() {\n\t\tif (this._redirectTo !== undefined)\n\t\t\treturn this._redirectTo.otherExportsInfo;\n\t\treturn this._otherExportsInfo;\n\t}\n\n\t_sortExportsMap(exports) {\n\t\tif (exports.size > 1) {\n\t\t\tconst namesInOrder = [];\n\t\t\tfor (const entry of exports.values()) {\n\t\t\t\tnamesInOrder.push(entry.name);\n\t\t\t}\n\t\t\tnamesInOrder.sort();\n\t\t\tlet i = 0;\n\t\t\tfor (const entry of exports.values()) {\n\t\t\t\tconst name = namesInOrder[i];\n\t\t\t\tif (entry.name !== name) break;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tfor (; i < namesInOrder.length; i++) {\n\t\t\t\tconst name = namesInOrder[i];\n\t\t\t\tconst correctEntry = exports.get(name);\n\t\t\t\texports.delete(name);\n\t\t\t\texports.set(name, correctEntry);\n\t\t\t}\n\t\t}\n\t}\n\n\t_sortExports() {\n\t\tthis._sortExportsMap(this._exports);\n\t\tthis._exportsAreOrdered = true;\n\t}\n\n\tsetRedirectNamedTo(exportsInfo) {\n\t\tif (this._redirectTo === exportsInfo) return false;\n\t\tthis._redirectTo = exportsInfo;\n\t\treturn true;\n\t}\n\n\tsetHasProvideInfo() {\n\t\tfor (const exportInfo of this._exports.values()) {\n\t\t\tif (exportInfo.provided === undefined) {\n\t\t\t\texportInfo.provided = false;\n\t\t\t}\n\t\t\tif (exportInfo.canMangleProvide === undefined) {\n\t\t\t\texportInfo.canMangleProvide = true;\n\t\t\t}\n\t\t}\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tthis._redirectTo.setHasProvideInfo();\n\t\t} else {\n\t\t\tif (this._otherExportsInfo.provided === undefined) {\n\t\t\t\tthis._otherExportsInfo.provided = false;\n\t\t\t}\n\t\t\tif (this._otherExportsInfo.canMangleProvide === undefined) {\n\t\t\t\tthis._otherExportsInfo.canMangleProvide = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tsetHasUseInfo() {\n\t\tfor (const exportInfo of this._exports.values()) {\n\t\t\texportInfo.setHasUseInfo();\n\t\t}\n\t\tthis._sideEffectsOnlyInfo.setHasUseInfo();\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tthis._redirectTo.setHasUseInfo();\n\t\t} else {\n\t\t\tthis._otherExportsInfo.setHasUseInfo();\n\t\t\tif (this._otherExportsInfo.canMangleUse === undefined) {\n\t\t\t\tthis._otherExportsInfo.canMangleUse = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} name export name\n\t * @returns {ExportInfo} export info for this name\n\t */\n\tgetOwnExportInfo(name) {\n\t\tconst info = this._exports.get(name);\n\t\tif (info !== undefined) return info;\n\t\tconst newInfo = new ExportInfo(name, this._otherExportsInfo);\n\t\tthis._exports.set(name, newInfo);\n\t\tthis._exportsAreOrdered = false;\n\t\treturn newInfo;\n\t}\n\n\t/**\n\t * @param {string} name export name\n\t * @returns {ExportInfo} export info for this name\n\t */\n\tgetExportInfo(name) {\n\t\tconst info = this._exports.get(name);\n\t\tif (info !== undefined) return info;\n\t\tif (this._redirectTo !== undefined)\n\t\t\treturn this._redirectTo.getExportInfo(name);\n\t\tconst newInfo = new ExportInfo(name, this._otherExportsInfo);\n\t\tthis._exports.set(name, newInfo);\n\t\tthis._exportsAreOrdered = false;\n\t\treturn newInfo;\n\t}\n\n\t/**\n\t * @param {string} name export name\n\t * @returns {ExportInfo} export info for this name\n\t */\n\tgetReadOnlyExportInfo(name) {\n\t\tconst info = this._exports.get(name);\n\t\tif (info !== undefined) return info;\n\t\tif (this._redirectTo !== undefined)\n\t\t\treturn this._redirectTo.getReadOnlyExportInfo(name);\n\t\treturn this._otherExportsInfo;\n\t}\n\n\t/**\n\t * @param {string[]} name export name\n\t * @returns {ExportInfo | undefined} export info for this name\n\t */\n\tgetReadOnlyExportInfoRecursive(name) {\n\t\tconst exportInfo = this.getReadOnlyExportInfo(name[0]);\n\t\tif (name.length === 1) return exportInfo;\n\t\tif (!exportInfo.exportsInfo) return undefined;\n\t\treturn exportInfo.exportsInfo.getReadOnlyExportInfoRecursive(name.slice(1));\n\t}\n\n\t/**\n\t * @param {string[]=} name the export name\n\t * @returns {ExportsInfo | undefined} the nested exports info\n\t */\n\tgetNestedExportsInfo(name) {\n\t\tif (Array.isArray(name) && name.length > 0) {\n\t\t\tconst info = this.getReadOnlyExportInfo(name[0]);\n\t\t\tif (!info.exportsInfo) return undefined;\n\t\t\treturn info.exportsInfo.getNestedExportsInfo(name.slice(1));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {boolean=} canMangle true, if exports can still be mangled (defaults to false)\n\t * @param {Set<string>=} excludeExports list of unaffected exports\n\t * @param {any=} targetKey use this as key for the target\n\t * @param {ModuleGraphConnection=} targetModule set this module as target\n\t * @param {number=} priority priority\n\t * @returns {boolean} true, if this call changed something\n\t */\n\tsetUnknownExportsProvided(\n\t\tcanMangle,\n\t\texcludeExports,\n\t\ttargetKey,\n\t\ttargetModule,\n\t\tpriority\n\t) {\n\t\tlet changed = false;\n\t\tif (excludeExports) {\n\t\t\tfor (const name of excludeExports) {\n\t\t\t\t// Make sure these entries exist, so they can get different info\n\t\t\t\tthis.getExportInfo(name);\n\t\t\t}\n\t\t}\n\t\tfor (const exportInfo of this._exports.values()) {\n\t\t\tif (!canMangle && exportInfo.canMangleProvide !== false) {\n\t\t\t\texportInfo.canMangleProvide = false;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (excludeExports && excludeExports.has(exportInfo.name)) continue;\n\t\t\tif (exportInfo.provided !== true && exportInfo.provided !== null) {\n\t\t\t\texportInfo.provided = null;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (targetKey) {\n\t\t\t\texportInfo.setTarget(targetKey, targetModule, [exportInfo.name], -1);\n\t\t\t}\n\t\t}\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tif (\n\t\t\t\tthis._redirectTo.setUnknownExportsProvided(\n\t\t\t\t\tcanMangle,\n\t\t\t\t\texcludeExports,\n\t\t\t\t\ttargetKey,\n\t\t\t\t\ttargetModule,\n\t\t\t\t\tpriority\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (\n\t\t\t\tthis._otherExportsInfo.provided !== true &&\n\t\t\t\tthis._otherExportsInfo.provided !== null\n\t\t\t) {\n\t\t\t\tthis._otherExportsInfo.provided = null;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (!canMangle && this._otherExportsInfo.canMangleProvide !== false) {\n\t\t\t\tthis._otherExportsInfo.canMangleProvide = false;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (targetKey) {\n\t\t\t\tthis._otherExportsInfo.setTarget(\n\t\t\t\t\ttargetKey,\n\t\t\t\t\ttargetModule,\n\t\t\t\t\tundefined,\n\t\t\t\t\tpriority\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn changed;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {boolean} true, when something changed\n\t */\n\tsetUsedInUnknownWay(runtime) {\n\t\tlet changed = false;\n\t\tfor (const exportInfo of this._exports.values()) {\n\t\t\tif (exportInfo.setUsedInUnknownWay(runtime)) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tif (this._redirectTo.setUsedInUnknownWay(runtime)) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (\n\t\t\t\tthis._otherExportsInfo.setUsedConditionally(\n\t\t\t\t\tused => used < UsageState.Unknown,\n\t\t\t\t\tUsageState.Unknown,\n\t\t\t\t\truntime\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (this._otherExportsInfo.canMangleUse !== false) {\n\t\t\t\tthis._otherExportsInfo.canMangleUse = false;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\t\treturn changed;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {boolean} true, when something changed\n\t */\n\tsetUsedWithoutInfo(runtime) {\n\t\tlet changed = false;\n\t\tfor (const exportInfo of this._exports.values()) {\n\t\t\tif (exportInfo.setUsedWithoutInfo(runtime)) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tif (this._redirectTo.setUsedWithoutInfo(runtime)) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (this._otherExportsInfo.setUsed(UsageState.NoInfo, runtime)) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (this._otherExportsInfo.canMangleUse !== false) {\n\t\t\t\tthis._otherExportsInfo.canMangleUse = false;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\t\treturn changed;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {boolean} true, when something changed\n\t */\n\tsetAllKnownExportsUsed(runtime) {\n\t\tlet changed = false;\n\t\tfor (const exportInfo of this._exports.values()) {\n\t\t\tif (!exportInfo.provided) continue;\n\t\t\tif (exportInfo.setUsed(UsageState.Used, runtime)) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\t\treturn changed;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {boolean} true, when something changed\n\t */\n\tsetUsedForSideEffectsOnly(runtime) {\n\t\treturn this._sideEffectsOnlyInfo.setUsedConditionally(\n\t\t\tused => used === UsageState.Unused,\n\t\t\tUsageState.Used,\n\t\t\truntime\n\t\t);\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {boolean} true, when the module exports are used in any way\n\t */\n\tisUsed(runtime) {\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tif (this._redirectTo.isUsed(runtime)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (this._otherExportsInfo.getUsed(runtime) !== UsageState.Unused) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tfor (const exportInfo of this._exports.values()) {\n\t\t\tif (exportInfo.getUsed(runtime) !== UsageState.Unused) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {boolean} true, when the module is used in any way\n\t */\n\tisModuleUsed(runtime) {\n\t\tif (this.isUsed(runtime)) return true;\n\t\tif (this._sideEffectsOnlyInfo.getUsed(runtime) !== UsageState.Unused)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {SortableSet<string> | boolean | null} set of used exports, or true (when namespace object is used), or false (when unused), or null (when unknown)\n\t */\n\tgetUsedExports(runtime) {\n\t\tif (!this._redirectTo !== undefined) {\n\t\t\tswitch (this._otherExportsInfo.getUsed(runtime)) {\n\t\t\t\tcase UsageState.NoInfo:\n\t\t\t\t\treturn null;\n\t\t\t\tcase UsageState.Unknown:\n\t\t\t\tcase UsageState.OnlyPropertiesUsed:\n\t\t\t\tcase UsageState.Used:\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tconst array = [];\n\t\tif (!this._exportsAreOrdered) this._sortExports();\n\t\tfor (const exportInfo of this._exports.values()) {\n\t\t\tswitch (exportInfo.getUsed(runtime)) {\n\t\t\t\tcase UsageState.NoInfo:\n\t\t\t\t\treturn null;\n\t\t\t\tcase UsageState.Unknown:\n\t\t\t\t\treturn true;\n\t\t\t\tcase UsageState.OnlyPropertiesUsed:\n\t\t\t\tcase UsageState.Used:\n\t\t\t\t\tarray.push(exportInfo.name);\n\t\t\t}\n\t\t}\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tconst inner = this._redirectTo.getUsedExports(runtime);\n\t\t\tif (inner === null) return null;\n\t\t\tif (inner === true) return true;\n\t\t\tif (inner !== false) {\n\t\t\t\tfor (const item of inner) {\n\t\t\t\t\tarray.push(item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (array.length === 0) {\n\t\t\tswitch (this._sideEffectsOnlyInfo.getUsed(runtime)) {\n\t\t\t\tcase UsageState.NoInfo:\n\t\t\t\t\treturn null;\n\t\t\t\tcase UsageState.Unused:\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn new SortableSet(array);\n\t}\n\n\t/**\n\t * @returns {null | true | string[]} list of exports when known\n\t */\n\tgetProvidedExports() {\n\t\tif (!this._redirectTo !== undefined) {\n\t\t\tswitch (this._otherExportsInfo.provided) {\n\t\t\t\tcase undefined:\n\t\t\t\t\treturn null;\n\t\t\t\tcase null:\n\t\t\t\t\treturn true;\n\t\t\t\tcase true:\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tconst array = [];\n\t\tif (!this._exportsAreOrdered) this._sortExports();\n\t\tfor (const exportInfo of this._exports.values()) {\n\t\t\tswitch (exportInfo.provided) {\n\t\t\t\tcase undefined:\n\t\t\t\t\treturn null;\n\t\t\t\tcase null:\n\t\t\t\t\treturn true;\n\t\t\t\tcase true:\n\t\t\t\t\tarray.push(exportInfo.name);\n\t\t\t}\n\t\t}\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tconst inner = this._redirectTo.getProvidedExports();\n\t\t\tif (inner === null) return null;\n\t\t\tif (inner === true) return true;\n\t\t\tfor (const item of inner) {\n\t\t\t\tif (!array.includes(item)) {\n\t\t\t\t\tarray.push(item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn array;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {ExportInfo[]} exports that are relevant (not unused and potential provided)\n\t */\n\tgetRelevantExports(runtime) {\n\t\tconst list = [];\n\t\tfor (const exportInfo of this._exports.values()) {\n\t\t\tconst used = exportInfo.getUsed(runtime);\n\t\t\tif (used === UsageState.Unused) continue;\n\t\t\tif (exportInfo.provided === false) continue;\n\t\t\tlist.push(exportInfo);\n\t\t}\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tfor (const exportInfo of this._redirectTo.getRelevantExports(runtime)) {\n\t\t\t\tif (!this._exports.has(exportInfo.name)) list.push(exportInfo);\n\t\t\t}\n\t\t}\n\t\tif (\n\t\t\tthis._otherExportsInfo.provided !== false &&\n\t\t\tthis._otherExportsInfo.getUsed(runtime) !== UsageState.Unused\n\t\t) {\n\t\t\tlist.push(this._otherExportsInfo);\n\t\t}\n\t\treturn list;\n\t}\n\n\t/**\n\t * @param {string | string[]} name the name of the export\n\t * @returns {boolean | undefined | null} if the export is provided\n\t */\n\tisExportProvided(name) {\n\t\tif (Array.isArray(name)) {\n\t\t\tconst info = this.getReadOnlyExportInfo(name[0]);\n\t\t\tif (info.exportsInfo && name.length > 1) {\n\t\t\t\treturn info.exportsInfo.isExportProvided(name.slice(1));\n\t\t\t}\n\t\t\treturn info.provided;\n\t\t}\n\t\tconst info = this.getReadOnlyExportInfo(name);\n\t\treturn info.provided;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime runtime\n\t * @returns {string} key representing the usage\n\t */\n\tgetUsageKey(runtime) {\n\t\tconst key = [];\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tkey.push(this._redirectTo.getUsageKey(runtime));\n\t\t} else {\n\t\t\tkey.push(this._otherExportsInfo.getUsed(runtime));\n\t\t}\n\t\tkey.push(this._sideEffectsOnlyInfo.getUsed(runtime));\n\t\tfor (const exportInfo of this.orderedOwnedExports) {\n\t\t\tkey.push(exportInfo.getUsed(runtime));\n\t\t}\n\t\treturn key.join(\"|\");\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtimeA first runtime\n\t * @param {RuntimeSpec} runtimeB second runtime\n\t * @returns {boolean} true, when equally used\n\t */\n\tisEquallyUsed(runtimeA, runtimeB) {\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tif (!this._redirectTo.isEquallyUsed(runtimeA, runtimeB)) return false;\n\t\t} else {\n\t\t\tif (\n\t\t\t\tthis._otherExportsInfo.getUsed(runtimeA) !==\n\t\t\t\tthis._otherExportsInfo.getUsed(runtimeB)\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (\n\t\t\tthis._sideEffectsOnlyInfo.getUsed(runtimeA) !==\n\t\t\tthis._sideEffectsOnlyInfo.getUsed(runtimeB)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (const exportInfo of this.ownedExports) {\n\t\t\tif (exportInfo.getUsed(runtimeA) !== exportInfo.getUsed(runtimeB))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {string | string[]} name export name\n\t * @param {RuntimeSpec} runtime check usage for this runtime only\n\t * @returns {UsageStateType} usage status\n\t */\n\tgetUsed(name, runtime) {\n\t\tif (Array.isArray(name)) {\n\t\t\tif (name.length === 0) return this.otherExportsInfo.getUsed(runtime);\n\t\t\tlet info = this.getReadOnlyExportInfo(name[0]);\n\t\t\tif (info.exportsInfo && name.length > 1) {\n\t\t\t\treturn info.exportsInfo.getUsed(name.slice(1), runtime);\n\t\t\t}\n\t\t\treturn info.getUsed(runtime);\n\t\t}\n\t\tlet info = this.getReadOnlyExportInfo(name);\n\t\treturn info.getUsed(runtime);\n\t}\n\n\t/**\n\t * @param {string | string[]} name the export name\n\t * @param {RuntimeSpec} runtime check usage for this runtime only\n\t * @returns {string | string[] | false} the used name\n\t */\n\tgetUsedName(name, runtime) {\n\t\tif (Array.isArray(name)) {\n\t\t\t// TODO improve this\n\t\t\tif (name.length === 0) {\n\t\t\t\tif (!this.isUsed(runtime)) return false;\n\t\t\t\treturn name;\n\t\t\t}\n\t\t\tlet info = this.getReadOnlyExportInfo(name[0]);\n\t\t\tconst x = info.getUsedName(name[0], runtime);\n\t\t\tif (x === false) return false;\n\t\t\tconst arr = x === name[0] && name.length === 1 ? name : [x];\n\t\t\tif (name.length === 1) {\n\t\t\t\treturn arr;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tinfo.exportsInfo &&\n\t\t\t\tinfo.getUsed(runtime) === UsageState.OnlyPropertiesUsed\n\t\t\t) {\n\t\t\t\tconst nested = info.exportsInfo.getUsedName(name.slice(1), runtime);\n\t\t\t\tif (!nested) return false;\n\t\t\t\treturn arr.concat(nested);\n\t\t\t} else {\n\t\t\t\treturn arr.concat(name.slice(1));\n\t\t\t}\n\t\t} else {\n\t\t\tlet info = this.getReadOnlyExportInfo(name);\n\t\t\tconst usedName = info.getUsedName(name, runtime);\n\t\t\treturn usedName;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Hash} hash the hash\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {void}\n\t */\n\tupdateHash(hash, runtime) {\n\t\tthis._updateHash(hash, runtime, new Set());\n\t}\n\n\t/**\n\t * @param {Hash} hash the hash\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {Set<ExportsInfo>} alreadyVisitedExportsInfo for circular references\n\t * @returns {void}\n\t */\n\t_updateHash(hash, runtime, alreadyVisitedExportsInfo) {\n\t\tconst set = new Set(alreadyVisitedExportsInfo);\n\t\tset.add(this);\n\t\tfor (const exportInfo of this.orderedExports) {\n\t\t\tif (exportInfo.hasInfo(this._otherExportsInfo, runtime)) {\n\t\t\t\texportInfo._updateHash(hash, runtime, set);\n\t\t\t}\n\t\t}\n\t\tthis._sideEffectsOnlyInfo._updateHash(hash, runtime, set);\n\t\tthis._otherExportsInfo._updateHash(hash, runtime, set);\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tthis._redirectTo._updateHash(hash, runtime, set);\n\t\t}\n\t}\n\n\tgetRestoreProvidedData() {\n\t\tconst otherProvided = this._otherExportsInfo.provided;\n\t\tconst otherCanMangleProvide = this._otherExportsInfo.canMangleProvide;\n\t\tconst otherTerminalBinding = this._otherExportsInfo.terminalBinding;\n\t\tconst exports = [];\n\t\tfor (const exportInfo of this.orderedExports) {\n\t\t\tif (\n\t\t\t\texportInfo.provided !== otherProvided ||\n\t\t\t\texportInfo.canMangleProvide !== otherCanMangleProvide ||\n\t\t\t\texportInfo.terminalBinding !== otherTerminalBinding ||\n\t\t\t\texportInfo.exportsInfoOwned\n\t\t\t) {\n\t\t\t\texports.push({\n\t\t\t\t\tname: exportInfo.name,\n\t\t\t\t\tprovided: exportInfo.provided,\n\t\t\t\t\tcanMangleProvide: exportInfo.canMangleProvide,\n\t\t\t\t\tterminalBinding: exportInfo.terminalBinding,\n\t\t\t\t\texportsInfo: exportInfo.exportsInfoOwned\n\t\t\t\t\t\t? exportInfo.exportsInfo.getRestoreProvidedData()\n\t\t\t\t\t\t: undefined\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn new RestoreProvidedData(\n\t\t\texports,\n\t\t\totherProvided,\n\t\t\totherCanMangleProvide,\n\t\t\totherTerminalBinding\n\t\t);\n\t}\n\n\trestoreProvided({\n\t\totherProvided,\n\t\totherCanMangleProvide,\n\t\totherTerminalBinding,\n\t\texports\n\t}) {\n\t\tlet wasEmpty = true;\n\t\tfor (const exportInfo of this._exports.values()) {\n\t\t\twasEmpty = false;\n\t\t\texportInfo.provided = otherProvided;\n\t\t\texportInfo.canMangleProvide = otherCanMangleProvide;\n\t\t\texportInfo.terminalBinding = otherTerminalBinding;\n\t\t}\n\t\tthis._otherExportsInfo.provided = otherProvided;\n\t\tthis._otherExportsInfo.canMangleProvide = otherCanMangleProvide;\n\t\tthis._otherExportsInfo.terminalBinding = otherTerminalBinding;\n\t\tfor (const exp of exports) {\n\t\t\tconst exportInfo = this.getExportInfo(exp.name);\n\t\t\texportInfo.provided = exp.provided;\n\t\t\texportInfo.canMangleProvide = exp.canMangleProvide;\n\t\t\texportInfo.terminalBinding = exp.terminalBinding;\n\t\t\tif (exp.exportsInfo) {\n\t\t\t\tconst exportsInfo = exportInfo.createNestedExportsInfo();\n\t\t\t\texportsInfo.restoreProvided(exp.exportsInfo);\n\t\t\t}\n\t\t}\n\t\tif (wasEmpty) this._exportsAreOrdered = true;\n\t}\n}\n\nclass ExportInfo {\n\t/**\n\t * @param {string} name the original name of the export\n\t * @param {ExportInfo=} initFrom init values from this ExportInfo\n\t */\n\tconstructor(name, initFrom) {\n\t\t/** @type {string} */\n\t\tthis.name = name;\n\t\t/** @private @type {string | null} */\n\t\tthis._usedName = initFrom ? initFrom._usedName : null;\n\t\t/** @private @type {UsageStateType} */\n\t\tthis._globalUsed = initFrom ? initFrom._globalUsed : undefined;\n\t\t/** @private @type {Map<string, RuntimeUsageStateType>} */\n\t\tthis._usedInRuntime =\n\t\t\tinitFrom && initFrom._usedInRuntime\n\t\t\t\t? new Map(initFrom._usedInRuntime)\n\t\t\t\t: undefined;\n\t\t/** @private @type {boolean} */\n\t\tthis._hasUseInRuntimeInfo = initFrom\n\t\t\t? initFrom._hasUseInRuntimeInfo\n\t\t\t: false;\n\t\t/**\n\t\t * true: it is provided\n\t\t * false: it is not provided\n\t\t * null: only the runtime knows if it is provided\n\t\t * undefined: it was not determined if it is provided\n\t\t * @type {boolean | null | undefined}\n\t\t */\n\t\tthis.provided = initFrom ? initFrom.provided : undefined;\n\t\t/**\n\t\t * is the export a terminal binding that should be checked for export star conflicts\n\t\t * @type {boolean}\n\t\t */\n\t\tthis.terminalBinding = initFrom ? initFrom.terminalBinding : false;\n\t\t/**\n\t\t * true: it can be mangled\n\t\t * false: is can not be mangled\n\t\t * undefined: it was not determined if it can be mangled\n\t\t * @type {boolean | undefined}\n\t\t */\n\t\tthis.canMangleProvide = initFrom ? initFrom.canMangleProvide : undefined;\n\t\t/**\n\t\t * true: it can be mangled\n\t\t * false: is can not be mangled\n\t\t * undefined: it was not determined if it can be mangled\n\t\t * @type {boolean | undefined}\n\t\t */\n\t\tthis.canMangleUse = initFrom ? initFrom.canMangleUse : undefined;\n\t\t/** @type {boolean} */\n\t\tthis.exportsInfoOwned = false;\n\t\t/** @type {ExportsInfo=} */\n\t\tthis.exportsInfo = undefined;\n\t\t/** @type {Map<any, { connection: ModuleGraphConnection | null, export: string[], priority: number }>=} */\n\t\tthis._target = undefined;\n\t\tif (initFrom && initFrom._target) {\n\t\t\tthis._target = new Map();\n\t\t\tfor (const [key, value] of initFrom._target) {\n\t\t\t\tthis._target.set(key, {\n\t\t\t\t\tconnection: value.connection,\n\t\t\t\t\texport: value.export || [name],\n\t\t\t\t\tpriority: value.priority\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t/** @type {Map<any, { connection: ModuleGraphConnection | null, export: string[], priority: number }>=} */\n\t\tthis._maxTarget = undefined;\n\t}\n\n\t// TODO webpack 5 remove\n\t/** @private */\n\tget used() {\n\t\tthrow new Error(\"REMOVED\");\n\t}\n\t/** @private */\n\tget usedName() {\n\t\tthrow new Error(\"REMOVED\");\n\t}\n\t/**\n\t * @private\n\t * @param {*} v v\n\t */\n\tset used(v) {\n\t\tthrow new Error(\"REMOVED\");\n\t}\n\t/**\n\t * @private\n\t * @param {*} v v\n\t */\n\tset usedName(v) {\n\t\tthrow new Error(\"REMOVED\");\n\t}\n\n\tget canMangle() {\n\t\tswitch (this.canMangleProvide) {\n\t\t\tcase undefined:\n\t\t\t\treturn this.canMangleUse === false ? false : undefined;\n\t\t\tcase false:\n\t\t\t\treturn false;\n\t\t\tcase true:\n\t\t\t\tswitch (this.canMangleUse) {\n\t\t\t\t\tcase undefined:\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\tcase false:\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tcase true:\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t}\n\t\tthrow new Error(\n\t\t\t`Unexpected flags for canMangle ${this.canMangleProvide} ${this.canMangleUse}`\n\t\t);\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime only apply to this runtime\n\t * @returns {boolean} true, when something changed\n\t */\n\tsetUsedInUnknownWay(runtime) {\n\t\tlet changed = false;\n\t\tif (\n\t\t\tthis.setUsedConditionally(\n\t\t\t\tused => used < UsageState.Unknown,\n\t\t\t\tUsageState.Unknown,\n\t\t\t\truntime\n\t\t\t)\n\t\t) {\n\t\t\tchanged = true;\n\t\t}\n\t\tif (this.canMangleUse !== false) {\n\t\t\tthis.canMangleUse = false;\n\t\t\tchanged = true;\n\t\t}\n\t\treturn changed;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime only apply to this runtime\n\t * @returns {boolean} true, when something changed\n\t */\n\tsetUsedWithoutInfo(runtime) {\n\t\tlet changed = false;\n\t\tif (this.setUsed(UsageState.NoInfo, runtime)) {\n\t\t\tchanged = true;\n\t\t}\n\t\tif (this.canMangleUse !== false) {\n\t\t\tthis.canMangleUse = false;\n\t\t\tchanged = true;\n\t\t}\n\t\treturn changed;\n\t}\n\n\tsetHasUseInfo() {\n\t\tif (!this._hasUseInRuntimeInfo) {\n\t\t\tthis._hasUseInRuntimeInfo = true;\n\t\t}\n\t\tif (this.canMangleUse === undefined) {\n\t\t\tthis.canMangleUse = true;\n\t\t}\n\t\tif (this.exportsInfoOwned) {\n\t\t\tthis.exportsInfo.setHasUseInfo();\n\t\t}\n\t}\n\n\t/**\n\t * @param {function(UsageStateType): boolean} condition compare with old value\n\t * @param {UsageStateType} newValue set when condition is true\n\t * @param {RuntimeSpec} runtime only apply to this runtime\n\t * @returns {boolean} true when something has changed\n\t */\n\tsetUsedConditionally(condition, newValue, runtime) {\n\t\tif (runtime === undefined) {\n\t\t\tif (this._globalUsed === undefined) {\n\t\t\t\tthis._globalUsed = newValue;\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tif (this._globalUsed !== newValue && condition(this._globalUsed)) {\n\t\t\t\t\tthis._globalUsed = newValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this._usedInRuntime === undefined) {\n\t\t\tif (newValue !== UsageState.Unused && condition(UsageState.Unused)) {\n\t\t\t\tthis._usedInRuntime = new Map();\n\t\t\t\tforEachRuntime(runtime, runtime =>\n\t\t\t\t\tthis._usedInRuntime.set(runtime, newValue)\n\t\t\t\t);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tlet changed = false;\n\t\t\tforEachRuntime(runtime, runtime => {\n\t\t\t\t/** @type {UsageStateType} */\n\t\t\t\tlet oldValue = this._usedInRuntime.get(runtime);\n\t\t\t\tif (oldValue === undefined) oldValue = UsageState.Unused;\n\t\t\t\tif (newValue !== oldValue && condition(oldValue)) {\n\t\t\t\t\tif (newValue === UsageState.Unused) {\n\t\t\t\t\t\tthis._usedInRuntime.delete(runtime);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._usedInRuntime.set(runtime, newValue);\n\t\t\t\t\t}\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (changed) {\n\t\t\t\tif (this._usedInRuntime.size === 0) this._usedInRuntime = undefined;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {UsageStateType} newValue new value of the used state\n\t * @param {RuntimeSpec} runtime only apply to this runtime\n\t * @returns {boolean} true when something has changed\n\t */\n\tsetUsed(newValue, runtime) {\n\t\tif (runtime === undefined) {\n\t\t\tif (this._globalUsed !== newValue) {\n\t\t\t\tthis._globalUsed = newValue;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (this._usedInRuntime === undefined) {\n\t\t\tif (newValue !== UsageState.Unused) {\n\t\t\t\tthis._usedInRuntime = new Map();\n\t\t\t\tforEachRuntime(runtime, runtime =>\n\t\t\t\t\tthis._usedInRuntime.set(runtime, newValue)\n\t\t\t\t);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tlet changed = false;\n\t\t\tforEachRuntime(runtime, runtime => {\n\t\t\t\t/** @type {UsageStateType} */\n\t\t\t\tlet oldValue = this._usedInRuntime.get(runtime);\n\t\t\t\tif (oldValue === undefined) oldValue = UsageState.Unused;\n\t\t\t\tif (newValue !== oldValue) {\n\t\t\t\t\tif (newValue === UsageState.Unused) {\n\t\t\t\t\t\tthis._usedInRuntime.delete(runtime);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._usedInRuntime.set(runtime, newValue);\n\t\t\t\t\t}\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (changed) {\n\t\t\t\tif (this._usedInRuntime.size === 0) this._usedInRuntime = undefined;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {any} key the key\n\t * @returns {boolean} true, if something has changed\n\t */\n\tunsetTarget(key) {\n\t\tif (!this._target) return false;\n\t\tif (this._target.delete(key)) {\n\t\t\tthis._maxTarget = undefined;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {any} key the key\n\t * @param {ModuleGraphConnection} connection the target module if a single one\n\t * @param {string[]=} exportName the exported name\n\t * @param {number=} priority priority\n\t * @returns {boolean} true, if something has changed\n\t */\n\tsetTarget(key, connection, exportName, priority = 0) {\n\t\tif (exportName) exportName = [...exportName];\n\t\tif (!this._target) {\n\t\t\tthis._target = new Map();\n\t\t\tthis._target.set(key, { connection, export: exportName, priority });\n\t\t\treturn true;\n\t\t}\n\t\tconst oldTarget = this._target.get(key);\n\t\tif (!oldTarget) {\n\t\t\tif (oldTarget === null && !connection) return false;\n\t\t\tthis._target.set(key, { connection, export: exportName, priority });\n\t\t\tthis._maxTarget = undefined;\n\t\t\treturn true;\n\t\t}\n\t\tif (\n\t\t\toldTarget.connection !== connection ||\n\t\t\toldTarget.priority !== priority ||\n\t\t\t(exportName\n\t\t\t\t? !oldTarget.export || !equals(oldTarget.export, exportName)\n\t\t\t\t: oldTarget.export)\n\t\t) {\n\t\t\toldTarget.connection = connection;\n\t\t\toldTarget.export = exportName;\n\t\t\toldTarget.priority = priority;\n\t\t\tthis._maxTarget = undefined;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime for this runtime\n\t * @returns {UsageStateType} usage state\n\t */\n\tgetUsed(runtime) {\n\t\tif (!this._hasUseInRuntimeInfo) return UsageState.NoInfo;\n\t\tif (this._globalUsed !== undefined) return this._globalUsed;\n\t\tif (this._usedInRuntime === undefined) {\n\t\t\treturn UsageState.Unused;\n\t\t} else if (typeof runtime === \"string\") {\n\t\t\tconst value = this._usedInRuntime.get(runtime);\n\t\t\treturn value === undefined ? UsageState.Unused : value;\n\t\t} else if (runtime === undefined) {\n\t\t\t/** @type {UsageStateType} */\n\t\t\tlet max = UsageState.Unused;\n\t\t\tfor (const value of this._usedInRuntime.values()) {\n\t\t\t\tif (value === UsageState.Used) {\n\t\t\t\t\treturn UsageState.Used;\n\t\t\t\t}\n\t\t\t\tif (max < value) max = value;\n\t\t\t}\n\t\t\treturn max;\n\t\t} else {\n\t\t\t/** @type {UsageStateType} */\n\t\t\tlet max = UsageState.Unused;\n\t\t\tfor (const item of runtime) {\n\t\t\t\tconst value = this._usedInRuntime.get(item);\n\t\t\t\tif (value !== undefined) {\n\t\t\t\t\tif (value === UsageState.Used) {\n\t\t\t\t\t\treturn UsageState.Used;\n\t\t\t\t\t}\n\t\t\t\t\tif (max < value) max = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn max;\n\t\t}\n\t}\n\n\t/**\n\t * get used name\n\t * @param {string | undefined} fallbackName fallback name for used exports with no name\n\t * @param {RuntimeSpec} runtime check usage for this runtime only\n\t * @returns {string | false} used name\n\t */\n\tgetUsedName(fallbackName, runtime) {\n\t\tif (this._hasUseInRuntimeInfo) {\n\t\t\tif (this._globalUsed !== undefined) {\n\t\t\t\tif (this._globalUsed === UsageState.Unused) return false;\n\t\t\t} else {\n\t\t\t\tif (this._usedInRuntime === undefined) return false;\n\t\t\t\tif (typeof runtime === \"string\") {\n\t\t\t\t\tif (!this._usedInRuntime.has(runtime)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} else if (runtime !== undefined) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tArray.from(runtime).every(\n\t\t\t\t\t\t\truntime => !this._usedInRuntime.has(runtime)\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this._usedName !== null) return this._usedName;\n\t\treturn this.name || fallbackName;\n\t}\n\n\t/**\n\t * @returns {boolean} true, when a mangled name of this export is set\n\t */\n\thasUsedName() {\n\t\treturn this._usedName !== null;\n\t}\n\n\t/**\n\t * Sets the mangled name of this export\n\t * @param {string} name the new name\n\t * @returns {void}\n\t */\n\tsetUsedName(name) {\n\t\tthis._usedName = name;\n\t}\n\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {function({ module: Module, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\n\t * @returns {ExportInfo | ExportsInfo | undefined} the terminal binding export(s) info if known\n\t */\n\tgetTerminalBinding(moduleGraph, resolveTargetFilter = RETURNS_TRUE) {\n\t\tif (this.terminalBinding) return this;\n\t\tconst target = this.getTarget(moduleGraph, resolveTargetFilter);\n\t\tif (!target) return undefined;\n\t\tconst exportsInfo = moduleGraph.getExportsInfo(target.module);\n\t\tif (!target.export) return exportsInfo;\n\t\treturn exportsInfo.getReadOnlyExportInfoRecursive(target.export);\n\t}\n\n\tisReexport() {\n\t\treturn !this.terminalBinding && this._target && this._target.size > 0;\n\t}\n\n\t_getMaxTarget() {\n\t\tif (this._maxTarget !== undefined) return this._maxTarget;\n\t\tif (this._target.size <= 1) return (this._maxTarget = this._target);\n\t\tlet maxPriority = -Infinity;\n\t\tlet minPriority = Infinity;\n\t\tfor (const { priority } of this._target.values()) {\n\t\t\tif (maxPriority < priority) maxPriority = priority;\n\t\t\tif (minPriority > priority) minPriority = priority;\n\t\t}\n\t\t// This should be very common\n\t\tif (maxPriority === minPriority) return (this._maxTarget = this._target);\n\n\t\t// This is an edge case\n\t\tconst map = new Map();\n\t\tfor (const [key, value] of this._target) {\n\t\t\tif (maxPriority === value.priority) {\n\t\t\t\tmap.set(key, value);\n\t\t\t}\n\t\t}\n\t\tthis._maxTarget = map;\n\t\treturn map;\n\t}\n\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {function(Module): boolean} validTargetModuleFilter a valid target module\n\t * @returns {{ module: Module, export: string[] | undefined } | undefined | false} the target, undefined when there is no target, false when no target is valid\n\t */\n\tfindTarget(moduleGraph, validTargetModuleFilter) {\n\t\treturn this._findTarget(moduleGraph, validTargetModuleFilter, new Set());\n\t}\n\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {function(Module): boolean} validTargetModuleFilter a valid target module\n\t * @param {Set<ExportInfo> | undefined} alreadyVisited set of already visited export info to avoid circular references\n\t * @returns {{ module: Module, export: string[] | undefined } | undefined | false} the target, undefined when there is no target, false when no target is valid\n\t */\n\t_findTarget(moduleGraph, validTargetModuleFilter, alreadyVisited) {\n\t\tif (!this._target || this._target.size === 0) return undefined;\n\t\tlet rawTarget = this._getMaxTarget().values().next().value;\n\t\tif (!rawTarget) return undefined;\n\t\t/** @type {{ module: Module, export: string[] | undefined }} */\n\t\tlet target = {\n\t\t\tmodule: rawTarget.connection.module,\n\t\t\texport: rawTarget.export\n\t\t};\n\t\tfor (;;) {\n\t\t\tif (validTargetModuleFilter(target.module)) return target;\n\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(target.module);\n\t\t\tconst exportInfo = exportsInfo.getExportInfo(target.export[0]);\n\t\t\tif (alreadyVisited.has(exportInfo)) return null;\n\t\t\tconst newTarget = exportInfo._findTarget(\n\t\t\t\tmoduleGraph,\n\t\t\t\tvalidTargetModuleFilter,\n\t\t\t\talreadyVisited\n\t\t\t);\n\t\t\tif (!newTarget) return false;\n\t\t\tif (target.export.length === 1) {\n\t\t\t\ttarget = newTarget;\n\t\t\t} else {\n\t\t\t\ttarget = {\n\t\t\t\t\tmodule: newTarget.module,\n\t\t\t\t\texport: newTarget.export\n\t\t\t\t\t\t? newTarget.export.concat(target.export.slice(1))\n\t\t\t\t\t\t: target.export.slice(1)\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {function({ module: Module, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\n\t * @returns {{ module: Module, export: string[] | undefined } | undefined} the target\n\t */\n\tgetTarget(moduleGraph, resolveTargetFilter = RETURNS_TRUE) {\n\t\tconst result = this._getTarget(moduleGraph, resolveTargetFilter, undefined);\n\t\tif (result === CIRCULAR) return undefined;\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {function({ module: Module, connection: ModuleGraphConnection, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\n\t * @param {Set<ExportInfo> | undefined} alreadyVisited set of already visited export info to avoid circular references\n\t * @returns {{ module: Module, connection: ModuleGraphConnection, export: string[] | undefined } | CIRCULAR | undefined} the target\n\t */\n\t_getTarget(moduleGraph, resolveTargetFilter, alreadyVisited) {\n\t\t/**\n\t\t * @param {{ connection: ModuleGraphConnection, export: string[] | undefined } | null} inputTarget unresolved target\n\t\t * @param {Set<ExportInfo>} alreadyVisited set of already visited export info to avoid circular references\n\t\t * @returns {{ module: Module, connection: ModuleGraphConnection, export: string[] | undefined } | CIRCULAR | null} resolved target\n\t\t */\n\t\tconst resolveTarget = (inputTarget, alreadyVisited) => {\n\t\t\tif (!inputTarget) return null;\n\t\t\tif (!inputTarget.export) {\n\t\t\t\treturn {\n\t\t\t\t\tmodule: inputTarget.connection.module,\n\t\t\t\t\tconnection: inputTarget.connection,\n\t\t\t\t\texport: undefined\n\t\t\t\t};\n\t\t\t}\n\t\t\t/** @type {{ module: Module, connection: ModuleGraphConnection, export: string[] | undefined }} */\n\t\t\tlet target = {\n\t\t\t\tmodule: inputTarget.connection.module,\n\t\t\t\tconnection: inputTarget.connection,\n\t\t\t\texport: inputTarget.export\n\t\t\t};\n\t\t\tif (!resolveTargetFilter(target)) return target;\n\t\t\tlet alreadyVisitedOwned = false;\n\t\t\tfor (;;) {\n\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(target.module);\n\t\t\t\tconst exportInfo = exportsInfo.getExportInfo(target.export[0]);\n\t\t\t\tif (!exportInfo) return target;\n\t\t\t\tif (alreadyVisited.has(exportInfo)) return CIRCULAR;\n\t\t\t\tconst newTarget = exportInfo._getTarget(\n\t\t\t\t\tmoduleGraph,\n\t\t\t\t\tresolveTargetFilter,\n\t\t\t\t\talreadyVisited\n\t\t\t\t);\n\t\t\t\tif (newTarget === CIRCULAR) return CIRCULAR;\n\t\t\t\tif (!newTarget) return target;\n\t\t\t\tif (target.export.length === 1) {\n\t\t\t\t\ttarget = newTarget;\n\t\t\t\t\tif (!target.export) return target;\n\t\t\t\t} else {\n\t\t\t\t\ttarget = {\n\t\t\t\t\t\tmodule: newTarget.module,\n\t\t\t\t\t\tconnection: newTarget.connection,\n\t\t\t\t\t\texport: newTarget.export\n\t\t\t\t\t\t\t? newTarget.export.concat(target.export.slice(1))\n\t\t\t\t\t\t\t: target.export.slice(1)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (!resolveTargetFilter(target)) return target;\n\t\t\t\tif (!alreadyVisitedOwned) {\n\t\t\t\t\talreadyVisited = new Set(alreadyVisited);\n\t\t\t\t\talreadyVisitedOwned = true;\n\t\t\t\t}\n\t\t\t\talreadyVisited.add(exportInfo);\n\t\t\t}\n\t\t};\n\n\t\tif (!this._target || this._target.size === 0) return undefined;\n\t\tif (alreadyVisited && alreadyVisited.has(this)) return CIRCULAR;\n\t\tconst newAlreadyVisited = new Set(alreadyVisited);\n\t\tnewAlreadyVisited.add(this);\n\t\tconst values = this._getMaxTarget().values();\n\t\tconst target = resolveTarget(values.next().value, newAlreadyVisited);\n\t\tif (target === CIRCULAR) return CIRCULAR;\n\t\tif (target === null) return undefined;\n\t\tlet result = values.next();\n\t\twhile (!result.done) {\n\t\t\tconst t = resolveTarget(result.value, newAlreadyVisited);\n\t\t\tif (t === CIRCULAR) return CIRCULAR;\n\t\t\tif (t === null) return undefined;\n\t\t\tif (t.module !== target.module) return undefined;\n\t\t\tif (!t.export !== !target.export) return undefined;\n\t\t\tif (target.export && !equals(t.export, target.export)) return undefined;\n\t\t\tresult = values.next();\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * Move the target forward as long resolveTargetFilter is fulfilled\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {function({ module: Module, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\n\t * @param {function({ module: Module, export: string[] | undefined }): ModuleGraphConnection=} updateOriginalConnection updates the original connection instead of using the target connection\n\t * @returns {{ module: Module, export: string[] | undefined } | undefined} the resolved target when moved\n\t */\n\tmoveTarget(moduleGraph, resolveTargetFilter, updateOriginalConnection) {\n\t\tconst target = this._getTarget(moduleGraph, resolveTargetFilter, undefined);\n\t\tif (target === CIRCULAR) return undefined;\n\t\tif (!target) return undefined;\n\t\tconst originalTarget = this._getMaxTarget().values().next().value;\n\t\tif (\n\t\t\toriginalTarget.connection === target.connection &&\n\t\t\toriginalTarget.export === target.export\n\t\t) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis._target.clear();\n\t\tthis._target.set(undefined, {\n\t\t\tconnection: updateOriginalConnection\n\t\t\t\t? updateOriginalConnection(target)\n\t\t\t\t: target.connection,\n\t\t\texport: target.export,\n\t\t\tpriority: 0\n\t\t});\n\t\treturn target;\n\t}\n\n\tcreateNestedExportsInfo() {\n\t\tif (this.exportsInfoOwned) return this.exportsInfo;\n\t\tthis.exportsInfoOwned = true;\n\t\tconst oldExportsInfo = this.exportsInfo;\n\t\tthis.exportsInfo = new ExportsInfo();\n\t\tthis.exportsInfo.setHasProvideInfo();\n\t\tif (oldExportsInfo) {\n\t\t\tthis.exportsInfo.setRedirectNamedTo(oldExportsInfo);\n\t\t}\n\t\treturn this.exportsInfo;\n\t}\n\n\tgetNestedExportsInfo() {\n\t\treturn this.exportsInfo;\n\t}\n\n\thasInfo(baseInfo, runtime) {\n\t\treturn (\n\t\t\t(this._usedName && this._usedName !== this.name) ||\n\t\t\tthis.provided ||\n\t\t\tthis.terminalBinding ||\n\t\t\tthis.getUsed(runtime) !== baseInfo.getUsed(runtime)\n\t\t);\n\t}\n\n\tupdateHash(hash, runtime) {\n\t\tthis._updateHash(hash, runtime, new Set());\n\t}\n\n\t_updateHash(hash, runtime, alreadyVisitedExportsInfo) {\n\t\thash.update(\n\t\t\t`${this._usedName || this.name}${this.getUsed(runtime)}${this.provided}${\n\t\t\t\tthis.terminalBinding\n\t\t\t}`\n\t\t);\n\t\tif (this.exportsInfo && !alreadyVisitedExportsInfo.has(this.exportsInfo)) {\n\t\t\tthis.exportsInfo._updateHash(hash, runtime, alreadyVisitedExportsInfo);\n\t\t}\n\t}\n\n\tgetUsedInfo() {\n\t\tif (this._globalUsed !== undefined) {\n\t\t\tswitch (this._globalUsed) {\n\t\t\t\tcase UsageState.Unused:\n\t\t\t\t\treturn \"unused\";\n\t\t\t\tcase UsageState.NoInfo:\n\t\t\t\t\treturn \"no usage info\";\n\t\t\t\tcase UsageState.Unknown:\n\t\t\t\t\treturn \"maybe used (runtime-defined)\";\n\t\t\t\tcase UsageState.Used:\n\t\t\t\t\treturn \"used\";\n\t\t\t\tcase UsageState.OnlyPropertiesUsed:\n\t\t\t\t\treturn \"only properties used\";\n\t\t\t}\n\t\t} else if (this._usedInRuntime !== undefined) {\n\t\t\t/** @type {Map<RuntimeUsageStateType, string[]>} */\n\t\t\tconst map = new Map();\n\t\t\tfor (const [runtime, used] of this._usedInRuntime) {\n\t\t\t\tconst list = map.get(used);\n\t\t\t\tif (list !== undefined) list.push(runtime);\n\t\t\t\telse map.set(used, [runtime]);\n\t\t\t}\n\t\t\tconst specificInfo = Array.from(map, ([used, runtimes]) => {\n\t\t\t\tswitch (used) {\n\t\t\t\t\tcase UsageState.NoInfo:\n\t\t\t\t\t\treturn `no usage info in ${runtimes.join(\", \")}`;\n\t\t\t\t\tcase UsageState.Unknown:\n\t\t\t\t\t\treturn `maybe used in ${runtimes.join(\", \")} (runtime-defined)`;\n\t\t\t\t\tcase UsageState.Used:\n\t\t\t\t\t\treturn `used in ${runtimes.join(\", \")}`;\n\t\t\t\t\tcase UsageState.OnlyPropertiesUsed:\n\t\t\t\t\t\treturn `only properties used in ${runtimes.join(\", \")}`;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (specificInfo.length > 0) {\n\t\t\t\treturn specificInfo.join(\"; \");\n\t\t\t}\n\t\t}\n\t\treturn this._hasUseInRuntimeInfo ? \"unused\" : \"no usage info\";\n\t}\n\n\tgetProvidedInfo() {\n\t\tswitch (this.provided) {\n\t\t\tcase undefined:\n\t\t\t\treturn \"no provided info\";\n\t\t\tcase null:\n\t\t\t\treturn \"maybe provided (runtime-defined)\";\n\t\t\tcase true:\n\t\t\t\treturn \"provided\";\n\t\t\tcase false:\n\t\t\t\treturn \"not provided\";\n\t\t}\n\t}\n\n\tgetRenameInfo() {\n\t\tif (this._usedName !== null && this._usedName !== this.name) {\n\t\t\treturn `renamed to ${JSON.stringify(this._usedName).slice(1, -1)}`;\n\t\t}\n\t\tswitch (this.canMangleProvide) {\n\t\t\tcase undefined:\n\t\t\t\tswitch (this.canMangleUse) {\n\t\t\t\t\tcase undefined:\n\t\t\t\t\t\treturn \"missing provision and use info prevents renaming\";\n\t\t\t\t\tcase false:\n\t\t\t\t\t\treturn \"usage prevents renaming (no provision info)\";\n\t\t\t\t\tcase true:\n\t\t\t\t\t\treturn \"missing provision info prevents renaming\";\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase true:\n\t\t\t\tswitch (this.canMangleUse) {\n\t\t\t\t\tcase undefined:\n\t\t\t\t\t\treturn \"missing usage info prevents renaming\";\n\t\t\t\t\tcase false:\n\t\t\t\t\t\treturn \"usage prevents renaming\";\n\t\t\t\t\tcase true:\n\t\t\t\t\t\treturn \"could be renamed\";\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase false:\n\t\t\t\tswitch (this.canMangleUse) {\n\t\t\t\t\tcase undefined:\n\t\t\t\t\t\treturn \"provision prevents renaming (no use info)\";\n\t\t\t\t\tcase false:\n\t\t\t\t\t\treturn \"usage and provision prevents renaming\";\n\t\t\t\t\tcase true:\n\t\t\t\t\t\treturn \"provision prevents renaming\";\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tthrow new Error(\n\t\t\t`Unexpected flags for getRenameInfo ${this.canMangleProvide} ${this.canMangleUse}`\n\t\t);\n\t}\n}\n\nmodule.exports = ExportsInfo;\nmodule.exports.ExportInfo = ExportInfo;\nmodule.exports.UsageState = UsageState;\n"]},"metadata":{},"sourceType":"script"}