{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _require = require(\"tapable\"),\n    AsyncParallelHook = _require.AsyncParallelHook,\n    AsyncSeriesBailHook = _require.AsyncSeriesBailHook,\n    SyncHook = _require.SyncHook;\n\nvar _require2 = require(\"./HookWebpackError\"),\n    makeWebpackError = _require2.makeWebpackError,\n    makeWebpackErrorCallback = _require2.makeWebpackErrorCallback;\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n\n/**\n * @typedef {Object} Etag\n * @property {function(): string} toString\n */\n\n/**\n * @template T\n * @callback CallbackCache\n * @param {(WebpackError | null)=} err\n * @param {T=} result\n * @returns {void}\n */\n\n/**\n * @callback GotHandler\n * @param {any} result\n * @param {function(Error=): void} callback\n * @returns {void}\n */\n\n\nvar needCalls = function needCalls(times, callback) {\n  return function (err) {\n    if (--times === 0) {\n      return callback(err);\n    }\n\n    if (err && times > 0) {\n      times = 0;\n      return callback(err);\n    }\n  };\n};\n\nvar Cache = /*#__PURE__*/function () {\n  function Cache() {\n    _classCallCheck(this, Cache);\n\n    this.hooks = {\n      /** @type {AsyncSeriesBailHook<[string, Etag | null, GotHandler[]], any>} */\n      get: new AsyncSeriesBailHook([\"identifier\", \"etag\", \"gotHandlers\"]),\n\n      /** @type {AsyncParallelHook<[string, Etag | null, any]>} */\n      store: new AsyncParallelHook([\"identifier\", \"etag\", \"data\"]),\n\n      /** @type {AsyncParallelHook<[Iterable<string>]>} */\n      storeBuildDependencies: new AsyncParallelHook([\"dependencies\"]),\n\n      /** @type {SyncHook<[]>} */\n      beginIdle: new SyncHook([]),\n\n      /** @type {AsyncParallelHook<[]>} */\n      endIdle: new AsyncParallelHook([]),\n\n      /** @type {AsyncParallelHook<[]>} */\n      shutdown: new AsyncParallelHook([])\n    };\n  }\n  /**\n   * @template T\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @param {CallbackCache<T>} callback signals when the value is retrieved\n   * @returns {void}\n   */\n\n\n  _createClass(Cache, [{\n    key: \"get\",\n    value: function get(identifier, etag, callback) {\n      var gotHandlers = [];\n      this.hooks.get.callAsync(identifier, etag, gotHandlers, function (err, result) {\n        if (err) {\n          callback(makeWebpackError(err, \"Cache.hooks.get\"));\n          return;\n        }\n\n        if (result === null) {\n          result = undefined;\n        }\n\n        if (gotHandlers.length > 1) {\n          var innerCallback = needCalls(gotHandlers.length, function () {\n            return callback(null, result);\n          });\n\n          var _iterator = _createForOfIteratorHelper(gotHandlers),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var gotHandler = _step.value;\n              gotHandler(result, innerCallback);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        } else if (gotHandlers.length === 1) {\n          gotHandlers[0](result, function () {\n            return callback(null, result);\n          });\n        } else {\n          callback(null, result);\n        }\n      });\n    }\n    /**\n     * @template T\n     * @param {string} identifier the cache identifier\n     * @param {Etag | null} etag the etag\n     * @param {T} data the value to store\n     * @param {CallbackCache<void>} callback signals when the value is stored\n     * @returns {void}\n     */\n\n  }, {\n    key: \"store\",\n    value: function store(identifier, etag, data, callback) {\n      this.hooks.store.callAsync(identifier, etag, data, makeWebpackErrorCallback(callback, \"Cache.hooks.store\"));\n    }\n    /**\n     * After this method has succeeded the cache can only be restored when build dependencies are\n     * @param {Iterable<string>} dependencies list of all build dependencies\n     * @param {CallbackCache<void>} callback signals when the dependencies are stored\n     * @returns {void}\n     */\n\n  }, {\n    key: \"storeBuildDependencies\",\n    value: function storeBuildDependencies(dependencies, callback) {\n      this.hooks.storeBuildDependencies.callAsync(dependencies, makeWebpackErrorCallback(callback, \"Cache.hooks.storeBuildDependencies\"));\n    }\n    /**\n     * @returns {void}\n     */\n\n  }, {\n    key: \"beginIdle\",\n    value: function beginIdle() {\n      this.hooks.beginIdle.call();\n    }\n    /**\n     * @param {CallbackCache<void>} callback signals when the call finishes\n     * @returns {void}\n     */\n\n  }, {\n    key: \"endIdle\",\n    value: function endIdle(callback) {\n      this.hooks.endIdle.callAsync(makeWebpackErrorCallback(callback, \"Cache.hooks.endIdle\"));\n    }\n    /**\n     * @param {CallbackCache<void>} callback signals when the call finishes\n     * @returns {void}\n     */\n\n  }, {\n    key: \"shutdown\",\n    value: function shutdown(callback) {\n      this.hooks.shutdown.callAsync(makeWebpackErrorCallback(callback, \"Cache.hooks.shutdown\"));\n    }\n  }]);\n\n  return Cache;\n}();\n\nCache.STAGE_MEMORY = -10;\nCache.STAGE_DEFAULT = 0;\nCache.STAGE_DISK = 10;\nCache.STAGE_NETWORK = 20;\nmodule.exports = Cache;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/Cache.js"],"names":["require","AsyncParallelHook","AsyncSeriesBailHook","SyncHook","makeWebpackError","makeWebpackErrorCallback","needCalls","times","callback","err","Cache","hooks","get","store","storeBuildDependencies","beginIdle","endIdle","shutdown","identifier","etag","gotHandlers","callAsync","result","undefined","length","innerCallback","gotHandler","data","dependencies","call","STAGE_MEMORY","STAGE_DEFAULT","STAGE_DISK","STAGE_NETWORK","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;;;;;;;AAEA,eAA6DA,OAAO,CAAC,SAAD,CAApE;AAAA,IAAQC,iBAAR,YAAQA,iBAAR;AAAA,IAA2BC,mBAA3B,YAA2BA,mBAA3B;AAAA,IAAgDC,QAAhD,YAAgDA,QAAhD;;AACA,gBAGIH,OAAO,CAAC,oBAAD,CAHX;AAAA,IACCI,gBADD,aACCA,gBADD;AAAA,IAECC,wBAFD,aAECA,wBAFD;AAKA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAEA,IAAMC,SAAS,GAAG,SAAZA,SAAY,CAACC,KAAD,EAAQC,QAAR,EAAqB;AACtC,SAAO,UAAAC,GAAG,EAAI;AACb,QAAI,EAAEF,KAAF,KAAY,CAAhB,EAAmB;AAClB,aAAOC,QAAQ,CAACC,GAAD,CAAf;AACA;;AACD,QAAIA,GAAG,IAAIF,KAAK,GAAG,CAAnB,EAAsB;AACrBA,MAAAA,KAAK,GAAG,CAAR;AACA,aAAOC,QAAQ,CAACC,GAAD,CAAf;AACA;AACD,GARD;AASA,CAVD;;IAYMC,K;AACL,mBAAc;AAAA;;AACb,SAAKC,KAAL,GAAa;AACZ;AACAC,MAAAA,GAAG,EAAE,IAAIV,mBAAJ,CAAwB,CAAC,YAAD,EAAe,MAAf,EAAuB,aAAvB,CAAxB,CAFO;;AAGZ;AACAW,MAAAA,KAAK,EAAE,IAAIZ,iBAAJ,CAAsB,CAAC,YAAD,EAAe,MAAf,EAAuB,MAAvB,CAAtB,CAJK;;AAKZ;AACAa,MAAAA,sBAAsB,EAAE,IAAIb,iBAAJ,CAAsB,CAAC,cAAD,CAAtB,CANZ;;AAOZ;AACAc,MAAAA,SAAS,EAAE,IAAIZ,QAAJ,CAAa,EAAb,CARC;;AASZ;AACAa,MAAAA,OAAO,EAAE,IAAIf,iBAAJ,CAAsB,EAAtB,CAVG;;AAWZ;AACAgB,MAAAA,QAAQ,EAAE,IAAIhB,iBAAJ,CAAsB,EAAtB;AAZE,KAAb;AAcA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;;WACC,aAAIiB,UAAJ,EAAgBC,IAAhB,EAAsBX,QAAtB,EAAgC;AAC/B,UAAMY,WAAW,GAAG,EAApB;AACA,WAAKT,KAAL,CAAWC,GAAX,CAAeS,SAAf,CAAyBH,UAAzB,EAAqCC,IAArC,EAA2CC,WAA3C,EAAwD,UAACX,GAAD,EAAMa,MAAN,EAAiB;AACxE,YAAIb,GAAJ,EAAS;AACRD,UAAAA,QAAQ,CAACJ,gBAAgB,CAACK,GAAD,EAAM,iBAAN,CAAjB,CAAR;AACA;AACA;;AACD,YAAIa,MAAM,KAAK,IAAf,EAAqB;AACpBA,UAAAA,MAAM,GAAGC,SAAT;AACA;;AACD,YAAIH,WAAW,CAACI,MAAZ,GAAqB,CAAzB,EAA4B;AAC3B,cAAMC,aAAa,GAAGnB,SAAS,CAACc,WAAW,CAACI,MAAb,EAAqB;AAAA,mBACnDhB,QAAQ,CAAC,IAAD,EAAOc,MAAP,CAD2C;AAAA,WAArB,CAA/B;;AAD2B,qDAIFF,WAJE;AAAA;;AAAA;AAI3B,gEAAsC;AAAA,kBAA3BM,UAA2B;AACrCA,cAAAA,UAAU,CAACJ,MAAD,EAASG,aAAT,CAAV;AACA;AAN0B;AAAA;AAAA;AAAA;AAAA;AAO3B,SAPD,MAOO,IAAIL,WAAW,CAACI,MAAZ,KAAuB,CAA3B,EAA8B;AACpCJ,UAAAA,WAAW,CAAC,CAAD,CAAX,CAAeE,MAAf,EAAuB;AAAA,mBAAMd,QAAQ,CAAC,IAAD,EAAOc,MAAP,CAAd;AAAA,WAAvB;AACA,SAFM,MAEA;AACNd,UAAAA,QAAQ,CAAC,IAAD,EAAOc,MAAP,CAAR;AACA;AACD,OApBD;AAqBA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,eAAMJ,UAAN,EAAkBC,IAAlB,EAAwBQ,IAAxB,EAA8BnB,QAA9B,EAAwC;AACvC,WAAKG,KAAL,CAAWE,KAAX,CAAiBQ,SAAjB,CACCH,UADD,EAECC,IAFD,EAGCQ,IAHD,EAICtB,wBAAwB,CAACG,QAAD,EAAW,mBAAX,CAJzB;AAMA;AAED;AACD;AACA;AACA;AACA;AACA;;;;WACC,gCAAuBoB,YAAvB,EAAqCpB,QAArC,EAA+C;AAC9C,WAAKG,KAAL,CAAWG,sBAAX,CAAkCO,SAAlC,CACCO,YADD,EAECvB,wBAAwB,CAACG,QAAD,EAAW,oCAAX,CAFzB;AAIA;AAED;AACD;AACA;;;;WACC,qBAAY;AACX,WAAKG,KAAL,CAAWI,SAAX,CAAqBc,IAArB;AACA;AAED;AACD;AACA;AACA;;;;WACC,iBAAQrB,QAAR,EAAkB;AACjB,WAAKG,KAAL,CAAWK,OAAX,CAAmBK,SAAnB,CACChB,wBAAwB,CAACG,QAAD,EAAW,qBAAX,CADzB;AAGA;AAED;AACD;AACA;AACA;;;;WACC,kBAASA,QAAT,EAAmB;AAClB,WAAKG,KAAL,CAAWM,QAAX,CAAoBI,SAApB,CACChB,wBAAwB,CAACG,QAAD,EAAW,sBAAX,CADzB;AAGA;;;;;;AAGFE,KAAK,CAACoB,YAAN,GAAqB,CAAC,EAAtB;AACApB,KAAK,CAACqB,aAAN,GAAsB,CAAtB;AACArB,KAAK,CAACsB,UAAN,GAAmB,EAAnB;AACAtB,KAAK,CAACuB,aAAN,GAAsB,EAAtB;AAEAC,MAAM,CAACC,OAAP,GAAiBzB,KAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { AsyncParallelHook, AsyncSeriesBailHook, SyncHook } = require(\"tapable\");\nconst {\n\tmakeWebpackError,\n\tmakeWebpackErrorCallback\n} = require(\"./HookWebpackError\");\n\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n\n/**\n * @typedef {Object} Etag\n * @property {function(): string} toString\n */\n\n/**\n * @template T\n * @callback CallbackCache\n * @param {(WebpackError | null)=} err\n * @param {T=} result\n * @returns {void}\n */\n\n/**\n * @callback GotHandler\n * @param {any} result\n * @param {function(Error=): void} callback\n * @returns {void}\n */\n\nconst needCalls = (times, callback) => {\n\treturn err => {\n\t\tif (--times === 0) {\n\t\t\treturn callback(err);\n\t\t}\n\t\tif (err && times > 0) {\n\t\t\ttimes = 0;\n\t\t\treturn callback(err);\n\t\t}\n\t};\n};\n\nclass Cache {\n\tconstructor() {\n\t\tthis.hooks = {\n\t\t\t/** @type {AsyncSeriesBailHook<[string, Etag | null, GotHandler[]], any>} */\n\t\t\tget: new AsyncSeriesBailHook([\"identifier\", \"etag\", \"gotHandlers\"]),\n\t\t\t/** @type {AsyncParallelHook<[string, Etag | null, any]>} */\n\t\t\tstore: new AsyncParallelHook([\"identifier\", \"etag\", \"data\"]),\n\t\t\t/** @type {AsyncParallelHook<[Iterable<string>]>} */\n\t\t\tstoreBuildDependencies: new AsyncParallelHook([\"dependencies\"]),\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\tbeginIdle: new SyncHook([]),\n\t\t\t/** @type {AsyncParallelHook<[]>} */\n\t\t\tendIdle: new AsyncParallelHook([]),\n\t\t\t/** @type {AsyncParallelHook<[]>} */\n\t\t\tshutdown: new AsyncParallelHook([])\n\t\t};\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {CallbackCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tget(identifier, etag, callback) {\n\t\tconst gotHandlers = [];\n\t\tthis.hooks.get.callAsync(identifier, etag, gotHandlers, (err, result) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(makeWebpackError(err, \"Cache.hooks.get\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (result === null) {\n\t\t\t\tresult = undefined;\n\t\t\t}\n\t\t\tif (gotHandlers.length > 1) {\n\t\t\t\tconst innerCallback = needCalls(gotHandlers.length, () =>\n\t\t\t\t\tcallback(null, result)\n\t\t\t\t);\n\t\t\t\tfor (const gotHandler of gotHandlers) {\n\t\t\t\t\tgotHandler(result, innerCallback);\n\t\t\t\t}\n\t\t\t} else if (gotHandlers.length === 1) {\n\t\t\t\tgotHandlers[0](result, () => callback(null, result));\n\t\t\t} else {\n\t\t\t\tcallback(null, result);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {T} data the value to store\n\t * @param {CallbackCache<void>} callback signals when the value is stored\n\t * @returns {void}\n\t */\n\tstore(identifier, etag, data, callback) {\n\t\tthis.hooks.store.callAsync(\n\t\t\tidentifier,\n\t\t\tetag,\n\t\t\tdata,\n\t\t\tmakeWebpackErrorCallback(callback, \"Cache.hooks.store\")\n\t\t);\n\t}\n\n\t/**\n\t * After this method has succeeded the cache can only be restored when build dependencies are\n\t * @param {Iterable<string>} dependencies list of all build dependencies\n\t * @param {CallbackCache<void>} callback signals when the dependencies are stored\n\t * @returns {void}\n\t */\n\tstoreBuildDependencies(dependencies, callback) {\n\t\tthis.hooks.storeBuildDependencies.callAsync(\n\t\t\tdependencies,\n\t\t\tmakeWebpackErrorCallback(callback, \"Cache.hooks.storeBuildDependencies\")\n\t\t);\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tbeginIdle() {\n\t\tthis.hooks.beginIdle.call();\n\t}\n\n\t/**\n\t * @param {CallbackCache<void>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\tendIdle(callback) {\n\t\tthis.hooks.endIdle.callAsync(\n\t\t\tmakeWebpackErrorCallback(callback, \"Cache.hooks.endIdle\")\n\t\t);\n\t}\n\n\t/**\n\t * @param {CallbackCache<void>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\tshutdown(callback) {\n\t\tthis.hooks.shutdown.callAsync(\n\t\t\tmakeWebpackErrorCallback(callback, \"Cache.hooks.shutdown\")\n\t\t);\n\t}\n}\n\nCache.STAGE_MEMORY = -10;\nCache.STAGE_DEFAULT = 0;\nCache.STAGE_DISK = 10;\nCache.STAGE_NETWORK = 20;\n\nmodule.exports = Cache;\n"]},"metadata":{},"sourceType":"script"}