{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Sergey Melyukov @smelukov\n*/\n\"use strict\";\n\nvar _objectSpread = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar asyncLib = require(\"neo-async\");\n\nvar _require = require(\"tapable\"),\n    SyncBailHook = _require.SyncBailHook;\n\nvar Compilation = require(\"../lib/Compilation\");\n\nvar createSchemaValidation = require(\"./util/create-schema-validation\");\n\nvar _require2 = require(\"./util/fs\"),\n    join = _require2.join;\n\nvar processAsyncTree = require(\"./util/processAsyncTree\");\n/** @typedef {import(\"../declarations/WebpackOptions\").CleanOptions} CleanOptions */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n\n/** @typedef {import(\"./util/fs\").StatsCallback} StatsCallback */\n\n/** @typedef {(function(string):boolean)|RegExp} IgnoreItem */\n\n/** @typedef {function(IgnoreItem): void} AddToIgnoreCallback */\n\n/**\n * @typedef {Object} CleanPluginCompilationHooks\n * @property {SyncBailHook<[string], boolean>} keep when returning true the file/directory will be kept during cleaning, returning false will clean it and ignore the following plugins and config\n */\n\n\nvar validate = createSchemaValidation(undefined, function () {\n  var _require3 = require(\"../schemas/WebpackOptions.json\"),\n      definitions = _require3.definitions;\n\n  return {\n    definitions: definitions,\n    oneOf: [{\n      $ref: \"#/definitions/CleanOptions\"\n    }]\n  };\n}, {\n  name: \"Clean Plugin\",\n  baseDataPath: \"options\"\n});\n/**\n * @param {OutputFileSystem} fs filesystem\n * @param {string} outputPath output path\n * @param {Set<string>} currentAssets filename of the current assets (must not start with .. or ., must only use / as path separator)\n * @param {function((Error | null)=, Set<string>=): void} callback returns the filenames of the assets that shouldn't be there\n * @returns {void}\n */\n\nvar getDiffToFs = function getDiffToFs(fs, outputPath, currentAssets, callback) {\n  var directories = new Set(); // get directories of assets\n\n  var _iterator = _createForOfIteratorHelper(currentAssets),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var asset = _step.value;\n      directories.add(asset.replace(/(^|\\/)[^/]*$/, \"\"));\n    } // and all parent directories\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(directories),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var directory = _step2.value;\n      directories.add(directory.replace(/(^|\\/)[^/]*$/, \"\"));\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  var diff = new Set();\n  asyncLib.forEachLimit(directories, 10, function (directory, callback) {\n    fs.readdir(join(fs, outputPath, directory), function (err, entries) {\n      if (err) {\n        if (err.code === \"ENOENT\") return callback();\n\n        if (err.code === \"ENOTDIR\") {\n          diff.add(directory);\n          return callback();\n        }\n\n        return callback(err);\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(entries),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var entry = _step3.value;\n          var file =\n          /** @type {string} */\n          entry;\n          var filename = directory ? \"\".concat(directory, \"/\").concat(file) : file;\n\n          if (!directories.has(filename) && !currentAssets.has(filename)) {\n            diff.add(filename);\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      callback();\n    });\n  }, function (err) {\n    if (err) return callback(err);\n    callback(null, diff);\n  });\n};\n/**\n * @param {Set<string>} currentAssets assets list\n * @param {Set<string>} oldAssets old assets list\n * @returns {Set<string>} diff\n */\n\n\nvar getDiffToOldAssets = function getDiffToOldAssets(currentAssets, oldAssets) {\n  var diff = new Set();\n\n  var _iterator4 = _createForOfIteratorHelper(oldAssets),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var asset = _step4.value;\n      if (!currentAssets.has(asset)) diff.add(asset);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return diff;\n};\n/**\n * @param {OutputFileSystem} fs filesystem\n * @param {string} filename path to file\n * @param {StatsCallback} callback callback for provided filename\n * @returns {void}\n */\n\n\nvar doStat = function doStat(fs, filename, callback) {\n  if (\"lstat\" in fs) {\n    fs.lstat(filename, callback);\n  } else {\n    fs.stat(filename, callback);\n  }\n};\n/**\n * @param {OutputFileSystem} fs filesystem\n * @param {string} outputPath output path\n * @param {boolean} dry only log instead of fs modification\n * @param {Logger} logger logger\n * @param {Set<string>} diff filenames of the assets that shouldn't be there\n * @param {function(string): boolean} isKept check if the entry is ignored\n * @param {function(Error=): void} callback callback\n * @returns {void}\n */\n\n\nvar applyDiff = function applyDiff(fs, outputPath, dry, logger, diff, isKept, callback) {\n  var log = function log(msg) {\n    if (dry) {\n      logger.info(msg);\n    } else {\n      logger.log(msg);\n    }\n  };\n  /** @typedef {{ type: \"check\" | \"unlink\" | \"rmdir\", filename: string, parent: { remaining: number, job: Job } | undefined }} Job */\n\n  /** @type {Job[]} */\n\n\n  var jobs = Array.from(diff, function (filename) {\n    return {\n      type: \"check\",\n      filename: filename,\n      parent: undefined\n    };\n  });\n  processAsyncTree(jobs, 10, function (_ref, push, callback) {\n    var type = _ref.type,\n        filename = _ref.filename,\n        parent = _ref.parent;\n\n    var handleError = function handleError(err) {\n      if (err.code === \"ENOENT\") {\n        log(\"\".concat(filename, \" was removed during cleaning by something else\"));\n        handleParent();\n        return callback();\n      }\n\n      return callback(err);\n    };\n\n    var handleParent = function handleParent() {\n      if (parent && --parent.remaining === 0) push(parent.job);\n    };\n\n    var path = join(fs, outputPath, filename);\n\n    switch (type) {\n      case \"check\":\n        if (isKept(filename)) {\n          // do not decrement parent entry as we don't want to delete the parent\n          log(\"\".concat(filename, \" will be kept\"));\n          return process.nextTick(callback);\n        }\n\n        doStat(fs, path, function (err, stats) {\n          if (err) return handleError(err);\n\n          if (!stats.isDirectory()) {\n            push({\n              type: \"unlink\",\n              filename: filename,\n              parent: parent\n            });\n            return callback();\n          }\n\n          fs.readdir(path, function (err, entries) {\n            if (err) return handleError(err);\n            /** @type {Job} */\n\n            var deleteJob = {\n              type: \"rmdir\",\n              filename: filename,\n              parent: parent\n            };\n\n            if (entries.length === 0) {\n              push(deleteJob);\n            } else {\n              var parentToken = {\n                remaining: entries.length,\n                job: deleteJob\n              };\n\n              var _iterator5 = _createForOfIteratorHelper(entries),\n                  _step5;\n\n              try {\n                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                  var entry = _step5.value;\n                  var file =\n                  /** @type {string} */\n                  entry;\n\n                  if (file.startsWith(\".\")) {\n                    log(\"\".concat(filename, \" will be kept (dot-files will never be removed)\"));\n                    continue;\n                  }\n\n                  push({\n                    type: \"check\",\n                    filename: \"\".concat(filename, \"/\").concat(file),\n                    parent: parentToken\n                  });\n                }\n              } catch (err) {\n                _iterator5.e(err);\n              } finally {\n                _iterator5.f();\n              }\n            }\n\n            return callback();\n          });\n        });\n        break;\n\n      case \"rmdir\":\n        log(\"\".concat(filename, \" will be removed\"));\n\n        if (dry) {\n          handleParent();\n          return process.nextTick(callback);\n        }\n\n        if (!fs.rmdir) {\n          logger.warn(\"\".concat(filename, \" can't be removed because output file system doesn't support removing directories (rmdir)\"));\n          return process.nextTick(callback);\n        }\n\n        fs.rmdir(path, function (err) {\n          if (err) return handleError(err);\n          handleParent();\n          callback();\n        });\n        break;\n\n      case \"unlink\":\n        log(\"\".concat(filename, \" will be removed\"));\n\n        if (dry) {\n          handleParent();\n          return process.nextTick(callback);\n        }\n\n        if (!fs.unlink) {\n          logger.warn(\"\".concat(filename, \" can't be removed because output file system doesn't support removing files (rmdir)\"));\n          return process.nextTick(callback);\n        }\n\n        fs.unlink(path, function (err) {\n          if (err) return handleError(err);\n          handleParent();\n          callback();\n        });\n        break;\n    }\n  }, callback);\n};\n/** @type {WeakMap<Compilation, CleanPluginCompilationHooks>} */\n\n\nvar compilationHooksMap = new WeakMap();\n\nvar CleanPlugin = /*#__PURE__*/function () {\n  /** @param {CleanOptions} options options */\n  function CleanPlugin() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, CleanPlugin);\n\n    validate(options);\n    this.options = _objectSpread({\n      dry: false\n    }, options);\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  _createClass(CleanPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var _this$options = this.options,\n          dry = _this$options.dry,\n          keep = _this$options.keep;\n      var keepFn = typeof keep === \"function\" ? keep : typeof keep === \"string\" ? function (path) {\n        return path.startsWith(keep);\n      } : typeof keep === \"object\" && keep.test ? function (path) {\n        return keep.test(path);\n      } : function () {\n        return false;\n      }; // We assume that no external modification happens while the compiler is active\n      // So we can store the old assets and only diff to them to avoid fs access on\n      // incremental builds\n\n      var oldAssets;\n      compiler.hooks.emit.tapAsync({\n        name: \"CleanPlugin\",\n        stage: 100\n      }, function (compilation, callback) {\n        var hooks = CleanPlugin.getCompilationHooks(compilation);\n        var logger = compilation.getLogger(\"webpack.CleanPlugin\");\n        var fs = compiler.outputFileSystem;\n\n        if (!fs.readdir) {\n          return callback(new Error(\"CleanPlugin: Output filesystem doesn't support listing directories (readdir)\"));\n        }\n\n        var currentAssets = new Set();\n\n        for (var _i = 0, _Object$keys = Object.keys(compilation.assets); _i < _Object$keys.length; _i++) {\n          var asset = _Object$keys[_i];\n          if (/^[A-Za-z]:\\\\|^\\/|^\\\\\\\\/.test(asset)) continue;\n          var normalizedAsset = void 0;\n          var newNormalizedAsset = asset.replace(/\\\\/g, \"/\");\n\n          do {\n            normalizedAsset = newNormalizedAsset;\n            newNormalizedAsset = normalizedAsset.replace(/(^|\\/)(?!\\.\\.)[^/]+\\/\\.\\.\\//g, \"$1\");\n          } while (newNormalizedAsset !== normalizedAsset);\n\n          if (normalizedAsset.startsWith(\"../\")) continue;\n          currentAssets.add(normalizedAsset);\n        }\n\n        var outputPath = compilation.getPath(compiler.outputPath, {});\n\n        var isKept = function isKept(path) {\n          var result = hooks.keep.call(path);\n          if (result !== undefined) return result;\n          return keepFn(path);\n        };\n\n        var diffCallback = function diffCallback(err, diff) {\n          if (err) {\n            oldAssets = undefined;\n            return callback(err);\n          }\n\n          applyDiff(fs, outputPath, dry, logger, diff, isKept, function (err) {\n            if (err) {\n              oldAssets = undefined;\n            } else {\n              oldAssets = currentAssets;\n            }\n\n            callback(err);\n          });\n        };\n\n        if (oldAssets) {\n          diffCallback(null, getDiffToOldAssets(currentAssets, oldAssets));\n        } else {\n          getDiffToFs(fs, outputPath, currentAssets, diffCallback);\n        }\n      });\n    }\n  }], [{\n    key: \"getCompilationHooks\",\n    value:\n    /**\n     * @param {Compilation} compilation the compilation\n     * @returns {CleanPluginCompilationHooks} the attached hooks\n     */\n    function getCompilationHooks(compilation) {\n      if (!(compilation instanceof Compilation)) {\n        throw new TypeError(\"The 'compilation' argument must be an instance of Compilation\");\n      }\n\n      var hooks = compilationHooksMap.get(compilation);\n\n      if (hooks === undefined) {\n        hooks = {\n          /** @type {SyncBailHook<[string], boolean>} */\n          keep: new SyncBailHook([\"ignore\"])\n        };\n        compilationHooksMap.set(compilation, hooks);\n      }\n\n      return hooks;\n    }\n  }]);\n\n  return CleanPlugin;\n}();\n\nmodule.exports = CleanPlugin;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/CleanPlugin.js"],"names":["asyncLib","require","SyncBailHook","Compilation","createSchemaValidation","join","processAsyncTree","validate","undefined","definitions","oneOf","$ref","name","baseDataPath","getDiffToFs","fs","outputPath","currentAssets","callback","directories","Set","asset","add","replace","directory","diff","forEachLimit","readdir","err","entries","code","entry","file","filename","has","getDiffToOldAssets","oldAssets","doStat","lstat","stat","applyDiff","dry","logger","isKept","log","msg","info","jobs","Array","from","type","parent","push","handleError","handleParent","remaining","job","path","process","nextTick","stats","isDirectory","deleteJob","length","parentToken","startsWith","rmdir","warn","unlink","compilationHooksMap","WeakMap","CleanPlugin","options","compiler","keep","keepFn","test","hooks","emit","tapAsync","stage","compilation","getCompilationHooks","getLogger","outputFileSystem","Error","Object","keys","assets","normalizedAsset","newNormalizedAsset","getPath","result","call","diffCallback","TypeError","get","set","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Sergey Melyukov @smelukov\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst { SyncBailHook } = require(\"tapable\");\nconst Compilation = require(\"../lib/Compilation\");\nconst createSchemaValidation = require(\"./util/create-schema-validation\");\nconst { join } = require(\"./util/fs\");\nconst processAsyncTree = require(\"./util/processAsyncTree\");\n\n/** @typedef {import(\"../declarations/WebpackOptions\").CleanOptions} CleanOptions */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n/** @typedef {import(\"./util/fs\").StatsCallback} StatsCallback */\n\n/** @typedef {(function(string):boolean)|RegExp} IgnoreItem */\n/** @typedef {function(IgnoreItem): void} AddToIgnoreCallback */\n\n/**\n * @typedef {Object} CleanPluginCompilationHooks\n * @property {SyncBailHook<[string], boolean>} keep when returning true the file/directory will be kept during cleaning, returning false will clean it and ignore the following plugins and config\n */\n\nconst validate = createSchemaValidation(\n\tundefined,\n\t() => {\n\t\tconst { definitions } = require(\"../schemas/WebpackOptions.json\");\n\t\treturn {\n\t\t\tdefinitions,\n\t\t\toneOf: [{ $ref: \"#/definitions/CleanOptions\" }]\n\t\t};\n\t},\n\t{\n\t\tname: \"Clean Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\n/**\n * @param {OutputFileSystem} fs filesystem\n * @param {string} outputPath output path\n * @param {Set<string>} currentAssets filename of the current assets (must not start with .. or ., must only use / as path separator)\n * @param {function((Error | null)=, Set<string>=): void} callback returns the filenames of the assets that shouldn't be there\n * @returns {void}\n */\nconst getDiffToFs = (fs, outputPath, currentAssets, callback) => {\n\tconst directories = new Set();\n\t// get directories of assets\n\tfor (const asset of currentAssets) {\n\t\tdirectories.add(asset.replace(/(^|\\/)[^/]*$/, \"\"));\n\t}\n\t// and all parent directories\n\tfor (const directory of directories) {\n\t\tdirectories.add(directory.replace(/(^|\\/)[^/]*$/, \"\"));\n\t}\n\tconst diff = new Set();\n\tasyncLib.forEachLimit(\n\t\tdirectories,\n\t\t10,\n\t\t(directory, callback) => {\n\t\t\tfs.readdir(join(fs, outputPath, directory), (err, entries) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tif (err.code === \"ENOENT\") return callback();\n\t\t\t\t\tif (err.code === \"ENOTDIR\") {\n\t\t\t\t\t\tdiff.add(directory);\n\t\t\t\t\t\treturn callback();\n\t\t\t\t\t}\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\t\t\t\tfor (const entry of entries) {\n\t\t\t\t\tconst file = /** @type {string} */ (entry);\n\t\t\t\t\tconst filename = directory ? `${directory}/${file}` : file;\n\t\t\t\t\tif (!directories.has(filename) && !currentAssets.has(filename)) {\n\t\t\t\t\t\tdiff.add(filename);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcallback();\n\t\t\t});\n\t\t},\n\t\terr => {\n\t\t\tif (err) return callback(err);\n\n\t\t\tcallback(null, diff);\n\t\t}\n\t);\n};\n\n/**\n * @param {Set<string>} currentAssets assets list\n * @param {Set<string>} oldAssets old assets list\n * @returns {Set<string>} diff\n */\nconst getDiffToOldAssets = (currentAssets, oldAssets) => {\n\tconst diff = new Set();\n\tfor (const asset of oldAssets) {\n\t\tif (!currentAssets.has(asset)) diff.add(asset);\n\t}\n\treturn diff;\n};\n\n/**\n * @param {OutputFileSystem} fs filesystem\n * @param {string} filename path to file\n * @param {StatsCallback} callback callback for provided filename\n * @returns {void}\n */\nconst doStat = (fs, filename, callback) => {\n\tif (\"lstat\" in fs) {\n\t\tfs.lstat(filename, callback);\n\t} else {\n\t\tfs.stat(filename, callback);\n\t}\n};\n\n/**\n * @param {OutputFileSystem} fs filesystem\n * @param {string} outputPath output path\n * @param {boolean} dry only log instead of fs modification\n * @param {Logger} logger logger\n * @param {Set<string>} diff filenames of the assets that shouldn't be there\n * @param {function(string): boolean} isKept check if the entry is ignored\n * @param {function(Error=): void} callback callback\n * @returns {void}\n */\nconst applyDiff = (fs, outputPath, dry, logger, diff, isKept, callback) => {\n\tconst log = msg => {\n\t\tif (dry) {\n\t\t\tlogger.info(msg);\n\t\t} else {\n\t\t\tlogger.log(msg);\n\t\t}\n\t};\n\t/** @typedef {{ type: \"check\" | \"unlink\" | \"rmdir\", filename: string, parent: { remaining: number, job: Job } | undefined }} Job */\n\t/** @type {Job[]} */\n\tconst jobs = Array.from(diff, filename => ({\n\t\ttype: \"check\",\n\t\tfilename,\n\t\tparent: undefined\n\t}));\n\tprocessAsyncTree(\n\t\tjobs,\n\t\t10,\n\t\t({ type, filename, parent }, push, callback) => {\n\t\t\tconst handleError = err => {\n\t\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\t\tlog(`${filename} was removed during cleaning by something else`);\n\t\t\t\t\thandleParent();\n\t\t\t\t\treturn callback();\n\t\t\t\t}\n\t\t\t\treturn callback(err);\n\t\t\t};\n\t\t\tconst handleParent = () => {\n\t\t\t\tif (parent && --parent.remaining === 0) push(parent.job);\n\t\t\t};\n\t\t\tconst path = join(fs, outputPath, filename);\n\t\t\tswitch (type) {\n\t\t\t\tcase \"check\":\n\t\t\t\t\tif (isKept(filename)) {\n\t\t\t\t\t\t// do not decrement parent entry as we don't want to delete the parent\n\t\t\t\t\t\tlog(`${filename} will be kept`);\n\t\t\t\t\t\treturn process.nextTick(callback);\n\t\t\t\t\t}\n\t\t\t\t\tdoStat(fs, path, (err, stats) => {\n\t\t\t\t\t\tif (err) return handleError(err);\n\t\t\t\t\t\tif (!stats.isDirectory()) {\n\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\ttype: \"unlink\",\n\t\t\t\t\t\t\t\tfilename,\n\t\t\t\t\t\t\t\tparent\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfs.readdir(path, (err, entries) => {\n\t\t\t\t\t\t\tif (err) return handleError(err);\n\t\t\t\t\t\t\t/** @type {Job} */\n\t\t\t\t\t\t\tconst deleteJob = {\n\t\t\t\t\t\t\t\ttype: \"rmdir\",\n\t\t\t\t\t\t\t\tfilename,\n\t\t\t\t\t\t\t\tparent\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (entries.length === 0) {\n\t\t\t\t\t\t\t\tpush(deleteJob);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst parentToken = {\n\t\t\t\t\t\t\t\t\tremaining: entries.length,\n\t\t\t\t\t\t\t\t\tjob: deleteJob\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tfor (const entry of entries) {\n\t\t\t\t\t\t\t\t\tconst file = /** @type {string} */ (entry);\n\t\t\t\t\t\t\t\t\tif (file.startsWith(\".\")) {\n\t\t\t\t\t\t\t\t\t\tlog(\n\t\t\t\t\t\t\t\t\t\t\t`${filename} will be kept (dot-files will never be removed)`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\t\ttype: \"check\",\n\t\t\t\t\t\t\t\t\t\tfilename: `${filename}/${file}`,\n\t\t\t\t\t\t\t\t\t\tparent: parentToken\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"rmdir\":\n\t\t\t\t\tlog(`${filename} will be removed`);\n\t\t\t\t\tif (dry) {\n\t\t\t\t\t\thandleParent();\n\t\t\t\t\t\treturn process.nextTick(callback);\n\t\t\t\t\t}\n\t\t\t\t\tif (!fs.rmdir) {\n\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t`${filename} can't be removed because output file system doesn't support removing directories (rmdir)`\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn process.nextTick(callback);\n\t\t\t\t\t}\n\t\t\t\t\tfs.rmdir(path, err => {\n\t\t\t\t\t\tif (err) return handleError(err);\n\t\t\t\t\t\thandleParent();\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"unlink\":\n\t\t\t\t\tlog(`${filename} will be removed`);\n\t\t\t\t\tif (dry) {\n\t\t\t\t\t\thandleParent();\n\t\t\t\t\t\treturn process.nextTick(callback);\n\t\t\t\t\t}\n\t\t\t\t\tif (!fs.unlink) {\n\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t`${filename} can't be removed because output file system doesn't support removing files (rmdir)`\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn process.nextTick(callback);\n\t\t\t\t\t}\n\t\t\t\t\tfs.unlink(path, err => {\n\t\t\t\t\t\tif (err) return handleError(err);\n\t\t\t\t\t\thandleParent();\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t},\n\t\tcallback\n\t);\n};\n\n/** @type {WeakMap<Compilation, CleanPluginCompilationHooks>} */\nconst compilationHooksMap = new WeakMap();\n\nclass CleanPlugin {\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @returns {CleanPluginCompilationHooks} the attached hooks\n\t */\n\tstatic getCompilationHooks(compilation) {\n\t\tif (!(compilation instanceof Compilation)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t\"The 'compilation' argument must be an instance of Compilation\"\n\t\t\t);\n\t\t}\n\t\tlet hooks = compilationHooksMap.get(compilation);\n\t\tif (hooks === undefined) {\n\t\t\thooks = {\n\t\t\t\t/** @type {SyncBailHook<[string], boolean>} */\n\t\t\t\tkeep: new SyncBailHook([\"ignore\"])\n\t\t\t};\n\t\t\tcompilationHooksMap.set(compilation, hooks);\n\t\t}\n\t\treturn hooks;\n\t}\n\n\t/** @param {CleanOptions} options options */\n\tconstructor(options = {}) {\n\t\tvalidate(options);\n\t\tthis.options = { dry: false, ...options };\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst { dry, keep } = this.options;\n\n\t\tconst keepFn =\n\t\t\ttypeof keep === \"function\"\n\t\t\t\t? keep\n\t\t\t\t: typeof keep === \"string\"\n\t\t\t\t? path => path.startsWith(keep)\n\t\t\t\t: typeof keep === \"object\" && keep.test\n\t\t\t\t? path => keep.test(path)\n\t\t\t\t: () => false;\n\n\t\t// We assume that no external modification happens while the compiler is active\n\t\t// So we can store the old assets and only diff to them to avoid fs access on\n\t\t// incremental builds\n\t\tlet oldAssets;\n\n\t\tcompiler.hooks.emit.tapAsync(\n\t\t\t{\n\t\t\t\tname: \"CleanPlugin\",\n\t\t\t\tstage: 100\n\t\t\t},\n\t\t\t(compilation, callback) => {\n\t\t\t\tconst hooks = CleanPlugin.getCompilationHooks(compilation);\n\t\t\t\tconst logger = compilation.getLogger(\"webpack.CleanPlugin\");\n\t\t\t\tconst fs = compiler.outputFileSystem;\n\n\t\t\t\tif (!fs.readdir) {\n\t\t\t\t\treturn callback(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\"CleanPlugin: Output filesystem doesn't support listing directories (readdir)\"\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst currentAssets = new Set();\n\t\t\t\tfor (const asset of Object.keys(compilation.assets)) {\n\t\t\t\t\tif (/^[A-Za-z]:\\\\|^\\/|^\\\\\\\\/.test(asset)) continue;\n\t\t\t\t\tlet normalizedAsset;\n\t\t\t\t\tlet newNormalizedAsset = asset.replace(/\\\\/g, \"/\");\n\t\t\t\t\tdo {\n\t\t\t\t\t\tnormalizedAsset = newNormalizedAsset;\n\t\t\t\t\t\tnewNormalizedAsset = normalizedAsset.replace(\n\t\t\t\t\t\t\t/(^|\\/)(?!\\.\\.)[^/]+\\/\\.\\.\\//g,\n\t\t\t\t\t\t\t\"$1\"\n\t\t\t\t\t\t);\n\t\t\t\t\t} while (newNormalizedAsset !== normalizedAsset);\n\t\t\t\t\tif (normalizedAsset.startsWith(\"../\")) continue;\n\t\t\t\t\tcurrentAssets.add(normalizedAsset);\n\t\t\t\t}\n\n\t\t\t\tconst outputPath = compilation.getPath(compiler.outputPath, {});\n\n\t\t\t\tconst isKept = path => {\n\t\t\t\t\tconst result = hooks.keep.call(path);\n\t\t\t\t\tif (result !== undefined) return result;\n\t\t\t\t\treturn keepFn(path);\n\t\t\t\t};\n\n\t\t\t\tconst diffCallback = (err, diff) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\toldAssets = undefined;\n\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t}\n\t\t\t\t\tapplyDiff(fs, outputPath, dry, logger, diff, isKept, err => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\toldAssets = undefined;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toldAssets = currentAssets;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tif (oldAssets) {\n\t\t\t\t\tdiffCallback(null, getDiffToOldAssets(currentAssets, oldAssets));\n\t\t\t\t} else {\n\t\t\t\t\tgetDiffToFs(fs, outputPath, currentAssets, diffCallback);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = CleanPlugin;\n"]},"metadata":{},"sourceType":"script"}