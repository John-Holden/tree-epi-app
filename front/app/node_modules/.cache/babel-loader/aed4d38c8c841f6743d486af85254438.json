{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _objectSpread = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _toConsumableArray = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _slicedToArray = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _inherits = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _require = require(\"acorn\"),\n    AcornParser = _require.Parser;\n\nvar _require2 = require(\"acorn-import-assertions\"),\n    importAssertions = _require2.importAssertions;\n\nvar _require3 = require(\"tapable\"),\n    SyncBailHook = _require3.SyncBailHook,\n    HookMap = _require3.HookMap;\n\nvar vm = require(\"vm\");\n\nvar Parser = require(\"../Parser\");\n\nvar StackedMap = require(\"../util/StackedMap\");\n\nvar binarySearchBounds = require(\"../util/binarySearchBounds\");\n\nvar memoize = require(\"../util/memoize\");\n\nvar BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\n/** @typedef {import(\"acorn\").Options} AcornOptions */\n\n/** @typedef {import(\"estree\").ArrayExpression} ArrayExpressionNode */\n\n/** @typedef {import(\"estree\").BinaryExpression} BinaryExpressionNode */\n\n/** @typedef {import(\"estree\").BlockStatement} BlockStatementNode */\n\n/** @typedef {import(\"estree\").SequenceExpression} SequenceExpressionNode */\n\n/** @typedef {import(\"estree\").CallExpression} CallExpressionNode */\n\n/** @typedef {import(\"estree\").ClassDeclaration} ClassDeclarationNode */\n\n/** @typedef {import(\"estree\").ClassExpression} ClassExpressionNode */\n\n/** @typedef {import(\"estree\").Comment} CommentNode */\n\n/** @typedef {import(\"estree\").ConditionalExpression} ConditionalExpressionNode */\n\n/** @typedef {import(\"estree\").Declaration} DeclarationNode */\n\n/** @typedef {import(\"estree\").PrivateIdentifier} PrivateIdentifierNode */\n\n/** @typedef {import(\"estree\").PropertyDefinition} PropertyDefinitionNode */\n\n/** @typedef {import(\"estree\").Expression} ExpressionNode */\n\n/** @typedef {import(\"estree\").Identifier} IdentifierNode */\n\n/** @typedef {import(\"estree\").IfStatement} IfStatementNode */\n\n/** @typedef {import(\"estree\").LabeledStatement} LabeledStatementNode */\n\n/** @typedef {import(\"estree\").Literal} LiteralNode */\n\n/** @typedef {import(\"estree\").LogicalExpression} LogicalExpressionNode */\n\n/** @typedef {import(\"estree\").ChainExpression} ChainExpressionNode */\n\n/** @typedef {import(\"estree\").MemberExpression} MemberExpressionNode */\n\n/** @typedef {import(\"estree\").MetaProperty} MetaPropertyNode */\n\n/** @typedef {import(\"estree\").MethodDefinition} MethodDefinitionNode */\n\n/** @typedef {import(\"estree\").ModuleDeclaration} ModuleDeclarationNode */\n\n/** @typedef {import(\"estree\").NewExpression} NewExpressionNode */\n\n/** @typedef {import(\"estree\").Node} AnyNode */\n\n/** @typedef {import(\"estree\").Program} ProgramNode */\n\n/** @typedef {import(\"estree\").Statement} StatementNode */\n\n/** @typedef {import(\"estree\").ImportDeclaration} ImportDeclarationNode */\n\n/** @typedef {import(\"estree\").ExportNamedDeclaration} ExportNamedDeclarationNode */\n\n/** @typedef {import(\"estree\").ExportDefaultDeclaration} ExportDefaultDeclarationNode */\n\n/** @typedef {import(\"estree\").ExportAllDeclaration} ExportAllDeclarationNode */\n\n/** @typedef {import(\"estree\").Super} SuperNode */\n\n/** @typedef {import(\"estree\").TaggedTemplateExpression} TaggedTemplateExpressionNode */\n\n/** @typedef {import(\"estree\").TemplateLiteral} TemplateLiteralNode */\n\n/** @typedef {import(\"estree\").ThisExpression} ThisExpressionNode */\n\n/** @typedef {import(\"estree\").UnaryExpression} UnaryExpressionNode */\n\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclaratorNode */\n\n/** @template T @typedef {import(\"tapable\").AsArray<T>} AsArray<T> */\n\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n\n/** @typedef {import(\"../Parser\").PreparsedAst} PreparsedAst */\n\n/** @typedef {{declaredScope: ScopeInfo, freeName: string | true, tagInfo: TagInfo | undefined}} VariableInfoInterface */\n\n/** @typedef {{ name: string | VariableInfo, rootInfo: string | VariableInfo, getMembers: () => string[] }} GetInfoResult */\n\n\nvar EMPTY_ARRAY = [];\nvar ALLOWED_MEMBER_TYPES_CALL_EXPRESSION = 1;\nvar ALLOWED_MEMBER_TYPES_EXPRESSION = 2;\nvar ALLOWED_MEMBER_TYPES_ALL = 3; // Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\n\nvar parser = AcornParser.extend(importAssertions);\n\nvar VariableInfo = /*#__PURE__*/_createClass(\n/**\n * @param {ScopeInfo} declaredScope scope in which the variable is declared\n * @param {string | true} freeName which free name the variable aliases, or true when none\n * @param {TagInfo | undefined} tagInfo info about tags\n */\nfunction VariableInfo(declaredScope, freeName, tagInfo) {\n  _classCallCheck(this, VariableInfo);\n\n  this.declaredScope = declaredScope;\n  this.freeName = freeName;\n  this.tagInfo = tagInfo;\n});\n/** @typedef {string | ScopeInfo | VariableInfo} ExportedVariableInfo */\n\n/** @typedef {LiteralNode | string | null | undefined} ImportSource */\n\n/** @typedef {Omit<AcornOptions, \"sourceType\" | \"ecmaVersion\"> & { sourceType: \"module\" | \"script\" | \"auto\", ecmaVersion?: AcornOptions[\"ecmaVersion\"] }} ParseOptions */\n\n/**\n * @typedef {Object} TagInfo\n * @property {any} tag\n * @property {any} data\n * @property {TagInfo | undefined} next\n */\n\n/**\n * @typedef {Object} ScopeInfo\n * @property {StackedMap<string, VariableInfo | ScopeInfo>} definitions\n * @property {boolean | \"arrow\"} topLevelScope\n * @property {boolean} inShorthand\n * @property {boolean} isStrict\n * @property {boolean} isAsmJs\n * @property {boolean} inTry\n */\n\n\nvar joinRanges = function joinRanges(startRange, endRange) {\n  if (!endRange) return startRange;\n  if (!startRange) return endRange;\n  return [startRange[0], endRange[1]];\n};\n\nvar objectAndMembersToName = function objectAndMembersToName(object, membersReversed) {\n  var name = object;\n\n  for (var i = membersReversed.length - 1; i >= 0; i--) {\n    name = name + \".\" + membersReversed[i];\n  }\n\n  return name;\n};\n\nvar getRootName = function getRootName(expression) {\n  switch (expression.type) {\n    case \"Identifier\":\n      return expression.name;\n\n    case \"ThisExpression\":\n      return \"this\";\n\n    case \"MetaProperty\":\n      return \"\".concat(expression.meta.name, \".\").concat(expression.property.name);\n\n    default:\n      return undefined;\n  }\n};\n/** @type {AcornOptions} */\n\n\nvar defaultParserOptions = {\n  ranges: true,\n  locations: true,\n  ecmaVersion: \"latest\",\n  sourceType: \"module\",\n  // https://github.com/tc39/proposal-hashbang\n  allowHashBang: true,\n  onComment: null\n}; // regexp to match at least one \"magic comment\"\n\nvar webpackCommentRegExp = new RegExp(/(^|\\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);\nvar EMPTY_COMMENT_OPTIONS = {\n  options: null,\n  errors: null\n};\n\nvar JavascriptParser = /*#__PURE__*/function (_Parser) {\n  _inherits(JavascriptParser, _Parser);\n\n  var _super = _createSuper(JavascriptParser);\n\n  /**\n   * @param {\"module\" | \"script\" | \"auto\"} sourceType default source type\n   */\n  function JavascriptParser() {\n    var _this;\n\n    var sourceType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"auto\";\n\n    _classCallCheck(this, JavascriptParser);\n\n    _this = _super.call(this);\n    _this.hooks = Object.freeze({\n      /** @type {HookMap<SyncBailHook<[UnaryExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n      evaluateTypeof: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n\n      /** @type {HookMap<SyncBailHook<[ExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n      evaluate: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n\n      /** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode | MetaPropertyNode], BasicEvaluatedExpression | undefined | null>>} */\n      evaluateIdentifier: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n\n      /** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n      evaluateDefinedIdentifier: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n\n      /** @type {HookMap<SyncBailHook<[CallExpressionNode, BasicEvaluatedExpression | undefined], BasicEvaluatedExpression | undefined | null>>} */\n      evaluateCallExpressionMember: new HookMap(function () {\n        return new SyncBailHook([\"expression\", \"param\"]);\n      }),\n\n      /** @type {HookMap<SyncBailHook<[ExpressionNode | DeclarationNode | PrivateIdentifierNode, number], boolean | void>>} */\n      isPure: new HookMap(function () {\n        return new SyncBailHook([\"expression\", \"commentsStartPosition\"]);\n      }),\n\n      /** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */\n      preStatement: new SyncBailHook([\"statement\"]),\n\n      /** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */\n      blockPreStatement: new SyncBailHook([\"declaration\"]),\n\n      /** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */\n      statement: new SyncBailHook([\"statement\"]),\n\n      /** @type {SyncBailHook<[IfStatementNode], boolean | void>} */\n      statementIf: new SyncBailHook([\"statement\"]),\n\n      /** @type {SyncBailHook<[ExpressionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */\n      classExtendsExpression: new SyncBailHook([\"expression\", \"classDefinition\"]),\n\n      /** @type {SyncBailHook<[MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */\n      classBodyElement: new SyncBailHook([\"element\", \"classDefinition\"]),\n\n      /** @type {SyncBailHook<[ExpressionNode, MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */\n      classBodyValue: new SyncBailHook([\"expression\", \"element\", \"classDefinition\"]),\n\n      /** @type {HookMap<SyncBailHook<[LabeledStatementNode], boolean | void>>} */\n      label: new HookMap(function () {\n        return new SyncBailHook([\"statement\"]);\n      }),\n\n      /** @type {SyncBailHook<[ImportDeclarationNode, ImportSource], boolean | void>} */\n      import: new SyncBailHook([\"statement\", \"source\"]),\n\n      /** @type {SyncBailHook<[ImportDeclarationNode, ImportSource, string, string], boolean | void>} */\n      importSpecifier: new SyncBailHook([\"statement\", \"source\", \"exportName\", \"identifierName\"]),\n\n      /** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode], boolean | void>} */\n      export: new SyncBailHook([\"statement\"]),\n\n      /** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource], boolean | void>} */\n      exportImport: new SyncBailHook([\"statement\", \"source\"]),\n\n      /** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, DeclarationNode], boolean | void>} */\n      exportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n\n      /** @type {SyncBailHook<[ExportDefaultDeclarationNode, DeclarationNode], boolean | void>} */\n      exportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n\n      /** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, string, string, number | undefined], boolean | void>} */\n      exportSpecifier: new SyncBailHook([\"statement\", \"identifierName\", \"exportName\", \"index\"]),\n\n      /** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource, string, string, number | undefined], boolean | void>} */\n      exportImportSpecifier: new SyncBailHook([\"statement\", \"source\", \"identifierName\", \"exportName\", \"index\"]),\n\n      /** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */\n      preDeclarator: new SyncBailHook([\"declarator\", \"statement\"]),\n\n      /** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */\n      declarator: new SyncBailHook([\"declarator\", \"statement\"]),\n\n      /** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n      varDeclaration: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n\n      /** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n      varDeclarationLet: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n\n      /** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n      varDeclarationConst: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n\n      /** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n      varDeclarationVar: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n\n      /** @type {HookMap<SyncBailHook<[IdentifierNode], boolean | void>>} */\n      pattern: new HookMap(function () {\n        return new SyncBailHook([\"pattern\"]);\n      }),\n\n      /** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n      canRename: new HookMap(function () {\n        return new SyncBailHook([\"initExpression\"]);\n      }),\n\n      /** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n      rename: new HookMap(function () {\n        return new SyncBailHook([\"initExpression\"]);\n      }),\n\n      /** @type {HookMap<SyncBailHook<[import(\"estree\").AssignmentExpression], boolean | void>>} */\n      assign: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n\n      /** @type {HookMap<SyncBailHook<[import(\"estree\").AssignmentExpression, string[]], boolean | void>>} */\n      assignMemberChain: new HookMap(function () {\n        return new SyncBailHook([\"expression\", \"members\"]);\n      }),\n\n      /** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n      typeof: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n\n      /** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n      importCall: new SyncBailHook([\"expression\"]),\n\n      /** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n      topLevelAwait: new SyncBailHook([\"expression\"]),\n\n      /** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n      call: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n\n      /** Something like \"a.b()\" */\n\n      /** @type {HookMap<SyncBailHook<[CallExpressionNode, string[]], boolean | void>>} */\n      callMemberChain: new HookMap(function () {\n        return new SyncBailHook([\"expression\", \"members\"]);\n      }),\n\n      /** Something like \"a.b().c.d\" */\n\n      /** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */\n      memberChainOfCallMemberChain: new HookMap(function () {\n        return new SyncBailHook([\"expression\", \"calleeMembers\", \"callExpression\", \"members\"]);\n      }),\n\n      /** Something like \"a.b().c.d()\"\" */\n\n      /** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */\n      callMemberChainOfCallMemberChain: new HookMap(function () {\n        return new SyncBailHook([\"expression\", \"calleeMembers\", \"innerCallExpression\", \"members\"]);\n      }),\n\n      /** @type {SyncBailHook<[ChainExpressionNode], boolean | void>} */\n      optionalChaining: new SyncBailHook([\"optionalChaining\"]),\n\n      /** @type {HookMap<SyncBailHook<[NewExpressionNode], boolean | void>>} */\n      new: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n\n      /** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n      expression: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n\n      /** @type {HookMap<SyncBailHook<[ExpressionNode, string[]], boolean | void>>} */\n      expressionMemberChain: new HookMap(function () {\n        return new SyncBailHook([\"expression\", \"members\"]);\n      }),\n\n      /** @type {HookMap<SyncBailHook<[ExpressionNode, string[]], boolean | void>>} */\n      unhandledExpressionMemberChain: new HookMap(function () {\n        return new SyncBailHook([\"expression\", \"members\"]);\n      }),\n\n      /** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n      expressionConditionalOperator: new SyncBailHook([\"expression\"]),\n\n      /** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n      expressionLogicalOperator: new SyncBailHook([\"expression\"]),\n\n      /** @type {SyncBailHook<[ProgramNode, CommentNode[]], boolean | void>} */\n      program: new SyncBailHook([\"ast\", \"comments\"]),\n\n      /** @type {SyncBailHook<[ProgramNode, CommentNode[]], boolean | void>} */\n      finish: new SyncBailHook([\"ast\", \"comments\"])\n    });\n    _this.sourceType = sourceType;\n    /** @type {ScopeInfo} */\n\n    _this.scope = undefined;\n    /** @type {ParserState} */\n\n    _this.state = undefined;\n    _this.comments = undefined;\n    _this.semicolons = undefined;\n    /** @type {(StatementNode|ExpressionNode)[]} */\n\n    _this.statementPath = undefined;\n    _this.prevStatement = undefined;\n    _this.currentTagData = undefined;\n\n    _this._initializeEvaluating();\n\n    return _this;\n  }\n\n  _createClass(JavascriptParser, [{\n    key: \"_initializeEvaluating\",\n    value: function _initializeEvaluating() {\n      var _this2 = this;\n\n      this.hooks.evaluate.for(\"Literal\").tap(\"JavascriptParser\", function (_expr) {\n        var expr =\n        /** @type {LiteralNode} */\n        _expr;\n\n        switch (typeof expr.value) {\n          case \"number\":\n            return new BasicEvaluatedExpression().setNumber(expr.value).setRange(expr.range);\n\n          case \"bigint\":\n            return new BasicEvaluatedExpression().setBigInt(expr.value).setRange(expr.range);\n\n          case \"string\":\n            return new BasicEvaluatedExpression().setString(expr.value).setRange(expr.range);\n\n          case \"boolean\":\n            return new BasicEvaluatedExpression().setBoolean(expr.value).setRange(expr.range);\n        }\n\n        if (expr.value === null) {\n          return new BasicEvaluatedExpression().setNull().setRange(expr.range);\n        }\n\n        if (expr.value instanceof RegExp) {\n          return new BasicEvaluatedExpression().setRegExp(expr.value).setRange(expr.range);\n        }\n      });\n      this.hooks.evaluate.for(\"NewExpression\").tap(\"JavascriptParser\", function (_expr) {\n        var expr =\n        /** @type {NewExpressionNode} */\n        _expr;\n        var callee = expr.callee;\n        if (callee.type !== \"Identifier\" || callee.name !== \"RegExp\" || expr.arguments.length > 2 || _this2.getVariableInfo(\"RegExp\") !== \"RegExp\") return;\n        var regExp, flags;\n        var arg1 = expr.arguments[0];\n\n        if (arg1) {\n          if (arg1.type === \"SpreadElement\") return;\n\n          var evaluatedRegExp = _this2.evaluateExpression(arg1);\n\n          if (!evaluatedRegExp) return;\n          regExp = evaluatedRegExp.asString();\n          if (!regExp) return;\n        } else {\n          return new BasicEvaluatedExpression().setRegExp(new RegExp(\"\")).setRange(expr.range);\n        }\n\n        var arg2 = expr.arguments[1];\n\n        if (arg2) {\n          if (arg2.type === \"SpreadElement\") return;\n\n          var evaluatedFlags = _this2.evaluateExpression(arg2);\n\n          if (!evaluatedFlags) return;\n\n          if (!evaluatedFlags.isUndefined()) {\n            flags = evaluatedFlags.asString();\n            if (flags === undefined || !BasicEvaluatedExpression.isValidRegExpFlags(flags)) return;\n          }\n        }\n\n        return new BasicEvaluatedExpression().setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp)).setRange(expr.range);\n      });\n      this.hooks.evaluate.for(\"LogicalExpression\").tap(\"JavascriptParser\", function (_expr) {\n        var expr =\n        /** @type {LogicalExpressionNode} */\n        _expr;\n\n        var left = _this2.evaluateExpression(expr.left);\n\n        if (!left) return;\n        var returnRight = false;\n        /** @type {boolean|undefined} */\n\n        var allowedRight;\n\n        if (expr.operator === \"&&\") {\n          var leftAsBool = left.asBool();\n          if (leftAsBool === false) return left.setRange(expr.range);\n          returnRight = leftAsBool === true;\n          allowedRight = false;\n        } else if (expr.operator === \"||\") {\n          var _leftAsBool = left.asBool();\n\n          if (_leftAsBool === true) return left.setRange(expr.range);\n          returnRight = _leftAsBool === false;\n          allowedRight = true;\n        } else if (expr.operator === \"??\") {\n          var leftAsNullish = left.asNullish();\n          if (leftAsNullish === false) return left.setRange(expr.range);\n          if (leftAsNullish !== true) return;\n          returnRight = true;\n        } else return;\n\n        var right = _this2.evaluateExpression(expr.right);\n\n        if (!right) return;\n\n        if (returnRight) {\n          if (left.couldHaveSideEffects()) right.setSideEffects();\n          return right.setRange(expr.range);\n        }\n\n        var asBool = right.asBool();\n\n        if (allowedRight === true && asBool === true) {\n          return new BasicEvaluatedExpression().setRange(expr.range).setTruthy();\n        } else if (allowedRight === false && asBool === false) {\n          return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();\n        }\n      });\n\n      var valueAsExpression = function valueAsExpression(value, expr, sideEffects) {\n        switch (typeof value) {\n          case \"boolean\":\n            return new BasicEvaluatedExpression().setBoolean(value).setSideEffects(sideEffects).setRange(expr.range);\n\n          case \"number\":\n            return new BasicEvaluatedExpression().setNumber(value).setSideEffects(sideEffects).setRange(expr.range);\n\n          case \"bigint\":\n            return new BasicEvaluatedExpression().setBigInt(value).setSideEffects(sideEffects).setRange(expr.range);\n\n          case \"string\":\n            return new BasicEvaluatedExpression().setString(value).setSideEffects(sideEffects).setRange(expr.range);\n        }\n      };\n\n      this.hooks.evaluate.for(\"BinaryExpression\").tap(\"JavascriptParser\", function (_expr) {\n        var expr =\n        /** @type {BinaryExpressionNode} */\n        _expr;\n\n        var handleConstOperation = function handleConstOperation(fn) {\n          var left = _this2.evaluateExpression(expr.left);\n\n          if (!left || !left.isCompileTimeValue()) return;\n\n          var right = _this2.evaluateExpression(expr.right);\n\n          if (!right || !right.isCompileTimeValue()) return;\n          var result = fn(left.asCompileTimeValue(), right.asCompileTimeValue());\n          return valueAsExpression(result, expr, left.couldHaveSideEffects() || right.couldHaveSideEffects());\n        };\n\n        var isAlwaysDifferent = function isAlwaysDifferent(a, b) {\n          return a === true && b === false || a === false && b === true;\n        };\n\n        var handleTemplateStringCompare = function handleTemplateStringCompare(left, right, res, eql) {\n          var getPrefix = function getPrefix(parts) {\n            var value = \"\";\n\n            var _iterator = _createForOfIteratorHelper(parts),\n                _step;\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var p = _step.value;\n                var v = p.asString();\n                if (v !== undefined) value += v;else break;\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n\n            return value;\n          };\n\n          var getSuffix = function getSuffix(parts) {\n            var value = \"\";\n\n            for (var i = parts.length - 1; i >= 0; i--) {\n              var v = parts[i].asString();\n              if (v !== undefined) value = v + value;else break;\n            }\n\n            return value;\n          };\n\n          var leftPrefix = getPrefix(left.parts);\n          var rightPrefix = getPrefix(right.parts);\n          var leftSuffix = getSuffix(left.parts);\n          var rightSuffix = getSuffix(right.parts);\n          var lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);\n          var lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);\n\n          if (leftPrefix.slice(0, lenPrefix) !== rightPrefix.slice(0, lenPrefix) || leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)) {\n            return res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n          }\n        };\n\n        var handleStrictEqualityComparison = function handleStrictEqualityComparison(eql) {\n          var left = _this2.evaluateExpression(expr.left);\n\n          if (!left) return;\n\n          var right = _this2.evaluateExpression(expr.right);\n\n          if (!right) return;\n          var res = new BasicEvaluatedExpression();\n          res.setRange(expr.range);\n          var leftConst = left.isCompileTimeValue();\n          var rightConst = right.isCompileTimeValue();\n\n          if (leftConst && rightConst) {\n            return res.setBoolean(eql === (left.asCompileTimeValue() === right.asCompileTimeValue())).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n          }\n\n          if (left.isArray() && right.isArray()) {\n            return res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n          }\n\n          if (left.isTemplateString() && right.isTemplateString()) {\n            return handleTemplateStringCompare(left, right, res, eql);\n          }\n\n          var leftPrimitive = left.isPrimitiveType();\n          var rightPrimitive = right.isPrimitiveType();\n\n          if ( // Primitive !== Object or\n          // compile-time object types are never equal to something at runtime\n          leftPrimitive === false && (leftConst || rightPrimitive === true) || rightPrimitive === false && (rightConst || leftPrimitive === true) || // Different nullish or boolish status also means not equal\n          isAlwaysDifferent(left.asBool(), right.asBool()) || isAlwaysDifferent(left.asNullish(), right.asNullish())) {\n            return res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n          }\n        };\n\n        var handleAbstractEqualityComparison = function handleAbstractEqualityComparison(eql) {\n          var left = _this2.evaluateExpression(expr.left);\n\n          if (!left) return;\n\n          var right = _this2.evaluateExpression(expr.right);\n\n          if (!right) return;\n          var res = new BasicEvaluatedExpression();\n          res.setRange(expr.range);\n          var leftConst = left.isCompileTimeValue();\n          var rightConst = right.isCompileTimeValue();\n\n          if (leftConst && rightConst) {\n            return res.setBoolean(eql === ( // eslint-disable-next-line eqeqeq\n            left.asCompileTimeValue() == right.asCompileTimeValue())).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n          }\n\n          if (left.isArray() && right.isArray()) {\n            return res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n          }\n\n          if (left.isTemplateString() && right.isTemplateString()) {\n            return handleTemplateStringCompare(left, right, res, eql);\n          }\n        };\n\n        if (expr.operator === \"+\") {\n          var left = _this2.evaluateExpression(expr.left);\n\n          if (!left) return;\n\n          var right = _this2.evaluateExpression(expr.right);\n\n          if (!right) return;\n          var res = new BasicEvaluatedExpression();\n\n          if (left.isString()) {\n            if (right.isString()) {\n              res.setString(left.string + right.string);\n            } else if (right.isNumber()) {\n              res.setString(left.string + right.number);\n            } else if (right.isWrapped() && right.prefix && right.prefix.isString()) {\n              // \"left\" + (\"prefix\" + inner + \"postfix\")\n              // => (\"leftPrefix\" + inner + \"postfix\")\n              res.setWrapped(new BasicEvaluatedExpression().setString(left.string + right.prefix.string).setRange(joinRanges(left.range, right.prefix.range)), right.postfix, right.wrappedInnerExpressions);\n            } else if (right.isWrapped()) {\n              // \"left\" + ([null] + inner + \"postfix\")\n              // => (\"left\" + inner + \"postfix\")\n              res.setWrapped(left, right.postfix, right.wrappedInnerExpressions);\n            } else {\n              // \"left\" + expr\n              // => (\"left\" + expr + \"\")\n              res.setWrapped(left, null, [right]);\n            }\n          } else if (left.isNumber()) {\n            if (right.isString()) {\n              res.setString(left.number + right.string);\n            } else if (right.isNumber()) {\n              res.setNumber(left.number + right.number);\n            } else {\n              return;\n            }\n          } else if (left.isBigInt()) {\n            if (right.isBigInt()) {\n              res.setBigInt(left.bigint + right.bigint);\n            }\n          } else if (left.isWrapped()) {\n            if (left.postfix && left.postfix.isString() && right.isString()) {\n              // (\"prefix\" + inner + \"postfix\") + \"right\"\n              // => (\"prefix\" + inner + \"postfixRight\")\n              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.string).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n            } else if (left.postfix && left.postfix.isString() && right.isNumber()) {\n              // (\"prefix\" + inner + \"postfix\") + 123\n              // => (\"prefix\" + inner + \"postfix123\")\n              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.number).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n            } else if (right.isString()) {\n              // (\"prefix\" + inner + [null]) + \"right\"\n              // => (\"prefix\" + inner + \"right\")\n              res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n            } else if (right.isNumber()) {\n              // (\"prefix\" + inner + [null]) + 123\n              // => (\"prefix\" + inner + \"123\")\n              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(right.number + \"\").setRange(right.range), left.wrappedInnerExpressions);\n            } else if (right.isWrapped()) {\n              // (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n              // (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n              res.setWrapped(left.prefix, right.postfix, left.wrappedInnerExpressions && right.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix] : []).concat(right.prefix ? [right.prefix] : []).concat(right.wrappedInnerExpressions));\n            } else {\n              // (\"prefix\" + inner + postfix) + expr\n              // => (\"prefix\" + inner + postfix + expr + [null])\n              res.setWrapped(left.prefix, null, left.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix, right] : [right]));\n            }\n          } else {\n            if (right.isString()) {\n              // left + \"right\"\n              // => ([null] + left + \"right\")\n              res.setWrapped(null, right, [left]);\n            } else if (right.isWrapped()) {\n              // left + (prefix + inner + \"postfix\")\n              // => ([null] + left + prefix + inner + \"postfix\")\n              res.setWrapped(null, right.postfix, right.wrappedInnerExpressions && (right.prefix ? [left, right.prefix] : [left]).concat(right.wrappedInnerExpressions));\n            } else {\n              return;\n            }\n          }\n\n          if (left.couldHaveSideEffects() || right.couldHaveSideEffects()) res.setSideEffects();\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"-\") {\n          return handleConstOperation(function (l, r) {\n            return l - r;\n          });\n        } else if (expr.operator === \"*\") {\n          return handleConstOperation(function (l, r) {\n            return l * r;\n          });\n        } else if (expr.operator === \"/\") {\n          return handleConstOperation(function (l, r) {\n            return l / r;\n          });\n        } else if (expr.operator === \"**\") {\n          return handleConstOperation(function (l, r) {\n            return Math.pow(l, r);\n          });\n        } else if (expr.operator === \"===\") {\n          return handleStrictEqualityComparison(true);\n        } else if (expr.operator === \"==\") {\n          return handleAbstractEqualityComparison(true);\n        } else if (expr.operator === \"!==\") {\n          return handleStrictEqualityComparison(false);\n        } else if (expr.operator === \"!=\") {\n          return handleAbstractEqualityComparison(false);\n        } else if (expr.operator === \"&\") {\n          return handleConstOperation(function (l, r) {\n            return l & r;\n          });\n        } else if (expr.operator === \"|\") {\n          return handleConstOperation(function (l, r) {\n            return l | r;\n          });\n        } else if (expr.operator === \"^\") {\n          return handleConstOperation(function (l, r) {\n            return l ^ r;\n          });\n        } else if (expr.operator === \">>>\") {\n          return handleConstOperation(function (l, r) {\n            return l >>> r;\n          });\n        } else if (expr.operator === \">>\") {\n          return handleConstOperation(function (l, r) {\n            return l >> r;\n          });\n        } else if (expr.operator === \"<<\") {\n          return handleConstOperation(function (l, r) {\n            return l << r;\n          });\n        } else if (expr.operator === \"<\") {\n          return handleConstOperation(function (l, r) {\n            return l < r;\n          });\n        } else if (expr.operator === \">\") {\n          return handleConstOperation(function (l, r) {\n            return l > r;\n          });\n        } else if (expr.operator === \"<=\") {\n          return handleConstOperation(function (l, r) {\n            return l <= r;\n          });\n        } else if (expr.operator === \">=\") {\n          return handleConstOperation(function (l, r) {\n            return l >= r;\n          });\n        }\n      });\n      this.hooks.evaluate.for(\"UnaryExpression\").tap(\"JavascriptParser\", function (_expr) {\n        var expr =\n        /** @type {UnaryExpressionNode} */\n        _expr;\n\n        var handleConstOperation = function handleConstOperation(fn) {\n          var argument = _this2.evaluateExpression(expr.argument);\n\n          if (!argument || !argument.isCompileTimeValue()) return;\n          var result = fn(argument.asCompileTimeValue());\n          return valueAsExpression(result, expr, argument.couldHaveSideEffects());\n        };\n\n        if (expr.operator === \"typeof\") {\n          switch (expr.argument.type) {\n            case \"Identifier\":\n              {\n                var res = _this2.callHooksForName(_this2.hooks.evaluateTypeof, expr.argument.name, expr);\n\n                if (res !== undefined) return res;\n                break;\n              }\n\n            case \"MetaProperty\":\n              {\n                var _res = _this2.callHooksForName(_this2.hooks.evaluateTypeof, getRootName(expr.argument), expr);\n\n                if (_res !== undefined) return _res;\n                break;\n              }\n\n            case \"MemberExpression\":\n              {\n                var _res2 = _this2.callHooksForExpression(_this2.hooks.evaluateTypeof, expr.argument, expr);\n\n                if (_res2 !== undefined) return _res2;\n                break;\n              }\n\n            case \"ChainExpression\":\n              {\n                var _res3 = _this2.callHooksForExpression(_this2.hooks.evaluateTypeof, expr.argument.expression, expr);\n\n                if (_res3 !== undefined) return _res3;\n                break;\n              }\n\n            case \"FunctionExpression\":\n              {\n                return new BasicEvaluatedExpression().setString(\"function\").setRange(expr.range);\n              }\n          }\n\n          var arg = _this2.evaluateExpression(expr.argument);\n\n          if (arg.isUnknown()) return;\n\n          if (arg.isString()) {\n            return new BasicEvaluatedExpression().setString(\"string\").setRange(expr.range);\n          }\n\n          if (arg.isWrapped()) {\n            return new BasicEvaluatedExpression().setString(\"string\").setSideEffects().setRange(expr.range);\n          }\n\n          if (arg.isUndefined()) {\n            return new BasicEvaluatedExpression().setString(\"undefined\").setRange(expr.range);\n          }\n\n          if (arg.isNumber()) {\n            return new BasicEvaluatedExpression().setString(\"number\").setRange(expr.range);\n          }\n\n          if (arg.isBigInt()) {\n            return new BasicEvaluatedExpression().setString(\"bigint\").setRange(expr.range);\n          }\n\n          if (arg.isBoolean()) {\n            return new BasicEvaluatedExpression().setString(\"boolean\").setRange(expr.range);\n          }\n\n          if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {\n            return new BasicEvaluatedExpression().setString(\"object\").setRange(expr.range);\n          }\n\n          if (arg.isArray()) {\n            return new BasicEvaluatedExpression().setString(\"object\").setSideEffects(arg.couldHaveSideEffects()).setRange(expr.range);\n          }\n        } else if (expr.operator === \"!\") {\n          var argument = _this2.evaluateExpression(expr.argument);\n\n          if (!argument) return;\n          var bool = argument.asBool();\n          if (typeof bool !== \"boolean\") return;\n          return new BasicEvaluatedExpression().setBoolean(!bool).setSideEffects(argument.couldHaveSideEffects()).setRange(expr.range);\n        } else if (expr.operator === \"~\") {\n          return handleConstOperation(function (v) {\n            return ~v;\n          });\n        } else if (expr.operator === \"+\") {\n          return handleConstOperation(function (v) {\n            return +v;\n          });\n        } else if (expr.operator === \"-\") {\n          return handleConstOperation(function (v) {\n            return -v;\n          });\n        }\n      });\n      this.hooks.evaluateTypeof.for(\"undefined\").tap(\"JavascriptParser\", function (expr) {\n        return new BasicEvaluatedExpression().setString(\"undefined\").setRange(expr.range);\n      });\n      this.hooks.evaluate.for(\"Identifier\").tap(\"JavascriptParser\", function (expr) {\n        if (\n        /** @type {IdentifierNode} */\n        expr.name === \"undefined\") {\n          return new BasicEvaluatedExpression().setUndefined().setRange(expr.range);\n        }\n      });\n      /**\n       * @param {string} exprType expression type name\n       * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info\n       * @returns {void}\n       */\n\n      var tapEvaluateWithVariableInfo = function tapEvaluateWithVariableInfo(exprType, getInfo) {\n        /** @type {ExpressionNode | undefined} */\n        var cachedExpression = undefined;\n        /** @type {GetInfoResult | undefined} */\n\n        var cachedInfo = undefined;\n\n        _this2.hooks.evaluate.for(exprType).tap(\"JavascriptParser\", function (expr) {\n          var expression =\n          /** @type {MemberExpressionNode} */\n          expr;\n          var info = getInfo(expr);\n\n          if (info !== undefined) {\n            return _this2.callHooksForInfoWithFallback(_this2.hooks.evaluateIdentifier, info.name, function (name) {\n              cachedExpression = expression;\n              cachedInfo = info;\n            }, function (name) {\n              var hook = _this2.hooks.evaluateDefinedIdentifier.get(name);\n\n              if (hook !== undefined) {\n                return hook.call(expression);\n              }\n            }, expression);\n          }\n        });\n\n        _this2.hooks.evaluate.for(exprType).tap({\n          name: \"JavascriptParser\",\n          stage: 100\n        }, function (expr) {\n          var info = cachedExpression === expr ? cachedInfo : getInfo(expr);\n\n          if (info !== undefined) {\n            return new BasicEvaluatedExpression().setIdentifier(info.name, info.rootInfo, info.getMembers).setRange(expr.range);\n          }\n        });\n\n        _this2.hooks.finish.tap(\"JavascriptParser\", function () {\n          // Cleanup for GC\n          cachedExpression = cachedInfo = undefined;\n        });\n      };\n\n      tapEvaluateWithVariableInfo(\"Identifier\", function (expr) {\n        var info = _this2.getVariableInfo(\n        /** @type {IdentifierNode} */\n        expr.name);\n\n        if (typeof info === \"string\" || info instanceof VariableInfo && typeof info.freeName === \"string\") {\n          return {\n            name: info,\n            rootInfo: info,\n            getMembers: function getMembers() {\n              return [];\n            }\n          };\n        }\n      });\n      tapEvaluateWithVariableInfo(\"ThisExpression\", function (expr) {\n        var info = _this2.getVariableInfo(\"this\");\n\n        if (typeof info === \"string\" || info instanceof VariableInfo && typeof info.freeName === \"string\") {\n          return {\n            name: info,\n            rootInfo: info,\n            getMembers: function getMembers() {\n              return [];\n            }\n          };\n        }\n      });\n      this.hooks.evaluate.for(\"MetaProperty\").tap(\"JavascriptParser\", function (expr) {\n        var metaProperty =\n        /** @type {MetaPropertyNode} */\n        expr;\n        return _this2.callHooksForName(_this2.hooks.evaluateIdentifier, getRootName(expr), metaProperty);\n      });\n      tapEvaluateWithVariableInfo(\"MemberExpression\", function (expr) {\n        return _this2.getMemberExpressionInfo(\n        /** @type {MemberExpressionNode} */\n        expr, ALLOWED_MEMBER_TYPES_EXPRESSION);\n      });\n      this.hooks.evaluate.for(\"CallExpression\").tap(\"JavascriptParser\", function (_expr) {\n        var expr =\n        /** @type {CallExpressionNode} */\n        _expr;\n\n        if (expr.callee.type !== \"MemberExpression\" || expr.callee.property.type !== (expr.callee.computed ? \"Literal\" : \"Identifier\")) {\n          return;\n        } // type Super also possible here\n\n\n        var param = _this2.evaluateExpression(\n        /** @type {ExpressionNode} */\n        expr.callee.object);\n\n        if (!param) return;\n        var property = expr.callee.property.type === \"Literal\" ? \"\".concat(expr.callee.property.value) : expr.callee.property.name;\n\n        var hook = _this2.hooks.evaluateCallExpressionMember.get(property);\n\n        if (hook !== undefined) {\n          return hook.call(expr, param);\n        }\n      });\n      this.hooks.evaluateCallExpressionMember.for(\"indexOf\").tap(\"JavascriptParser\", function (expr, param) {\n        if (!param.isString()) return;\n        if (expr.arguments.length === 0) return;\n\n        var _expr$arguments = _slicedToArray(expr.arguments, 2),\n            arg1 = _expr$arguments[0],\n            arg2 = _expr$arguments[1];\n\n        if (arg1.type === \"SpreadElement\") return;\n\n        var arg1Eval = _this2.evaluateExpression(arg1);\n\n        if (!arg1Eval.isString()) return;\n        var arg1Value = arg1Eval.string;\n        var result;\n\n        if (arg2) {\n          if (arg2.type === \"SpreadElement\") return;\n\n          var arg2Eval = _this2.evaluateExpression(arg2);\n\n          if (!arg2Eval.isNumber()) return;\n          result = param.string.indexOf(arg1Value, arg2Eval.number);\n        } else {\n          result = param.string.indexOf(arg1Value);\n        }\n\n        return new BasicEvaluatedExpression().setNumber(result).setSideEffects(param.couldHaveSideEffects()).setRange(expr.range);\n      });\n      this.hooks.evaluateCallExpressionMember.for(\"replace\").tap(\"JavascriptParser\", function (expr, param) {\n        if (!param.isString()) return;\n        if (expr.arguments.length !== 2) return;\n        if (expr.arguments[0].type === \"SpreadElement\") return;\n        if (expr.arguments[1].type === \"SpreadElement\") return;\n\n        var arg1 = _this2.evaluateExpression(expr.arguments[0]);\n\n        var arg2 = _this2.evaluateExpression(expr.arguments[1]);\n\n        if (!arg1.isString() && !arg1.isRegExp()) return;\n        var arg1Value = arg1.regExp || arg1.string;\n        if (!arg2.isString()) return;\n        var arg2Value = arg2.string;\n        return new BasicEvaluatedExpression().setString(param.string.replace(arg1Value, arg2Value)).setSideEffects(param.couldHaveSideEffects()).setRange(expr.range);\n      });\n      [\"substr\", \"substring\", \"slice\"].forEach(function (fn) {\n        _this2.hooks.evaluateCallExpressionMember.for(fn).tap(\"JavascriptParser\", function (expr, param) {\n          if (!param.isString()) return;\n          var arg1;\n          var result,\n              str = param.string;\n\n          switch (expr.arguments.length) {\n            case 1:\n              if (expr.arguments[0].type === \"SpreadElement\") return;\n              arg1 = _this2.evaluateExpression(expr.arguments[0]);\n              if (!arg1.isNumber()) return;\n              result = str[fn](arg1.number);\n              break;\n\n            case 2:\n              {\n                if (expr.arguments[0].type === \"SpreadElement\") return;\n                if (expr.arguments[1].type === \"SpreadElement\") return;\n                arg1 = _this2.evaluateExpression(expr.arguments[0]);\n\n                var arg2 = _this2.evaluateExpression(expr.arguments[1]);\n\n                if (!arg1.isNumber()) return;\n                if (!arg2.isNumber()) return;\n                result = str[fn](arg1.number, arg2.number);\n                break;\n              }\n\n            default:\n              return;\n          }\n\n          return new BasicEvaluatedExpression().setString(result).setSideEffects(param.couldHaveSideEffects()).setRange(expr.range);\n        });\n      });\n      /**\n       * @param {\"cooked\" | \"raw\"} kind kind of values to get\n       * @param {TemplateLiteralNode} templateLiteralExpr TemplateLiteral expr\n       * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n       */\n\n      var getSimplifiedTemplateResult = function getSimplifiedTemplateResult(kind, templateLiteralExpr) {\n        /** @type {BasicEvaluatedExpression[]} */\n        var quasis = [];\n        /** @type {BasicEvaluatedExpression[]} */\n\n        var parts = [];\n\n        for (var i = 0; i < templateLiteralExpr.quasis.length; i++) {\n          var quasiExpr = templateLiteralExpr.quasis[i];\n          var quasi = quasiExpr.value[kind];\n\n          if (i > 0) {\n            var prevExpr = parts[parts.length - 1];\n\n            var expr = _this2.evaluateExpression(templateLiteralExpr.expressions[i - 1]);\n\n            var exprAsString = expr.asString();\n\n            if (typeof exprAsString === \"string\" && !expr.couldHaveSideEffects()) {\n              // We can merge quasi + expr + quasi when expr\n              // is a const string\n              prevExpr.setString(prevExpr.string + exprAsString + quasi);\n              prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]); // We unset the expression as it doesn't match to a single expression\n\n              prevExpr.setExpression(undefined);\n              continue;\n            }\n\n            parts.push(expr);\n          }\n\n          var part = new BasicEvaluatedExpression().setString(quasi).setRange(quasiExpr.range).setExpression(quasiExpr);\n          quasis.push(part);\n          parts.push(part);\n        }\n\n        return {\n          quasis: quasis,\n          parts: parts\n        };\n      };\n\n      this.hooks.evaluate.for(\"TemplateLiteral\").tap(\"JavascriptParser\", function (_node) {\n        var node =\n        /** @type {TemplateLiteralNode} */\n        _node;\n\n        var _getSimplifiedTemplat = getSimplifiedTemplateResult(\"cooked\", node),\n            quasis = _getSimplifiedTemplat.quasis,\n            parts = _getSimplifiedTemplat.parts;\n\n        if (parts.length === 1) {\n          return parts[0].setRange(node.range);\n        }\n\n        return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"cooked\").setRange(node.range);\n      });\n      this.hooks.evaluate.for(\"TaggedTemplateExpression\").tap(\"JavascriptParser\", function (_node) {\n        var node =\n        /** @type {TaggedTemplateExpressionNode} */\n        _node;\n\n        var tag = _this2.evaluateExpression(node.tag);\n\n        if (tag.isIdentifier() && tag.identifier === \"String.raw\") {\n          var _getSimplifiedTemplat2 = getSimplifiedTemplateResult(\"raw\", node.quasi),\n              quasis = _getSimplifiedTemplat2.quasis,\n              parts = _getSimplifiedTemplat2.parts;\n\n          return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"raw\").setRange(node.range);\n        }\n      });\n      this.hooks.evaluateCallExpressionMember.for(\"concat\").tap(\"JavascriptParser\", function (expr, param) {\n        if (!param.isString() && !param.isWrapped()) return;\n        var stringSuffix = null;\n        var hasUnknownParams = false;\n        var innerExpressions = [];\n\n        for (var i = expr.arguments.length - 1; i >= 0; i--) {\n          var arg = expr.arguments[i];\n          if (arg.type === \"SpreadElement\") return;\n\n          var argExpr = _this2.evaluateExpression(arg);\n\n          if (hasUnknownParams || !argExpr.isString() && !argExpr.isNumber()) {\n            hasUnknownParams = true;\n            innerExpressions.push(argExpr);\n            continue;\n          }\n\n          var value = argExpr.isString() ? argExpr.string : \"\" + argExpr.number;\n          var newString = value + (stringSuffix ? stringSuffix.string : \"\");\n          var newRange = [argExpr.range[0], (stringSuffix || argExpr).range[1]];\n          stringSuffix = new BasicEvaluatedExpression().setString(newString).setSideEffects(stringSuffix && stringSuffix.couldHaveSideEffects() || argExpr.couldHaveSideEffects()).setRange(newRange);\n        }\n\n        if (hasUnknownParams) {\n          var prefix = param.isString() ? param : param.prefix;\n          var inner = param.isWrapped() && param.wrappedInnerExpressions ? param.wrappedInnerExpressions.concat(innerExpressions.reverse()) : innerExpressions.reverse();\n          return new BasicEvaluatedExpression().setWrapped(prefix, stringSuffix, inner).setRange(expr.range);\n        } else if (param.isWrapped()) {\n          var postfix = stringSuffix || param.postfix;\n\n          var _inner = param.wrappedInnerExpressions ? param.wrappedInnerExpressions.concat(innerExpressions.reverse()) : innerExpressions.reverse();\n\n          return new BasicEvaluatedExpression().setWrapped(param.prefix, postfix, _inner).setRange(expr.range);\n        } else {\n          var _newString = param.string + (stringSuffix ? stringSuffix.string : \"\");\n\n          return new BasicEvaluatedExpression().setString(_newString).setSideEffects(stringSuffix && stringSuffix.couldHaveSideEffects() || param.couldHaveSideEffects()).setRange(expr.range);\n        }\n      });\n      this.hooks.evaluateCallExpressionMember.for(\"split\").tap(\"JavascriptParser\", function (expr, param) {\n        if (!param.isString()) return;\n        if (expr.arguments.length !== 1) return;\n        if (expr.arguments[0].type === \"SpreadElement\") return;\n        var result;\n\n        var arg = _this2.evaluateExpression(expr.arguments[0]);\n\n        if (arg.isString()) {\n          result = param.string.split(arg.string);\n        } else if (arg.isRegExp()) {\n          result = param.string.split(arg.regExp);\n        } else {\n          return;\n        }\n\n        return new BasicEvaluatedExpression().setArray(result).setSideEffects(param.couldHaveSideEffects()).setRange(expr.range);\n      });\n      this.hooks.evaluate.for(\"ConditionalExpression\").tap(\"JavascriptParser\", function (_expr) {\n        var expr =\n        /** @type {ConditionalExpressionNode} */\n        _expr;\n\n        var condition = _this2.evaluateExpression(expr.test);\n\n        var conditionValue = condition.asBool();\n        var res;\n\n        if (conditionValue === undefined) {\n          var consequent = _this2.evaluateExpression(expr.consequent);\n\n          var alternate = _this2.evaluateExpression(expr.alternate);\n\n          if (!consequent || !alternate) return;\n          res = new BasicEvaluatedExpression();\n\n          if (consequent.isConditional()) {\n            res.setOptions(consequent.options);\n          } else {\n            res.setOptions([consequent]);\n          }\n\n          if (alternate.isConditional()) {\n            res.addOptions(alternate.options);\n          } else {\n            res.addOptions([alternate]);\n          }\n        } else {\n          res = _this2.evaluateExpression(conditionValue ? expr.consequent : expr.alternate);\n          if (condition.couldHaveSideEffects()) res.setSideEffects();\n        }\n\n        res.setRange(expr.range);\n        return res;\n      });\n      this.hooks.evaluate.for(\"ArrayExpression\").tap(\"JavascriptParser\", function (_expr) {\n        var expr =\n        /** @type {ArrayExpressionNode} */\n        _expr;\n        var items = expr.elements.map(function (element) {\n          return element !== null && element.type !== \"SpreadElement\" && _this2.evaluateExpression(element);\n        });\n        if (!items.every(Boolean)) return;\n        return new BasicEvaluatedExpression().setItems(items).setRange(expr.range);\n      });\n      this.hooks.evaluate.for(\"ChainExpression\").tap(\"JavascriptParser\", function (_expr) {\n        var expr =\n        /** @type {ChainExpressionNode} */\n        _expr;\n        /** @type {ExpressionNode[]} */\n\n        var optionalExpressionsStack = [];\n        /** @type {ExpressionNode|SuperNode} */\n\n        var next = expr.expression;\n\n        while (next.type === \"MemberExpression\" || next.type === \"CallExpression\") {\n          if (next.type === \"MemberExpression\") {\n            if (next.optional) {\n              // SuperNode can not be optional\n              optionalExpressionsStack.push(\n              /** @type {ExpressionNode} */\n              next.object);\n            }\n\n            next = next.object;\n          } else {\n            if (next.optional) {\n              // SuperNode can not be optional\n              optionalExpressionsStack.push(\n              /** @type {ExpressionNode} */\n              next.callee);\n            }\n\n            next = next.callee;\n          }\n        }\n\n        while (optionalExpressionsStack.length > 0) {\n          var expression = optionalExpressionsStack.pop();\n\n          var evaluated = _this2.evaluateExpression(expression);\n\n          if (evaluated && evaluated.asNullish()) {\n            return evaluated.setRange(_expr.range);\n          }\n        }\n\n        return _this2.evaluateExpression(expr.expression);\n      });\n    }\n  }, {\n    key: \"getRenameIdentifier\",\n    value: function getRenameIdentifier(expr) {\n      var result = this.evaluateExpression(expr);\n\n      if (result && result.isIdentifier()) {\n        return result.identifier;\n      }\n    }\n    /**\n     * @param {ClassExpressionNode | ClassDeclarationNode} classy a class node\n     * @returns {void}\n     */\n\n  }, {\n    key: \"walkClass\",\n    value: function walkClass(classy) {\n      if (classy.superClass) {\n        if (!this.hooks.classExtendsExpression.call(classy.superClass, classy)) {\n          this.walkExpression(classy.superClass);\n        }\n      }\n\n      if (classy.body && classy.body.type === \"ClassBody\") {\n        var _iterator2 = _createForOfIteratorHelper(\n        /** @type {TODO} */\n        classy.body.body),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var classElement = _step2.value;\n\n            if (!this.hooks.classBodyElement.call(classElement, classy)) {\n              if (classElement.computed && classElement.key) {\n                this.walkExpression(classElement.key);\n              }\n\n              if (classElement.value) {\n                if (!this.hooks.classBodyValue.call(classElement.value, classElement, classy)) {\n                  var wasTopLevel = this.scope.topLevelScope;\n                  this.scope.topLevelScope = false;\n                  this.walkExpression(classElement.value);\n                  this.scope.topLevelScope = wasTopLevel;\n                }\n              }\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    } // Pre walking iterates the scope for variable declarations\n\n  }, {\n    key: \"preWalkStatements\",\n    value: function preWalkStatements(statements) {\n      for (var index = 0, len = statements.length; index < len; index++) {\n        var statement = statements[index];\n        this.preWalkStatement(statement);\n      }\n    } // Block pre walking iterates the scope for block variable declarations\n\n  }, {\n    key: \"blockPreWalkStatements\",\n    value: function blockPreWalkStatements(statements) {\n      for (var index = 0, len = statements.length; index < len; index++) {\n        var statement = statements[index];\n        this.blockPreWalkStatement(statement);\n      }\n    } // Walking iterates the statements and expressions and processes them\n\n  }, {\n    key: \"walkStatements\",\n    value: function walkStatements(statements) {\n      for (var index = 0, len = statements.length; index < len; index++) {\n        var statement = statements[index];\n        this.walkStatement(statement);\n      }\n    }\n  }, {\n    key: \"preWalkStatement\",\n    value: function preWalkStatement(statement) {\n      this.statementPath.push(statement);\n\n      if (this.hooks.preStatement.call(statement)) {\n        this.prevStatement = this.statementPath.pop();\n        return;\n      }\n\n      switch (statement.type) {\n        case \"BlockStatement\":\n          this.preWalkBlockStatement(statement);\n          break;\n\n        case \"DoWhileStatement\":\n          this.preWalkDoWhileStatement(statement);\n          break;\n\n        case \"ForInStatement\":\n          this.preWalkForInStatement(statement);\n          break;\n\n        case \"ForOfStatement\":\n          this.preWalkForOfStatement(statement);\n          break;\n\n        case \"ForStatement\":\n          this.preWalkForStatement(statement);\n          break;\n\n        case \"FunctionDeclaration\":\n          this.preWalkFunctionDeclaration(statement);\n          break;\n\n        case \"IfStatement\":\n          this.preWalkIfStatement(statement);\n          break;\n\n        case \"LabeledStatement\":\n          this.preWalkLabeledStatement(statement);\n          break;\n\n        case \"SwitchStatement\":\n          this.preWalkSwitchStatement(statement);\n          break;\n\n        case \"TryStatement\":\n          this.preWalkTryStatement(statement);\n          break;\n\n        case \"VariableDeclaration\":\n          this.preWalkVariableDeclaration(statement);\n          break;\n\n        case \"WhileStatement\":\n          this.preWalkWhileStatement(statement);\n          break;\n\n        case \"WithStatement\":\n          this.preWalkWithStatement(statement);\n          break;\n      }\n\n      this.prevStatement = this.statementPath.pop();\n    }\n  }, {\n    key: \"blockPreWalkStatement\",\n    value: function blockPreWalkStatement(statement) {\n      this.statementPath.push(statement);\n\n      if (this.hooks.blockPreStatement.call(statement)) {\n        this.prevStatement = this.statementPath.pop();\n        return;\n      }\n\n      switch (statement.type) {\n        case \"ImportDeclaration\":\n          this.blockPreWalkImportDeclaration(statement);\n          break;\n\n        case \"ExportAllDeclaration\":\n          this.blockPreWalkExportAllDeclaration(statement);\n          break;\n\n        case \"ExportDefaultDeclaration\":\n          this.blockPreWalkExportDefaultDeclaration(statement);\n          break;\n\n        case \"ExportNamedDeclaration\":\n          this.blockPreWalkExportNamedDeclaration(statement);\n          break;\n\n        case \"VariableDeclaration\":\n          this.blockPreWalkVariableDeclaration(statement);\n          break;\n\n        case \"ClassDeclaration\":\n          this.blockPreWalkClassDeclaration(statement);\n          break;\n      }\n\n      this.prevStatement = this.statementPath.pop();\n    }\n  }, {\n    key: \"walkStatement\",\n    value: function walkStatement(statement) {\n      this.statementPath.push(statement);\n\n      if (this.hooks.statement.call(statement) !== undefined) {\n        this.prevStatement = this.statementPath.pop();\n        return;\n      }\n\n      switch (statement.type) {\n        case \"BlockStatement\":\n          this.walkBlockStatement(statement);\n          break;\n\n        case \"ClassDeclaration\":\n          this.walkClassDeclaration(statement);\n          break;\n\n        case \"DoWhileStatement\":\n          this.walkDoWhileStatement(statement);\n          break;\n\n        case \"ExportDefaultDeclaration\":\n          this.walkExportDefaultDeclaration(statement);\n          break;\n\n        case \"ExportNamedDeclaration\":\n          this.walkExportNamedDeclaration(statement);\n          break;\n\n        case \"ExpressionStatement\":\n          this.walkExpressionStatement(statement);\n          break;\n\n        case \"ForInStatement\":\n          this.walkForInStatement(statement);\n          break;\n\n        case \"ForOfStatement\":\n          this.walkForOfStatement(statement);\n          break;\n\n        case \"ForStatement\":\n          this.walkForStatement(statement);\n          break;\n\n        case \"FunctionDeclaration\":\n          this.walkFunctionDeclaration(statement);\n          break;\n\n        case \"IfStatement\":\n          this.walkIfStatement(statement);\n          break;\n\n        case \"LabeledStatement\":\n          this.walkLabeledStatement(statement);\n          break;\n\n        case \"ReturnStatement\":\n          this.walkReturnStatement(statement);\n          break;\n\n        case \"SwitchStatement\":\n          this.walkSwitchStatement(statement);\n          break;\n\n        case \"ThrowStatement\":\n          this.walkThrowStatement(statement);\n          break;\n\n        case \"TryStatement\":\n          this.walkTryStatement(statement);\n          break;\n\n        case \"VariableDeclaration\":\n          this.walkVariableDeclaration(statement);\n          break;\n\n        case \"WhileStatement\":\n          this.walkWhileStatement(statement);\n          break;\n\n        case \"WithStatement\":\n          this.walkWithStatement(statement);\n          break;\n      }\n\n      this.prevStatement = this.statementPath.pop();\n    }\n    /**\n     * Walks a statements that is nested within a parent statement\n     * and can potentially be a non-block statement.\n     * This enforces the nested statement to never be in ASI position.\n     * @param {StatementNode} statement the nested statement\n     * @returns {void}\n     */\n\n  }, {\n    key: \"walkNestedStatement\",\n    value: function walkNestedStatement(statement) {\n      this.prevStatement = undefined;\n      this.walkStatement(statement);\n    } // Real Statements\n\n  }, {\n    key: \"preWalkBlockStatement\",\n    value: function preWalkBlockStatement(statement) {\n      this.preWalkStatements(statement.body);\n    }\n  }, {\n    key: \"walkBlockStatement\",\n    value: function walkBlockStatement(statement) {\n      var _this3 = this;\n\n      this.inBlockScope(function () {\n        var body = statement.body;\n        var prev = _this3.prevStatement;\n\n        _this3.blockPreWalkStatements(body);\n\n        _this3.prevStatement = prev;\n\n        _this3.walkStatements(body);\n      });\n    }\n  }, {\n    key: \"walkExpressionStatement\",\n    value: function walkExpressionStatement(statement) {\n      this.walkExpression(statement.expression);\n    }\n  }, {\n    key: \"preWalkIfStatement\",\n    value: function preWalkIfStatement(statement) {\n      this.preWalkStatement(statement.consequent);\n\n      if (statement.alternate) {\n        this.preWalkStatement(statement.alternate);\n      }\n    }\n  }, {\n    key: \"walkIfStatement\",\n    value: function walkIfStatement(statement) {\n      var result = this.hooks.statementIf.call(statement);\n\n      if (result === undefined) {\n        this.walkExpression(statement.test);\n        this.walkNestedStatement(statement.consequent);\n\n        if (statement.alternate) {\n          this.walkNestedStatement(statement.alternate);\n        }\n      } else {\n        if (result) {\n          this.walkNestedStatement(statement.consequent);\n        } else if (statement.alternate) {\n          this.walkNestedStatement(statement.alternate);\n        }\n      }\n    }\n  }, {\n    key: \"preWalkLabeledStatement\",\n    value: function preWalkLabeledStatement(statement) {\n      this.preWalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkLabeledStatement\",\n    value: function walkLabeledStatement(statement) {\n      var hook = this.hooks.label.get(statement.label.name);\n\n      if (hook !== undefined) {\n        var result = hook.call(statement);\n        if (result === true) return;\n      }\n\n      this.walkNestedStatement(statement.body);\n    }\n  }, {\n    key: \"preWalkWithStatement\",\n    value: function preWalkWithStatement(statement) {\n      this.preWalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkWithStatement\",\n    value: function walkWithStatement(statement) {\n      this.walkExpression(statement.object);\n      this.walkNestedStatement(statement.body);\n    }\n  }, {\n    key: \"preWalkSwitchStatement\",\n    value: function preWalkSwitchStatement(statement) {\n      this.preWalkSwitchCases(statement.cases);\n    }\n  }, {\n    key: \"walkSwitchStatement\",\n    value: function walkSwitchStatement(statement) {\n      this.walkExpression(statement.discriminant);\n      this.walkSwitchCases(statement.cases);\n    }\n  }, {\n    key: \"walkTerminatingStatement\",\n    value: function walkTerminatingStatement(statement) {\n      if (statement.argument) this.walkExpression(statement.argument);\n    }\n  }, {\n    key: \"walkReturnStatement\",\n    value: function walkReturnStatement(statement) {\n      this.walkTerminatingStatement(statement);\n    }\n  }, {\n    key: \"walkThrowStatement\",\n    value: function walkThrowStatement(statement) {\n      this.walkTerminatingStatement(statement);\n    }\n  }, {\n    key: \"preWalkTryStatement\",\n    value: function preWalkTryStatement(statement) {\n      this.preWalkStatement(statement.block);\n      if (statement.handler) this.preWalkCatchClause(statement.handler);\n      if (statement.finializer) this.preWalkStatement(statement.finializer);\n    }\n  }, {\n    key: \"walkTryStatement\",\n    value: function walkTryStatement(statement) {\n      if (this.scope.inTry) {\n        this.walkStatement(statement.block);\n      } else {\n        this.scope.inTry = true;\n        this.walkStatement(statement.block);\n        this.scope.inTry = false;\n      }\n\n      if (statement.handler) this.walkCatchClause(statement.handler);\n      if (statement.finalizer) this.walkStatement(statement.finalizer);\n    }\n  }, {\n    key: \"preWalkWhileStatement\",\n    value: function preWalkWhileStatement(statement) {\n      this.preWalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkWhileStatement\",\n    value: function walkWhileStatement(statement) {\n      this.walkExpression(statement.test);\n      this.walkNestedStatement(statement.body);\n    }\n  }, {\n    key: \"preWalkDoWhileStatement\",\n    value: function preWalkDoWhileStatement(statement) {\n      this.preWalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkDoWhileStatement\",\n    value: function walkDoWhileStatement(statement) {\n      this.walkNestedStatement(statement.body);\n      this.walkExpression(statement.test);\n    }\n  }, {\n    key: \"preWalkForStatement\",\n    value: function preWalkForStatement(statement) {\n      if (statement.init) {\n        if (statement.init.type === \"VariableDeclaration\") {\n          this.preWalkStatement(statement.init);\n        }\n      }\n\n      this.preWalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkForStatement\",\n    value: function walkForStatement(statement) {\n      var _this4 = this;\n\n      this.inBlockScope(function () {\n        if (statement.init) {\n          if (statement.init.type === \"VariableDeclaration\") {\n            _this4.blockPreWalkVariableDeclaration(statement.init);\n\n            _this4.prevStatement = undefined;\n\n            _this4.walkStatement(statement.init);\n          } else {\n            _this4.walkExpression(statement.init);\n          }\n        }\n\n        if (statement.test) {\n          _this4.walkExpression(statement.test);\n        }\n\n        if (statement.update) {\n          _this4.walkExpression(statement.update);\n        }\n\n        var body = statement.body;\n\n        if (body.type === \"BlockStatement\") {\n          // no need to add additional scope\n          var prev = _this4.prevStatement;\n\n          _this4.blockPreWalkStatements(body.body);\n\n          _this4.prevStatement = prev;\n\n          _this4.walkStatements(body.body);\n        } else {\n          _this4.walkNestedStatement(body);\n        }\n      });\n    }\n  }, {\n    key: \"preWalkForInStatement\",\n    value: function preWalkForInStatement(statement) {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.preWalkVariableDeclaration(statement.left);\n      }\n\n      this.preWalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkForInStatement\",\n    value: function walkForInStatement(statement) {\n      var _this5 = this;\n\n      this.inBlockScope(function () {\n        if (statement.left.type === \"VariableDeclaration\") {\n          _this5.blockPreWalkVariableDeclaration(statement.left);\n\n          _this5.walkVariableDeclaration(statement.left);\n        } else {\n          _this5.walkPattern(statement.left);\n        }\n\n        _this5.walkExpression(statement.right);\n\n        var body = statement.body;\n\n        if (body.type === \"BlockStatement\") {\n          // no need to add additional scope\n          var prev = _this5.prevStatement;\n\n          _this5.blockPreWalkStatements(body.body);\n\n          _this5.prevStatement = prev;\n\n          _this5.walkStatements(body.body);\n        } else {\n          _this5.walkNestedStatement(body);\n        }\n      });\n    }\n  }, {\n    key: \"preWalkForOfStatement\",\n    value: function preWalkForOfStatement(statement) {\n      if (statement.await && this.scope.topLevelScope === true) {\n        this.hooks.topLevelAwait.call(statement);\n      }\n\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.preWalkVariableDeclaration(statement.left);\n      }\n\n      this.preWalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkForOfStatement\",\n    value: function walkForOfStatement(statement) {\n      var _this6 = this;\n\n      this.inBlockScope(function () {\n        if (statement.left.type === \"VariableDeclaration\") {\n          _this6.blockPreWalkVariableDeclaration(statement.left);\n\n          _this6.walkVariableDeclaration(statement.left);\n        } else {\n          _this6.walkPattern(statement.left);\n        }\n\n        _this6.walkExpression(statement.right);\n\n        var body = statement.body;\n\n        if (body.type === \"BlockStatement\") {\n          // no need to add additional scope\n          var prev = _this6.prevStatement;\n\n          _this6.blockPreWalkStatements(body.body);\n\n          _this6.prevStatement = prev;\n\n          _this6.walkStatements(body.body);\n        } else {\n          _this6.walkNestedStatement(body);\n        }\n      });\n    } // Declarations\n\n  }, {\n    key: \"preWalkFunctionDeclaration\",\n    value: function preWalkFunctionDeclaration(statement) {\n      if (statement.id) {\n        this.defineVariable(statement.id.name);\n      }\n    }\n  }, {\n    key: \"walkFunctionDeclaration\",\n    value: function walkFunctionDeclaration(statement) {\n      var _this7 = this;\n\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n      this.inFunctionScope(true, statement.params, function () {\n        var _iterator3 = _createForOfIteratorHelper(statement.params),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var param = _step3.value;\n\n            _this7.walkPattern(param);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        if (statement.body.type === \"BlockStatement\") {\n          _this7.detectMode(statement.body.body);\n\n          var prev = _this7.prevStatement;\n\n          _this7.preWalkStatement(statement.body);\n\n          _this7.prevStatement = prev;\n\n          _this7.walkStatement(statement.body);\n        } else {\n          _this7.walkExpression(statement.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }, {\n    key: \"blockPreWalkImportDeclaration\",\n    value: function blockPreWalkImportDeclaration(statement) {\n      var source = statement.source.value;\n      this.hooks.import.call(statement, source);\n\n      var _iterator4 = _createForOfIteratorHelper(statement.specifiers),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var specifier = _step4.value;\n          var name = specifier.local.name;\n\n          switch (specifier.type) {\n            case \"ImportDefaultSpecifier\":\n              if (!this.hooks.importSpecifier.call(statement, source, \"default\", name)) {\n                this.defineVariable(name);\n              }\n\n              break;\n\n            case \"ImportSpecifier\":\n              if (!this.hooks.importSpecifier.call(statement, source, specifier.imported.name, name)) {\n                this.defineVariable(name);\n              }\n\n              break;\n\n            case \"ImportNamespaceSpecifier\":\n              if (!this.hooks.importSpecifier.call(statement, source, null, name)) {\n                this.defineVariable(name);\n              }\n\n              break;\n\n            default:\n              this.defineVariable(name);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"enterDeclaration\",\n    value: function enterDeclaration(declaration, onIdent) {\n      switch (declaration.type) {\n        case \"VariableDeclaration\":\n          var _iterator5 = _createForOfIteratorHelper(declaration.declarations),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var declarator = _step5.value;\n\n              switch (declarator.type) {\n                case \"VariableDeclarator\":\n                  {\n                    this.enterPattern(declarator.id, onIdent);\n                    break;\n                  }\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n\n          break;\n\n        case \"FunctionDeclaration\":\n          this.enterPattern(declaration.id, onIdent);\n          break;\n\n        case \"ClassDeclaration\":\n          this.enterPattern(declaration.id, onIdent);\n          break;\n      }\n    }\n  }, {\n    key: \"blockPreWalkExportNamedDeclaration\",\n    value: function blockPreWalkExportNamedDeclaration(statement) {\n      var _this8 = this;\n\n      var source;\n\n      if (statement.source) {\n        source = statement.source.value;\n        this.hooks.exportImport.call(statement, source);\n      } else {\n        this.hooks.export.call(statement);\n      }\n\n      if (statement.declaration) {\n        if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n          var prev = this.prevStatement;\n          this.preWalkStatement(statement.declaration);\n          this.prevStatement = prev;\n          this.blockPreWalkStatement(statement.declaration);\n          var index = 0;\n          this.enterDeclaration(statement.declaration, function (def) {\n            _this8.hooks.exportSpecifier.call(statement, def, def, index++);\n          });\n        }\n      }\n\n      if (statement.specifiers) {\n        for (var specifierIndex = 0; specifierIndex < statement.specifiers.length; specifierIndex++) {\n          var specifier = statement.specifiers[specifierIndex];\n\n          switch (specifier.type) {\n            case \"ExportSpecifier\":\n              {\n                var name = specifier.exported.name;\n\n                if (source) {\n                  this.hooks.exportImportSpecifier.call(statement, source, specifier.local.name, name, specifierIndex);\n                } else {\n                  this.hooks.exportSpecifier.call(statement, specifier.local.name, name, specifierIndex);\n                }\n\n                break;\n              }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"walkExportNamedDeclaration\",\n    value: function walkExportNamedDeclaration(statement) {\n      if (statement.declaration) {\n        this.walkStatement(statement.declaration);\n      }\n    }\n  }, {\n    key: \"blockPreWalkExportDefaultDeclaration\",\n    value: function blockPreWalkExportDefaultDeclaration(statement) {\n      var prev = this.prevStatement;\n      this.preWalkStatement(statement.declaration);\n      this.prevStatement = prev;\n      this.blockPreWalkStatement(statement.declaration);\n\n      if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n        this.hooks.exportSpecifier.call(statement, statement.declaration.id.name, \"default\", undefined);\n      }\n    }\n  }, {\n    key: \"walkExportDefaultDeclaration\",\n    value: function walkExportDefaultDeclaration(statement) {\n      this.hooks.export.call(statement);\n\n      if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n        if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n          this.walkStatement(statement.declaration);\n        }\n      } else {\n        // Acorn parses `export default function() {}` as `FunctionDeclaration` and\n        // `export default class {}` as `ClassDeclaration`, both with `id = null`.\n        // These nodes must be treated as expressions.\n        if (statement.declaration.type === \"FunctionDeclaration\" || statement.declaration.type === \"ClassDeclaration\") {\n          this.walkStatement(statement.declaration);\n        } else {\n          this.walkExpression(statement.declaration);\n        }\n\n        if (!this.hooks.exportExpression.call(statement, statement.declaration)) {\n          this.hooks.exportSpecifier.call(statement, statement.declaration, \"default\", undefined);\n        }\n      }\n    }\n  }, {\n    key: \"blockPreWalkExportAllDeclaration\",\n    value: function blockPreWalkExportAllDeclaration(statement) {\n      var source = statement.source.value;\n      var name = statement.exported ? statement.exported.name : null;\n      this.hooks.exportImport.call(statement, source);\n      this.hooks.exportImportSpecifier.call(statement, source, null, name, 0);\n    }\n  }, {\n    key: \"preWalkVariableDeclaration\",\n    value: function preWalkVariableDeclaration(statement) {\n      if (statement.kind !== \"var\") return;\n\n      this._preWalkVariableDeclaration(statement, this.hooks.varDeclarationVar);\n    }\n  }, {\n    key: \"blockPreWalkVariableDeclaration\",\n    value: function blockPreWalkVariableDeclaration(statement) {\n      if (statement.kind === \"var\") return;\n      var hookMap = statement.kind === \"const\" ? this.hooks.varDeclarationConst : this.hooks.varDeclarationLet;\n\n      this._preWalkVariableDeclaration(statement, hookMap);\n    }\n  }, {\n    key: \"_preWalkVariableDeclaration\",\n    value: function _preWalkVariableDeclaration(statement, hookMap) {\n      var _this9 = this;\n\n      var _iterator6 = _createForOfIteratorHelper(statement.declarations),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var declarator = _step6.value;\n\n          switch (declarator.type) {\n            case \"VariableDeclarator\":\n              {\n                if (!this.hooks.preDeclarator.call(declarator, statement)) {\n                  this.enterPattern(declarator.id, function (name, decl) {\n                    var hook = hookMap.get(name);\n\n                    if (hook === undefined || !hook.call(decl)) {\n                      hook = _this9.hooks.varDeclaration.get(name);\n\n                      if (hook === undefined || !hook.call(decl)) {\n                        _this9.defineVariable(name);\n                      }\n                    }\n                  });\n                }\n\n                break;\n              }\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  }, {\n    key: \"walkVariableDeclaration\",\n    value: function walkVariableDeclaration(statement) {\n      var _iterator7 = _createForOfIteratorHelper(statement.declarations),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var declarator = _step7.value;\n\n          switch (declarator.type) {\n            case \"VariableDeclarator\":\n              {\n                var renameIdentifier = declarator.init && this.getRenameIdentifier(declarator.init);\n\n                if (renameIdentifier && declarator.id.type === \"Identifier\") {\n                  var hook = this.hooks.canRename.get(renameIdentifier);\n\n                  if (hook !== undefined && hook.call(declarator.init)) {\n                    // renaming with \"var a = b;\"\n                    var _hook = this.hooks.rename.get(renameIdentifier);\n\n                    if (_hook === undefined || !_hook.call(declarator.init)) {\n                      this.setVariable(declarator.id.name, renameIdentifier);\n                    }\n\n                    break;\n                  }\n                }\n\n                if (!this.hooks.declarator.call(declarator, statement)) {\n                  this.walkPattern(declarator.id);\n                  if (declarator.init) this.walkExpression(declarator.init);\n                }\n\n                break;\n              }\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  }, {\n    key: \"blockPreWalkClassDeclaration\",\n    value: function blockPreWalkClassDeclaration(statement) {\n      if (statement.id) {\n        this.defineVariable(statement.id.name);\n      }\n    }\n  }, {\n    key: \"walkClassDeclaration\",\n    value: function walkClassDeclaration(statement) {\n      this.walkClass(statement);\n    }\n  }, {\n    key: \"preWalkSwitchCases\",\n    value: function preWalkSwitchCases(switchCases) {\n      for (var index = 0, len = switchCases.length; index < len; index++) {\n        var switchCase = switchCases[index];\n        this.preWalkStatements(switchCase.consequent);\n      }\n    }\n  }, {\n    key: \"walkSwitchCases\",\n    value: function walkSwitchCases(switchCases) {\n      var _this10 = this;\n\n      this.inBlockScope(function () {\n        var len = switchCases.length; // we need to pre walk all statements first since we can have invalid code\n        // import A from \"module\";\n        // switch(1) {\n        //    case 1:\n        //      console.log(A); // should fail at runtime\n        //    case 2:\n        //      const A = 1;\n        // }\n\n        for (var index = 0; index < len; index++) {\n          var switchCase = switchCases[index];\n\n          if (switchCase.consequent.length > 0) {\n            var prev = _this10.prevStatement;\n\n            _this10.blockPreWalkStatements(switchCase.consequent);\n\n            _this10.prevStatement = prev;\n          }\n        }\n\n        for (var _index = 0; _index < len; _index++) {\n          var _switchCase = switchCases[_index];\n\n          if (_switchCase.test) {\n            _this10.walkExpression(_switchCase.test);\n          }\n\n          if (_switchCase.consequent.length > 0) {\n            _this10.walkStatements(_switchCase.consequent);\n          }\n        }\n      });\n    }\n  }, {\n    key: \"preWalkCatchClause\",\n    value: function preWalkCatchClause(catchClause) {\n      this.preWalkStatement(catchClause.body);\n    }\n  }, {\n    key: \"walkCatchClause\",\n    value: function walkCatchClause(catchClause) {\n      var _this11 = this;\n\n      this.inBlockScope(function () {\n        // Error binding is optional in catch clause since ECMAScript 2019\n        if (catchClause.param !== null) {\n          _this11.enterPattern(catchClause.param, function (ident) {\n            _this11.defineVariable(ident);\n          });\n\n          _this11.walkPattern(catchClause.param);\n        }\n\n        var prev = _this11.prevStatement;\n\n        _this11.blockPreWalkStatement(catchClause.body);\n\n        _this11.prevStatement = prev;\n\n        _this11.walkStatement(catchClause.body);\n      });\n    }\n  }, {\n    key: \"walkPattern\",\n    value: function walkPattern(pattern) {\n      switch (pattern.type) {\n        case \"ArrayPattern\":\n          this.walkArrayPattern(pattern);\n          break;\n\n        case \"AssignmentPattern\":\n          this.walkAssignmentPattern(pattern);\n          break;\n\n        case \"MemberExpression\":\n          this.walkMemberExpression(pattern);\n          break;\n\n        case \"ObjectPattern\":\n          this.walkObjectPattern(pattern);\n          break;\n\n        case \"RestElement\":\n          this.walkRestElement(pattern);\n          break;\n      }\n    }\n  }, {\n    key: \"walkAssignmentPattern\",\n    value: function walkAssignmentPattern(pattern) {\n      this.walkExpression(pattern.right);\n      this.walkPattern(pattern.left);\n    }\n  }, {\n    key: \"walkObjectPattern\",\n    value: function walkObjectPattern(pattern) {\n      for (var i = 0, len = pattern.properties.length; i < len; i++) {\n        var prop = pattern.properties[i];\n\n        if (prop) {\n          if (prop.computed) this.walkExpression(prop.key);\n          if (prop.value) this.walkPattern(prop.value);\n        }\n      }\n    }\n  }, {\n    key: \"walkArrayPattern\",\n    value: function walkArrayPattern(pattern) {\n      for (var i = 0, len = pattern.elements.length; i < len; i++) {\n        var element = pattern.elements[i];\n        if (element) this.walkPattern(element);\n      }\n    }\n  }, {\n    key: \"walkRestElement\",\n    value: function walkRestElement(pattern) {\n      this.walkPattern(pattern.argument);\n    }\n  }, {\n    key: \"walkExpressions\",\n    value: function walkExpressions(expressions) {\n      var _iterator8 = _createForOfIteratorHelper(expressions),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var expression = _step8.value;\n\n          if (expression) {\n            this.walkExpression(expression);\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  }, {\n    key: \"walkExpression\",\n    value: function walkExpression(expression) {\n      switch (expression.type) {\n        case \"ArrayExpression\":\n          this.walkArrayExpression(expression);\n          break;\n\n        case \"ArrowFunctionExpression\":\n          this.walkArrowFunctionExpression(expression);\n          break;\n\n        case \"AssignmentExpression\":\n          this.walkAssignmentExpression(expression);\n          break;\n\n        case \"AwaitExpression\":\n          this.walkAwaitExpression(expression);\n          break;\n\n        case \"BinaryExpression\":\n          this.walkBinaryExpression(expression);\n          break;\n\n        case \"CallExpression\":\n          this.walkCallExpression(expression);\n          break;\n\n        case \"ChainExpression\":\n          this.walkChainExpression(expression);\n          break;\n\n        case \"ClassExpression\":\n          this.walkClassExpression(expression);\n          break;\n\n        case \"ConditionalExpression\":\n          this.walkConditionalExpression(expression);\n          break;\n\n        case \"FunctionExpression\":\n          this.walkFunctionExpression(expression);\n          break;\n\n        case \"Identifier\":\n          this.walkIdentifier(expression);\n          break;\n\n        case \"ImportExpression\":\n          this.walkImportExpression(expression);\n          break;\n\n        case \"LogicalExpression\":\n          this.walkLogicalExpression(expression);\n          break;\n\n        case \"MetaProperty\":\n          this.walkMetaProperty(expression);\n          break;\n\n        case \"MemberExpression\":\n          this.walkMemberExpression(expression);\n          break;\n\n        case \"NewExpression\":\n          this.walkNewExpression(expression);\n          break;\n\n        case \"ObjectExpression\":\n          this.walkObjectExpression(expression);\n          break;\n\n        case \"SequenceExpression\":\n          this.walkSequenceExpression(expression);\n          break;\n\n        case \"SpreadElement\":\n          this.walkSpreadElement(expression);\n          break;\n\n        case \"TaggedTemplateExpression\":\n          this.walkTaggedTemplateExpression(expression);\n          break;\n\n        case \"TemplateLiteral\":\n          this.walkTemplateLiteral(expression);\n          break;\n\n        case \"ThisExpression\":\n          this.walkThisExpression(expression);\n          break;\n\n        case \"UnaryExpression\":\n          this.walkUnaryExpression(expression);\n          break;\n\n        case \"UpdateExpression\":\n          this.walkUpdateExpression(expression);\n          break;\n\n        case \"YieldExpression\":\n          this.walkYieldExpression(expression);\n          break;\n      }\n    }\n  }, {\n    key: \"walkAwaitExpression\",\n    value: function walkAwaitExpression(expression) {\n      if (this.scope.topLevelScope === true) this.hooks.topLevelAwait.call(expression);\n      this.walkExpression(expression.argument);\n    }\n  }, {\n    key: \"walkArrayExpression\",\n    value: function walkArrayExpression(expression) {\n      if (expression.elements) {\n        this.walkExpressions(expression.elements);\n      }\n    }\n  }, {\n    key: \"walkSpreadElement\",\n    value: function walkSpreadElement(expression) {\n      if (expression.argument) {\n        this.walkExpression(expression.argument);\n      }\n    }\n  }, {\n    key: \"walkObjectExpression\",\n    value: function walkObjectExpression(expression) {\n      for (var propIndex = 0, len = expression.properties.length; propIndex < len; propIndex++) {\n        var prop = expression.properties[propIndex];\n        this.walkProperty(prop);\n      }\n    }\n  }, {\n    key: \"walkProperty\",\n    value: function walkProperty(prop) {\n      if (prop.type === \"SpreadElement\") {\n        this.walkExpression(prop.argument);\n        return;\n      }\n\n      if (prop.computed) {\n        this.walkExpression(prop.key);\n      }\n\n      if (prop.shorthand && prop.value && prop.value.type === \"Identifier\") {\n        this.scope.inShorthand = prop.value.name;\n        this.walkIdentifier(prop.value);\n        this.scope.inShorthand = false;\n      } else {\n        this.walkExpression(prop.value);\n      }\n    }\n  }, {\n    key: \"walkFunctionExpression\",\n    value: function walkFunctionExpression(expression) {\n      var _this12 = this;\n\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n      var scopeParams = expression.params; // Add function name in scope for recursive calls\n\n      if (expression.id) {\n        scopeParams.push(expression.id.name);\n      }\n\n      this.inFunctionScope(true, scopeParams, function () {\n        var _iterator9 = _createForOfIteratorHelper(expression.params),\n            _step9;\n\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var param = _step9.value;\n\n            _this12.walkPattern(param);\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n\n        if (expression.body.type === \"BlockStatement\") {\n          _this12.detectMode(expression.body.body);\n\n          var prev = _this12.prevStatement;\n\n          _this12.preWalkStatement(expression.body);\n\n          _this12.prevStatement = prev;\n\n          _this12.walkStatement(expression.body);\n        } else {\n          _this12.walkExpression(expression.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }, {\n    key: \"walkArrowFunctionExpression\",\n    value: function walkArrowFunctionExpression(expression) {\n      var _this13 = this;\n\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = wasTopLevel ? \"arrow\" : false;\n      this.inFunctionScope(false, expression.params, function () {\n        var _iterator10 = _createForOfIteratorHelper(expression.params),\n            _step10;\n\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var param = _step10.value;\n\n            _this13.walkPattern(param);\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n\n        if (expression.body.type === \"BlockStatement\") {\n          _this13.detectMode(expression.body.body);\n\n          var prev = _this13.prevStatement;\n\n          _this13.preWalkStatement(expression.body);\n\n          _this13.prevStatement = prev;\n\n          _this13.walkStatement(expression.body);\n        } else {\n          _this13.walkExpression(expression.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n    /**\n     * @param {SequenceExpressionNode} expression the sequence\n     */\n\n  }, {\n    key: \"walkSequenceExpression\",\n    value: function walkSequenceExpression(expression) {\n      if (!expression.expressions) return; // We treat sequence expressions like statements when they are one statement level\n      // This has some benefits for optimizations that only work on statement level\n\n      var currentStatement = this.statementPath[this.statementPath.length - 1];\n\n      if (currentStatement === expression || currentStatement.type === \"ExpressionStatement\" && currentStatement.expression === expression) {\n        var old = this.statementPath.pop();\n\n        var _iterator11 = _createForOfIteratorHelper(expression.expressions),\n            _step11;\n\n        try {\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            var expr = _step11.value;\n            this.statementPath.push(expr);\n            this.walkExpression(expr);\n            this.statementPath.pop();\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n\n        this.statementPath.push(old);\n      } else {\n        this.walkExpressions(expression.expressions);\n      }\n    }\n  }, {\n    key: \"walkUpdateExpression\",\n    value: function walkUpdateExpression(expression) {\n      this.walkExpression(expression.argument);\n    }\n  }, {\n    key: \"walkUnaryExpression\",\n    value: function walkUnaryExpression(expression) {\n      if (expression.operator === \"typeof\") {\n        var result = this.callHooksForExpression(this.hooks.typeof, expression.argument, expression);\n        if (result === true) return;\n\n        if (expression.argument.type === \"ChainExpression\") {\n          var _result = this.callHooksForExpression(this.hooks.typeof, expression.argument.expression, expression);\n\n          if (_result === true) return;\n        }\n      }\n\n      this.walkExpression(expression.argument);\n    }\n  }, {\n    key: \"walkLeftRightExpression\",\n    value: function walkLeftRightExpression(expression) {\n      this.walkExpression(expression.left);\n      this.walkExpression(expression.right);\n    }\n  }, {\n    key: \"walkBinaryExpression\",\n    value: function walkBinaryExpression(expression) {\n      this.walkLeftRightExpression(expression);\n    }\n  }, {\n    key: \"walkLogicalExpression\",\n    value: function walkLogicalExpression(expression) {\n      var result = this.hooks.expressionLogicalOperator.call(expression);\n\n      if (result === undefined) {\n        this.walkLeftRightExpression(expression);\n      } else {\n        if (result) {\n          this.walkExpression(expression.right);\n        }\n      }\n    }\n  }, {\n    key: \"walkAssignmentExpression\",\n    value: function walkAssignmentExpression(expression) {\n      var _this14 = this;\n\n      if (expression.left.type === \"Identifier\") {\n        var renameIdentifier = this.getRenameIdentifier(expression.right);\n\n        if (renameIdentifier) {\n          if (this.callHooksForInfo(this.hooks.canRename, renameIdentifier, expression.right)) {\n            // renaming \"a = b;\"\n            if (!this.callHooksForInfo(this.hooks.rename, renameIdentifier, expression.right)) {\n              this.setVariable(expression.left.name, this.getVariableInfo(renameIdentifier));\n            }\n\n            return;\n          }\n        }\n\n        this.walkExpression(expression.right);\n        this.enterPattern(expression.left, function (name, decl) {\n          if (!_this14.callHooksForName(_this14.hooks.assign, name, expression)) {\n            _this14.walkExpression(expression.left);\n          }\n        });\n        return;\n      }\n\n      if (expression.left.type.endsWith(\"Pattern\")) {\n        this.walkExpression(expression.right);\n        this.enterPattern(expression.left, function (name, decl) {\n          if (!_this14.callHooksForName(_this14.hooks.assign, name, expression)) {\n            _this14.defineVariable(name);\n          }\n        });\n        this.walkPattern(expression.left);\n      } else if (expression.left.type === \"MemberExpression\") {\n        var exprName = this.getMemberExpressionInfo(expression.left, ALLOWED_MEMBER_TYPES_EXPRESSION);\n\n        if (exprName) {\n          if (this.callHooksForInfo(this.hooks.assignMemberChain, exprName.rootInfo, expression, exprName.getMembers())) {\n            return;\n          }\n        }\n\n        this.walkExpression(expression.right);\n        this.walkExpression(expression.left);\n      } else {\n        this.walkExpression(expression.right);\n        this.walkExpression(expression.left);\n      }\n    }\n  }, {\n    key: \"walkConditionalExpression\",\n    value: function walkConditionalExpression(expression) {\n      var result = this.hooks.expressionConditionalOperator.call(expression);\n\n      if (result === undefined) {\n        this.walkExpression(expression.test);\n        this.walkExpression(expression.consequent);\n\n        if (expression.alternate) {\n          this.walkExpression(expression.alternate);\n        }\n      } else {\n        if (result) {\n          this.walkExpression(expression.consequent);\n        } else if (expression.alternate) {\n          this.walkExpression(expression.alternate);\n        }\n      }\n    }\n  }, {\n    key: \"walkNewExpression\",\n    value: function walkNewExpression(expression) {\n      var result = this.callHooksForExpression(this.hooks.new, expression.callee, expression);\n      if (result === true) return;\n      this.walkExpression(expression.callee);\n\n      if (expression.arguments) {\n        this.walkExpressions(expression.arguments);\n      }\n    }\n  }, {\n    key: \"walkYieldExpression\",\n    value: function walkYieldExpression(expression) {\n      if (expression.argument) {\n        this.walkExpression(expression.argument);\n      }\n    }\n  }, {\n    key: \"walkTemplateLiteral\",\n    value: function walkTemplateLiteral(expression) {\n      if (expression.expressions) {\n        this.walkExpressions(expression.expressions);\n      }\n    }\n  }, {\n    key: \"walkTaggedTemplateExpression\",\n    value: function walkTaggedTemplateExpression(expression) {\n      if (expression.tag) {\n        this.walkExpression(expression.tag);\n      }\n\n      if (expression.quasi && expression.quasi.expressions) {\n        this.walkExpressions(expression.quasi.expressions);\n      }\n    }\n  }, {\n    key: \"walkClassExpression\",\n    value: function walkClassExpression(expression) {\n      this.walkClass(expression);\n    }\n    /**\n     * @param {ChainExpressionNode} expression expression\n     */\n\n  }, {\n    key: \"walkChainExpression\",\n    value: function walkChainExpression(expression) {\n      var result = this.hooks.optionalChaining.call(expression);\n\n      if (result === undefined) {\n        if (expression.expression.type === \"CallExpression\") {\n          this.walkCallExpression(expression.expression);\n        } else {\n          this.walkMemberExpression(expression.expression);\n        }\n      }\n    }\n  }, {\n    key: \"_walkIIFE\",\n    value: function _walkIIFE(functionExpression, options, currentThis) {\n      var _this15 = this;\n\n      var getVarInfo = function getVarInfo(argOrThis) {\n        var renameIdentifier = _this15.getRenameIdentifier(argOrThis);\n\n        if (renameIdentifier) {\n          if (_this15.callHooksForInfo(_this15.hooks.canRename, renameIdentifier, argOrThis)) {\n            if (!_this15.callHooksForInfo(_this15.hooks.rename, renameIdentifier, argOrThis)) {\n              return _this15.getVariableInfo(renameIdentifier);\n            }\n          }\n        }\n\n        _this15.walkExpression(argOrThis);\n      };\n\n      var params = functionExpression.params,\n          type = functionExpression.type;\n      var arrow = type === \"ArrowFunctionExpression\";\n      var renameThis = currentThis ? getVarInfo(currentThis) : null;\n      var varInfoForArgs = options.map(getVarInfo);\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = wasTopLevel && arrow ? \"arrow\" : false;\n      var scopeParams = params.filter(function (identifier, idx) {\n        return !varInfoForArgs[idx];\n      }); // Add function name in scope for recursive calls\n\n      if (functionExpression.id) {\n        scopeParams.push(functionExpression.id.name);\n      }\n\n      this.inFunctionScope(true, scopeParams, function () {\n        if (renameThis && !arrow) {\n          _this15.setVariable(\"this\", renameThis);\n        }\n\n        for (var i = 0; i < varInfoForArgs.length; i++) {\n          var varInfo = varInfoForArgs[i];\n          if (!varInfo) continue;\n          if (!params[i] || params[i].type !== \"Identifier\") continue;\n\n          _this15.setVariable(params[i].name, varInfo);\n        }\n\n        if (functionExpression.body.type === \"BlockStatement\") {\n          _this15.detectMode(functionExpression.body.body);\n\n          var prev = _this15.prevStatement;\n\n          _this15.preWalkStatement(functionExpression.body);\n\n          _this15.prevStatement = prev;\n\n          _this15.walkStatement(functionExpression.body);\n        } else {\n          _this15.walkExpression(functionExpression.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }, {\n    key: \"walkImportExpression\",\n    value: function walkImportExpression(expression) {\n      var result = this.hooks.importCall.call(expression);\n      if (result === true) return;\n      this.walkExpression(expression.source);\n    }\n  }, {\n    key: \"walkCallExpression\",\n    value: function walkCallExpression(expression) {\n      var isSimpleFunction = function isSimpleFunction(fn) {\n        return fn.params.every(function (p) {\n          return p.type === \"Identifier\";\n        });\n      };\n\n      if (expression.callee.type === \"MemberExpression\" && expression.callee.object.type.endsWith(\"FunctionExpression\") && !expression.callee.computed && (expression.callee.property.name === \"call\" || expression.callee.property.name === \"bind\") && expression.arguments.length > 0 && isSimpleFunction(expression.callee.object)) {\n        // (function() { }.call/bind(?, ))\n        this._walkIIFE(expression.callee.object, expression.arguments.slice(1), expression.arguments[0]);\n      } else if (expression.callee.type.endsWith(\"FunctionExpression\") && isSimpleFunction(expression.callee)) {\n        // (function() { }())\n        this._walkIIFE(expression.callee, expression.arguments, null);\n      } else {\n        if (expression.callee.type === \"MemberExpression\") {\n          var exprInfo = this.getMemberExpressionInfo(expression.callee, ALLOWED_MEMBER_TYPES_CALL_EXPRESSION);\n\n          if (exprInfo && exprInfo.type === \"call\") {\n            var result = this.callHooksForInfo(this.hooks.callMemberChainOfCallMemberChain, exprInfo.rootInfo, expression, exprInfo.getCalleeMembers(), exprInfo.call, exprInfo.getMembers());\n            if (result === true) return;\n          }\n        }\n\n        var callee = this.evaluateExpression(expression.callee);\n\n        if (callee.isIdentifier()) {\n          var result1 = this.callHooksForInfo(this.hooks.callMemberChain, callee.rootInfo, expression, callee.getMembers());\n          if (result1 === true) return;\n          var result2 = this.callHooksForInfo(this.hooks.call, callee.identifier, expression);\n          if (result2 === true) return;\n        }\n\n        if (expression.callee) {\n          if (expression.callee.type === \"MemberExpression\") {\n            // because of call context we need to walk the call context as expression\n            this.walkExpression(expression.callee.object);\n            if (expression.callee.computed === true) this.walkExpression(expression.callee.property);\n          } else {\n            this.walkExpression(expression.callee);\n          }\n        }\n\n        if (expression.arguments) this.walkExpressions(expression.arguments);\n      }\n    }\n  }, {\n    key: \"walkMemberExpression\",\n    value: function walkMemberExpression(expression) {\n      var _this16 = this;\n\n      var exprInfo = this.getMemberExpressionInfo(expression, ALLOWED_MEMBER_TYPES_ALL);\n\n      if (exprInfo) {\n        switch (exprInfo.type) {\n          case \"expression\":\n            {\n              var result1 = this.callHooksForInfo(this.hooks.expression, exprInfo.name, expression);\n              if (result1 === true) return;\n              var members = exprInfo.getMembers();\n              var result2 = this.callHooksForInfo(this.hooks.expressionMemberChain, exprInfo.rootInfo, expression, members);\n              if (result2 === true) return;\n              this.walkMemberExpressionWithExpressionName(expression, exprInfo.name, exprInfo.rootInfo, members.slice(), function () {\n                return _this16.callHooksForInfo(_this16.hooks.unhandledExpressionMemberChain, exprInfo.rootInfo, expression, members);\n              });\n              return;\n            }\n\n          case \"call\":\n            {\n              var result = this.callHooksForInfo(this.hooks.memberChainOfCallMemberChain, exprInfo.rootInfo, expression, exprInfo.getCalleeMembers(), exprInfo.call, exprInfo.getMembers());\n              if (result === true) return; // Fast skip over the member chain as we already called memberChainOfCallMemberChain\n              // and call computed property are literals anyway\n\n              this.walkExpression(exprInfo.call);\n              return;\n            }\n        }\n      }\n\n      this.walkExpression(expression.object);\n      if (expression.computed === true) this.walkExpression(expression.property);\n    }\n  }, {\n    key: \"walkMemberExpressionWithExpressionName\",\n    value: function walkMemberExpressionWithExpressionName(expression, name, rootInfo, members, onUnhandled) {\n      if (expression.object.type === \"MemberExpression\") {\n        // optimize the case where expression.object is a MemberExpression too.\n        // we can keep info here when calling walkMemberExpression directly\n        var property = expression.property.name || \"\".concat(expression.property.value);\n        name = name.slice(0, -property.length - 1);\n        members.pop();\n        var result = this.callHooksForInfo(this.hooks.expression, name, expression.object);\n        if (result === true) return;\n        this.walkMemberExpressionWithExpressionName(expression.object, name, rootInfo, members, onUnhandled);\n      } else if (!onUnhandled || !onUnhandled()) {\n        this.walkExpression(expression.object);\n      }\n\n      if (expression.computed === true) this.walkExpression(expression.property);\n    }\n  }, {\n    key: \"walkThisExpression\",\n    value: function walkThisExpression(expression) {\n      this.callHooksForName(this.hooks.expression, \"this\", expression);\n    }\n  }, {\n    key: \"walkIdentifier\",\n    value: function walkIdentifier(expression) {\n      this.callHooksForName(this.hooks.expression, expression.name, expression);\n    }\n    /**\n     * @param {MetaPropertyNode} metaProperty meta property\n     */\n\n  }, {\n    key: \"walkMetaProperty\",\n    value: function walkMetaProperty(metaProperty) {\n      this.hooks.expression.for(getRootName(metaProperty)).call(metaProperty);\n    }\n  }, {\n    key: \"callHooksForExpression\",\n    value: function callHooksForExpression(hookMap, expr) {\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      return this.callHooksForExpressionWithFallback.apply(this, [hookMap, expr, undefined, undefined].concat(args));\n    }\n    /**\n     * @template T\n     * @template R\n     * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n     * @param {MemberExpressionNode} expr expression info\n     * @param {function(string, string | ScopeInfo | VariableInfo, function(): string[]): any} fallback callback when variable in not handled by hooks\n     * @param {function(string): any} defined callback when variable is defined\n     * @param {AsArray<T>} args args for the hook\n     * @returns {R} result of hook\n     */\n\n  }, {\n    key: \"callHooksForExpressionWithFallback\",\n    value: function callHooksForExpressionWithFallback(hookMap, expr, fallback, defined) {\n      var exprName = this.getMemberExpressionInfo(expr, ALLOWED_MEMBER_TYPES_EXPRESSION);\n\n      if (exprName !== undefined) {\n        var members = exprName.getMembers();\n\n        for (var _len2 = arguments.length, args = new Array(_len2 > 4 ? _len2 - 4 : 0), _key2 = 4; _key2 < _len2; _key2++) {\n          args[_key2 - 4] = arguments[_key2];\n        }\n\n        return this.callHooksForInfoWithFallback.apply(this, [hookMap, members.length === 0 ? exprName.rootInfo : exprName.name, fallback && function (name) {\n          return fallback(name, exprName.rootInfo, exprName.getMembers);\n        }, defined && function () {\n          return defined(exprName.name);\n        }].concat(args));\n      }\n    }\n    /**\n     * @template T\n     * @template R\n     * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n     * @param {string} name key in map\n     * @param {AsArray<T>} args args for the hook\n     * @returns {R} result of hook\n     */\n\n  }, {\n    key: \"callHooksForName\",\n    value: function callHooksForName(hookMap, name) {\n      for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        args[_key3 - 2] = arguments[_key3];\n      }\n\n      return this.callHooksForNameWithFallback.apply(this, [hookMap, name, undefined, undefined].concat(args));\n    }\n    /**\n     * @template T\n     * @template R\n     * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks that should be called\n     * @param {ExportedVariableInfo} info variable info\n     * @param  {AsArray<T>} args args for the hook\n     * @returns {R} result of hook\n     */\n\n  }, {\n    key: \"callHooksForInfo\",\n    value: function callHooksForInfo(hookMap, info) {\n      for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n        args[_key4 - 2] = arguments[_key4];\n      }\n\n      return this.callHooksForInfoWithFallback.apply(this, [hookMap, info, undefined, undefined].concat(args));\n    }\n    /**\n     * @template T\n     * @template R\n     * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n     * @param {ExportedVariableInfo} info variable info\n     * @param {function(string): any} fallback callback when variable in not handled by hooks\n     * @param {function(): any} defined callback when variable is defined\n     * @param {AsArray<T>} args args for the hook\n     * @returns {R} result of hook\n     */\n\n  }, {\n    key: \"callHooksForInfoWithFallback\",\n    value: function callHooksForInfoWithFallback(hookMap, info, fallback, defined) {\n      var name;\n\n      for (var _len5 = arguments.length, args = new Array(_len5 > 4 ? _len5 - 4 : 0), _key5 = 4; _key5 < _len5; _key5++) {\n        args[_key5 - 4] = arguments[_key5];\n      }\n\n      if (typeof info === \"string\") {\n        name = info;\n      } else {\n        if (!(info instanceof VariableInfo)) {\n          if (defined !== undefined) {\n            return defined();\n          }\n\n          return;\n        }\n\n        var tagInfo = info.tagInfo;\n\n        while (tagInfo !== undefined) {\n          var _hook2 = hookMap.get(tagInfo.tag);\n\n          if (_hook2 !== undefined) {\n            this.currentTagData = tagInfo.data;\n\n            var result = _hook2.call.apply(_hook2, args);\n\n            this.currentTagData = undefined;\n            if (result !== undefined) return result;\n          }\n\n          tagInfo = tagInfo.next;\n        }\n\n        if (info.freeName === true) {\n          if (defined !== undefined) {\n            return defined();\n          }\n\n          return;\n        }\n\n        name = info.freeName;\n      }\n\n      var hook = hookMap.get(name);\n\n      if (hook !== undefined) {\n        var _result2 = hook.call.apply(hook, args);\n\n        if (_result2 !== undefined) return _result2;\n      }\n\n      if (fallback !== undefined) {\n        return fallback(name);\n      }\n    }\n    /**\n     * @template T\n     * @template R\n     * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n     * @param {string} name key in map\n     * @param {function(string): any} fallback callback when variable in not handled by hooks\n     * @param {function(): any} defined callback when variable is defined\n     * @param {AsArray<T>} args args for the hook\n     * @returns {R} result of hook\n     */\n\n  }, {\n    key: \"callHooksForNameWithFallback\",\n    value: function callHooksForNameWithFallback(hookMap, name, fallback, defined) {\n      for (var _len6 = arguments.length, args = new Array(_len6 > 4 ? _len6 - 4 : 0), _key6 = 4; _key6 < _len6; _key6++) {\n        args[_key6 - 4] = arguments[_key6];\n      }\n\n      return this.callHooksForInfoWithFallback.apply(this, [hookMap, this.getVariableInfo(name), fallback, defined].concat(args));\n    }\n    /**\n     * @deprecated\n     * @param {any} params scope params\n     * @param {function(): void} fn inner function\n     * @returns {void}\n     */\n\n  }, {\n    key: \"inScope\",\n    value: function inScope(params, fn) {\n      var _this17 = this;\n\n      var oldScope = this.scope;\n      this.scope = {\n        topLevelScope: oldScope.topLevelScope,\n        inTry: false,\n        inShorthand: false,\n        isStrict: oldScope.isStrict,\n        isAsmJs: oldScope.isAsmJs,\n        definitions: oldScope.definitions.createChild()\n      };\n      this.undefineVariable(\"this\");\n      this.enterPatterns(params, function (ident, pattern) {\n        _this17.defineVariable(ident);\n      });\n      fn();\n      this.scope = oldScope;\n    }\n  }, {\n    key: \"inFunctionScope\",\n    value: function inFunctionScope(hasThis, params, fn) {\n      var _this18 = this;\n\n      var oldScope = this.scope;\n      this.scope = {\n        topLevelScope: oldScope.topLevelScope,\n        inTry: false,\n        inShorthand: false,\n        isStrict: oldScope.isStrict,\n        isAsmJs: oldScope.isAsmJs,\n        definitions: oldScope.definitions.createChild()\n      };\n\n      if (hasThis) {\n        this.undefineVariable(\"this\");\n      }\n\n      this.enterPatterns(params, function (ident, pattern) {\n        _this18.defineVariable(ident);\n      });\n      fn();\n      this.scope = oldScope;\n    }\n  }, {\n    key: \"inBlockScope\",\n    value: function inBlockScope(fn) {\n      var oldScope = this.scope;\n      this.scope = {\n        topLevelScope: oldScope.topLevelScope,\n        inTry: oldScope.inTry,\n        inShorthand: false,\n        isStrict: oldScope.isStrict,\n        isAsmJs: oldScope.isAsmJs,\n        definitions: oldScope.definitions.createChild()\n      };\n      fn();\n      this.scope = oldScope;\n    }\n  }, {\n    key: \"detectMode\",\n    value: function detectMode(statements) {\n      var isLiteral = statements.length >= 1 && statements[0].type === \"ExpressionStatement\" && statements[0].expression.type === \"Literal\";\n\n      if (isLiteral && statements[0].expression.value === \"use strict\") {\n        this.scope.isStrict = true;\n      }\n\n      if (isLiteral && statements[0].expression.value === \"use asm\") {\n        this.scope.isAsmJs = true;\n      }\n    }\n  }, {\n    key: \"enterPatterns\",\n    value: function enterPatterns(patterns, onIdent) {\n      var _iterator12 = _createForOfIteratorHelper(patterns),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var pattern = _step12.value;\n\n          if (typeof pattern !== \"string\") {\n            this.enterPattern(pattern, onIdent);\n          } else if (pattern) {\n            onIdent(pattern);\n          }\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n    }\n  }, {\n    key: \"enterPattern\",\n    value: function enterPattern(pattern, onIdent) {\n      if (!pattern) return;\n\n      switch (pattern.type) {\n        case \"ArrayPattern\":\n          this.enterArrayPattern(pattern, onIdent);\n          break;\n\n        case \"AssignmentPattern\":\n          this.enterAssignmentPattern(pattern, onIdent);\n          break;\n\n        case \"Identifier\":\n          this.enterIdentifier(pattern, onIdent);\n          break;\n\n        case \"ObjectPattern\":\n          this.enterObjectPattern(pattern, onIdent);\n          break;\n\n        case \"RestElement\":\n          this.enterRestElement(pattern, onIdent);\n          break;\n\n        case \"Property\":\n          if (pattern.shorthand && pattern.value.type === \"Identifier\") {\n            this.scope.inShorthand = pattern.value.name;\n            this.enterIdentifier(pattern.value, onIdent);\n            this.scope.inShorthand = false;\n          } else {\n            this.enterPattern(pattern.value, onIdent);\n          }\n\n          break;\n      }\n    }\n  }, {\n    key: \"enterIdentifier\",\n    value: function enterIdentifier(pattern, onIdent) {\n      if (!this.callHooksForName(this.hooks.pattern, pattern.name, pattern)) {\n        onIdent(pattern.name, pattern);\n      }\n    }\n  }, {\n    key: \"enterObjectPattern\",\n    value: function enterObjectPattern(pattern, onIdent) {\n      for (var propIndex = 0, len = pattern.properties.length; propIndex < len; propIndex++) {\n        var prop = pattern.properties[propIndex];\n        this.enterPattern(prop, onIdent);\n      }\n    }\n  }, {\n    key: \"enterArrayPattern\",\n    value: function enterArrayPattern(pattern, onIdent) {\n      for (var elementIndex = 0, len = pattern.elements.length; elementIndex < len; elementIndex++) {\n        var element = pattern.elements[elementIndex];\n        this.enterPattern(element, onIdent);\n      }\n    }\n  }, {\n    key: \"enterRestElement\",\n    value: function enterRestElement(pattern, onIdent) {\n      this.enterPattern(pattern.argument, onIdent);\n    }\n  }, {\n    key: \"enterAssignmentPattern\",\n    value: function enterAssignmentPattern(pattern, onIdent) {\n      this.enterPattern(pattern.left, onIdent);\n    }\n    /**\n     * @param {ExpressionNode} expression expression node\n     * @returns {BasicEvaluatedExpression | undefined} evaluation result\n     */\n\n  }, {\n    key: \"evaluateExpression\",\n    value: function evaluateExpression(expression) {\n      try {\n        var hook = this.hooks.evaluate.get(expression.type);\n\n        if (hook !== undefined) {\n          var result = hook.call(expression);\n\n          if (result !== undefined) {\n            if (result) {\n              result.setExpression(expression);\n            }\n\n            return result;\n          }\n        }\n      } catch (e) {\n        console.warn(e); // ignore error\n      }\n\n      return new BasicEvaluatedExpression().setRange(expression.range).setExpression(expression);\n    }\n  }, {\n    key: \"parseString\",\n    value: function parseString(expression) {\n      switch (expression.type) {\n        case \"BinaryExpression\":\n          if (expression.operator === \"+\") {\n            return this.parseString(expression.left) + this.parseString(expression.right);\n          }\n\n          break;\n\n        case \"Literal\":\n          return expression.value + \"\";\n      }\n\n      throw new Error(expression.type + \" is not supported as parameter for require\");\n    }\n  }, {\n    key: \"parseCalculatedString\",\n    value: function parseCalculatedString(expression) {\n      switch (expression.type) {\n        case \"BinaryExpression\":\n          if (expression.operator === \"+\") {\n            var left = this.parseCalculatedString(expression.left);\n            var right = this.parseCalculatedString(expression.right);\n\n            if (left.code) {\n              return {\n                range: left.range,\n                value: left.value,\n                code: true,\n                conditional: false\n              };\n            } else if (right.code) {\n              return {\n                range: [left.range[0], right.range ? right.range[1] : left.range[1]],\n                value: left.value + right.value,\n                code: true,\n                conditional: false\n              };\n            } else {\n              return {\n                range: [left.range[0], right.range[1]],\n                value: left.value + right.value,\n                code: false,\n                conditional: false\n              };\n            }\n          }\n\n          break;\n\n        case \"ConditionalExpression\":\n          {\n            var consequent = this.parseCalculatedString(expression.consequent);\n            var alternate = this.parseCalculatedString(expression.alternate);\n            var items = [];\n\n            if (consequent.conditional) {\n              items.push.apply(items, _toConsumableArray(consequent.conditional));\n            } else if (!consequent.code) {\n              items.push(consequent);\n            } else {\n              break;\n            }\n\n            if (alternate.conditional) {\n              items.push.apply(items, _toConsumableArray(alternate.conditional));\n            } else if (!alternate.code) {\n              items.push(alternate);\n            } else {\n              break;\n            }\n\n            return {\n              range: undefined,\n              value: \"\",\n              code: true,\n              conditional: items\n            };\n          }\n\n        case \"Literal\":\n          return {\n            range: expression.range,\n            value: expression.value + \"\",\n            code: false,\n            conditional: false\n          };\n      }\n\n      return {\n        range: undefined,\n        value: \"\",\n        code: true,\n        conditional: false\n      };\n    }\n    /**\n     * @param {string | Buffer | PreparsedAst} source the source to parse\n     * @param {ParserState} state the parser state\n     * @returns {ParserState} the parser state\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(source, state) {\n      var ast;\n      var comments;\n      var semicolons = new Set();\n\n      if (source === null) {\n        throw new Error(\"source must not be null\");\n      }\n\n      if (Buffer.isBuffer(source)) {\n        source = source.toString(\"utf-8\");\n      }\n\n      if (typeof source === \"object\") {\n        ast =\n        /** @type {ProgramNode} */\n        source;\n        comments = source.comments;\n      } else {\n        comments = [];\n        ast = JavascriptParser._parse(source, {\n          sourceType: this.sourceType,\n          onComment: comments,\n          onInsertedSemicolon: function onInsertedSemicolon(pos) {\n            return semicolons.add(pos);\n          }\n        });\n      }\n\n      var oldScope = this.scope;\n      var oldState = this.state;\n      var oldComments = this.comments;\n      var oldSemicolons = this.semicolons;\n      var oldStatementPath = this.statementPath;\n      var oldPrevStatement = this.prevStatement;\n      this.scope = {\n        topLevelScope: true,\n        inTry: false,\n        inShorthand: false,\n        isStrict: false,\n        isAsmJs: false,\n        definitions: new StackedMap()\n      };\n      /** @type {ParserState} */\n\n      this.state = state;\n      this.comments = comments;\n      this.semicolons = semicolons;\n      this.statementPath = [];\n      this.prevStatement = undefined;\n\n      if (this.hooks.program.call(ast, comments) === undefined) {\n        this.detectMode(ast.body);\n        this.preWalkStatements(ast.body);\n        this.prevStatement = undefined;\n        this.blockPreWalkStatements(ast.body);\n        this.prevStatement = undefined;\n        this.walkStatements(ast.body);\n      }\n\n      this.hooks.finish.call(ast, comments);\n      this.scope = oldScope;\n      /** @type {ParserState} */\n\n      this.state = oldState;\n      this.comments = oldComments;\n      this.semicolons = oldSemicolons;\n      this.statementPath = oldStatementPath;\n      this.prevStatement = oldPrevStatement;\n      return state;\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(source) {\n      var ast = JavascriptParser._parse(\"(\" + source + \")\", {\n        sourceType: this.sourceType,\n        locations: false\n      });\n\n      if (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n        throw new Error(\"evaluate: Source is not a expression\");\n      }\n\n      return this.evaluateExpression(ast.body[0].expression);\n    }\n    /**\n     * @param {ExpressionNode | DeclarationNode | PrivateIdentifierNode | null | undefined} expr an expression\n     * @param {number} commentsStartPos source position from which annotation comments are checked\n     * @returns {boolean} true, when the expression is pure\n     */\n\n  }, {\n    key: \"isPure\",\n    value: function isPure(expr, commentsStartPos) {\n      var _this19 = this;\n\n      if (!expr) return true;\n      var result = this.hooks.isPure.for(expr.type).call(expr, commentsStartPos);\n      if (typeof result === \"boolean\") return result;\n\n      switch (expr.type) {\n        case \"ClassDeclaration\":\n        case \"ClassExpression\":\n          {\n            if (expr.body.type !== \"ClassBody\") return false;\n\n            if (expr.superClass && !this.isPure(expr.superClass, expr.range[0])) {\n              return false;\n            }\n\n            var items =\n            /** @type {(MethodDefinitionNode | PropertyDefinitionNode)[]} */\n            expr.body.body;\n            return items.every(function (item) {\n              return (!item.computed || !item.key || _this19.isPure(item.key, item.range[0])) && (!item.static || !item.value || _this19.isPure(item.value, item.key ? item.key.range[1] : item.range[0]));\n            });\n          }\n\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"Literal\":\n        case \"PrivateIdentifier\":\n          return true;\n\n        case \"VariableDeclaration\":\n          return expr.declarations.every(function (decl) {\n            return _this19.isPure(decl.init, decl.range[0]);\n          });\n\n        case \"ConditionalExpression\":\n          return this.isPure(expr.test, commentsStartPos) && this.isPure(expr.consequent, expr.test.range[1]) && this.isPure(expr.alternate, expr.consequent.range[1]);\n\n        case \"SequenceExpression\":\n          return expr.expressions.every(function (expr) {\n            var pureFlag = _this19.isPure(expr, commentsStartPos);\n\n            commentsStartPos = expr.range[1];\n            return pureFlag;\n          });\n\n        case \"CallExpression\":\n          {\n            var pureFlag = expr.range[0] - commentsStartPos > 12 && this.getComments([commentsStartPos, expr.range[0]]).some(function (comment) {\n              return comment.type === \"Block\" && /^\\s*(#|@)__PURE__\\s*$/.test(comment.value);\n            });\n            if (!pureFlag) return false;\n            commentsStartPos = expr.callee.range[1];\n            return expr.arguments.every(function (arg) {\n              if (arg.type === \"SpreadElement\") return false;\n\n              var pureFlag = _this19.isPure(arg, commentsStartPos);\n\n              commentsStartPos = arg.range[1];\n              return pureFlag;\n            });\n          }\n      }\n\n      var evaluated = this.evaluateExpression(expr);\n      return !evaluated.couldHaveSideEffects();\n    }\n  }, {\n    key: \"getComments\",\n    value: function getComments(range) {\n      var _range = _slicedToArray(range, 2),\n          rangeStart = _range[0],\n          rangeEnd = _range[1];\n\n      var compare = function compare(comment, needle) {\n        return comment.range[0] - needle;\n      };\n\n      var idx = binarySearchBounds.ge(this.comments, rangeStart, compare);\n      var commentsInRange = [];\n\n      while (this.comments[idx] && this.comments[idx].range[1] <= rangeEnd) {\n        commentsInRange.push(this.comments[idx]);\n        idx++;\n      }\n\n      return commentsInRange;\n    }\n    /**\n     * @param {number} pos source code position\n     * @returns {boolean} true when a semicolon has been inserted before this position, false if not\n     */\n\n  }, {\n    key: \"isAsiPosition\",\n    value: function isAsiPosition(pos) {\n      var currentStatement = this.statementPath[this.statementPath.length - 1];\n      if (currentStatement === undefined) throw new Error(\"Not in statement\");\n      return (// Either asking directly for the end position of the current statement\n        currentStatement.range[1] === pos && this.semicolons.has(pos) || // Or asking for the start position of the current statement,\n        // here we have to check multiple things\n        currentStatement.range[0] === pos && // is there a previous statement which might be relevant?\n        this.prevStatement !== undefined && // is the end position of the previous statement an ASI position?\n        this.semicolons.has(this.prevStatement.range[1])\n      );\n    }\n    /**\n     * @param {number} pos source code position\n     * @returns {void}\n     */\n\n  }, {\n    key: \"unsetAsiPosition\",\n    value: function unsetAsiPosition(pos) {\n      this.semicolons.delete(pos);\n    }\n  }, {\n    key: \"isStatementLevelExpression\",\n    value: function isStatementLevelExpression(expr) {\n      var currentStatement = this.statementPath[this.statementPath.length - 1];\n      return expr === currentStatement || currentStatement.type === \"ExpressionStatement\" && currentStatement.expression === expr;\n    }\n  }, {\n    key: \"getTagData\",\n    value: function getTagData(name, tag) {\n      var info = this.scope.definitions.get(name);\n\n      if (info instanceof VariableInfo) {\n        var tagInfo = info.tagInfo;\n\n        while (tagInfo !== undefined) {\n          if (tagInfo.tag === tag) return tagInfo.data;\n          tagInfo = tagInfo.next;\n        }\n      }\n    }\n  }, {\n    key: \"tagVariable\",\n    value: function tagVariable(name, tag, data) {\n      var oldInfo = this.scope.definitions.get(name);\n      /** @type {VariableInfo} */\n\n      var newInfo;\n\n      if (oldInfo === undefined) {\n        newInfo = new VariableInfo(this.scope, name, {\n          tag: tag,\n          data: data,\n          next: undefined\n        });\n      } else if (oldInfo instanceof VariableInfo) {\n        newInfo = new VariableInfo(oldInfo.declaredScope, oldInfo.freeName, {\n          tag: tag,\n          data: data,\n          next: oldInfo.tagInfo\n        });\n      } else {\n        newInfo = new VariableInfo(oldInfo, true, {\n          tag: tag,\n          data: data,\n          next: undefined\n        });\n      }\n\n      this.scope.definitions.set(name, newInfo);\n    }\n  }, {\n    key: \"defineVariable\",\n    value: function defineVariable(name) {\n      var oldInfo = this.scope.definitions.get(name); // Don't redefine variable in same scope to keep existing tags\n\n      if (oldInfo instanceof VariableInfo && oldInfo.declaredScope === this.scope) return;\n      this.scope.definitions.set(name, this.scope);\n    }\n  }, {\n    key: \"undefineVariable\",\n    value: function undefineVariable(name) {\n      this.scope.definitions.delete(name);\n    }\n  }, {\n    key: \"isVariableDefined\",\n    value: function isVariableDefined(name) {\n      var info = this.scope.definitions.get(name);\n      if (info === undefined) return false;\n\n      if (info instanceof VariableInfo) {\n        return info.freeName === true;\n      }\n\n      return true;\n    }\n    /**\n     * @param {string} name variable name\n     * @returns {ExportedVariableInfo} info for this variable\n     */\n\n  }, {\n    key: \"getVariableInfo\",\n    value: function getVariableInfo(name) {\n      var value = this.scope.definitions.get(name);\n\n      if (value === undefined) {\n        return name;\n      } else {\n        return value;\n      }\n    }\n    /**\n     * @param {string} name variable name\n     * @param {ExportedVariableInfo} variableInfo new info for this variable\n     * @returns {void}\n     */\n\n  }, {\n    key: \"setVariable\",\n    value: function setVariable(name, variableInfo) {\n      if (typeof variableInfo === \"string\") {\n        if (variableInfo === name) {\n          this.scope.definitions.delete(name);\n        } else {\n          this.scope.definitions.set(name, new VariableInfo(this.scope, variableInfo, undefined));\n        }\n      } else {\n        this.scope.definitions.set(name, variableInfo);\n      }\n    }\n  }, {\n    key: \"parseCommentOptions\",\n    value: function parseCommentOptions(range) {\n      var comments = this.getComments(range);\n\n      if (comments.length === 0) {\n        return EMPTY_COMMENT_OPTIONS;\n      }\n\n      var options = {};\n      var errors = [];\n\n      var _iterator13 = _createForOfIteratorHelper(comments),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var comment = _step13.value;\n          var value = comment.value;\n\n          if (value && webpackCommentRegExp.test(value)) {\n            // try compile only if webpack options comment is present\n            try {\n              var val = vm.runInNewContext(\"(function(){return {\".concat(value, \"};})()\"));\n              Object.assign(options, val);\n            } catch (e) {\n              e.comment = comment;\n              errors.push(e);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n\n      return {\n        options: options,\n        errors: errors\n      };\n    }\n    /**\n     * @param {MemberExpressionNode} expression a member expression\n     * @returns {{ members: string[], object: ExpressionNode | SuperNode }} member names (reverse order) and remaining object\n     */\n\n  }, {\n    key: \"extractMemberExpressionChain\",\n    value: function extractMemberExpressionChain(expression) {\n      /** @type {AnyNode} */\n      var expr = expression;\n      var members = [];\n\n      while (expr.type === \"MemberExpression\") {\n        if (expr.computed) {\n          if (expr.property.type !== \"Literal\") break;\n          members.push(\"\".concat(expr.property.value));\n        } else {\n          if (expr.property.type !== \"Identifier\") break;\n          members.push(expr.property.name);\n        }\n\n        expr = expr.object;\n      }\n\n      return {\n        members: members,\n        object: expr\n      };\n    }\n    /**\n     * @param {string} varName variable name\n     * @returns {{name: string, info: VariableInfo | string}} name of the free variable and variable info for that\n     */\n\n  }, {\n    key: \"getFreeInfoFromVariable\",\n    value: function getFreeInfoFromVariable(varName) {\n      var info = this.getVariableInfo(varName);\n      var name;\n\n      if (info instanceof VariableInfo) {\n        name = info.freeName;\n        if (typeof name !== \"string\") return undefined;\n      } else if (typeof info !== \"string\") {\n        return undefined;\n      } else {\n        name = info;\n      }\n\n      return {\n        info: info,\n        name: name\n      };\n    }\n    /** @typedef {{ type: \"call\", call: CallExpressionNode, calleeName: string, rootInfo: string | VariableInfo, getCalleeMembers: () => string[], name: string, getMembers: () => string[]}} CallExpressionInfo */\n\n    /** @typedef {{ type: \"expression\", rootInfo: string | VariableInfo, name: string, getMembers: () => string[]}} ExpressionExpressionInfo */\n\n    /**\n     * @param {MemberExpressionNode} expression a member expression\n     * @param {number} allowedTypes which types should be returned, presented in bit mask\n     * @returns {CallExpressionInfo | ExpressionExpressionInfo | undefined} expression info\n     */\n\n  }, {\n    key: \"getMemberExpressionInfo\",\n    value: function getMemberExpressionInfo(expression, allowedTypes) {\n      var _this$extractMemberEx = this.extractMemberExpressionChain(expression),\n          object = _this$extractMemberEx.object,\n          members = _this$extractMemberEx.members;\n\n      switch (object.type) {\n        case \"CallExpression\":\n          {\n            if ((allowedTypes & ALLOWED_MEMBER_TYPES_CALL_EXPRESSION) === 0) return undefined;\n            var callee = object.callee;\n            var rootMembers = EMPTY_ARRAY;\n\n            if (callee.type === \"MemberExpression\") {\n              var _this$extractMemberEx2 = this.extractMemberExpressionChain(callee);\n\n              callee = _this$extractMemberEx2.object;\n              rootMembers = _this$extractMemberEx2.members;\n            }\n\n            var rootName = getRootName(callee);\n            if (!rootName) return undefined;\n            var result = this.getFreeInfoFromVariable(rootName);\n            if (!result) return undefined;\n            var rootInfo = result.info,\n                resolvedRoot = result.name;\n            var calleeName = objectAndMembersToName(resolvedRoot, rootMembers);\n            return {\n              type: \"call\",\n              call: object,\n              calleeName: calleeName,\n              rootInfo: rootInfo,\n              getCalleeMembers: memoize(function () {\n                return rootMembers.reverse();\n              }),\n              name: objectAndMembersToName(\"\".concat(calleeName, \"()\"), members),\n              getMembers: memoize(function () {\n                return members.reverse();\n              })\n            };\n          }\n\n        case \"Identifier\":\n        case \"MetaProperty\":\n        case \"ThisExpression\":\n          {\n            if ((allowedTypes & ALLOWED_MEMBER_TYPES_EXPRESSION) === 0) return undefined;\n\n            var _rootName = getRootName(object);\n\n            if (!_rootName) return undefined;\n\n            var _result3 = this.getFreeInfoFromVariable(_rootName);\n\n            if (!_result3) return undefined;\n            var _rootInfo = _result3.info,\n                _resolvedRoot = _result3.name;\n            return {\n              type: \"expression\",\n              name: objectAndMembersToName(_resolvedRoot, members),\n              rootInfo: _rootInfo,\n              getMembers: memoize(function () {\n                return members.reverse();\n              })\n            };\n          }\n      }\n    }\n    /**\n     * @param {MemberExpressionNode} expression an expression\n     * @returns {{ name: string, rootInfo: ExportedVariableInfo, getMembers: () => string[]}} name info\n     */\n\n  }, {\n    key: \"getNameForExpression\",\n    value: function getNameForExpression(expression) {\n      return this.getMemberExpressionInfo(expression, ALLOWED_MEMBER_TYPES_EXPRESSION);\n    }\n    /**\n     * @param {string} code source code\n     * @param {ParseOptions} options parsing options\n     * @returns {ProgramNode} parsed ast\n     */\n\n  }], [{\n    key: \"_parse\",\n    value: function _parse(code, options) {\n      var type = options ? options.sourceType : \"module\";\n      /** @type {AcornOptions} */\n\n      var parserOptions = _objectSpread(_objectSpread(_objectSpread({}, defaultParserOptions), {}, {\n        allowReturnOutsideFunction: type === \"script\"\n      }, options), {}, {\n        sourceType: type === \"auto\" ? \"module\" : type\n      });\n      /** @type {AnyNode} */\n\n\n      var ast;\n      var error;\n      var threw = false;\n\n      try {\n        ast =\n        /** @type {AnyNode} */\n        parser.parse(code, parserOptions);\n      } catch (e) {\n        error = e;\n        threw = true;\n      }\n\n      if (threw && type === \"auto\") {\n        parserOptions.sourceType = \"script\";\n\n        if (!(\"allowReturnOutsideFunction\" in options)) {\n          parserOptions.allowReturnOutsideFunction = true;\n        }\n\n        if (Array.isArray(parserOptions.onComment)) {\n          parserOptions.onComment.length = 0;\n        }\n\n        try {\n          ast =\n          /** @type {AnyNode} */\n          parser.parse(code, parserOptions);\n          threw = false;\n        } catch (e) {// we use the error from first parse try\n          // so nothing to do here\n        }\n      }\n\n      if (threw) {\n        throw error;\n      }\n\n      return (\n        /** @type {ProgramNode} */\n        ast\n      );\n    }\n  }]);\n\n  return JavascriptParser;\n}(Parser);\n\nmodule.exports = JavascriptParser;\nmodule.exports.ALLOWED_MEMBER_TYPES_ALL = ALLOWED_MEMBER_TYPES_ALL;\nmodule.exports.ALLOWED_MEMBER_TYPES_EXPRESSION = ALLOWED_MEMBER_TYPES_EXPRESSION;\nmodule.exports.ALLOWED_MEMBER_TYPES_CALL_EXPRESSION = ALLOWED_MEMBER_TYPES_CALL_EXPRESSION;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/javascript/JavascriptParser.js"],"names":["require","AcornParser","Parser","importAssertions","SyncBailHook","HookMap","vm","StackedMap","binarySearchBounds","memoize","BasicEvaluatedExpression","EMPTY_ARRAY","ALLOWED_MEMBER_TYPES_CALL_EXPRESSION","ALLOWED_MEMBER_TYPES_EXPRESSION","ALLOWED_MEMBER_TYPES_ALL","parser","extend","VariableInfo","declaredScope","freeName","tagInfo","joinRanges","startRange","endRange","objectAndMembersToName","object","membersReversed","name","i","length","getRootName","expression","type","meta","property","undefined","defaultParserOptions","ranges","locations","ecmaVersion","sourceType","allowHashBang","onComment","webpackCommentRegExp","RegExp","EMPTY_COMMENT_OPTIONS","options","errors","JavascriptParser","hooks","Object","freeze","evaluateTypeof","evaluate","evaluateIdentifier","evaluateDefinedIdentifier","evaluateCallExpressionMember","isPure","preStatement","blockPreStatement","statement","statementIf","classExtendsExpression","classBodyElement","classBodyValue","label","import","importSpecifier","export","exportImport","exportDeclaration","exportExpression","exportSpecifier","exportImportSpecifier","preDeclarator","declarator","varDeclaration","varDeclarationLet","varDeclarationConst","varDeclarationVar","pattern","canRename","rename","assign","assignMemberChain","typeof","importCall","topLevelAwait","call","callMemberChain","memberChainOfCallMemberChain","callMemberChainOfCallMemberChain","optionalChaining","new","expressionMemberChain","unhandledExpressionMemberChain","expressionConditionalOperator","expressionLogicalOperator","program","finish","scope","state","comments","semicolons","statementPath","prevStatement","currentTagData","_initializeEvaluating","for","tap","_expr","expr","value","setNumber","setRange","range","setBigInt","setString","setBoolean","setNull","setRegExp","callee","arguments","getVariableInfo","regExp","flags","arg1","evaluatedRegExp","evaluateExpression","asString","arg2","evaluatedFlags","isUndefined","isValidRegExpFlags","left","returnRight","allowedRight","operator","leftAsBool","asBool","leftAsNullish","asNullish","right","couldHaveSideEffects","setSideEffects","setTruthy","setFalsy","valueAsExpression","sideEffects","handleConstOperation","fn","isCompileTimeValue","result","asCompileTimeValue","isAlwaysDifferent","a","b","handleTemplateStringCompare","res","eql","getPrefix","parts","p","v","getSuffix","leftPrefix","rightPrefix","leftSuffix","rightSuffix","lenPrefix","Math","min","lenSuffix","slice","handleStrictEqualityComparison","leftConst","rightConst","isArray","isTemplateString","leftPrimitive","isPrimitiveType","rightPrimitive","handleAbstractEqualityComparison","isString","string","isNumber","number","isWrapped","prefix","setWrapped","postfix","wrappedInnerExpressions","isBigInt","bigint","concat","l","r","argument","callHooksForName","callHooksForExpression","arg","isUnknown","isBoolean","isConstArray","isRegExp","isNull","bool","setUndefined","tapEvaluateWithVariableInfo","exprType","getInfo","cachedExpression","cachedInfo","info","callHooksForInfoWithFallback","hook","get","stage","setIdentifier","rootInfo","getMembers","metaProperty","getMemberExpressionInfo","computed","param","arg1Eval","arg1Value","arg2Eval","indexOf","arg2Value","replace","forEach","str","getSimplifiedTemplateResult","kind","templateLiteralExpr","quasis","quasiExpr","quasi","prevExpr","expressions","exprAsString","setExpression","push","part","_node","node","setTemplateString","tag","isIdentifier","identifier","stringSuffix","hasUnknownParams","innerExpressions","argExpr","newString","newRange","inner","reverse","split","setArray","condition","test","conditionValue","consequent","alternate","isConditional","setOptions","addOptions","items","elements","map","element","every","Boolean","setItems","optionalExpressionsStack","next","optional","pop","evaluated","classy","superClass","walkExpression","body","classElement","key","wasTopLevel","topLevelScope","statements","index","len","preWalkStatement","blockPreWalkStatement","walkStatement","preWalkBlockStatement","preWalkDoWhileStatement","preWalkForInStatement","preWalkForOfStatement","preWalkForStatement","preWalkFunctionDeclaration","preWalkIfStatement","preWalkLabeledStatement","preWalkSwitchStatement","preWalkTryStatement","preWalkVariableDeclaration","preWalkWhileStatement","preWalkWithStatement","blockPreWalkImportDeclaration","blockPreWalkExportAllDeclaration","blockPreWalkExportDefaultDeclaration","blockPreWalkExportNamedDeclaration","blockPreWalkVariableDeclaration","blockPreWalkClassDeclaration","walkBlockStatement","walkClassDeclaration","walkDoWhileStatement","walkExportDefaultDeclaration","walkExportNamedDeclaration","walkExpressionStatement","walkForInStatement","walkForOfStatement","walkForStatement","walkFunctionDeclaration","walkIfStatement","walkLabeledStatement","walkReturnStatement","walkSwitchStatement","walkThrowStatement","walkTryStatement","walkVariableDeclaration","walkWhileStatement","walkWithStatement","preWalkStatements","inBlockScope","prev","blockPreWalkStatements","walkStatements","walkNestedStatement","preWalkSwitchCases","cases","discriminant","walkSwitchCases","walkTerminatingStatement","block","handler","preWalkCatchClause","finializer","inTry","walkCatchClause","finalizer","init","update","walkPattern","await","id","defineVariable","inFunctionScope","params","detectMode","source","specifiers","specifier","local","imported","declaration","onIdent","declarations","enterPattern","enterDeclaration","def","specifierIndex","exported","_preWalkVariableDeclaration","hookMap","decl","renameIdentifier","getRenameIdentifier","setVariable","walkClass","switchCases","switchCase","catchClause","ident","walkArrayPattern","walkAssignmentPattern","walkMemberExpression","walkObjectPattern","walkRestElement","properties","prop","walkArrayExpression","walkArrowFunctionExpression","walkAssignmentExpression","walkAwaitExpression","walkBinaryExpression","walkCallExpression","walkChainExpression","walkClassExpression","walkConditionalExpression","walkFunctionExpression","walkIdentifier","walkImportExpression","walkLogicalExpression","walkMetaProperty","walkNewExpression","walkObjectExpression","walkSequenceExpression","walkSpreadElement","walkTaggedTemplateExpression","walkTemplateLiteral","walkThisExpression","walkUnaryExpression","walkUpdateExpression","walkYieldExpression","walkExpressions","propIndex","walkProperty","shorthand","inShorthand","scopeParams","currentStatement","old","walkLeftRightExpression","callHooksForInfo","endsWith","exprName","functionExpression","currentThis","getVarInfo","argOrThis","arrow","renameThis","varInfoForArgs","filter","idx","varInfo","isSimpleFunction","_walkIIFE","exprInfo","getCalleeMembers","result1","result2","members","walkMemberExpressionWithExpressionName","onUnhandled","args","callHooksForExpressionWithFallback","fallback","defined","callHooksForNameWithFallback","data","oldScope","isStrict","isAsmJs","definitions","createChild","undefineVariable","enterPatterns","hasThis","isLiteral","patterns","enterArrayPattern","enterAssignmentPattern","enterIdentifier","enterObjectPattern","enterRestElement","elementIndex","e","console","warn","parseString","Error","parseCalculatedString","code","conditional","ast","Set","Buffer","isBuffer","toString","_parse","onInsertedSemicolon","pos","add","oldState","oldComments","oldSemicolons","oldStatementPath","oldPrevStatement","commentsStartPos","item","static","pureFlag","getComments","some","comment","rangeStart","rangeEnd","compare","needle","ge","commentsInRange","has","delete","oldInfo","newInfo","set","variableInfo","val","runInNewContext","varName","allowedTypes","extractMemberExpressionChain","rootMembers","rootName","getFreeInfoFromVariable","resolvedRoot","calleeName","parserOptions","allowReturnOutsideFunction","error","threw","parse","Array","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;AAEA,eAAgCA,OAAO,CAAC,OAAD,CAAvC;AAAA,IAAgBC,WAAhB,YAAQC,MAAR;;AACA,gBAA6BF,OAAO,CAAC,yBAAD,CAApC;AAAA,IAAQG,gBAAR,aAAQA,gBAAR;;AACA,gBAAkCH,OAAO,CAAC,SAAD,CAAzC;AAAA,IAAQI,YAAR,aAAQA,YAAR;AAAA,IAAsBC,OAAtB,aAAsBA,OAAtB;;AACA,IAAMC,EAAE,GAAGN,OAAO,CAAC,IAAD,CAAlB;;AACA,IAAME,MAAM,GAAGF,OAAO,CAAC,WAAD,CAAtB;;AACA,IAAMO,UAAU,GAAGP,OAAO,CAAC,oBAAD,CAA1B;;AACA,IAAMQ,kBAAkB,GAAGR,OAAO,CAAC,4BAAD,CAAlC;;AACA,IAAMS,OAAO,GAAGT,OAAO,CAAC,iBAAD,CAAvB;;AACA,IAAMU,wBAAwB,GAAGV,OAAO,CAAC,4BAAD,CAAxC;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;AAEA,IAAMW,WAAW,GAAG,EAApB;AACA,IAAMC,oCAAoC,GAAG,CAA7C;AACA,IAAMC,+BAA+B,GAAG,CAAxC;AACA,IAAMC,wBAAwB,GAAG,CAAjC,C,CAEA;;AAEA,IAAMC,MAAM,GAAGd,WAAW,CAACe,MAAZ,CAAmBb,gBAAnB,CAAf;;IAEMc,Y;AACL;AACD;AACA;AACA;AACA;AACC,sBAAYC,aAAZ,EAA2BC,QAA3B,EAAqCC,OAArC,EAA8C;AAAA;;AAC7C,OAAKF,aAAL,GAAqBA,aAArB;AACA,OAAKC,QAAL,GAAgBA,QAAhB;AACA,OAAKC,OAAL,GAAeA,OAAf;AACA,C;AAGF;;AACA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,IAAMC,UAAU,GAAG,SAAbA,UAAa,CAACC,UAAD,EAAaC,QAAb,EAA0B;AAC5C,MAAI,CAACA,QAAL,EAAe,OAAOD,UAAP;AACf,MAAI,CAACA,UAAL,EAAiB,OAAOC,QAAP;AACjB,SAAO,CAACD,UAAU,CAAC,CAAD,CAAX,EAAgBC,QAAQ,CAAC,CAAD,CAAxB,CAAP;AACA,CAJD;;AAMA,IAAMC,sBAAsB,GAAG,SAAzBA,sBAAyB,CAACC,MAAD,EAASC,eAAT,EAA6B;AAC3D,MAAIC,IAAI,GAAGF,MAAX;;AACA,OAAK,IAAIG,CAAC,GAAGF,eAAe,CAACG,MAAhB,GAAyB,CAAtC,EAAyCD,CAAC,IAAI,CAA9C,EAAiDA,CAAC,EAAlD,EAAsD;AACrDD,IAAAA,IAAI,GAAGA,IAAI,GAAG,GAAP,GAAaD,eAAe,CAACE,CAAD,CAAnC;AACA;;AACD,SAAOD,IAAP;AACA,CAND;;AAQA,IAAMG,WAAW,GAAG,SAAdA,WAAc,CAAAC,UAAU,EAAI;AACjC,UAAQA,UAAU,CAACC,IAAnB;AACC,SAAK,YAAL;AACC,aAAOD,UAAU,CAACJ,IAAlB;;AACD,SAAK,gBAAL;AACC,aAAO,MAAP;;AACD,SAAK,cAAL;AACC,uBAAUI,UAAU,CAACE,IAAX,CAAgBN,IAA1B,cAAkCI,UAAU,CAACG,QAAX,CAAoBP,IAAtD;;AACD;AACC,aAAOQ,SAAP;AARF;AAUA,CAXD;AAaA;;;AACA,IAAMC,oBAAoB,GAAG;AAC5BC,EAAAA,MAAM,EAAE,IADoB;AAE5BC,EAAAA,SAAS,EAAE,IAFiB;AAG5BC,EAAAA,WAAW,EAAE,QAHe;AAI5BC,EAAAA,UAAU,EAAE,QAJgB;AAK5B;AACAC,EAAAA,aAAa,EAAE,IANa;AAO5BC,EAAAA,SAAS,EAAE;AAPiB,CAA7B,C,CAUA;;AACA,IAAMC,oBAAoB,GAAG,IAAIC,MAAJ,CAAW,qCAAX,CAA7B;AAEA,IAAMC,qBAAqB,GAAG;AAC7BC,EAAAA,OAAO,EAAE,IADoB;AAE7BC,EAAAA,MAAM,EAAE;AAFqB,CAA9B;;IAKMC,gB;;;;;AACL;AACD;AACA;AACC,8BAAiC;AAAA;;AAAA,QAArBR,UAAqB,uEAAR,MAAQ;;AAAA;;AAChC;AACA,UAAKS,KAAL,GAAaC,MAAM,CAACC,MAAP,CAAc;AAC1B;AACAC,MAAAA,cAAc,EAAE,IAAI/C,OAAJ,CAAY;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,YAAD,CAAjB,CAAN;AAAA,OAAZ,CAFU;;AAG1B;AACAiD,MAAAA,QAAQ,EAAE,IAAIhD,OAAJ,CAAY;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,YAAD,CAAjB,CAAN;AAAA,OAAZ,CAJgB;;AAK1B;AACAkD,MAAAA,kBAAkB,EAAE,IAAIjD,OAAJ,CAAY;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,YAAD,CAAjB,CAAN;AAAA,OAAZ,CANM;;AAO1B;AACAmD,MAAAA,yBAAyB,EAAE,IAAIlD,OAAJ,CAC1B;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,YAAD,CAAjB,CAAN;AAAA,OAD0B,CARD;;AAW1B;AACAoD,MAAAA,4BAA4B,EAAE,IAAInD,OAAJ,CAC7B;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,YAAD,EAAe,OAAf,CAAjB,CAAN;AAAA,OAD6B,CAZJ;;AAe1B;AACAqD,MAAAA,MAAM,EAAE,IAAIpD,OAAJ,CACP;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,YAAD,EAAe,uBAAf,CAAjB,CAAN;AAAA,OADO,CAhBkB;;AAmB1B;AACAsD,MAAAA,YAAY,EAAE,IAAItD,YAAJ,CAAiB,CAAC,WAAD,CAAjB,CApBY;;AAsB1B;AACAuD,MAAAA,iBAAiB,EAAE,IAAIvD,YAAJ,CAAiB,CAAC,aAAD,CAAjB,CAvBO;;AAwB1B;AACAwD,MAAAA,SAAS,EAAE,IAAIxD,YAAJ,CAAiB,CAAC,WAAD,CAAjB,CAzBe;;AA0B1B;AACAyD,MAAAA,WAAW,EAAE,IAAIzD,YAAJ,CAAiB,CAAC,WAAD,CAAjB,CA3Ba;;AA4B1B;AACA0D,MAAAA,sBAAsB,EAAE,IAAI1D,YAAJ,CAAiB,CACxC,YADwC,EAExC,iBAFwC,CAAjB,CA7BE;;AAiC1B;AACA2D,MAAAA,gBAAgB,EAAE,IAAI3D,YAAJ,CAAiB,CAAC,SAAD,EAAY,iBAAZ,CAAjB,CAlCQ;;AAmC1B;AACA4D,MAAAA,cAAc,EAAE,IAAI5D,YAAJ,CAAiB,CAChC,YADgC,EAEhC,SAFgC,EAGhC,iBAHgC,CAAjB,CApCU;;AAyC1B;AACA6D,MAAAA,KAAK,EAAE,IAAI5D,OAAJ,CAAY;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,WAAD,CAAjB,CAAN;AAAA,OAAZ,CA1CmB;;AA2C1B;AACA8D,MAAAA,MAAM,EAAE,IAAI9D,YAAJ,CAAiB,CAAC,WAAD,EAAc,QAAd,CAAjB,CA5CkB;;AA6C1B;AACA+D,MAAAA,eAAe,EAAE,IAAI/D,YAAJ,CAAiB,CACjC,WADiC,EAEjC,QAFiC,EAGjC,YAHiC,EAIjC,gBAJiC,CAAjB,CA9CS;;AAoD1B;AACAgE,MAAAA,MAAM,EAAE,IAAIhE,YAAJ,CAAiB,CAAC,WAAD,CAAjB,CArDkB;;AAsD1B;AACAiE,MAAAA,YAAY,EAAE,IAAIjE,YAAJ,CAAiB,CAAC,WAAD,EAAc,QAAd,CAAjB,CAvDY;;AAwD1B;AACAkE,MAAAA,iBAAiB,EAAE,IAAIlE,YAAJ,CAAiB,CAAC,WAAD,EAAc,aAAd,CAAjB,CAzDO;;AA0D1B;AACAmE,MAAAA,gBAAgB,EAAE,IAAInE,YAAJ,CAAiB,CAAC,WAAD,EAAc,aAAd,CAAjB,CA3DQ;;AA4D1B;AACAoE,MAAAA,eAAe,EAAE,IAAIpE,YAAJ,CAAiB,CACjC,WADiC,EAEjC,gBAFiC,EAGjC,YAHiC,EAIjC,OAJiC,CAAjB,CA7DS;;AAmE1B;AACAqE,MAAAA,qBAAqB,EAAE,IAAIrE,YAAJ,CAAiB,CACvC,WADuC,EAEvC,QAFuC,EAGvC,gBAHuC,EAIvC,YAJuC,EAKvC,OALuC,CAAjB,CApEG;;AA2E1B;AACAsE,MAAAA,aAAa,EAAE,IAAItE,YAAJ,CAAiB,CAAC,YAAD,EAAe,WAAf,CAAjB,CA5EW;;AA6E1B;AACAuE,MAAAA,UAAU,EAAE,IAAIvE,YAAJ,CAAiB,CAAC,YAAD,EAAe,WAAf,CAAjB,CA9Ec;;AA+E1B;AACAwE,MAAAA,cAAc,EAAE,IAAIvE,OAAJ,CAAY;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,aAAD,CAAjB,CAAN;AAAA,OAAZ,CAhFU;;AAiF1B;AACAyE,MAAAA,iBAAiB,EAAE,IAAIxE,OAAJ,CAAY;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,aAAD,CAAjB,CAAN;AAAA,OAAZ,CAlFO;;AAmF1B;AACA0E,MAAAA,mBAAmB,EAAE,IAAIzE,OAAJ,CAAY;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,aAAD,CAAjB,CAAN;AAAA,OAAZ,CApFK;;AAqF1B;AACA2E,MAAAA,iBAAiB,EAAE,IAAI1E,OAAJ,CAAY;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,aAAD,CAAjB,CAAN;AAAA,OAAZ,CAtFO;;AAuF1B;AACA4E,MAAAA,OAAO,EAAE,IAAI3E,OAAJ,CAAY;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,SAAD,CAAjB,CAAN;AAAA,OAAZ,CAxFiB;;AAyF1B;AACA6E,MAAAA,SAAS,EAAE,IAAI5E,OAAJ,CAAY;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,gBAAD,CAAjB,CAAN;AAAA,OAAZ,CA1Fe;;AA2F1B;AACA8E,MAAAA,MAAM,EAAE,IAAI7E,OAAJ,CAAY;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,gBAAD,CAAjB,CAAN;AAAA,OAAZ,CA5FkB;;AA6F1B;AACA+E,MAAAA,MAAM,EAAE,IAAI9E,OAAJ,CAAY;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,YAAD,CAAjB,CAAN;AAAA,OAAZ,CA9FkB;;AA+F1B;AACAgF,MAAAA,iBAAiB,EAAE,IAAI/E,OAAJ,CAClB;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,YAAD,EAAe,SAAf,CAAjB,CAAN;AAAA,OADkB,CAhGO;;AAmG1B;AACAiF,MAAAA,MAAM,EAAE,IAAIhF,OAAJ,CAAY;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,YAAD,CAAjB,CAAN;AAAA,OAAZ,CApGkB;;AAqG1B;AACAkF,MAAAA,UAAU,EAAE,IAAIlF,YAAJ,CAAiB,CAAC,YAAD,CAAjB,CAtGc;;AAuG1B;AACAmF,MAAAA,aAAa,EAAE,IAAInF,YAAJ,CAAiB,CAAC,YAAD,CAAjB,CAxGW;;AAyG1B;AACAoF,MAAAA,IAAI,EAAE,IAAInF,OAAJ,CAAY;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,YAAD,CAAjB,CAAN;AAAA,OAAZ,CA1GoB;;AA2G1B;;AACA;AACAqF,MAAAA,eAAe,EAAE,IAAIpF,OAAJ,CAChB;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,YAAD,EAAe,SAAf,CAAjB,CAAN;AAAA,OADgB,CA7GS;;AAgH1B;;AACA;AACAsF,MAAAA,4BAA4B,EAAE,IAAIrF,OAAJ,CAC7B;AAAA,eACC,IAAID,YAAJ,CAAiB,CAChB,YADgB,EAEhB,eAFgB,EAGhB,gBAHgB,EAIhB,SAJgB,CAAjB,CADD;AAAA,OAD6B,CAlHJ;;AA2H1B;;AACA;AACAuF,MAAAA,gCAAgC,EAAE,IAAItF,OAAJ,CACjC;AAAA,eACC,IAAID,YAAJ,CAAiB,CAChB,YADgB,EAEhB,eAFgB,EAGhB,qBAHgB,EAIhB,SAJgB,CAAjB,CADD;AAAA,OADiC,CA7HR;;AAsI1B;AACAwF,MAAAA,gBAAgB,EAAE,IAAIxF,YAAJ,CAAiB,CAAC,kBAAD,CAAjB,CAvIQ;;AAwI1B;AACAyF,MAAAA,GAAG,EAAE,IAAIxF,OAAJ,CAAY;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,YAAD,CAAjB,CAAN;AAAA,OAAZ,CAzIqB;;AA0I1B;AACA2B,MAAAA,UAAU,EAAE,IAAI1B,OAAJ,CAAY;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,YAAD,CAAjB,CAAN;AAAA,OAAZ,CA3Ic;;AA4I1B;AACA0F,MAAAA,qBAAqB,EAAE,IAAIzF,OAAJ,CACtB;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,YAAD,EAAe,SAAf,CAAjB,CAAN;AAAA,OADsB,CA7IG;;AAgJ1B;AACA2F,MAAAA,8BAA8B,EAAE,IAAI1F,OAAJ,CAC/B;AAAA,eAAM,IAAID,YAAJ,CAAiB,CAAC,YAAD,EAAe,SAAf,CAAjB,CAAN;AAAA,OAD+B,CAjJN;;AAoJ1B;AACA4F,MAAAA,6BAA6B,EAAE,IAAI5F,YAAJ,CAAiB,CAAC,YAAD,CAAjB,CArJL;;AAsJ1B;AACA6F,MAAAA,yBAAyB,EAAE,IAAI7F,YAAJ,CAAiB,CAAC,YAAD,CAAjB,CAvJD;;AAwJ1B;AACA8F,MAAAA,OAAO,EAAE,IAAI9F,YAAJ,CAAiB,CAAC,KAAD,EAAQ,UAAR,CAAjB,CAzJiB;;AA0J1B;AACA+F,MAAAA,MAAM,EAAE,IAAI/F,YAAJ,CAAiB,CAAC,KAAD,EAAQ,UAAR,CAAjB;AA3JkB,KAAd,CAAb;AA6JA,UAAKoC,UAAL,GAAkBA,UAAlB;AACA;;AACA,UAAK4D,KAAL,GAAajE,SAAb;AACA;;AACA,UAAKkE,KAAL,GAAalE,SAAb;AACA,UAAKmE,QAAL,GAAgBnE,SAAhB;AACA,UAAKoE,UAAL,GAAkBpE,SAAlB;AACA;;AACA,UAAKqE,aAAL,GAAqBrE,SAArB;AACA,UAAKsE,aAAL,GAAqBtE,SAArB;AACA,UAAKuE,cAAL,GAAsBvE,SAAtB;;AACA,UAAKwE,qBAAL;;AA1KgC;AA2KhC;;;;WAED,iCAAwB;AAAA;;AACvB,WAAK1D,KAAL,CAAWI,QAAX,CAAoBuD,GAApB,CAAwB,SAAxB,EAAmCC,GAAnC,CAAuC,kBAAvC,EAA2D,UAAAC,KAAK,EAAI;AACnE,YAAMC,IAAI;AAAG;AAA4BD,QAAAA,KAAzC;;AAEA,gBAAQ,OAAOC,IAAI,CAACC,KAApB;AACC,eAAK,QAAL;AACC,mBAAO,IAAItG,wBAAJ,GACLuG,SADK,CACKF,IAAI,CAACC,KADV,EAELE,QAFK,CAEIH,IAAI,CAACI,KAFT,CAAP;;AAGD,eAAK,QAAL;AACC,mBAAO,IAAIzG,wBAAJ,GACL0G,SADK,CACKL,IAAI,CAACC,KADV,EAELE,QAFK,CAEIH,IAAI,CAACI,KAFT,CAAP;;AAGD,eAAK,QAAL;AACC,mBAAO,IAAIzG,wBAAJ,GACL2G,SADK,CACKN,IAAI,CAACC,KADV,EAELE,QAFK,CAEIH,IAAI,CAACI,KAFT,CAAP;;AAGD,eAAK,SAAL;AACC,mBAAO,IAAIzG,wBAAJ,GACL4G,UADK,CACMP,IAAI,CAACC,KADX,EAELE,QAFK,CAEIH,IAAI,CAACI,KAFT,CAAP;AAdF;;AAkBA,YAAIJ,IAAI,CAACC,KAAL,KAAe,IAAnB,EAAyB;AACxB,iBAAO,IAAItG,wBAAJ,GAA+B6G,OAA/B,GAAyCL,QAAzC,CAAkDH,IAAI,CAACI,KAAvD,CAAP;AACA;;AACD,YAAIJ,IAAI,CAACC,KAAL,YAAsBpE,MAA1B,EAAkC;AACjC,iBAAO,IAAIlC,wBAAJ,GACL8G,SADK,CACKT,IAAI,CAACC,KADV,EAELE,QAFK,CAEIH,IAAI,CAACI,KAFT,CAAP;AAGA;AACD,OA7BD;AA8BA,WAAKlE,KAAL,CAAWI,QAAX,CAAoBuD,GAApB,CAAwB,eAAxB,EAAyCC,GAAzC,CAA6C,kBAA7C,EAAiE,UAAAC,KAAK,EAAI;AACzE,YAAMC,IAAI;AAAG;AAAkCD,QAAAA,KAA/C;AACA,YAAMW,MAAM,GAAGV,IAAI,CAACU,MAApB;AACA,YACCA,MAAM,CAACzF,IAAP,KAAgB,YAAhB,IACAyF,MAAM,CAAC9F,IAAP,KAAgB,QADhB,IAEAoF,IAAI,CAACW,SAAL,CAAe7F,MAAf,GAAwB,CAFxB,IAGA,MAAI,CAAC8F,eAAL,CAAqB,QAArB,MAAmC,QAJpC,EAMC;AAED,YAAIC,MAAJ,EAAYC,KAAZ;AACA,YAAMC,IAAI,GAAGf,IAAI,CAACW,SAAL,CAAe,CAAf,CAAb;;AAEA,YAAII,IAAJ,EAAU;AACT,cAAIA,IAAI,CAAC9F,IAAL,KAAc,eAAlB,EAAmC;;AAEnC,cAAM+F,eAAe,GAAG,MAAI,CAACC,kBAAL,CAAwBF,IAAxB,CAAxB;;AAEA,cAAI,CAACC,eAAL,EAAsB;AAEtBH,UAAAA,MAAM,GAAGG,eAAe,CAACE,QAAhB,EAAT;AAEA,cAAI,CAACL,MAAL,EAAa;AACb,SAVD,MAUO;AACN,iBAAO,IAAIlH,wBAAJ,GACL8G,SADK,CACK,IAAI5E,MAAJ,CAAW,EAAX,CADL,EAELsE,QAFK,CAEIH,IAAI,CAACI,KAFT,CAAP;AAGA;;AAED,YAAMe,IAAI,GAAGnB,IAAI,CAACW,SAAL,CAAe,CAAf,CAAb;;AAEA,YAAIQ,IAAJ,EAAU;AACT,cAAIA,IAAI,CAAClG,IAAL,KAAc,eAAlB,EAAmC;;AAEnC,cAAMmG,cAAc,GAAG,MAAI,CAACH,kBAAL,CAAwBE,IAAxB,CAAvB;;AAEA,cAAI,CAACC,cAAL,EAAqB;;AAErB,cAAI,CAACA,cAAc,CAACC,WAAf,EAAL,EAAmC;AAClCP,YAAAA,KAAK,GAAGM,cAAc,CAACF,QAAf,EAAR;AAEA,gBACCJ,KAAK,KAAK1F,SAAV,IACA,CAACzB,wBAAwB,CAAC2H,kBAAzB,CAA4CR,KAA5C,CAFF,EAIC;AACD;AACD;;AAED,eAAO,IAAInH,wBAAJ,GACL8G,SADK,CACKK,KAAK,GAAG,IAAIjF,MAAJ,CAAWgF,MAAX,EAAmBC,KAAnB,CAAH,GAA+B,IAAIjF,MAAJ,CAAWgF,MAAX,CADzC,EAELV,QAFK,CAEIH,IAAI,CAACI,KAFT,CAAP;AAGA,OArDD;AAsDA,WAAKlE,KAAL,CAAWI,QAAX,CACEuD,GADF,CACM,mBADN,EAEEC,GAFF,CAEM,kBAFN,EAE0B,UAAAC,KAAK,EAAI;AACjC,YAAMC,IAAI;AAAG;AAAsCD,QAAAA,KAAnD;;AAEA,YAAMwB,IAAI,GAAG,MAAI,CAACN,kBAAL,CAAwBjB,IAAI,CAACuB,IAA7B,CAAb;;AACA,YAAI,CAACA,IAAL,EAAW;AACX,YAAIC,WAAW,GAAG,KAAlB;AACA;;AACA,YAAIC,YAAJ;;AACA,YAAIzB,IAAI,CAAC0B,QAAL,KAAkB,IAAtB,EAA4B;AAC3B,cAAMC,UAAU,GAAGJ,IAAI,CAACK,MAAL,EAAnB;AACA,cAAID,UAAU,KAAK,KAAnB,EAA0B,OAAOJ,IAAI,CAACpB,QAAL,CAAcH,IAAI,CAACI,KAAnB,CAAP;AAC1BoB,UAAAA,WAAW,GAAGG,UAAU,KAAK,IAA7B;AACAF,UAAAA,YAAY,GAAG,KAAf;AACA,SALD,MAKO,IAAIzB,IAAI,CAAC0B,QAAL,KAAkB,IAAtB,EAA4B;AAClC,cAAMC,WAAU,GAAGJ,IAAI,CAACK,MAAL,EAAnB;;AACA,cAAID,WAAU,KAAK,IAAnB,EAAyB,OAAOJ,IAAI,CAACpB,QAAL,CAAcH,IAAI,CAACI,KAAnB,CAAP;AACzBoB,UAAAA,WAAW,GAAGG,WAAU,KAAK,KAA7B;AACAF,UAAAA,YAAY,GAAG,IAAf;AACA,SALM,MAKA,IAAIzB,IAAI,CAAC0B,QAAL,KAAkB,IAAtB,EAA4B;AAClC,cAAMG,aAAa,GAAGN,IAAI,CAACO,SAAL,EAAtB;AACA,cAAID,aAAa,KAAK,KAAtB,EAA6B,OAAON,IAAI,CAACpB,QAAL,CAAcH,IAAI,CAACI,KAAnB,CAAP;AAC7B,cAAIyB,aAAa,KAAK,IAAtB,EAA4B;AAC5BL,UAAAA,WAAW,GAAG,IAAd;AACA,SALM,MAKA;;AACP,YAAMO,KAAK,GAAG,MAAI,CAACd,kBAAL,CAAwBjB,IAAI,CAAC+B,KAA7B,CAAd;;AACA,YAAI,CAACA,KAAL,EAAY;;AACZ,YAAIP,WAAJ,EAAiB;AAChB,cAAID,IAAI,CAACS,oBAAL,EAAJ,EAAiCD,KAAK,CAACE,cAAN;AACjC,iBAAOF,KAAK,CAAC5B,QAAN,CAAeH,IAAI,CAACI,KAApB,CAAP;AACA;;AAED,YAAMwB,MAAM,GAAGG,KAAK,CAACH,MAAN,EAAf;;AAEA,YAAIH,YAAY,KAAK,IAAjB,IAAyBG,MAAM,KAAK,IAAxC,EAA8C;AAC7C,iBAAO,IAAIjI,wBAAJ,GACLwG,QADK,CACIH,IAAI,CAACI,KADT,EAEL8B,SAFK,EAAP;AAGA,SAJD,MAIO,IAAIT,YAAY,KAAK,KAAjB,IAA0BG,MAAM,KAAK,KAAzC,EAAgD;AACtD,iBAAO,IAAIjI,wBAAJ,GAA+BwG,QAA/B,CAAwCH,IAAI,CAACI,KAA7C,EAAoD+B,QAApD,EAAP;AACA;AACD,OA1CF;;AA4CA,UAAMC,iBAAiB,GAAG,SAApBA,iBAAoB,CAACnC,KAAD,EAAQD,IAAR,EAAcqC,WAAd,EAA8B;AACvD,gBAAQ,OAAOpC,KAAf;AACC,eAAK,SAAL;AACC,mBAAO,IAAItG,wBAAJ,GACL4G,UADK,CACMN,KADN,EAELgC,cAFK,CAEUI,WAFV,EAGLlC,QAHK,CAGIH,IAAI,CAACI,KAHT,CAAP;;AAID,eAAK,QAAL;AACC,mBAAO,IAAIzG,wBAAJ,GACLuG,SADK,CACKD,KADL,EAELgC,cAFK,CAEUI,WAFV,EAGLlC,QAHK,CAGIH,IAAI,CAACI,KAHT,CAAP;;AAID,eAAK,QAAL;AACC,mBAAO,IAAIzG,wBAAJ,GACL0G,SADK,CACKJ,KADL,EAELgC,cAFK,CAEUI,WAFV,EAGLlC,QAHK,CAGIH,IAAI,CAACI,KAHT,CAAP;;AAID,eAAK,QAAL;AACC,mBAAO,IAAIzG,wBAAJ,GACL2G,SADK,CACKL,KADL,EAELgC,cAFK,CAEUI,WAFV,EAGLlC,QAHK,CAGIH,IAAI,CAACI,KAHT,CAAP;AAjBF;AAsBA,OAvBD;;AAyBA,WAAKlE,KAAL,CAAWI,QAAX,CACEuD,GADF,CACM,kBADN,EAEEC,GAFF,CAEM,kBAFN,EAE0B,UAAAC,KAAK,EAAI;AACjC,YAAMC,IAAI;AAAG;AAAqCD,QAAAA,KAAlD;;AAEA,YAAMuC,oBAAoB,GAAG,SAAvBA,oBAAuB,CAAAC,EAAE,EAAI;AAClC,cAAMhB,IAAI,GAAG,MAAI,CAACN,kBAAL,CAAwBjB,IAAI,CAACuB,IAA7B,CAAb;;AACA,cAAI,CAACA,IAAD,IAAS,CAACA,IAAI,CAACiB,kBAAL,EAAd,EAAyC;;AAEzC,cAAMT,KAAK,GAAG,MAAI,CAACd,kBAAL,CAAwBjB,IAAI,CAAC+B,KAA7B,CAAd;;AACA,cAAI,CAACA,KAAD,IAAU,CAACA,KAAK,CAACS,kBAAN,EAAf,EAA2C;AAE3C,cAAMC,MAAM,GAAGF,EAAE,CAChBhB,IAAI,CAACmB,kBAAL,EADgB,EAEhBX,KAAK,CAACW,kBAAN,EAFgB,CAAjB;AAIA,iBAAON,iBAAiB,CACvBK,MADuB,EAEvBzC,IAFuB,EAGvBuB,IAAI,CAACS,oBAAL,MAA+BD,KAAK,CAACC,oBAAN,EAHR,CAAxB;AAKA,SAhBD;;AAkBA,YAAMW,iBAAiB,GAAG,SAApBA,iBAAoB,CAACC,CAAD,EAAIC,CAAJ;AAAA,iBACxBD,CAAC,KAAK,IAAN,IAAcC,CAAC,KAAK,KAArB,IAAgCD,CAAC,KAAK,KAAN,IAAeC,CAAC,KAAK,IAD5B;AAAA,SAA1B;;AAGA,YAAMC,2BAA2B,GAAG,SAA9BA,2BAA8B,CAACvB,IAAD,EAAOQ,KAAP,EAAcgB,GAAd,EAAmBC,GAAnB,EAA2B;AAC9D,cAAMC,SAAS,GAAG,SAAZA,SAAY,CAAAC,KAAK,EAAI;AAC1B,gBAAIjD,KAAK,GAAG,EAAZ;;AAD0B,uDAEViD,KAFU;AAAA;;AAAA;AAE1B,kEAAuB;AAAA,oBAAZC,CAAY;AACtB,oBAAMC,CAAC,GAAGD,CAAC,CAACjC,QAAF,EAAV;AACA,oBAAIkC,CAAC,KAAKhI,SAAV,EAAqB6E,KAAK,IAAImD,CAAT,CAArB,KACK;AACL;AANyB;AAAA;AAAA;AAAA;AAAA;;AAO1B,mBAAOnD,KAAP;AACA,WARD;;AASA,cAAMoD,SAAS,GAAG,SAAZA,SAAY,CAAAH,KAAK,EAAI;AAC1B,gBAAIjD,KAAK,GAAG,EAAZ;;AACA,iBAAK,IAAIpF,CAAC,GAAGqI,KAAK,CAACpI,MAAN,GAAe,CAA5B,EAA+BD,CAAC,IAAI,CAApC,EAAuCA,CAAC,EAAxC,EAA4C;AAC3C,kBAAMuI,CAAC,GAAGF,KAAK,CAACrI,CAAD,CAAL,CAASqG,QAAT,EAAV;AACA,kBAAIkC,CAAC,KAAKhI,SAAV,EAAqB6E,KAAK,GAAGmD,CAAC,GAAGnD,KAAZ,CAArB,KACK;AACL;;AACD,mBAAOA,KAAP;AACA,WARD;;AASA,cAAMqD,UAAU,GAAGL,SAAS,CAAC1B,IAAI,CAAC2B,KAAN,CAA5B;AACA,cAAMK,WAAW,GAAGN,SAAS,CAAClB,KAAK,CAACmB,KAAP,CAA7B;AACA,cAAMM,UAAU,GAAGH,SAAS,CAAC9B,IAAI,CAAC2B,KAAN,CAA5B;AACA,cAAMO,WAAW,GAAGJ,SAAS,CAACtB,KAAK,CAACmB,KAAP,CAA7B;AACA,cAAMQ,SAAS,GAAGC,IAAI,CAACC,GAAL,CAASN,UAAU,CAACxI,MAApB,EAA4ByI,WAAW,CAACzI,MAAxC,CAAlB;AACA,cAAM+I,SAAS,GAAGF,IAAI,CAACC,GAAL,CAASJ,UAAU,CAAC1I,MAApB,EAA4B2I,WAAW,CAAC3I,MAAxC,CAAlB;;AACA,cACCwI,UAAU,CAACQ,KAAX,CAAiB,CAAjB,EAAoBJ,SAApB,MACCH,WAAW,CAACO,KAAZ,CAAkB,CAAlB,EAAqBJ,SAArB,CADD,IAEAF,UAAU,CAACM,KAAX,CAAiB,CAACD,SAAlB,MAAiCJ,WAAW,CAACK,KAAZ,CAAkB,CAACD,SAAnB,CAHlC,EAIE;AACD,mBAAOd,GAAG,CACRxC,UADK,CACM,CAACyC,GADP,EAELf,cAFK,CAGLV,IAAI,CAACS,oBAAL,MAA+BD,KAAK,CAACC,oBAAN,EAH1B,CAAP;AAKA;AACD,SApCD;;AAsCA,YAAM+B,8BAA8B,GAAG,SAAjCA,8BAAiC,CAAAf,GAAG,EAAI;AAC7C,cAAMzB,IAAI,GAAG,MAAI,CAACN,kBAAL,CAAwBjB,IAAI,CAACuB,IAA7B,CAAb;;AACA,cAAI,CAACA,IAAL,EAAW;;AACX,cAAMQ,KAAK,GAAG,MAAI,CAACd,kBAAL,CAAwBjB,IAAI,CAAC+B,KAA7B,CAAd;;AACA,cAAI,CAACA,KAAL,EAAY;AACZ,cAAMgB,GAAG,GAAG,IAAIpJ,wBAAJ,EAAZ;AACAoJ,UAAAA,GAAG,CAAC5C,QAAJ,CAAaH,IAAI,CAACI,KAAlB;AAEA,cAAM4D,SAAS,GAAGzC,IAAI,CAACiB,kBAAL,EAAlB;AACA,cAAMyB,UAAU,GAAGlC,KAAK,CAACS,kBAAN,EAAnB;;AAEA,cAAIwB,SAAS,IAAIC,UAAjB,EAA6B;AAC5B,mBAAOlB,GAAG,CACRxC,UADK,CAELyC,GAAG,MACDzB,IAAI,CAACmB,kBAAL,OAA8BX,KAAK,CAACW,kBAAN,EAD7B,CAFE,EAKLT,cALK,CAMLV,IAAI,CAACS,oBAAL,MAA+BD,KAAK,CAACC,oBAAN,EAN1B,CAAP;AAQA;;AAED,cAAIT,IAAI,CAAC2C,OAAL,MAAkBnC,KAAK,CAACmC,OAAN,EAAtB,EAAuC;AACtC,mBAAOnB,GAAG,CACRxC,UADK,CACM,CAACyC,GADP,EAELf,cAFK,CAGLV,IAAI,CAACS,oBAAL,MAA+BD,KAAK,CAACC,oBAAN,EAH1B,CAAP;AAKA;;AACD,cAAIT,IAAI,CAAC4C,gBAAL,MAA2BpC,KAAK,CAACoC,gBAAN,EAA/B,EAAyD;AACxD,mBAAOrB,2BAA2B,CAACvB,IAAD,EAAOQ,KAAP,EAAcgB,GAAd,EAAmBC,GAAnB,CAAlC;AACA;;AAED,cAAMoB,aAAa,GAAG7C,IAAI,CAAC8C,eAAL,EAAtB;AACA,cAAMC,cAAc,GAAGvC,KAAK,CAACsC,eAAN,EAAvB;;AAEA,eACC;AACA;AACCD,UAAAA,aAAa,KAAK,KAAlB,KACCJ,SAAS,IAAIM,cAAc,KAAK,IADjC,CAAD,IAECA,cAAc,KAAK,KAAnB,KACCL,UAAU,IAAIG,aAAa,KAAK,IADjC,CAFD,IAIA;AACAzB,UAAAA,iBAAiB,CAACpB,IAAI,CAACK,MAAL,EAAD,EAAgBG,KAAK,CAACH,MAAN,EAAhB,CALjB,IAMAe,iBAAiB,CAACpB,IAAI,CAACO,SAAL,EAAD,EAAmBC,KAAK,CAACD,SAAN,EAAnB,CATlB,EAUE;AACD,mBAAOiB,GAAG,CACRxC,UADK,CACM,CAACyC,GADP,EAELf,cAFK,CAGLV,IAAI,CAACS,oBAAL,MAA+BD,KAAK,CAACC,oBAAN,EAH1B,CAAP;AAKA;AACD,SArDD;;AAuDA,YAAMuC,gCAAgC,GAAG,SAAnCA,gCAAmC,CAAAvB,GAAG,EAAI;AAC/C,cAAMzB,IAAI,GAAG,MAAI,CAACN,kBAAL,CAAwBjB,IAAI,CAACuB,IAA7B,CAAb;;AACA,cAAI,CAACA,IAAL,EAAW;;AACX,cAAMQ,KAAK,GAAG,MAAI,CAACd,kBAAL,CAAwBjB,IAAI,CAAC+B,KAA7B,CAAd;;AACA,cAAI,CAACA,KAAL,EAAY;AACZ,cAAMgB,GAAG,GAAG,IAAIpJ,wBAAJ,EAAZ;AACAoJ,UAAAA,GAAG,CAAC5C,QAAJ,CAAaH,IAAI,CAACI,KAAlB;AAEA,cAAM4D,SAAS,GAAGzC,IAAI,CAACiB,kBAAL,EAAlB;AACA,cAAMyB,UAAU,GAAGlC,KAAK,CAACS,kBAAN,EAAnB;;AAEA,cAAIwB,SAAS,IAAIC,UAAjB,EAA6B;AAC5B,mBAAOlB,GAAG,CACRxC,UADK,CAELyC,GAAG,OACF;AACCzB,YAAAA,IAAI,CAACmB,kBAAL,MAA6BX,KAAK,CAACW,kBAAN,EAF5B,CAFE,EAMLT,cANK,CAOLV,IAAI,CAACS,oBAAL,MAA+BD,KAAK,CAACC,oBAAN,EAP1B,CAAP;AASA;;AAED,cAAIT,IAAI,CAAC2C,OAAL,MAAkBnC,KAAK,CAACmC,OAAN,EAAtB,EAAuC;AACtC,mBAAOnB,GAAG,CACRxC,UADK,CACM,CAACyC,GADP,EAELf,cAFK,CAGLV,IAAI,CAACS,oBAAL,MAA+BD,KAAK,CAACC,oBAAN,EAH1B,CAAP;AAKA;;AACD,cAAIT,IAAI,CAAC4C,gBAAL,MAA2BpC,KAAK,CAACoC,gBAAN,EAA/B,EAAyD;AACxD,mBAAOrB,2BAA2B,CAACvB,IAAD,EAAOQ,KAAP,EAAcgB,GAAd,EAAmBC,GAAnB,CAAlC;AACA;AACD,SAjCD;;AAmCA,YAAIhD,IAAI,CAAC0B,QAAL,KAAkB,GAAtB,EAA2B;AAC1B,cAAMH,IAAI,GAAG,MAAI,CAACN,kBAAL,CAAwBjB,IAAI,CAACuB,IAA7B,CAAb;;AACA,cAAI,CAACA,IAAL,EAAW;;AACX,cAAMQ,KAAK,GAAG,MAAI,CAACd,kBAAL,CAAwBjB,IAAI,CAAC+B,KAA7B,CAAd;;AACA,cAAI,CAACA,KAAL,EAAY;AACZ,cAAMgB,GAAG,GAAG,IAAIpJ,wBAAJ,EAAZ;;AACA,cAAI4H,IAAI,CAACiD,QAAL,EAAJ,EAAqB;AACpB,gBAAIzC,KAAK,CAACyC,QAAN,EAAJ,EAAsB;AACrBzB,cAAAA,GAAG,CAACzC,SAAJ,CAAciB,IAAI,CAACkD,MAAL,GAAc1C,KAAK,CAAC0C,MAAlC;AACA,aAFD,MAEO,IAAI1C,KAAK,CAAC2C,QAAN,EAAJ,EAAsB;AAC5B3B,cAAAA,GAAG,CAACzC,SAAJ,CAAciB,IAAI,CAACkD,MAAL,GAAc1C,KAAK,CAAC4C,MAAlC;AACA,aAFM,MAEA,IACN5C,KAAK,CAAC6C,SAAN,MACA7C,KAAK,CAAC8C,MADN,IAEA9C,KAAK,CAAC8C,MAAN,CAAaL,QAAb,EAHM,EAIL;AACD;AACA;AACAzB,cAAAA,GAAG,CAAC+B,UAAJ,CACC,IAAInL,wBAAJ,GACE2G,SADF,CACYiB,IAAI,CAACkD,MAAL,GAAc1C,KAAK,CAAC8C,MAAN,CAAaJ,MADvC,EAEEtE,QAFF,CAEW7F,UAAU,CAACiH,IAAI,CAACnB,KAAN,EAAa2B,KAAK,CAAC8C,MAAN,CAAazE,KAA1B,CAFrB,CADD,EAIC2B,KAAK,CAACgD,OAJP,EAKChD,KAAK,CAACiD,uBALP;AAOA,aAdM,MAcA,IAAIjD,KAAK,CAAC6C,SAAN,EAAJ,EAAuB;AAC7B;AACA;AACA7B,cAAAA,GAAG,CAAC+B,UAAJ,CACCvD,IADD,EAECQ,KAAK,CAACgD,OAFP,EAGChD,KAAK,CAACiD,uBAHP;AAKA,aARM,MAQA;AACN;AACA;AACAjC,cAAAA,GAAG,CAAC+B,UAAJ,CAAevD,IAAf,EAAqB,IAArB,EAA2B,CAACQ,KAAD,CAA3B;AACA;AACD,WAhCD,MAgCO,IAAIR,IAAI,CAACmD,QAAL,EAAJ,EAAqB;AAC3B,gBAAI3C,KAAK,CAACyC,QAAN,EAAJ,EAAsB;AACrBzB,cAAAA,GAAG,CAACzC,SAAJ,CAAciB,IAAI,CAACoD,MAAL,GAAc5C,KAAK,CAAC0C,MAAlC;AACA,aAFD,MAEO,IAAI1C,KAAK,CAAC2C,QAAN,EAAJ,EAAsB;AAC5B3B,cAAAA,GAAG,CAAC7C,SAAJ,CAAcqB,IAAI,CAACoD,MAAL,GAAc5C,KAAK,CAAC4C,MAAlC;AACA,aAFM,MAEA;AACN;AACA;AACD,WARM,MAQA,IAAIpD,IAAI,CAAC0D,QAAL,EAAJ,EAAqB;AAC3B,gBAAIlD,KAAK,CAACkD,QAAN,EAAJ,EAAsB;AACrBlC,cAAAA,GAAG,CAAC1C,SAAJ,CAAckB,IAAI,CAAC2D,MAAL,GAAcnD,KAAK,CAACmD,MAAlC;AACA;AACD,WAJM,MAIA,IAAI3D,IAAI,CAACqD,SAAL,EAAJ,EAAsB;AAC5B,gBAAIrD,IAAI,CAACwD,OAAL,IAAgBxD,IAAI,CAACwD,OAAL,CAAaP,QAAb,EAAhB,IAA2CzC,KAAK,CAACyC,QAAN,EAA/C,EAAiE;AAChE;AACA;AACAzB,cAAAA,GAAG,CAAC+B,UAAJ,CACCvD,IAAI,CAACsD,MADN,EAEC,IAAIlL,wBAAJ,GACE2G,SADF,CACYiB,IAAI,CAACwD,OAAL,CAAaN,MAAb,GAAsB1C,KAAK,CAAC0C,MADxC,EAEEtE,QAFF,CAEW7F,UAAU,CAACiH,IAAI,CAACwD,OAAL,CAAa3E,KAAd,EAAqB2B,KAAK,CAAC3B,KAA3B,CAFrB,CAFD,EAKCmB,IAAI,CAACyD,uBALN;AAOA,aAVD,MAUO,IACNzD,IAAI,CAACwD,OAAL,IACAxD,IAAI,CAACwD,OAAL,CAAaP,QAAb,EADA,IAEAzC,KAAK,CAAC2C,QAAN,EAHM,EAIL;AACD;AACA;AACA3B,cAAAA,GAAG,CAAC+B,UAAJ,CACCvD,IAAI,CAACsD,MADN,EAEC,IAAIlL,wBAAJ,GACE2G,SADF,CACYiB,IAAI,CAACwD,OAAL,CAAaN,MAAb,GAAsB1C,KAAK,CAAC4C,MADxC,EAEExE,QAFF,CAEW7F,UAAU,CAACiH,IAAI,CAACwD,OAAL,CAAa3E,KAAd,EAAqB2B,KAAK,CAAC3B,KAA3B,CAFrB,CAFD,EAKCmB,IAAI,CAACyD,uBALN;AAOA,aAdM,MAcA,IAAIjD,KAAK,CAACyC,QAAN,EAAJ,EAAsB;AAC5B;AACA;AACAzB,cAAAA,GAAG,CAAC+B,UAAJ,CAAevD,IAAI,CAACsD,MAApB,EAA4B9C,KAA5B,EAAmCR,IAAI,CAACyD,uBAAxC;AACA,aAJM,MAIA,IAAIjD,KAAK,CAAC2C,QAAN,EAAJ,EAAsB;AAC5B;AACA;AACA3B,cAAAA,GAAG,CAAC+B,UAAJ,CACCvD,IAAI,CAACsD,MADN,EAEC,IAAIlL,wBAAJ,GACE2G,SADF,CACYyB,KAAK,CAAC4C,MAAN,GAAe,EAD3B,EAEExE,QAFF,CAEW4B,KAAK,CAAC3B,KAFjB,CAFD,EAKCmB,IAAI,CAACyD,uBALN;AAOA,aAVM,MAUA,IAAIjD,KAAK,CAAC6C,SAAN,EAAJ,EAAuB;AAC7B;AACA;AACA7B,cAAAA,GAAG,CAAC+B,UAAJ,CACCvD,IAAI,CAACsD,MADN,EAEC9C,KAAK,CAACgD,OAFP,EAGCxD,IAAI,CAACyD,uBAAL,IACCjD,KAAK,CAACiD,uBADP,IAECzD,IAAI,CAACyD,uBAAL,CACEG,MADF,CACS5D,IAAI,CAACwD,OAAL,GAAe,CAACxD,IAAI,CAACwD,OAAN,CAAf,GAAgC,EADzC,EAEEI,MAFF,CAESpD,KAAK,CAAC8C,MAAN,GAAe,CAAC9C,KAAK,CAAC8C,MAAP,CAAf,GAAgC,EAFzC,EAGEM,MAHF,CAGSpD,KAAK,CAACiD,uBAHf,CALF;AAUA,aAbM,MAaA;AACN;AACA;AACAjC,cAAAA,GAAG,CAAC+B,UAAJ,CACCvD,IAAI,CAACsD,MADN,EAEC,IAFD,EAGCtD,IAAI,CAACyD,uBAAL,IACCzD,IAAI,CAACyD,uBAAL,CAA6BG,MAA7B,CACC5D,IAAI,CAACwD,OAAL,GAAe,CAACxD,IAAI,CAACwD,OAAN,EAAehD,KAAf,CAAf,GAAuC,CAACA,KAAD,CADxC,CAJF;AAQA;AACD,WAhEM,MAgEA;AACN,gBAAIA,KAAK,CAACyC,QAAN,EAAJ,EAAsB;AACrB;AACA;AACAzB,cAAAA,GAAG,CAAC+B,UAAJ,CAAe,IAAf,EAAqB/C,KAArB,EAA4B,CAACR,IAAD,CAA5B;AACA,aAJD,MAIO,IAAIQ,KAAK,CAAC6C,SAAN,EAAJ,EAAuB;AAC7B;AACA;AACA7B,cAAAA,GAAG,CAAC+B,UAAJ,CACC,IADD,EAEC/C,KAAK,CAACgD,OAFP,EAGChD,KAAK,CAACiD,uBAAN,IACC,CAACjD,KAAK,CAAC8C,MAAN,GAAe,CAACtD,IAAD,EAAOQ,KAAK,CAAC8C,MAAb,CAAf,GAAsC,CAACtD,IAAD,CAAvC,EAA+C4D,MAA/C,CACCpD,KAAK,CAACiD,uBADP,CAJF;AAQA,aAXM,MAWA;AACN;AACA;AACD;;AACD,cAAIzD,IAAI,CAACS,oBAAL,MAA+BD,KAAK,CAACC,oBAAN,EAAnC,EACCe,GAAG,CAACd,cAAJ;AACDc,UAAAA,GAAG,CAAC5C,QAAJ,CAAaH,IAAI,CAACI,KAAlB;AACA,iBAAO2C,GAAP;AACA,SA1ID,MA0IO,IAAI/C,IAAI,CAAC0B,QAAL,KAAkB,GAAtB,EAA2B;AACjC,iBAAOY,oBAAoB,CAAC,UAAC8C,CAAD,EAAIC,CAAJ;AAAA,mBAAUD,CAAC,GAAGC,CAAd;AAAA,WAAD,CAA3B;AACA,SAFM,MAEA,IAAIrF,IAAI,CAAC0B,QAAL,KAAkB,GAAtB,EAA2B;AACjC,iBAAOY,oBAAoB,CAAC,UAAC8C,CAAD,EAAIC,CAAJ;AAAA,mBAAUD,CAAC,GAAGC,CAAd;AAAA,WAAD,CAA3B;AACA,SAFM,MAEA,IAAIrF,IAAI,CAAC0B,QAAL,KAAkB,GAAtB,EAA2B;AACjC,iBAAOY,oBAAoB,CAAC,UAAC8C,CAAD,EAAIC,CAAJ;AAAA,mBAAUD,CAAC,GAAGC,CAAd;AAAA,WAAD,CAA3B;AACA,SAFM,MAEA,IAAIrF,IAAI,CAAC0B,QAAL,KAAkB,IAAtB,EAA4B;AAClC,iBAAOY,oBAAoB,CAAC,UAAC8C,CAAD,EAAIC,CAAJ;AAAA,4BAAUD,CAAV,EAAeC,CAAf;AAAA,WAAD,CAA3B;AACA,SAFM,MAEA,IAAIrF,IAAI,CAAC0B,QAAL,KAAkB,KAAtB,EAA6B;AACnC,iBAAOqC,8BAA8B,CAAC,IAAD,CAArC;AACA,SAFM,MAEA,IAAI/D,IAAI,CAAC0B,QAAL,KAAkB,IAAtB,EAA4B;AAClC,iBAAO6C,gCAAgC,CAAC,IAAD,CAAvC;AACA,SAFM,MAEA,IAAIvE,IAAI,CAAC0B,QAAL,KAAkB,KAAtB,EAA6B;AACnC,iBAAOqC,8BAA8B,CAAC,KAAD,CAArC;AACA,SAFM,MAEA,IAAI/D,IAAI,CAAC0B,QAAL,KAAkB,IAAtB,EAA4B;AAClC,iBAAO6C,gCAAgC,CAAC,KAAD,CAAvC;AACA,SAFM,MAEA,IAAIvE,IAAI,CAAC0B,QAAL,KAAkB,GAAtB,EAA2B;AACjC,iBAAOY,oBAAoB,CAAC,UAAC8C,CAAD,EAAIC,CAAJ;AAAA,mBAAUD,CAAC,GAAGC,CAAd;AAAA,WAAD,CAA3B;AACA,SAFM,MAEA,IAAIrF,IAAI,CAAC0B,QAAL,KAAkB,GAAtB,EAA2B;AACjC,iBAAOY,oBAAoB,CAAC,UAAC8C,CAAD,EAAIC,CAAJ;AAAA,mBAAUD,CAAC,GAAGC,CAAd;AAAA,WAAD,CAA3B;AACA,SAFM,MAEA,IAAIrF,IAAI,CAAC0B,QAAL,KAAkB,GAAtB,EAA2B;AACjC,iBAAOY,oBAAoB,CAAC,UAAC8C,CAAD,EAAIC,CAAJ;AAAA,mBAAUD,CAAC,GAAGC,CAAd;AAAA,WAAD,CAA3B;AACA,SAFM,MAEA,IAAIrF,IAAI,CAAC0B,QAAL,KAAkB,KAAtB,EAA6B;AACnC,iBAAOY,oBAAoB,CAAC,UAAC8C,CAAD,EAAIC,CAAJ;AAAA,mBAAUD,CAAC,KAAKC,CAAhB;AAAA,WAAD,CAA3B;AACA,SAFM,MAEA,IAAIrF,IAAI,CAAC0B,QAAL,KAAkB,IAAtB,EAA4B;AAClC,iBAAOY,oBAAoB,CAAC,UAAC8C,CAAD,EAAIC,CAAJ;AAAA,mBAAUD,CAAC,IAAIC,CAAf;AAAA,WAAD,CAA3B;AACA,SAFM,MAEA,IAAIrF,IAAI,CAAC0B,QAAL,KAAkB,IAAtB,EAA4B;AAClC,iBAAOY,oBAAoB,CAAC,UAAC8C,CAAD,EAAIC,CAAJ;AAAA,mBAAUD,CAAC,IAAIC,CAAf;AAAA,WAAD,CAA3B;AACA,SAFM,MAEA,IAAIrF,IAAI,CAAC0B,QAAL,KAAkB,GAAtB,EAA2B;AACjC,iBAAOY,oBAAoB,CAAC,UAAC8C,CAAD,EAAIC,CAAJ;AAAA,mBAAUD,CAAC,GAAGC,CAAd;AAAA,WAAD,CAA3B;AACA,SAFM,MAEA,IAAIrF,IAAI,CAAC0B,QAAL,KAAkB,GAAtB,EAA2B;AACjC,iBAAOY,oBAAoB,CAAC,UAAC8C,CAAD,EAAIC,CAAJ;AAAA,mBAAUD,CAAC,GAAGC,CAAd;AAAA,WAAD,CAA3B;AACA,SAFM,MAEA,IAAIrF,IAAI,CAAC0B,QAAL,KAAkB,IAAtB,EAA4B;AAClC,iBAAOY,oBAAoB,CAAC,UAAC8C,CAAD,EAAIC,CAAJ;AAAA,mBAAUD,CAAC,IAAIC,CAAf;AAAA,WAAD,CAA3B;AACA,SAFM,MAEA,IAAIrF,IAAI,CAAC0B,QAAL,KAAkB,IAAtB,EAA4B;AAClC,iBAAOY,oBAAoB,CAAC,UAAC8C,CAAD,EAAIC,CAAJ;AAAA,mBAAUD,CAAC,IAAIC,CAAf;AAAA,WAAD,CAA3B;AACA;AACD,OAzUF;AA0UA,WAAKnJ,KAAL,CAAWI,QAAX,CACEuD,GADF,CACM,iBADN,EAEEC,GAFF,CAEM,kBAFN,EAE0B,UAAAC,KAAK,EAAI;AACjC,YAAMC,IAAI;AAAG;AAAoCD,QAAAA,KAAjD;;AAEA,YAAMuC,oBAAoB,GAAG,SAAvBA,oBAAuB,CAAAC,EAAE,EAAI;AAClC,cAAM+C,QAAQ,GAAG,MAAI,CAACrE,kBAAL,CAAwBjB,IAAI,CAACsF,QAA7B,CAAjB;;AACA,cAAI,CAACA,QAAD,IAAa,CAACA,QAAQ,CAAC9C,kBAAT,EAAlB,EAAiD;AACjD,cAAMC,MAAM,GAAGF,EAAE,CAAC+C,QAAQ,CAAC5C,kBAAT,EAAD,CAAjB;AACA,iBAAON,iBAAiB,CACvBK,MADuB,EAEvBzC,IAFuB,EAGvBsF,QAAQ,CAACtD,oBAAT,EAHuB,CAAxB;AAKA,SATD;;AAWA,YAAIhC,IAAI,CAAC0B,QAAL,KAAkB,QAAtB,EAAgC;AAC/B,kBAAQ1B,IAAI,CAACsF,QAAL,CAAcrK,IAAtB;AACC,iBAAK,YAAL;AAAmB;AAClB,oBAAM8H,GAAG,GAAG,MAAI,CAACwC,gBAAL,CACX,MAAI,CAACrJ,KAAL,CAAWG,cADA,EAEX2D,IAAI,CAACsF,QAAL,CAAc1K,IAFH,EAGXoF,IAHW,CAAZ;;AAKA,oBAAI+C,GAAG,KAAK3H,SAAZ,EAAuB,OAAO2H,GAAP;AACvB;AACA;;AACD,iBAAK,cAAL;AAAqB;AACpB,oBAAMA,IAAG,GAAG,MAAI,CAACwC,gBAAL,CACX,MAAI,CAACrJ,KAAL,CAAWG,cADA,EAEXtB,WAAW,CAACiF,IAAI,CAACsF,QAAN,CAFA,EAGXtF,IAHW,CAAZ;;AAKA,oBAAI+C,IAAG,KAAK3H,SAAZ,EAAuB,OAAO2H,IAAP;AACvB;AACA;;AACD,iBAAK,kBAAL;AAAyB;AACxB,oBAAMA,KAAG,GAAG,MAAI,CAACyC,sBAAL,CACX,MAAI,CAACtJ,KAAL,CAAWG,cADA,EAEX2D,IAAI,CAACsF,QAFM,EAGXtF,IAHW,CAAZ;;AAKA,oBAAI+C,KAAG,KAAK3H,SAAZ,EAAuB,OAAO2H,KAAP;AACvB;AACA;;AACD,iBAAK,iBAAL;AAAwB;AACvB,oBAAMA,KAAG,GAAG,MAAI,CAACyC,sBAAL,CACX,MAAI,CAACtJ,KAAL,CAAWG,cADA,EAEX2D,IAAI,CAACsF,QAAL,CAActK,UAFH,EAGXgF,IAHW,CAAZ;;AAKA,oBAAI+C,KAAG,KAAK3H,SAAZ,EAAuB,OAAO2H,KAAP;AACvB;AACA;;AACD,iBAAK,oBAAL;AAA2B;AAC1B,uBAAO,IAAIpJ,wBAAJ,GACL2G,SADK,CACK,UADL,EAELH,QAFK,CAEIH,IAAI,CAACI,KAFT,CAAP;AAGA;AAzCF;;AA2CA,cAAMqF,GAAG,GAAG,MAAI,CAACxE,kBAAL,CAAwBjB,IAAI,CAACsF,QAA7B,CAAZ;;AACA,cAAIG,GAAG,CAACC,SAAJ,EAAJ,EAAqB;;AACrB,cAAID,GAAG,CAACjB,QAAJ,EAAJ,EAAoB;AACnB,mBAAO,IAAI7K,wBAAJ,GACL2G,SADK,CACK,QADL,EAELH,QAFK,CAEIH,IAAI,CAACI,KAFT,CAAP;AAGA;;AACD,cAAIqF,GAAG,CAACb,SAAJ,EAAJ,EAAqB;AACpB,mBAAO,IAAIjL,wBAAJ,GACL2G,SADK,CACK,QADL,EAEL2B,cAFK,GAGL9B,QAHK,CAGIH,IAAI,CAACI,KAHT,CAAP;AAIA;;AACD,cAAIqF,GAAG,CAACpE,WAAJ,EAAJ,EAAuB;AACtB,mBAAO,IAAI1H,wBAAJ,GACL2G,SADK,CACK,WADL,EAELH,QAFK,CAEIH,IAAI,CAACI,KAFT,CAAP;AAGA;;AACD,cAAIqF,GAAG,CAACf,QAAJ,EAAJ,EAAoB;AACnB,mBAAO,IAAI/K,wBAAJ,GACL2G,SADK,CACK,QADL,EAELH,QAFK,CAEIH,IAAI,CAACI,KAFT,CAAP;AAGA;;AACD,cAAIqF,GAAG,CAACR,QAAJ,EAAJ,EAAoB;AACnB,mBAAO,IAAItL,wBAAJ,GACL2G,SADK,CACK,QADL,EAELH,QAFK,CAEIH,IAAI,CAACI,KAFT,CAAP;AAGA;;AACD,cAAIqF,GAAG,CAACE,SAAJ,EAAJ,EAAqB;AACpB,mBAAO,IAAIhM,wBAAJ,GACL2G,SADK,CACK,SADL,EAELH,QAFK,CAEIH,IAAI,CAACI,KAFT,CAAP;AAGA;;AACD,cAAIqF,GAAG,CAACG,YAAJ,MAAsBH,GAAG,CAACI,QAAJ,EAAtB,IAAwCJ,GAAG,CAACK,MAAJ,EAA5C,EAA0D;AACzD,mBAAO,IAAInM,wBAAJ,GACL2G,SADK,CACK,QADL,EAELH,QAFK,CAEIH,IAAI,CAACI,KAFT,CAAP;AAGA;;AACD,cAAIqF,GAAG,CAACvB,OAAJ,EAAJ,EAAmB;AAClB,mBAAO,IAAIvK,wBAAJ,GACL2G,SADK,CACK,QADL,EAEL2B,cAFK,CAEUwD,GAAG,CAACzD,oBAAJ,EAFV,EAGL7B,QAHK,CAGIH,IAAI,CAACI,KAHT,CAAP;AAIA;AACD,SAxFD,MAwFO,IAAIJ,IAAI,CAAC0B,QAAL,KAAkB,GAAtB,EAA2B;AACjC,cAAM4D,QAAQ,GAAG,MAAI,CAACrE,kBAAL,CAAwBjB,IAAI,CAACsF,QAA7B,CAAjB;;AACA,cAAI,CAACA,QAAL,EAAe;AACf,cAAMS,IAAI,GAAGT,QAAQ,CAAC1D,MAAT,EAAb;AACA,cAAI,OAAOmE,IAAP,KAAgB,SAApB,EAA+B;AAC/B,iBAAO,IAAIpM,wBAAJ,GACL4G,UADK,CACM,CAACwF,IADP,EAEL9D,cAFK,CAEUqD,QAAQ,CAACtD,oBAAT,EAFV,EAGL7B,QAHK,CAGIH,IAAI,CAACI,KAHT,CAAP;AAIA,SATM,MASA,IAAIJ,IAAI,CAAC0B,QAAL,KAAkB,GAAtB,EAA2B;AACjC,iBAAOY,oBAAoB,CAAC,UAAAc,CAAC;AAAA,mBAAI,CAACA,CAAL;AAAA,WAAF,CAA3B;AACA,SAFM,MAEA,IAAIpD,IAAI,CAAC0B,QAAL,KAAkB,GAAtB,EAA2B;AACjC,iBAAOY,oBAAoB,CAAC,UAAAc,CAAC;AAAA,mBAAI,CAACA,CAAL;AAAA,WAAF,CAA3B;AACA,SAFM,MAEA,IAAIpD,IAAI,CAAC0B,QAAL,KAAkB,GAAtB,EAA2B;AACjC,iBAAOY,oBAAoB,CAAC,UAAAc,CAAC;AAAA,mBAAI,CAACA,CAAL;AAAA,WAAF,CAA3B;AACA;AACD,OAxHF;AAyHA,WAAKlH,KAAL,CAAWG,cAAX,CAA0BwD,GAA1B,CAA8B,WAA9B,EAA2CC,GAA3C,CAA+C,kBAA/C,EAAmE,UAAAE,IAAI,EAAI;AAC1E,eAAO,IAAIrG,wBAAJ,GACL2G,SADK,CACK,WADL,EAELH,QAFK,CAEIH,IAAI,CAACI,KAFT,CAAP;AAGA,OAJD;AAKA,WAAKlE,KAAL,CAAWI,QAAX,CAAoBuD,GAApB,CAAwB,YAAxB,EAAsCC,GAAtC,CAA0C,kBAA1C,EAA8D,UAAAE,IAAI,EAAI;AACrE;AAAI;AAA+BA,QAAAA,IAAD,CAAOpF,IAAP,KAAgB,WAAlD,EAA+D;AAC9D,iBAAO,IAAIjB,wBAAJ,GACLqM,YADK,GAEL7F,QAFK,CAEIH,IAAI,CAACI,KAFT,CAAP;AAGA;AACD,OAND;AAOA;AACF;AACA;AACA;AACA;;AACE,UAAM6F,2BAA2B,GAAG,SAA9BA,2BAA8B,CAACC,QAAD,EAAWC,OAAX,EAAuB;AAC1D;AACA,YAAIC,gBAAgB,GAAGhL,SAAvB;AACA;;AACA,YAAIiL,UAAU,GAAGjL,SAAjB;;AACA,QAAA,MAAI,CAACc,KAAL,CAAWI,QAAX,CAAoBuD,GAApB,CAAwBqG,QAAxB,EAAkCpG,GAAlC,CAAsC,kBAAtC,EAA0D,UAAAE,IAAI,EAAI;AACjE,cAAMhF,UAAU;AAAG;AAAqCgF,UAAAA,IAAxD;AAEA,cAAMsG,IAAI,GAAGH,OAAO,CAACnG,IAAD,CAApB;;AACA,cAAIsG,IAAI,KAAKlL,SAAb,EAAwB;AACvB,mBAAO,MAAI,CAACmL,4BAAL,CACN,MAAI,CAACrK,KAAL,CAAWK,kBADL,EAEN+J,IAAI,CAAC1L,IAFC,EAGN,UAAAA,IAAI,EAAI;AACPwL,cAAAA,gBAAgB,GAAGpL,UAAnB;AACAqL,cAAAA,UAAU,GAAGC,IAAb;AACA,aANK,EAON,UAAA1L,IAAI,EAAI;AACP,kBAAM4L,IAAI,GAAG,MAAI,CAACtK,KAAL,CAAWM,yBAAX,CAAqCiK,GAArC,CAAyC7L,IAAzC,CAAb;;AACA,kBAAI4L,IAAI,KAAKpL,SAAb,EAAwB;AACvB,uBAAOoL,IAAI,CAAC/H,IAAL,CAAUzD,UAAV,CAAP;AACA;AACD,aAZK,EAaNA,UAbM,CAAP;AAeA;AACD,SArBD;;AAsBA,QAAA,MAAI,CAACkB,KAAL,CAAWI,QAAX,CACEuD,GADF,CACMqG,QADN,EAEEpG,GAFF,CAEM;AAAElF,UAAAA,IAAI,EAAE,kBAAR;AAA4B8L,UAAAA,KAAK,EAAE;AAAnC,SAFN,EAEgD,UAAA1G,IAAI,EAAI;AACtD,cAAMsG,IAAI,GAAGF,gBAAgB,KAAKpG,IAArB,GAA4BqG,UAA5B,GAAyCF,OAAO,CAACnG,IAAD,CAA7D;;AACA,cAAIsG,IAAI,KAAKlL,SAAb,EAAwB;AACvB,mBAAO,IAAIzB,wBAAJ,GACLgN,aADK,CACSL,IAAI,CAAC1L,IADd,EACoB0L,IAAI,CAACM,QADzB,EACmCN,IAAI,CAACO,UADxC,EAEL1G,QAFK,CAEIH,IAAI,CAACI,KAFT,CAAP;AAGA;AACD,SATF;;AAUA,QAAA,MAAI,CAAClE,KAAL,CAAWkD,MAAX,CAAkBU,GAAlB,CAAsB,kBAAtB,EAA0C,YAAM;AAC/C;AACAsG,UAAAA,gBAAgB,GAAGC,UAAU,GAAGjL,SAAhC;AACA,SAHD;AAIA,OAzCD;;AA0CA6K,MAAAA,2BAA2B,CAAC,YAAD,EAAe,UAAAjG,IAAI,EAAI;AACjD,YAAMsG,IAAI,GAAG,MAAI,CAAC1F,eAAL;AACZ;AAA+BZ,QAAAA,IAAD,CAAOpF,IADzB,CAAb;;AAGA,YACC,OAAO0L,IAAP,KAAgB,QAAhB,IACCA,IAAI,YAAYpM,YAAhB,IAAgC,OAAOoM,IAAI,CAAClM,QAAZ,KAAyB,QAF3D,EAGE;AACD,iBAAO;AAAEQ,YAAAA,IAAI,EAAE0L,IAAR;AAAcM,YAAAA,QAAQ,EAAEN,IAAxB;AAA8BO,YAAAA,UAAU,EAAE;AAAA,qBAAM,EAAN;AAAA;AAA1C,WAAP;AACA;AACD,OAV0B,CAA3B;AAWAZ,MAAAA,2BAA2B,CAAC,gBAAD,EAAmB,UAAAjG,IAAI,EAAI;AACrD,YAAMsG,IAAI,GAAG,MAAI,CAAC1F,eAAL,CAAqB,MAArB,CAAb;;AACA,YACC,OAAO0F,IAAP,KAAgB,QAAhB,IACCA,IAAI,YAAYpM,YAAhB,IAAgC,OAAOoM,IAAI,CAAClM,QAAZ,KAAyB,QAF3D,EAGE;AACD,iBAAO;AAAEQ,YAAAA,IAAI,EAAE0L,IAAR;AAAcM,YAAAA,QAAQ,EAAEN,IAAxB;AAA8BO,YAAAA,UAAU,EAAE;AAAA,qBAAM,EAAN;AAAA;AAA1C,WAAP;AACA;AACD,OAR0B,CAA3B;AASA,WAAK3K,KAAL,CAAWI,QAAX,CAAoBuD,GAApB,CAAwB,cAAxB,EAAwCC,GAAxC,CAA4C,kBAA5C,EAAgE,UAAAE,IAAI,EAAI;AACvE,YAAM8G,YAAY;AAAG;AAAiC9G,QAAAA,IAAtD;AAEA,eAAO,MAAI,CAACuF,gBAAL,CACN,MAAI,CAACrJ,KAAL,CAAWK,kBADL,EAENxB,WAAW,CAACiF,IAAD,CAFL,EAGN8G,YAHM,CAAP;AAKA,OARD;AASAb,MAAAA,2BAA2B,CAAC,kBAAD,EAAqB,UAAAjG,IAAI;AAAA,eACnD,MAAI,CAAC+G,uBAAL;AACC;AAAqC/G,QAAAA,IADtC,EAEClG,+BAFD,CADmD;AAAA,OAAzB,CAA3B;AAOA,WAAKoC,KAAL,CAAWI,QAAX,CAAoBuD,GAApB,CAAwB,gBAAxB,EAA0CC,GAA1C,CAA8C,kBAA9C,EAAkE,UAAAC,KAAK,EAAI;AAC1E,YAAMC,IAAI;AAAG;AAAmCD,QAAAA,KAAhD;;AACA,YACCC,IAAI,CAACU,MAAL,CAAYzF,IAAZ,KAAqB,kBAArB,IACA+E,IAAI,CAACU,MAAL,CAAYvF,QAAZ,CAAqBF,IAArB,MACE+E,IAAI,CAACU,MAAL,CAAYsG,QAAZ,GAAuB,SAAvB,GAAmC,YADrC,CAFD,EAIE;AACD;AACA,SARyE,CAU1E;;;AACA,YAAMC,KAAK,GAAG,MAAI,CAAChG,kBAAL;AACb;AAA+BjB,QAAAA,IAAI,CAACU,MAAL,CAAYhG,MAD9B,CAAd;;AAGA,YAAI,CAACuM,KAAL,EAAY;AACZ,YAAM9L,QAAQ,GACb6E,IAAI,CAACU,MAAL,CAAYvF,QAAZ,CAAqBF,IAArB,KAA8B,SAA9B,aACM+E,IAAI,CAACU,MAAL,CAAYvF,QAAZ,CAAqB8E,KAD3B,IAEGD,IAAI,CAACU,MAAL,CAAYvF,QAAZ,CAAqBP,IAHzB;;AAIA,YAAM4L,IAAI,GAAG,MAAI,CAACtK,KAAL,CAAWO,4BAAX,CAAwCgK,GAAxC,CAA4CtL,QAA5C,CAAb;;AACA,YAAIqL,IAAI,KAAKpL,SAAb,EAAwB;AACvB,iBAAOoL,IAAI,CAAC/H,IAAL,CAAUuB,IAAV,EAAgBiH,KAAhB,CAAP;AACA;AACD,OAvBD;AAwBA,WAAK/K,KAAL,CAAWO,4BAAX,CACEoD,GADF,CACM,SADN,EAEEC,GAFF,CAEM,kBAFN,EAE0B,UAACE,IAAD,EAAOiH,KAAP,EAAiB;AACzC,YAAI,CAACA,KAAK,CAACzC,QAAN,EAAL,EAAuB;AACvB,YAAIxE,IAAI,CAACW,SAAL,CAAe7F,MAAf,KAA0B,CAA9B,EAAiC;;AACjC,6CAAqBkF,IAAI,CAACW,SAA1B;AAAA,YAAOI,IAAP;AAAA,YAAaI,IAAb;;AACA,YAAIJ,IAAI,CAAC9F,IAAL,KAAc,eAAlB,EAAmC;;AACnC,YAAMiM,QAAQ,GAAG,MAAI,CAACjG,kBAAL,CAAwBF,IAAxB,CAAjB;;AACA,YAAI,CAACmG,QAAQ,CAAC1C,QAAT,EAAL,EAA0B;AAC1B,YAAM2C,SAAS,GAAGD,QAAQ,CAACzC,MAA3B;AAEA,YAAIhC,MAAJ;;AACA,YAAItB,IAAJ,EAAU;AACT,cAAIA,IAAI,CAAClG,IAAL,KAAc,eAAlB,EAAmC;;AACnC,cAAMmM,QAAQ,GAAG,MAAI,CAACnG,kBAAL,CAAwBE,IAAxB,CAAjB;;AACA,cAAI,CAACiG,QAAQ,CAAC1C,QAAT,EAAL,EAA0B;AAC1BjC,UAAAA,MAAM,GAAGwE,KAAK,CAACxC,MAAN,CAAa4C,OAAb,CAAqBF,SAArB,EAAgCC,QAAQ,CAACzC,MAAzC,CAAT;AACA,SALD,MAKO;AACNlC,UAAAA,MAAM,GAAGwE,KAAK,CAACxC,MAAN,CAAa4C,OAAb,CAAqBF,SAArB,CAAT;AACA;;AACD,eAAO,IAAIxN,wBAAJ,GACLuG,SADK,CACKuC,MADL,EAELR,cAFK,CAEUgF,KAAK,CAACjF,oBAAN,EAFV,EAGL7B,QAHK,CAGIH,IAAI,CAACI,KAHT,CAAP;AAIA,OAxBF;AAyBA,WAAKlE,KAAL,CAAWO,4BAAX,CACEoD,GADF,CACM,SADN,EAEEC,GAFF,CAEM,kBAFN,EAE0B,UAACE,IAAD,EAAOiH,KAAP,EAAiB;AACzC,YAAI,CAACA,KAAK,CAACzC,QAAN,EAAL,EAAuB;AACvB,YAAIxE,IAAI,CAACW,SAAL,CAAe7F,MAAf,KAA0B,CAA9B,EAAiC;AACjC,YAAIkF,IAAI,CAACW,SAAL,CAAe,CAAf,EAAkB1F,IAAlB,KAA2B,eAA/B,EAAgD;AAChD,YAAI+E,IAAI,CAACW,SAAL,CAAe,CAAf,EAAkB1F,IAAlB,KAA2B,eAA/B,EAAgD;;AAChD,YAAI8F,IAAI,GAAG,MAAI,CAACE,kBAAL,CAAwBjB,IAAI,CAACW,SAAL,CAAe,CAAf,CAAxB,CAAX;;AACA,YAAIQ,IAAI,GAAG,MAAI,CAACF,kBAAL,CAAwBjB,IAAI,CAACW,SAAL,CAAe,CAAf,CAAxB,CAAX;;AACA,YAAI,CAACI,IAAI,CAACyD,QAAL,EAAD,IAAoB,CAACzD,IAAI,CAAC8E,QAAL,EAAzB,EAA0C;AAC1C,YAAMsB,SAAS,GAAGpG,IAAI,CAACF,MAAL,IAAeE,IAAI,CAAC0D,MAAtC;AACA,YAAI,CAACtD,IAAI,CAACqD,QAAL,EAAL,EAAsB;AACtB,YAAM8C,SAAS,GAAGnG,IAAI,CAACsD,MAAvB;AACA,eAAO,IAAI9K,wBAAJ,GACL2G,SADK,CACK2G,KAAK,CAACxC,MAAN,CAAa8C,OAAb,CAAqBJ,SAArB,EAAgCG,SAAhC,CADL,EAELrF,cAFK,CAEUgF,KAAK,CAACjF,oBAAN,EAFV,EAGL7B,QAHK,CAGIH,IAAI,CAACI,KAHT,CAAP;AAIA,OAjBF;AAkBA,OAAC,QAAD,EAAW,WAAX,EAAwB,OAAxB,EAAiCoH,OAAjC,CAAyC,UAAAjF,EAAE,EAAI;AAC9C,QAAA,MAAI,CAACrG,KAAL,CAAWO,4BAAX,CACEoD,GADF,CACM0C,EADN,EAEEzC,GAFF,CAEM,kBAFN,EAE0B,UAACE,IAAD,EAAOiH,KAAP,EAAiB;AACzC,cAAI,CAACA,KAAK,CAACzC,QAAN,EAAL,EAAuB;AACvB,cAAIzD,IAAJ;AACA,cAAI0B,MAAJ;AAAA,cACCgF,GAAG,GAAGR,KAAK,CAACxC,MADb;;AAEA,kBAAQzE,IAAI,CAACW,SAAL,CAAe7F,MAAvB;AACC,iBAAK,CAAL;AACC,kBAAIkF,IAAI,CAACW,SAAL,CAAe,CAAf,EAAkB1F,IAAlB,KAA2B,eAA/B,EAAgD;AAChD8F,cAAAA,IAAI,GAAG,MAAI,CAACE,kBAAL,CAAwBjB,IAAI,CAACW,SAAL,CAAe,CAAf,CAAxB,CAAP;AACA,kBAAI,CAACI,IAAI,CAAC2D,QAAL,EAAL,EAAsB;AACtBjC,cAAAA,MAAM,GAAGgF,GAAG,CAAClF,EAAD,CAAH,CAAQxB,IAAI,CAAC4D,MAAb,CAAT;AACA;;AACD,iBAAK,CAAL;AAAQ;AACP,oBAAI3E,IAAI,CAACW,SAAL,CAAe,CAAf,EAAkB1F,IAAlB,KAA2B,eAA/B,EAAgD;AAChD,oBAAI+E,IAAI,CAACW,SAAL,CAAe,CAAf,EAAkB1F,IAAlB,KAA2B,eAA/B,EAAgD;AAChD8F,gBAAAA,IAAI,GAAG,MAAI,CAACE,kBAAL,CAAwBjB,IAAI,CAACW,SAAL,CAAe,CAAf,CAAxB,CAAP;;AACA,oBAAMQ,IAAI,GAAG,MAAI,CAACF,kBAAL,CAAwBjB,IAAI,CAACW,SAAL,CAAe,CAAf,CAAxB,CAAb;;AACA,oBAAI,CAACI,IAAI,CAAC2D,QAAL,EAAL,EAAsB;AACtB,oBAAI,CAACvD,IAAI,CAACuD,QAAL,EAAL,EAAsB;AACtBjC,gBAAAA,MAAM,GAAGgF,GAAG,CAAClF,EAAD,CAAH,CAAQxB,IAAI,CAAC4D,MAAb,EAAqBxD,IAAI,CAACwD,MAA1B,CAAT;AACA;AACA;;AACD;AACC;AAlBF;;AAoBA,iBAAO,IAAIhL,wBAAJ,GACL2G,SADK,CACKmC,MADL,EAELR,cAFK,CAEUgF,KAAK,CAACjF,oBAAN,EAFV,EAGL7B,QAHK,CAGIH,IAAI,CAACI,KAHT,CAAP;AAIA,SA/BF;AAgCA,OAjCD;AAmCA;AACF;AACA;AACA;AACA;;AACE,UAAMsH,2BAA2B,GAAG,SAA9BA,2BAA8B,CAACC,IAAD,EAAOC,mBAAP,EAA+B;AAClE;AACA,YAAMC,MAAM,GAAG,EAAf;AACA;;AACA,YAAM3E,KAAK,GAAG,EAAd;;AAEA,aAAK,IAAIrI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+M,mBAAmB,CAACC,MAApB,CAA2B/M,MAA/C,EAAuDD,CAAC,EAAxD,EAA4D;AAC3D,cAAMiN,SAAS,GAAGF,mBAAmB,CAACC,MAApB,CAA2BhN,CAA3B,CAAlB;AACA,cAAMkN,KAAK,GAAGD,SAAS,CAAC7H,KAAV,CAAgB0H,IAAhB,CAAd;;AAEA,cAAI9M,CAAC,GAAG,CAAR,EAAW;AACV,gBAAMmN,QAAQ,GAAG9E,KAAK,CAACA,KAAK,CAACpI,MAAN,GAAe,CAAhB,CAAtB;;AACA,gBAAMkF,IAAI,GAAG,MAAI,CAACiB,kBAAL,CACZ2G,mBAAmB,CAACK,WAApB,CAAgCpN,CAAC,GAAG,CAApC,CADY,CAAb;;AAGA,gBAAMqN,YAAY,GAAGlI,IAAI,CAACkB,QAAL,EAArB;;AACA,gBACC,OAAOgH,YAAP,KAAwB,QAAxB,IACA,CAAClI,IAAI,CAACgC,oBAAL,EAFF,EAGE;AACD;AACA;AAEAgG,cAAAA,QAAQ,CAAC1H,SAAT,CAAmB0H,QAAQ,CAACvD,MAAT,GAAkByD,YAAlB,GAAiCH,KAApD;AACAC,cAAAA,QAAQ,CAAC7H,QAAT,CAAkB,CAAC6H,QAAQ,CAAC5H,KAAT,CAAe,CAAf,CAAD,EAAoB0H,SAAS,CAAC1H,KAAV,CAAgB,CAAhB,CAApB,CAAlB,EALC,CAMD;;AACA4H,cAAAA,QAAQ,CAACG,aAAT,CAAuB/M,SAAvB;AACA;AACA;;AACD8H,YAAAA,KAAK,CAACkF,IAAN,CAAWpI,IAAX;AACA;;AAED,cAAMqI,IAAI,GAAG,IAAI1O,wBAAJ,GACX2G,SADW,CACDyH,KADC,EAEX5H,QAFW,CAEF2H,SAAS,CAAC1H,KAFR,EAGX+H,aAHW,CAGGL,SAHH,CAAb;AAIAD,UAAAA,MAAM,CAACO,IAAP,CAAYC,IAAZ;AACAnF,UAAAA,KAAK,CAACkF,IAAN,CAAWC,IAAX;AACA;;AACD,eAAO;AACNR,UAAAA,MAAM,EAANA,MADM;AAEN3E,UAAAA,KAAK,EAALA;AAFM,SAAP;AAIA,OA3CD;;AA6CA,WAAKhH,KAAL,CAAWI,QAAX,CACEuD,GADF,CACM,iBADN,EAEEC,GAFF,CAEM,kBAFN,EAE0B,UAAAwI,KAAK,EAAI;AACjC,YAAMC,IAAI;AAAG;AAAoCD,QAAAA,KAAjD;;AAEA,oCAA0BZ,2BAA2B,CAAC,QAAD,EAAWa,IAAX,CAArD;AAAA,YAAQV,MAAR,yBAAQA,MAAR;AAAA,YAAgB3E,KAAhB,yBAAgBA,KAAhB;;AACA,YAAIA,KAAK,CAACpI,MAAN,KAAiB,CAArB,EAAwB;AACvB,iBAAOoI,KAAK,CAAC,CAAD,CAAL,CAAS/C,QAAT,CAAkBoI,IAAI,CAACnI,KAAvB,CAAP;AACA;;AACD,eAAO,IAAIzG,wBAAJ,GACL6O,iBADK,CACaX,MADb,EACqB3E,KADrB,EAC4B,QAD5B,EAEL/C,QAFK,CAEIoI,IAAI,CAACnI,KAFT,CAAP;AAGA,OAZF;AAaA,WAAKlE,KAAL,CAAWI,QAAX,CACEuD,GADF,CACM,0BADN,EAEEC,GAFF,CAEM,kBAFN,EAE0B,UAAAwI,KAAK,EAAI;AACjC,YAAMC,IAAI;AAAG;AAA6CD,QAAAA,KAA1D;;AACA,YAAMG,GAAG,GAAG,MAAI,CAACxH,kBAAL,CAAwBsH,IAAI,CAACE,GAA7B,CAAZ;;AAEA,YAAIA,GAAG,CAACC,YAAJ,MAAsBD,GAAG,CAACE,UAAJ,KAAmB,YAA7C,EAA2D;AAC1D,uCAA0BjB,2BAA2B,CACpD,KADoD,EAEpDa,IAAI,CAACR,KAF+C,CAArD;AAAA,cAAQF,MAAR,0BAAQA,MAAR;AAAA,cAAgB3E,KAAhB,0BAAgBA,KAAhB;;AAIA,iBAAO,IAAIvJ,wBAAJ,GACL6O,iBADK,CACaX,MADb,EACqB3E,KADrB,EAC4B,KAD5B,EAEL/C,QAFK,CAEIoI,IAAI,CAACnI,KAFT,CAAP;AAGA;AACD,OAfF;AAiBA,WAAKlE,KAAL,CAAWO,4BAAX,CACEoD,GADF,CACM,QADN,EAEEC,GAFF,CAEM,kBAFN,EAE0B,UAACE,IAAD,EAAOiH,KAAP,EAAiB;AACzC,YAAI,CAACA,KAAK,CAACzC,QAAN,EAAD,IAAqB,CAACyC,KAAK,CAACrC,SAAN,EAA1B,EAA6C;AAE7C,YAAIgE,YAAY,GAAG,IAAnB;AACA,YAAIC,gBAAgB,GAAG,KAAvB;AACA,YAAMC,gBAAgB,GAAG,EAAzB;;AACA,aAAK,IAAIjO,CAAC,GAAGmF,IAAI,CAACW,SAAL,CAAe7F,MAAf,GAAwB,CAArC,EAAwCD,CAAC,IAAI,CAA7C,EAAgDA,CAAC,EAAjD,EAAqD;AACpD,cAAM4K,GAAG,GAAGzF,IAAI,CAACW,SAAL,CAAe9F,CAAf,CAAZ;AACA,cAAI4K,GAAG,CAACxK,IAAJ,KAAa,eAAjB,EAAkC;;AAClC,cAAM8N,OAAO,GAAG,MAAI,CAAC9H,kBAAL,CAAwBwE,GAAxB,CAAhB;;AACA,cACCoD,gBAAgB,IACf,CAACE,OAAO,CAACvE,QAAR,EAAD,IAAuB,CAACuE,OAAO,CAACrE,QAAR,EAF1B,EAGE;AACDmE,YAAAA,gBAAgB,GAAG,IAAnB;AACAC,YAAAA,gBAAgB,CAACV,IAAjB,CAAsBW,OAAtB;AACA;AACA;;AAED,cAAM9I,KAAK,GAAG8I,OAAO,CAACvE,QAAR,KACXuE,OAAO,CAACtE,MADG,GAEX,KAAKsE,OAAO,CAACpE,MAFhB;AAIA,cAAMqE,SAAS,GAAG/I,KAAK,IAAI2I,YAAY,GAAGA,YAAY,CAACnE,MAAhB,GAAyB,EAAzC,CAAvB;AACA,cAAMwE,QAAQ,GAAG,CAChBF,OAAO,CAAC3I,KAAR,CAAc,CAAd,CADgB,EAEhB,CAACwI,YAAY,IAAIG,OAAjB,EAA0B3I,KAA1B,CAAgC,CAAhC,CAFgB,CAAjB;AAIAwI,UAAAA,YAAY,GAAG,IAAIjP,wBAAJ,GACb2G,SADa,CACH0I,SADG,EAEb/G,cAFa,CAGZ2G,YAAY,IAAIA,YAAY,CAAC5G,oBAAb,EAAjB,IACC+G,OAAO,CAAC/G,oBAAR,EAJY,EAMb7B,QANa,CAMJ8I,QANI,CAAf;AAOA;;AAED,YAAIJ,gBAAJ,EAAsB;AACrB,cAAMhE,MAAM,GAAGoC,KAAK,CAACzC,QAAN,KAAmByC,KAAnB,GAA2BA,KAAK,CAACpC,MAAhD;AACA,cAAMqE,KAAK,GACVjC,KAAK,CAACrC,SAAN,MAAqBqC,KAAK,CAACjC,uBAA3B,GACGiC,KAAK,CAACjC,uBAAN,CAA8BG,MAA9B,CAAqC2D,gBAAgB,CAACK,OAAjB,EAArC,CADH,GAEGL,gBAAgB,CAACK,OAAjB,EAHJ;AAIA,iBAAO,IAAIxP,wBAAJ,GACLmL,UADK,CACMD,MADN,EACc+D,YADd,EAC4BM,KAD5B,EAEL/I,QAFK,CAEIH,IAAI,CAACI,KAFT,CAAP;AAGA,SATD,MASO,IAAI6G,KAAK,CAACrC,SAAN,EAAJ,EAAuB;AAC7B,cAAMG,OAAO,GAAG6D,YAAY,IAAI3B,KAAK,CAAClC,OAAtC;;AACA,cAAMmE,MAAK,GAAGjC,KAAK,CAACjC,uBAAN,GACXiC,KAAK,CAACjC,uBAAN,CAA8BG,MAA9B,CAAqC2D,gBAAgB,CAACK,OAAjB,EAArC,CADW,GAEXL,gBAAgB,CAACK,OAAjB,EAFH;;AAGA,iBAAO,IAAIxP,wBAAJ,GACLmL,UADK,CACMmC,KAAK,CAACpC,MADZ,EACoBE,OADpB,EAC6BmE,MAD7B,EAEL/I,QAFK,CAEIH,IAAI,CAACI,KAFT,CAAP;AAGA,SARM,MAQA;AACN,cAAM4I,UAAS,GACd/B,KAAK,CAACxC,MAAN,IAAgBmE,YAAY,GAAGA,YAAY,CAACnE,MAAhB,GAAyB,EAArD,CADD;;AAEA,iBAAO,IAAI9K,wBAAJ,GACL2G,SADK,CACK0I,UADL,EAEL/G,cAFK,CAGJ2G,YAAY,IAAIA,YAAY,CAAC5G,oBAAb,EAAjB,IACCiF,KAAK,CAACjF,oBAAN,EAJI,EAML7B,QANK,CAMIH,IAAI,CAACI,KANT,CAAP;AAOA;AACD,OAnEF;AAoEA,WAAKlE,KAAL,CAAWO,4BAAX,CACEoD,GADF,CACM,OADN,EAEEC,GAFF,CAEM,kBAFN,EAE0B,UAACE,IAAD,EAAOiH,KAAP,EAAiB;AACzC,YAAI,CAACA,KAAK,CAACzC,QAAN,EAAL,EAAuB;AACvB,YAAIxE,IAAI,CAACW,SAAL,CAAe7F,MAAf,KAA0B,CAA9B,EAAiC;AACjC,YAAIkF,IAAI,CAACW,SAAL,CAAe,CAAf,EAAkB1F,IAAlB,KAA2B,eAA/B,EAAgD;AAChD,YAAIwH,MAAJ;;AACA,YAAMgD,GAAG,GAAG,MAAI,CAACxE,kBAAL,CAAwBjB,IAAI,CAACW,SAAL,CAAe,CAAf,CAAxB,CAAZ;;AACA,YAAI8E,GAAG,CAACjB,QAAJ,EAAJ,EAAoB;AACnB/B,UAAAA,MAAM,GAAGwE,KAAK,CAACxC,MAAN,CAAa2E,KAAb,CAAmB3D,GAAG,CAAChB,MAAvB,CAAT;AACA,SAFD,MAEO,IAAIgB,GAAG,CAACI,QAAJ,EAAJ,EAAoB;AAC1BpD,UAAAA,MAAM,GAAGwE,KAAK,CAACxC,MAAN,CAAa2E,KAAb,CAAmB3D,GAAG,CAAC5E,MAAvB,CAAT;AACA,SAFM,MAEA;AACN;AACA;;AACD,eAAO,IAAIlH,wBAAJ,GACL0P,QADK,CACI5G,MADJ,EAELR,cAFK,CAEUgF,KAAK,CAACjF,oBAAN,EAFV,EAGL7B,QAHK,CAGIH,IAAI,CAACI,KAHT,CAAP;AAIA,OAnBF;AAoBA,WAAKlE,KAAL,CAAWI,QAAX,CACEuD,GADF,CACM,uBADN,EAEEC,GAFF,CAEM,kBAFN,EAE0B,UAAAC,KAAK,EAAI;AACjC,YAAMC,IAAI;AAAG;AAA0CD,QAAAA,KAAvD;;AAEA,YAAMuJ,SAAS,GAAG,MAAI,CAACrI,kBAAL,CAAwBjB,IAAI,CAACuJ,IAA7B,CAAlB;;AACA,YAAMC,cAAc,GAAGF,SAAS,CAAC1H,MAAV,EAAvB;AACA,YAAImB,GAAJ;;AACA,YAAIyG,cAAc,KAAKpO,SAAvB,EAAkC;AACjC,cAAMqO,UAAU,GAAG,MAAI,CAACxI,kBAAL,CAAwBjB,IAAI,CAACyJ,UAA7B,CAAnB;;AACA,cAAMC,SAAS,GAAG,MAAI,CAACzI,kBAAL,CAAwBjB,IAAI,CAAC0J,SAA7B,CAAlB;;AACA,cAAI,CAACD,UAAD,IAAe,CAACC,SAApB,EAA+B;AAC/B3G,UAAAA,GAAG,GAAG,IAAIpJ,wBAAJ,EAAN;;AACA,cAAI8P,UAAU,CAACE,aAAX,EAAJ,EAAgC;AAC/B5G,YAAAA,GAAG,CAAC6G,UAAJ,CAAeH,UAAU,CAAC1N,OAA1B;AACA,WAFD,MAEO;AACNgH,YAAAA,GAAG,CAAC6G,UAAJ,CAAe,CAACH,UAAD,CAAf;AACA;;AACD,cAAIC,SAAS,CAACC,aAAV,EAAJ,EAA+B;AAC9B5G,YAAAA,GAAG,CAAC8G,UAAJ,CAAeH,SAAS,CAAC3N,OAAzB;AACA,WAFD,MAEO;AACNgH,YAAAA,GAAG,CAAC8G,UAAJ,CAAe,CAACH,SAAD,CAAf;AACA;AACD,SAfD,MAeO;AACN3G,UAAAA,GAAG,GAAG,MAAI,CAAC9B,kBAAL,CACLuI,cAAc,GAAGxJ,IAAI,CAACyJ,UAAR,GAAqBzJ,IAAI,CAAC0J,SADnC,CAAN;AAGA,cAAIJ,SAAS,CAACtH,oBAAV,EAAJ,EAAsCe,GAAG,CAACd,cAAJ;AACtC;;AACDc,QAAAA,GAAG,CAAC5C,QAAJ,CAAaH,IAAI,CAACI,KAAlB;AACA,eAAO2C,GAAP;AACA,OA/BF;AAgCA,WAAK7G,KAAL,CAAWI,QAAX,CACEuD,GADF,CACM,iBADN,EAEEC,GAFF,CAEM,kBAFN,EAE0B,UAAAC,KAAK,EAAI;AACjC,YAAMC,IAAI;AAAG;AAAoCD,QAAAA,KAAjD;AAEA,YAAM+J,KAAK,GAAG9J,IAAI,CAAC+J,QAAL,CAAcC,GAAd,CAAkB,UAAAC,OAAO,EAAI;AAC1C,iBACCA,OAAO,KAAK,IAAZ,IACAA,OAAO,CAAChP,IAAR,KAAiB,eADjB,IAEA,MAAI,CAACgG,kBAAL,CAAwBgJ,OAAxB,CAHD;AAKA,SANa,CAAd;AAOA,YAAI,CAACH,KAAK,CAACI,KAAN,CAAYC,OAAZ,CAAL,EAA2B;AAC3B,eAAO,IAAIxQ,wBAAJ,GACLyQ,QADK,CACIN,KADJ,EAEL3J,QAFK,CAEIH,IAAI,CAACI,KAFT,CAAP;AAGA,OAhBF;AAiBA,WAAKlE,KAAL,CAAWI,QAAX,CACEuD,GADF,CACM,iBADN,EAEEC,GAFF,CAEM,kBAFN,EAE0B,UAAAC,KAAK,EAAI;AACjC,YAAMC,IAAI;AAAG;AAAoCD,QAAAA,KAAjD;AACA;;AACA,YAAMsK,wBAAwB,GAAG,EAAjC;AACA;;AACA,YAAIC,IAAI,GAAGtK,IAAI,CAAChF,UAAhB;;AAEA,eACCsP,IAAI,CAACrP,IAAL,KAAc,kBAAd,IACAqP,IAAI,CAACrP,IAAL,KAAc,gBAFf,EAGE;AACD,cAAIqP,IAAI,CAACrP,IAAL,KAAc,kBAAlB,EAAsC;AACrC,gBAAIqP,IAAI,CAACC,QAAT,EAAmB;AAClB;AACAF,cAAAA,wBAAwB,CAACjC,IAAzB;AACC;AAA+BkC,cAAAA,IAAI,CAAC5P,MADrC;AAGA;;AACD4P,YAAAA,IAAI,GAAGA,IAAI,CAAC5P,MAAZ;AACA,WARD,MAQO;AACN,gBAAI4P,IAAI,CAACC,QAAT,EAAmB;AAClB;AACAF,cAAAA,wBAAwB,CAACjC,IAAzB;AACC;AAA+BkC,cAAAA,IAAI,CAAC5J,MADrC;AAGA;;AACD4J,YAAAA,IAAI,GAAGA,IAAI,CAAC5J,MAAZ;AACA;AACD;;AAED,eAAO2J,wBAAwB,CAACvP,MAAzB,GAAkC,CAAzC,EAA4C;AAC3C,cAAME,UAAU,GAAGqP,wBAAwB,CAACG,GAAzB,EAAnB;;AACA,cAAMC,SAAS,GAAG,MAAI,CAACxJ,kBAAL,CAAwBjG,UAAxB,CAAlB;;AAEA,cAAIyP,SAAS,IAAIA,SAAS,CAAC3I,SAAV,EAAjB,EAAwC;AACvC,mBAAO2I,SAAS,CAACtK,QAAV,CAAmBJ,KAAK,CAACK,KAAzB,CAAP;AACA;AACD;;AACD,eAAO,MAAI,CAACa,kBAAL,CAAwBjB,IAAI,CAAChF,UAA7B,CAAP;AACA,OAzCF;AA0CA;;;WAED,6BAAoBgF,IAApB,EAA0B;AACzB,UAAMyC,MAAM,GAAG,KAAKxB,kBAAL,CAAwBjB,IAAxB,CAAf;;AACA,UAAIyC,MAAM,IAAIA,MAAM,CAACiG,YAAP,EAAd,EAAqC;AACpC,eAAOjG,MAAM,CAACkG,UAAd;AACA;AACD;AAED;AACD;AACA;AACA;;;;WACC,mBAAU+B,MAAV,EAAkB;AACjB,UAAIA,MAAM,CAACC,UAAX,EAAuB;AACtB,YAAI,CAAC,KAAKzO,KAAL,CAAWa,sBAAX,CAAkC0B,IAAlC,CAAuCiM,MAAM,CAACC,UAA9C,EAA0DD,MAA1D,CAAL,EAAwE;AACvE,eAAKE,cAAL,CAAoBF,MAAM,CAACC,UAA3B;AACA;AACD;;AACD,UAAID,MAAM,CAACG,IAAP,IAAeH,MAAM,CAACG,IAAP,CAAY5P,IAAZ,KAAqB,WAAxC,EAAqD;AAAA;AACzB;AAAqByP,QAAAA,MAAM,CAACG,IAAP,CAAYA,IADR;AAAA;;AAAA;AACpD,iEAAmE;AAAA,gBAAxDC,YAAwD;;AAClE,gBAAI,CAAC,KAAK5O,KAAL,CAAWc,gBAAX,CAA4ByB,IAA5B,CAAiCqM,YAAjC,EAA+CJ,MAA/C,CAAL,EAA6D;AAC5D,kBAAII,YAAY,CAAC9D,QAAb,IAAyB8D,YAAY,CAACC,GAA1C,EAA+C;AAC9C,qBAAKH,cAAL,CAAoBE,YAAY,CAACC,GAAjC;AACA;;AACD,kBAAID,YAAY,CAAC7K,KAAjB,EAAwB;AACvB,oBACC,CAAC,KAAK/D,KAAL,CAAWe,cAAX,CAA0BwB,IAA1B,CACAqM,YAAY,CAAC7K,KADb,EAEA6K,YAFA,EAGAJ,MAHA,CADF,EAME;AACD,sBAAMM,WAAW,GAAG,KAAK3L,KAAL,CAAW4L,aAA/B;AACA,uBAAK5L,KAAL,CAAW4L,aAAX,GAA2B,KAA3B;AACA,uBAAKL,cAAL,CAAoBE,YAAY,CAAC7K,KAAjC;AACA,uBAAKZ,KAAL,CAAW4L,aAAX,GAA2BD,WAA3B;AACA;AACD;AACD;AACD;AArBmD;AAAA;AAAA;AAAA;AAAA;AAsBpD;AACD,K,CAED;;;;WACA,2BAAkBE,UAAlB,EAA8B;AAC7B,WAAK,IAAIC,KAAK,GAAG,CAAZ,EAAeC,GAAG,GAAGF,UAAU,CAACpQ,MAArC,EAA6CqQ,KAAK,GAAGC,GAArD,EAA0DD,KAAK,EAA/D,EAAmE;AAClE,YAAMtO,SAAS,GAAGqO,UAAU,CAACC,KAAD,CAA5B;AACA,aAAKE,gBAAL,CAAsBxO,SAAtB;AACA;AACD,K,CAED;;;;WACA,gCAAuBqO,UAAvB,EAAmC;AAClC,WAAK,IAAIC,KAAK,GAAG,CAAZ,EAAeC,GAAG,GAAGF,UAAU,CAACpQ,MAArC,EAA6CqQ,KAAK,GAAGC,GAArD,EAA0DD,KAAK,EAA/D,EAAmE;AAClE,YAAMtO,SAAS,GAAGqO,UAAU,CAACC,KAAD,CAA5B;AACA,aAAKG,qBAAL,CAA2BzO,SAA3B;AACA;AACD,K,CAED;;;;WACA,wBAAeqO,UAAf,EAA2B;AAC1B,WAAK,IAAIC,KAAK,GAAG,CAAZ,EAAeC,GAAG,GAAGF,UAAU,CAACpQ,MAArC,EAA6CqQ,KAAK,GAAGC,GAArD,EAA0DD,KAAK,EAA/D,EAAmE;AAClE,YAAMtO,SAAS,GAAGqO,UAAU,CAACC,KAAD,CAA5B;AACA,aAAKI,aAAL,CAAmB1O,SAAnB;AACA;AACD;;;WAED,0BAAiBA,SAAjB,EAA4B;AAC3B,WAAK4C,aAAL,CAAmB2I,IAAnB,CAAwBvL,SAAxB;;AACA,UAAI,KAAKX,KAAL,CAAWS,YAAX,CAAwB8B,IAAxB,CAA6B5B,SAA7B,CAAJ,EAA6C;AAC5C,aAAK6C,aAAL,GAAqB,KAAKD,aAAL,CAAmB+K,GAAnB,EAArB;AACA;AACA;;AACD,cAAQ3N,SAAS,CAAC5B,IAAlB;AACC,aAAK,gBAAL;AACC,eAAKuQ,qBAAL,CAA2B3O,SAA3B;AACA;;AACD,aAAK,kBAAL;AACC,eAAK4O,uBAAL,CAA6B5O,SAA7B;AACA;;AACD,aAAK,gBAAL;AACC,eAAK6O,qBAAL,CAA2B7O,SAA3B;AACA;;AACD,aAAK,gBAAL;AACC,eAAK8O,qBAAL,CAA2B9O,SAA3B;AACA;;AACD,aAAK,cAAL;AACC,eAAK+O,mBAAL,CAAyB/O,SAAzB;AACA;;AACD,aAAK,qBAAL;AACC,eAAKgP,0BAAL,CAAgChP,SAAhC;AACA;;AACD,aAAK,aAAL;AACC,eAAKiP,kBAAL,CAAwBjP,SAAxB;AACA;;AACD,aAAK,kBAAL;AACC,eAAKkP,uBAAL,CAA6BlP,SAA7B;AACA;;AACD,aAAK,iBAAL;AACC,eAAKmP,sBAAL,CAA4BnP,SAA5B;AACA;;AACD,aAAK,cAAL;AACC,eAAKoP,mBAAL,CAAyBpP,SAAzB;AACA;;AACD,aAAK,qBAAL;AACC,eAAKqP,0BAAL,CAAgCrP,SAAhC;AACA;;AACD,aAAK,gBAAL;AACC,eAAKsP,qBAAL,CAA2BtP,SAA3B;AACA;;AACD,aAAK,eAAL;AACC,eAAKuP,oBAAL,CAA0BvP,SAA1B;AACA;AAvCF;;AAyCA,WAAK6C,aAAL,GAAqB,KAAKD,aAAL,CAAmB+K,GAAnB,EAArB;AACA;;;WAED,+BAAsB3N,SAAtB,EAAiC;AAChC,WAAK4C,aAAL,CAAmB2I,IAAnB,CAAwBvL,SAAxB;;AACA,UAAI,KAAKX,KAAL,CAAWU,iBAAX,CAA6B6B,IAA7B,CAAkC5B,SAAlC,CAAJ,EAAkD;AACjD,aAAK6C,aAAL,GAAqB,KAAKD,aAAL,CAAmB+K,GAAnB,EAArB;AACA;AACA;;AACD,cAAQ3N,SAAS,CAAC5B,IAAlB;AACC,aAAK,mBAAL;AACC,eAAKoR,6BAAL,CAAmCxP,SAAnC;AACA;;AACD,aAAK,sBAAL;AACC,eAAKyP,gCAAL,CAAsCzP,SAAtC;AACA;;AACD,aAAK,0BAAL;AACC,eAAK0P,oCAAL,CAA0C1P,SAA1C;AACA;;AACD,aAAK,wBAAL;AACC,eAAK2P,kCAAL,CAAwC3P,SAAxC;AACA;;AACD,aAAK,qBAAL;AACC,eAAK4P,+BAAL,CAAqC5P,SAArC;AACA;;AACD,aAAK,kBAAL;AACC,eAAK6P,4BAAL,CAAkC7P,SAAlC;AACA;AAlBF;;AAoBA,WAAK6C,aAAL,GAAqB,KAAKD,aAAL,CAAmB+K,GAAnB,EAArB;AACA;;;WAED,uBAAc3N,SAAd,EAAyB;AACxB,WAAK4C,aAAL,CAAmB2I,IAAnB,CAAwBvL,SAAxB;;AACA,UAAI,KAAKX,KAAL,CAAWW,SAAX,CAAqB4B,IAArB,CAA0B5B,SAA1B,MAAyCzB,SAA7C,EAAwD;AACvD,aAAKsE,aAAL,GAAqB,KAAKD,aAAL,CAAmB+K,GAAnB,EAArB;AACA;AACA;;AACD,cAAQ3N,SAAS,CAAC5B,IAAlB;AACC,aAAK,gBAAL;AACC,eAAK0R,kBAAL,CAAwB9P,SAAxB;AACA;;AACD,aAAK,kBAAL;AACC,eAAK+P,oBAAL,CAA0B/P,SAA1B;AACA;;AACD,aAAK,kBAAL;AACC,eAAKgQ,oBAAL,CAA0BhQ,SAA1B;AACA;;AACD,aAAK,0BAAL;AACC,eAAKiQ,4BAAL,CAAkCjQ,SAAlC;AACA;;AACD,aAAK,wBAAL;AACC,eAAKkQ,0BAAL,CAAgClQ,SAAhC;AACA;;AACD,aAAK,qBAAL;AACC,eAAKmQ,uBAAL,CAA6BnQ,SAA7B;AACA;;AACD,aAAK,gBAAL;AACC,eAAKoQ,kBAAL,CAAwBpQ,SAAxB;AACA;;AACD,aAAK,gBAAL;AACC,eAAKqQ,kBAAL,CAAwBrQ,SAAxB;AACA;;AACD,aAAK,cAAL;AACC,eAAKsQ,gBAAL,CAAsBtQ,SAAtB;AACA;;AACD,aAAK,qBAAL;AACC,eAAKuQ,uBAAL,CAA6BvQ,SAA7B;AACA;;AACD,aAAK,aAAL;AACC,eAAKwQ,eAAL,CAAqBxQ,SAArB;AACA;;AACD,aAAK,kBAAL;AACC,eAAKyQ,oBAAL,CAA0BzQ,SAA1B;AACA;;AACD,aAAK,iBAAL;AACC,eAAK0Q,mBAAL,CAAyB1Q,SAAzB;AACA;;AACD,aAAK,iBAAL;AACC,eAAK2Q,mBAAL,CAAyB3Q,SAAzB;AACA;;AACD,aAAK,gBAAL;AACC,eAAK4Q,kBAAL,CAAwB5Q,SAAxB;AACA;;AACD,aAAK,cAAL;AACC,eAAK6Q,gBAAL,CAAsB7Q,SAAtB;AACA;;AACD,aAAK,qBAAL;AACC,eAAK8Q,uBAAL,CAA6B9Q,SAA7B;AACA;;AACD,aAAK,gBAAL;AACC,eAAK+Q,kBAAL,CAAwB/Q,SAAxB;AACA;;AACD,aAAK,eAAL;AACC,eAAKgR,iBAAL,CAAuBhR,SAAvB;AACA;AAzDF;;AA2DA,WAAK6C,aAAL,GAAqB,KAAKD,aAAL,CAAmB+K,GAAnB,EAArB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;WACC,6BAAoB3N,SAApB,EAA+B;AAC9B,WAAK6C,aAAL,GAAqBtE,SAArB;AACA,WAAKmQ,aAAL,CAAmB1O,SAAnB;AACA,K,CAED;;;;WACA,+BAAsBA,SAAtB,EAAiC;AAChC,WAAKiR,iBAAL,CAAuBjR,SAAS,CAACgO,IAAjC;AACA;;;WAED,4BAAmBhO,SAAnB,EAA8B;AAAA;;AAC7B,WAAKkR,YAAL,CAAkB,YAAM;AACvB,YAAMlD,IAAI,GAAGhO,SAAS,CAACgO,IAAvB;AACA,YAAMmD,IAAI,GAAG,MAAI,CAACtO,aAAlB;;AACA,QAAA,MAAI,CAACuO,sBAAL,CAA4BpD,IAA5B;;AACA,QAAA,MAAI,CAACnL,aAAL,GAAqBsO,IAArB;;AACA,QAAA,MAAI,CAACE,cAAL,CAAoBrD,IAApB;AACA,OAND;AAOA;;;WAED,iCAAwBhO,SAAxB,EAAmC;AAClC,WAAK+N,cAAL,CAAoB/N,SAAS,CAAC7B,UAA9B;AACA;;;WAED,4BAAmB6B,SAAnB,EAA8B;AAC7B,WAAKwO,gBAAL,CAAsBxO,SAAS,CAAC4M,UAAhC;;AACA,UAAI5M,SAAS,CAAC6M,SAAd,EAAyB;AACxB,aAAK2B,gBAAL,CAAsBxO,SAAS,CAAC6M,SAAhC;AACA;AACD;;;WAED,yBAAgB7M,SAAhB,EAA2B;AAC1B,UAAM4F,MAAM,GAAG,KAAKvG,KAAL,CAAWY,WAAX,CAAuB2B,IAAvB,CAA4B5B,SAA5B,CAAf;;AACA,UAAI4F,MAAM,KAAKrH,SAAf,EAA0B;AACzB,aAAKwP,cAAL,CAAoB/N,SAAS,CAAC0M,IAA9B;AACA,aAAK4E,mBAAL,CAAyBtR,SAAS,CAAC4M,UAAnC;;AACA,YAAI5M,SAAS,CAAC6M,SAAd,EAAyB;AACxB,eAAKyE,mBAAL,CAAyBtR,SAAS,CAAC6M,SAAnC;AACA;AACD,OAND,MAMO;AACN,YAAIjH,MAAJ,EAAY;AACX,eAAK0L,mBAAL,CAAyBtR,SAAS,CAAC4M,UAAnC;AACA,SAFD,MAEO,IAAI5M,SAAS,CAAC6M,SAAd,EAAyB;AAC/B,eAAKyE,mBAAL,CAAyBtR,SAAS,CAAC6M,SAAnC;AACA;AACD;AACD;;;WAED,iCAAwB7M,SAAxB,EAAmC;AAClC,WAAKwO,gBAAL,CAAsBxO,SAAS,CAACgO,IAAhC;AACA;;;WAED,8BAAqBhO,SAArB,EAAgC;AAC/B,UAAM2J,IAAI,GAAG,KAAKtK,KAAL,CAAWgB,KAAX,CAAiBuJ,GAAjB,CAAqB5J,SAAS,CAACK,KAAV,CAAgBtC,IAArC,CAAb;;AACA,UAAI4L,IAAI,KAAKpL,SAAb,EAAwB;AACvB,YAAMqH,MAAM,GAAG+D,IAAI,CAAC/H,IAAL,CAAU5B,SAAV,CAAf;AACA,YAAI4F,MAAM,KAAK,IAAf,EAAqB;AACrB;;AACD,WAAK0L,mBAAL,CAAyBtR,SAAS,CAACgO,IAAnC;AACA;;;WAED,8BAAqBhO,SAArB,EAAgC;AAC/B,WAAKwO,gBAAL,CAAsBxO,SAAS,CAACgO,IAAhC;AACA;;;WAED,2BAAkBhO,SAAlB,EAA6B;AAC5B,WAAK+N,cAAL,CAAoB/N,SAAS,CAACnC,MAA9B;AACA,WAAKyT,mBAAL,CAAyBtR,SAAS,CAACgO,IAAnC;AACA;;;WAED,gCAAuBhO,SAAvB,EAAkC;AACjC,WAAKuR,kBAAL,CAAwBvR,SAAS,CAACwR,KAAlC;AACA;;;WAED,6BAAoBxR,SAApB,EAA+B;AAC9B,WAAK+N,cAAL,CAAoB/N,SAAS,CAACyR,YAA9B;AACA,WAAKC,eAAL,CAAqB1R,SAAS,CAACwR,KAA/B;AACA;;;WAED,kCAAyBxR,SAAzB,EAAoC;AACnC,UAAIA,SAAS,CAACyI,QAAd,EAAwB,KAAKsF,cAAL,CAAoB/N,SAAS,CAACyI,QAA9B;AACxB;;;WAED,6BAAoBzI,SAApB,EAA+B;AAC9B,WAAK2R,wBAAL,CAA8B3R,SAA9B;AACA;;;WAED,4BAAmBA,SAAnB,EAA8B;AAC7B,WAAK2R,wBAAL,CAA8B3R,SAA9B;AACA;;;WAED,6BAAoBA,SAApB,EAA+B;AAC9B,WAAKwO,gBAAL,CAAsBxO,SAAS,CAAC4R,KAAhC;AACA,UAAI5R,SAAS,CAAC6R,OAAd,EAAuB,KAAKC,kBAAL,CAAwB9R,SAAS,CAAC6R,OAAlC;AACvB,UAAI7R,SAAS,CAAC+R,UAAd,EAA0B,KAAKvD,gBAAL,CAAsBxO,SAAS,CAAC+R,UAAhC;AAC1B;;;WAED,0BAAiB/R,SAAjB,EAA4B;AAC3B,UAAI,KAAKwC,KAAL,CAAWwP,KAAf,EAAsB;AACrB,aAAKtD,aAAL,CAAmB1O,SAAS,CAAC4R,KAA7B;AACA,OAFD,MAEO;AACN,aAAKpP,KAAL,CAAWwP,KAAX,GAAmB,IAAnB;AACA,aAAKtD,aAAL,CAAmB1O,SAAS,CAAC4R,KAA7B;AACA,aAAKpP,KAAL,CAAWwP,KAAX,GAAmB,KAAnB;AACA;;AACD,UAAIhS,SAAS,CAAC6R,OAAd,EAAuB,KAAKI,eAAL,CAAqBjS,SAAS,CAAC6R,OAA/B;AACvB,UAAI7R,SAAS,CAACkS,SAAd,EAAyB,KAAKxD,aAAL,CAAmB1O,SAAS,CAACkS,SAA7B;AACzB;;;WAED,+BAAsBlS,SAAtB,EAAiC;AAChC,WAAKwO,gBAAL,CAAsBxO,SAAS,CAACgO,IAAhC;AACA;;;WAED,4BAAmBhO,SAAnB,EAA8B;AAC7B,WAAK+N,cAAL,CAAoB/N,SAAS,CAAC0M,IAA9B;AACA,WAAK4E,mBAAL,CAAyBtR,SAAS,CAACgO,IAAnC;AACA;;;WAED,iCAAwBhO,SAAxB,EAAmC;AAClC,WAAKwO,gBAAL,CAAsBxO,SAAS,CAACgO,IAAhC;AACA;;;WAED,8BAAqBhO,SAArB,EAAgC;AAC/B,WAAKsR,mBAAL,CAAyBtR,SAAS,CAACgO,IAAnC;AACA,WAAKD,cAAL,CAAoB/N,SAAS,CAAC0M,IAA9B;AACA;;;WAED,6BAAoB1M,SAApB,EAA+B;AAC9B,UAAIA,SAAS,CAACmS,IAAd,EAAoB;AACnB,YAAInS,SAAS,CAACmS,IAAV,CAAe/T,IAAf,KAAwB,qBAA5B,EAAmD;AAClD,eAAKoQ,gBAAL,CAAsBxO,SAAS,CAACmS,IAAhC;AACA;AACD;;AACD,WAAK3D,gBAAL,CAAsBxO,SAAS,CAACgO,IAAhC;AACA;;;WAED,0BAAiBhO,SAAjB,EAA4B;AAAA;;AAC3B,WAAKkR,YAAL,CAAkB,YAAM;AACvB,YAAIlR,SAAS,CAACmS,IAAd,EAAoB;AACnB,cAAInS,SAAS,CAACmS,IAAV,CAAe/T,IAAf,KAAwB,qBAA5B,EAAmD;AAClD,YAAA,MAAI,CAACwR,+BAAL,CAAqC5P,SAAS,CAACmS,IAA/C;;AACA,YAAA,MAAI,CAACtP,aAAL,GAAqBtE,SAArB;;AACA,YAAA,MAAI,CAACmQ,aAAL,CAAmB1O,SAAS,CAACmS,IAA7B;AACA,WAJD,MAIO;AACN,YAAA,MAAI,CAACpE,cAAL,CAAoB/N,SAAS,CAACmS,IAA9B;AACA;AACD;;AACD,YAAInS,SAAS,CAAC0M,IAAd,EAAoB;AACnB,UAAA,MAAI,CAACqB,cAAL,CAAoB/N,SAAS,CAAC0M,IAA9B;AACA;;AACD,YAAI1M,SAAS,CAACoS,MAAd,EAAsB;AACrB,UAAA,MAAI,CAACrE,cAAL,CAAoB/N,SAAS,CAACoS,MAA9B;AACA;;AACD,YAAMpE,IAAI,GAAGhO,SAAS,CAACgO,IAAvB;;AACA,YAAIA,IAAI,CAAC5P,IAAL,KAAc,gBAAlB,EAAoC;AACnC;AACA,cAAM+S,IAAI,GAAG,MAAI,CAACtO,aAAlB;;AACA,UAAA,MAAI,CAACuO,sBAAL,CAA4BpD,IAAI,CAACA,IAAjC;;AACA,UAAA,MAAI,CAACnL,aAAL,GAAqBsO,IAArB;;AACA,UAAA,MAAI,CAACE,cAAL,CAAoBrD,IAAI,CAACA,IAAzB;AACA,SAND,MAMO;AACN,UAAA,MAAI,CAACsD,mBAAL,CAAyBtD,IAAzB;AACA;AACD,OA1BD;AA2BA;;;WAED,+BAAsBhO,SAAtB,EAAiC;AAChC,UAAIA,SAAS,CAAC0E,IAAV,CAAetG,IAAf,KAAwB,qBAA5B,EAAmD;AAClD,aAAKiR,0BAAL,CAAgCrP,SAAS,CAAC0E,IAA1C;AACA;;AACD,WAAK8J,gBAAL,CAAsBxO,SAAS,CAACgO,IAAhC;AACA;;;WAED,4BAAmBhO,SAAnB,EAA8B;AAAA;;AAC7B,WAAKkR,YAAL,CAAkB,YAAM;AACvB,YAAIlR,SAAS,CAAC0E,IAAV,CAAetG,IAAf,KAAwB,qBAA5B,EAAmD;AAClD,UAAA,MAAI,CAACwR,+BAAL,CAAqC5P,SAAS,CAAC0E,IAA/C;;AACA,UAAA,MAAI,CAACoM,uBAAL,CAA6B9Q,SAAS,CAAC0E,IAAvC;AACA,SAHD,MAGO;AACN,UAAA,MAAI,CAAC2N,WAAL,CAAiBrS,SAAS,CAAC0E,IAA3B;AACA;;AACD,QAAA,MAAI,CAACqJ,cAAL,CAAoB/N,SAAS,CAACkF,KAA9B;;AACA,YAAM8I,IAAI,GAAGhO,SAAS,CAACgO,IAAvB;;AACA,YAAIA,IAAI,CAAC5P,IAAL,KAAc,gBAAlB,EAAoC;AACnC;AACA,cAAM+S,IAAI,GAAG,MAAI,CAACtO,aAAlB;;AACA,UAAA,MAAI,CAACuO,sBAAL,CAA4BpD,IAAI,CAACA,IAAjC;;AACA,UAAA,MAAI,CAACnL,aAAL,GAAqBsO,IAArB;;AACA,UAAA,MAAI,CAACE,cAAL,CAAoBrD,IAAI,CAACA,IAAzB;AACA,SAND,MAMO;AACN,UAAA,MAAI,CAACsD,mBAAL,CAAyBtD,IAAzB;AACA;AACD,OAlBD;AAmBA;;;WAED,+BAAsBhO,SAAtB,EAAiC;AAChC,UAAIA,SAAS,CAACsS,KAAV,IAAmB,KAAK9P,KAAL,CAAW4L,aAAX,KAA6B,IAApD,EAA0D;AACzD,aAAK/O,KAAL,CAAWsC,aAAX,CAAyBC,IAAzB,CAA8B5B,SAA9B;AACA;;AACD,UAAIA,SAAS,CAAC0E,IAAV,CAAetG,IAAf,KAAwB,qBAA5B,EAAmD;AAClD,aAAKiR,0BAAL,CAAgCrP,SAAS,CAAC0E,IAA1C;AACA;;AACD,WAAK8J,gBAAL,CAAsBxO,SAAS,CAACgO,IAAhC;AACA;;;WAED,4BAAmBhO,SAAnB,EAA8B;AAAA;;AAC7B,WAAKkR,YAAL,CAAkB,YAAM;AACvB,YAAIlR,SAAS,CAAC0E,IAAV,CAAetG,IAAf,KAAwB,qBAA5B,EAAmD;AAClD,UAAA,MAAI,CAACwR,+BAAL,CAAqC5P,SAAS,CAAC0E,IAA/C;;AACA,UAAA,MAAI,CAACoM,uBAAL,CAA6B9Q,SAAS,CAAC0E,IAAvC;AACA,SAHD,MAGO;AACN,UAAA,MAAI,CAAC2N,WAAL,CAAiBrS,SAAS,CAAC0E,IAA3B;AACA;;AACD,QAAA,MAAI,CAACqJ,cAAL,CAAoB/N,SAAS,CAACkF,KAA9B;;AACA,YAAM8I,IAAI,GAAGhO,SAAS,CAACgO,IAAvB;;AACA,YAAIA,IAAI,CAAC5P,IAAL,KAAc,gBAAlB,EAAoC;AACnC;AACA,cAAM+S,IAAI,GAAG,MAAI,CAACtO,aAAlB;;AACA,UAAA,MAAI,CAACuO,sBAAL,CAA4BpD,IAAI,CAACA,IAAjC;;AACA,UAAA,MAAI,CAACnL,aAAL,GAAqBsO,IAArB;;AACA,UAAA,MAAI,CAACE,cAAL,CAAoBrD,IAAI,CAACA,IAAzB;AACA,SAND,MAMO;AACN,UAAA,MAAI,CAACsD,mBAAL,CAAyBtD,IAAzB;AACA;AACD,OAlBD;AAmBA,K,CAED;;;;WACA,oCAA2BhO,SAA3B,EAAsC;AACrC,UAAIA,SAAS,CAACuS,EAAd,EAAkB;AACjB,aAAKC,cAAL,CAAoBxS,SAAS,CAACuS,EAAV,CAAaxU,IAAjC;AACA;AACD;;;WAED,iCAAwBiC,SAAxB,EAAmC;AAAA;;AAClC,UAAMmO,WAAW,GAAG,KAAK3L,KAAL,CAAW4L,aAA/B;AACA,WAAK5L,KAAL,CAAW4L,aAAX,GAA2B,KAA3B;AACA,WAAKqE,eAAL,CAAqB,IAArB,EAA2BzS,SAAS,CAAC0S,MAArC,EAA6C,YAAM;AAAA,oDAC9B1S,SAAS,CAAC0S,MADoB;AAAA;;AAAA;AAClD,iEAAsC;AAAA,gBAA3BtI,KAA2B;;AACrC,YAAA,MAAI,CAACiI,WAAL,CAAiBjI,KAAjB;AACA;AAHiD;AAAA;AAAA;AAAA;AAAA;;AAIlD,YAAIpK,SAAS,CAACgO,IAAV,CAAe5P,IAAf,KAAwB,gBAA5B,EAA8C;AAC7C,UAAA,MAAI,CAACuU,UAAL,CAAgB3S,SAAS,CAACgO,IAAV,CAAeA,IAA/B;;AACA,cAAMmD,IAAI,GAAG,MAAI,CAACtO,aAAlB;;AACA,UAAA,MAAI,CAAC2L,gBAAL,CAAsBxO,SAAS,CAACgO,IAAhC;;AACA,UAAA,MAAI,CAACnL,aAAL,GAAqBsO,IAArB;;AACA,UAAA,MAAI,CAACzC,aAAL,CAAmB1O,SAAS,CAACgO,IAA7B;AACA,SAND,MAMO;AACN,UAAA,MAAI,CAACD,cAAL,CAAoB/N,SAAS,CAACgO,IAA9B;AACA;AACD,OAbD;AAcA,WAAKxL,KAAL,CAAW4L,aAAX,GAA2BD,WAA3B;AACA;;;WAED,uCAA8BnO,SAA9B,EAAyC;AACxC,UAAM4S,MAAM,GAAG5S,SAAS,CAAC4S,MAAV,CAAiBxP,KAAhC;AACA,WAAK/D,KAAL,CAAWiB,MAAX,CAAkBsB,IAAlB,CAAuB5B,SAAvB,EAAkC4S,MAAlC;;AAFwC,kDAGhB5S,SAAS,CAAC6S,UAHM;AAAA;;AAAA;AAGxC,+DAA8C;AAAA,cAAnCC,SAAmC;AAC7C,cAAM/U,IAAI,GAAG+U,SAAS,CAACC,KAAV,CAAgBhV,IAA7B;;AACA,kBAAQ+U,SAAS,CAAC1U,IAAlB;AACC,iBAAK,wBAAL;AACC,kBACC,CAAC,KAAKiB,KAAL,CAAWkB,eAAX,CAA2BqB,IAA3B,CAAgC5B,SAAhC,EAA2C4S,MAA3C,EAAmD,SAAnD,EAA8D7U,IAA9D,CADF,EAEE;AACD,qBAAKyU,cAAL,CAAoBzU,IAApB;AACA;;AACD;;AACD,iBAAK,iBAAL;AACC,kBACC,CAAC,KAAKsB,KAAL,CAAWkB,eAAX,CAA2BqB,IAA3B,CACA5B,SADA,EAEA4S,MAFA,EAGAE,SAAS,CAACE,QAAV,CAAmBjV,IAHnB,EAIAA,IAJA,CADF,EAOE;AACD,qBAAKyU,cAAL,CAAoBzU,IAApB;AACA;;AACD;;AACD,iBAAK,0BAAL;AACC,kBAAI,CAAC,KAAKsB,KAAL,CAAWkB,eAAX,CAA2BqB,IAA3B,CAAgC5B,SAAhC,EAA2C4S,MAA3C,EAAmD,IAAnD,EAAyD7U,IAAzD,CAAL,EAAqE;AACpE,qBAAKyU,cAAL,CAAoBzU,IAApB;AACA;;AACD;;AACD;AACC,mBAAKyU,cAAL,CAAoBzU,IAApB;AA1BF;AA4BA;AAjCuC;AAAA;AAAA;AAAA;AAAA;AAkCxC;;;WAED,0BAAiBkV,WAAjB,EAA8BC,OAA9B,EAAuC;AACtC,cAAQD,WAAW,CAAC7U,IAApB;AACC,aAAK,qBAAL;AAAA,sDAC0B6U,WAAW,CAACE,YADtC;AAAA;;AAAA;AACC,mEAAmD;AAAA,kBAAxCpS,UAAwC;;AAClD,sBAAQA,UAAU,CAAC3C,IAAnB;AACC,qBAAK,oBAAL;AAA2B;AAC1B,yBAAKgV,YAAL,CAAkBrS,UAAU,CAACwR,EAA7B,EAAiCW,OAAjC;AACA;AACA;AAJF;AAMA;AARF;AAAA;AAAA;AAAA;AAAA;;AASC;;AACD,aAAK,qBAAL;AACC,eAAKE,YAAL,CAAkBH,WAAW,CAACV,EAA9B,EAAkCW,OAAlC;AACA;;AACD,aAAK,kBAAL;AACC,eAAKE,YAAL,CAAkBH,WAAW,CAACV,EAA9B,EAAkCW,OAAlC;AACA;AAhBF;AAkBA;;;WAED,4CAAmClT,SAAnC,EAA8C;AAAA;;AAC7C,UAAI4S,MAAJ;;AACA,UAAI5S,SAAS,CAAC4S,MAAd,EAAsB;AACrBA,QAAAA,MAAM,GAAG5S,SAAS,CAAC4S,MAAV,CAAiBxP,KAA1B;AACA,aAAK/D,KAAL,CAAWoB,YAAX,CAAwBmB,IAAxB,CAA6B5B,SAA7B,EAAwC4S,MAAxC;AACA,OAHD,MAGO;AACN,aAAKvT,KAAL,CAAWmB,MAAX,CAAkBoB,IAAlB,CAAuB5B,SAAvB;AACA;;AACD,UAAIA,SAAS,CAACiT,WAAd,EAA2B;AAC1B,YACC,CAAC,KAAK5T,KAAL,CAAWqB,iBAAX,CAA6BkB,IAA7B,CAAkC5B,SAAlC,EAA6CA,SAAS,CAACiT,WAAvD,CADF,EAEE;AACD,cAAM9B,IAAI,GAAG,KAAKtO,aAAlB;AACA,eAAK2L,gBAAL,CAAsBxO,SAAS,CAACiT,WAAhC;AACA,eAAKpQ,aAAL,GAAqBsO,IAArB;AACA,eAAK1C,qBAAL,CAA2BzO,SAAS,CAACiT,WAArC;AACA,cAAI3E,KAAK,GAAG,CAAZ;AACA,eAAK+E,gBAAL,CAAsBrT,SAAS,CAACiT,WAAhC,EAA6C,UAAAK,GAAG,EAAI;AACnD,YAAA,MAAI,CAACjU,KAAL,CAAWuB,eAAX,CAA2BgB,IAA3B,CAAgC5B,SAAhC,EAA2CsT,GAA3C,EAAgDA,GAAhD,EAAqDhF,KAAK,EAA1D;AACA,WAFD;AAGA;AACD;;AACD,UAAItO,SAAS,CAAC6S,UAAd,EAA0B;AACzB,aACC,IAAIU,cAAc,GAAG,CADtB,EAECA,cAAc,GAAGvT,SAAS,CAAC6S,UAAV,CAAqB5U,MAFvC,EAGCsV,cAAc,EAHf,EAIE;AACD,cAAMT,SAAS,GAAG9S,SAAS,CAAC6S,UAAV,CAAqBU,cAArB,CAAlB;;AACA,kBAAQT,SAAS,CAAC1U,IAAlB;AACC,iBAAK,iBAAL;AAAwB;AACvB,oBAAML,IAAI,GAAG+U,SAAS,CAACU,QAAV,CAAmBzV,IAAhC;;AACA,oBAAI6U,MAAJ,EAAY;AACX,uBAAKvT,KAAL,CAAWwB,qBAAX,CAAiCe,IAAjC,CACC5B,SADD,EAEC4S,MAFD,EAGCE,SAAS,CAACC,KAAV,CAAgBhV,IAHjB,EAICA,IAJD,EAKCwV,cALD;AAOA,iBARD,MAQO;AACN,uBAAKlU,KAAL,CAAWuB,eAAX,CAA2BgB,IAA3B,CACC5B,SADD,EAEC8S,SAAS,CAACC,KAAV,CAAgBhV,IAFjB,EAGCA,IAHD,EAICwV,cAJD;AAMA;;AACD;AACA;AApBF;AAsBA;AACD;AACD;;;WAED,oCAA2BvT,SAA3B,EAAsC;AACrC,UAAIA,SAAS,CAACiT,WAAd,EAA2B;AAC1B,aAAKvE,aAAL,CAAmB1O,SAAS,CAACiT,WAA7B;AACA;AACD;;;WAED,8CAAqCjT,SAArC,EAAgD;AAC/C,UAAMmR,IAAI,GAAG,KAAKtO,aAAlB;AACA,WAAK2L,gBAAL,CAAsBxO,SAAS,CAACiT,WAAhC;AACA,WAAKpQ,aAAL,GAAqBsO,IAArB;AACA,WAAK1C,qBAAL,CAA2BzO,SAAS,CAACiT,WAArC;;AACA,UACCjT,SAAS,CAACiT,WAAV,CAAsBV,EAAtB,IACAvS,SAAS,CAACiT,WAAV,CAAsB7U,IAAtB,KAA+B,oBAD/B,IAEA4B,SAAS,CAACiT,WAAV,CAAsB7U,IAAtB,KAA+B,iBAHhC,EAIE;AACD,aAAKiB,KAAL,CAAWuB,eAAX,CAA2BgB,IAA3B,CACC5B,SADD,EAECA,SAAS,CAACiT,WAAV,CAAsBV,EAAtB,CAAyBxU,IAF1B,EAGC,SAHD,EAICQ,SAJD;AAMA;AACD;;;WAED,sCAA6ByB,SAA7B,EAAwC;AACvC,WAAKX,KAAL,CAAWmB,MAAX,CAAkBoB,IAAlB,CAAuB5B,SAAvB;;AACA,UACCA,SAAS,CAACiT,WAAV,CAAsBV,EAAtB,IACAvS,SAAS,CAACiT,WAAV,CAAsB7U,IAAtB,KAA+B,oBAD/B,IAEA4B,SAAS,CAACiT,WAAV,CAAsB7U,IAAtB,KAA+B,iBAHhC,EAIE;AACD,YACC,CAAC,KAAKiB,KAAL,CAAWqB,iBAAX,CAA6BkB,IAA7B,CAAkC5B,SAAlC,EAA6CA,SAAS,CAACiT,WAAvD,CADF,EAEE;AACD,eAAKvE,aAAL,CAAmB1O,SAAS,CAACiT,WAA7B;AACA;AACD,OAVD,MAUO;AACN;AACA;AACA;AACA,YACCjT,SAAS,CAACiT,WAAV,CAAsB7U,IAAtB,KAA+B,qBAA/B,IACA4B,SAAS,CAACiT,WAAV,CAAsB7U,IAAtB,KAA+B,kBAFhC,EAGE;AACD,eAAKsQ,aAAL,CAAmB1O,SAAS,CAACiT,WAA7B;AACA,SALD,MAKO;AACN,eAAKlF,cAAL,CAAoB/N,SAAS,CAACiT,WAA9B;AACA;;AACD,YAAI,CAAC,KAAK5T,KAAL,CAAWsB,gBAAX,CAA4BiB,IAA5B,CAAiC5B,SAAjC,EAA4CA,SAAS,CAACiT,WAAtD,CAAL,EAAyE;AACxE,eAAK5T,KAAL,CAAWuB,eAAX,CAA2BgB,IAA3B,CACC5B,SADD,EAECA,SAAS,CAACiT,WAFX,EAGC,SAHD,EAIC1U,SAJD;AAMA;AACD;AACD;;;WAED,0CAAiCyB,SAAjC,EAA4C;AAC3C,UAAM4S,MAAM,GAAG5S,SAAS,CAAC4S,MAAV,CAAiBxP,KAAhC;AACA,UAAMrF,IAAI,GAAGiC,SAAS,CAACwT,QAAV,GAAqBxT,SAAS,CAACwT,QAAV,CAAmBzV,IAAxC,GAA+C,IAA5D;AACA,WAAKsB,KAAL,CAAWoB,YAAX,CAAwBmB,IAAxB,CAA6B5B,SAA7B,EAAwC4S,MAAxC;AACA,WAAKvT,KAAL,CAAWwB,qBAAX,CAAiCe,IAAjC,CAAsC5B,SAAtC,EAAiD4S,MAAjD,EAAyD,IAAzD,EAA+D7U,IAA/D,EAAqE,CAArE;AACA;;;WAED,oCAA2BiC,SAA3B,EAAsC;AACrC,UAAIA,SAAS,CAAC8K,IAAV,KAAmB,KAAvB,EAA8B;;AAC9B,WAAK2I,2BAAL,CAAiCzT,SAAjC,EAA4C,KAAKX,KAAL,CAAW8B,iBAAvD;AACA;;;WAED,yCAAgCnB,SAAhC,EAA2C;AAC1C,UAAIA,SAAS,CAAC8K,IAAV,KAAmB,KAAvB,EAA8B;AAC9B,UAAM4I,OAAO,GACZ1T,SAAS,CAAC8K,IAAV,KAAmB,OAAnB,GACG,KAAKzL,KAAL,CAAW6B,mBADd,GAEG,KAAK7B,KAAL,CAAW4B,iBAHf;;AAIA,WAAKwS,2BAAL,CAAiCzT,SAAjC,EAA4C0T,OAA5C;AACA;;;WAED,qCAA4B1T,SAA5B,EAAuC0T,OAAvC,EAAgD;AAAA;;AAAA,kDACtB1T,SAAS,CAACmT,YADY;AAAA;;AAAA;AAC/C,+DAAiD;AAAA,cAAtCpS,UAAsC;;AAChD,kBAAQA,UAAU,CAAC3C,IAAnB;AACC,iBAAK,oBAAL;AAA2B;AAC1B,oBAAI,CAAC,KAAKiB,KAAL,CAAWyB,aAAX,CAAyBc,IAAzB,CAA8Bb,UAA9B,EAA0Cf,SAA1C,CAAL,EAA2D;AAC1D,uBAAKoT,YAAL,CAAkBrS,UAAU,CAACwR,EAA7B,EAAiC,UAACxU,IAAD,EAAO4V,IAAP,EAAgB;AAChD,wBAAIhK,IAAI,GAAG+J,OAAO,CAAC9J,GAAR,CAAY7L,IAAZ,CAAX;;AACA,wBAAI4L,IAAI,KAAKpL,SAAT,IAAsB,CAACoL,IAAI,CAAC/H,IAAL,CAAU+R,IAAV,CAA3B,EAA4C;AAC3ChK,sBAAAA,IAAI,GAAG,MAAI,CAACtK,KAAL,CAAW2B,cAAX,CAA0B4I,GAA1B,CAA8B7L,IAA9B,CAAP;;AACA,0BAAI4L,IAAI,KAAKpL,SAAT,IAAsB,CAACoL,IAAI,CAAC/H,IAAL,CAAU+R,IAAV,CAA3B,EAA4C;AAC3C,wBAAA,MAAI,CAACnB,cAAL,CAAoBzU,IAApB;AACA;AACD;AACD,mBARD;AASA;;AACD;AACA;AAdF;AAgBA;AAlB8C;AAAA;AAAA;AAAA;AAAA;AAmB/C;;;WAED,iCAAwBiC,SAAxB,EAAmC;AAAA,kDACTA,SAAS,CAACmT,YADD;AAAA;;AAAA;AAClC,+DAAiD;AAAA,cAAtCpS,UAAsC;;AAChD,kBAAQA,UAAU,CAAC3C,IAAnB;AACC,iBAAK,oBAAL;AAA2B;AAC1B,oBAAMwV,gBAAgB,GACrB7S,UAAU,CAACoR,IAAX,IAAmB,KAAK0B,mBAAL,CAAyB9S,UAAU,CAACoR,IAApC,CADpB;;AAEA,oBAAIyB,gBAAgB,IAAI7S,UAAU,CAACwR,EAAX,CAAcnU,IAAd,KAAuB,YAA/C,EAA6D;AAC5D,sBAAMuL,IAAI,GAAG,KAAKtK,KAAL,CAAWgC,SAAX,CAAqBuI,GAArB,CAAyBgK,gBAAzB,CAAb;;AACA,sBAAIjK,IAAI,KAAKpL,SAAT,IAAsBoL,IAAI,CAAC/H,IAAL,CAAUb,UAAU,CAACoR,IAArB,CAA1B,EAAsD;AACrD;AACA,wBAAMxI,KAAI,GAAG,KAAKtK,KAAL,CAAWiC,MAAX,CAAkBsI,GAAlB,CAAsBgK,gBAAtB,CAAb;;AACA,wBAAIjK,KAAI,KAAKpL,SAAT,IAAsB,CAACoL,KAAI,CAAC/H,IAAL,CAAUb,UAAU,CAACoR,IAArB,CAA3B,EAAuD;AACtD,2BAAK2B,WAAL,CAAiB/S,UAAU,CAACwR,EAAX,CAAcxU,IAA/B,EAAqC6V,gBAArC;AACA;;AACD;AACA;AACD;;AACD,oBAAI,CAAC,KAAKvU,KAAL,CAAW0B,UAAX,CAAsBa,IAAtB,CAA2Bb,UAA3B,EAAuCf,SAAvC,CAAL,EAAwD;AACvD,uBAAKqS,WAAL,CAAiBtR,UAAU,CAACwR,EAA5B;AACA,sBAAIxR,UAAU,CAACoR,IAAf,EAAqB,KAAKpE,cAAL,CAAoBhN,UAAU,CAACoR,IAA/B;AACrB;;AACD;AACA;AApBF;AAsBA;AAxBiC;AAAA;AAAA;AAAA;AAAA;AAyBlC;;;WAED,sCAA6BnS,SAA7B,EAAwC;AACvC,UAAIA,SAAS,CAACuS,EAAd,EAAkB;AACjB,aAAKC,cAAL,CAAoBxS,SAAS,CAACuS,EAAV,CAAaxU,IAAjC;AACA;AACD;;;WAED,8BAAqBiC,SAArB,EAAgC;AAC/B,WAAK+T,SAAL,CAAe/T,SAAf;AACA;;;WAED,4BAAmBgU,WAAnB,EAAgC;AAC/B,WAAK,IAAI1F,KAAK,GAAG,CAAZ,EAAeC,GAAG,GAAGyF,WAAW,CAAC/V,MAAtC,EAA8CqQ,KAAK,GAAGC,GAAtD,EAA2DD,KAAK,EAAhE,EAAoE;AACnE,YAAM2F,UAAU,GAAGD,WAAW,CAAC1F,KAAD,CAA9B;AACA,aAAK2C,iBAAL,CAAuBgD,UAAU,CAACrH,UAAlC;AACA;AACD;;;WAED,yBAAgBoH,WAAhB,EAA6B;AAAA;;AAC5B,WAAK9C,YAAL,CAAkB,YAAM;AACvB,YAAM3C,GAAG,GAAGyF,WAAW,CAAC/V,MAAxB,CADuB,CAGvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,aAAK,IAAIqQ,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGC,GAA5B,EAAiCD,KAAK,EAAtC,EAA0C;AACzC,cAAM2F,UAAU,GAAGD,WAAW,CAAC1F,KAAD,CAA9B;;AAEA,cAAI2F,UAAU,CAACrH,UAAX,CAAsB3O,MAAtB,GAA+B,CAAnC,EAAsC;AACrC,gBAAMkT,IAAI,GAAG,OAAI,CAACtO,aAAlB;;AACA,YAAA,OAAI,CAACuO,sBAAL,CAA4B6C,UAAU,CAACrH,UAAvC;;AACA,YAAA,OAAI,CAAC/J,aAAL,GAAqBsO,IAArB;AACA;AACD;;AAED,aAAK,IAAI7C,MAAK,GAAG,CAAjB,EAAoBA,MAAK,GAAGC,GAA5B,EAAiCD,MAAK,EAAtC,EAA0C;AACzC,cAAM2F,WAAU,GAAGD,WAAW,CAAC1F,MAAD,CAA9B;;AAEA,cAAI2F,WAAU,CAACvH,IAAf,EAAqB;AACpB,YAAA,OAAI,CAACqB,cAAL,CAAoBkG,WAAU,CAACvH,IAA/B;AACA;;AACD,cAAIuH,WAAU,CAACrH,UAAX,CAAsB3O,MAAtB,GAA+B,CAAnC,EAAsC;AACrC,YAAA,OAAI,CAACoT,cAAL,CAAoB4C,WAAU,CAACrH,UAA/B;AACA;AACD;AACD,OA/BD;AAgCA;;;WAED,4BAAmBsH,WAAnB,EAAgC;AAC/B,WAAK1F,gBAAL,CAAsB0F,WAAW,CAAClG,IAAlC;AACA;;;WAED,yBAAgBkG,WAAhB,EAA6B;AAAA;;AAC5B,WAAKhD,YAAL,CAAkB,YAAM;AACvB;AACA,YAAIgD,WAAW,CAAC9J,KAAZ,KAAsB,IAA1B,EAAgC;AAC/B,UAAA,OAAI,CAACgJ,YAAL,CAAkBc,WAAW,CAAC9J,KAA9B,EAAqC,UAAA+J,KAAK,EAAI;AAC7C,YAAA,OAAI,CAAC3B,cAAL,CAAoB2B,KAApB;AACA,WAFD;;AAGA,UAAA,OAAI,CAAC9B,WAAL,CAAiB6B,WAAW,CAAC9J,KAA7B;AACA;;AACD,YAAM+G,IAAI,GAAG,OAAI,CAACtO,aAAlB;;AACA,QAAA,OAAI,CAAC4L,qBAAL,CAA2ByF,WAAW,CAAClG,IAAvC;;AACA,QAAA,OAAI,CAACnL,aAAL,GAAqBsO,IAArB;;AACA,QAAA,OAAI,CAACzC,aAAL,CAAmBwF,WAAW,CAAClG,IAA/B;AACA,OAZD;AAaA;;;WAED,qBAAY5M,OAAZ,EAAqB;AACpB,cAAQA,OAAO,CAAChD,IAAhB;AACC,aAAK,cAAL;AACC,eAAKgW,gBAAL,CAAsBhT,OAAtB;AACA;;AACD,aAAK,mBAAL;AACC,eAAKiT,qBAAL,CAA2BjT,OAA3B;AACA;;AACD,aAAK,kBAAL;AACC,eAAKkT,oBAAL,CAA0BlT,OAA1B;AACA;;AACD,aAAK,eAAL;AACC,eAAKmT,iBAAL,CAAuBnT,OAAvB;AACA;;AACD,aAAK,aAAL;AACC,eAAKoT,eAAL,CAAqBpT,OAArB;AACA;AAfF;AAiBA;;;WAED,+BAAsBA,OAAtB,EAA+B;AAC9B,WAAK2M,cAAL,CAAoB3M,OAAO,CAAC8D,KAA5B;AACA,WAAKmN,WAAL,CAAiBjR,OAAO,CAACsD,IAAzB;AACA;;;WAED,2BAAkBtD,OAAlB,EAA2B;AAC1B,WAAK,IAAIpD,CAAC,GAAG,CAAR,EAAWuQ,GAAG,GAAGnN,OAAO,CAACqT,UAAR,CAAmBxW,MAAzC,EAAiDD,CAAC,GAAGuQ,GAArD,EAA0DvQ,CAAC,EAA3D,EAA+D;AAC9D,YAAM0W,IAAI,GAAGtT,OAAO,CAACqT,UAAR,CAAmBzW,CAAnB,CAAb;;AACA,YAAI0W,IAAJ,EAAU;AACT,cAAIA,IAAI,CAACvK,QAAT,EAAmB,KAAK4D,cAAL,CAAoB2G,IAAI,CAACxG,GAAzB;AACnB,cAAIwG,IAAI,CAACtR,KAAT,EAAgB,KAAKiP,WAAL,CAAiBqC,IAAI,CAACtR,KAAtB;AAChB;AACD;AACD;;;WAED,0BAAiBhC,OAAjB,EAA0B;AACzB,WAAK,IAAIpD,CAAC,GAAG,CAAR,EAAWuQ,GAAG,GAAGnN,OAAO,CAAC8L,QAAR,CAAiBjP,MAAvC,EAA+CD,CAAC,GAAGuQ,GAAnD,EAAwDvQ,CAAC,EAAzD,EAA6D;AAC5D,YAAMoP,OAAO,GAAGhM,OAAO,CAAC8L,QAAR,CAAiBlP,CAAjB,CAAhB;AACA,YAAIoP,OAAJ,EAAa,KAAKiF,WAAL,CAAiBjF,OAAjB;AACb;AACD;;;WAED,yBAAgBhM,OAAhB,EAAyB;AACxB,WAAKiR,WAAL,CAAiBjR,OAAO,CAACqH,QAAzB;AACA;;;WAED,yBAAgB2C,WAAhB,EAA6B;AAAA,kDACHA,WADG;AAAA;;AAAA;AAC5B,+DAAsC;AAAA,cAA3BjN,UAA2B;;AACrC,cAAIA,UAAJ,EAAgB;AACf,iBAAK4P,cAAL,CAAoB5P,UAApB;AACA;AACD;AAL2B;AAAA;AAAA;AAAA;AAAA;AAM5B;;;WAED,wBAAeA,UAAf,EAA2B;AAC1B,cAAQA,UAAU,CAACC,IAAnB;AACC,aAAK,iBAAL;AACC,eAAKuW,mBAAL,CAAyBxW,UAAzB;AACA;;AACD,aAAK,yBAAL;AACC,eAAKyW,2BAAL,CAAiCzW,UAAjC;AACA;;AACD,aAAK,sBAAL;AACC,eAAK0W,wBAAL,CAA8B1W,UAA9B;AACA;;AACD,aAAK,iBAAL;AACC,eAAK2W,mBAAL,CAAyB3W,UAAzB;AACA;;AACD,aAAK,kBAAL;AACC,eAAK4W,oBAAL,CAA0B5W,UAA1B;AACA;;AACD,aAAK,gBAAL;AACC,eAAK6W,kBAAL,CAAwB7W,UAAxB;AACA;;AACD,aAAK,iBAAL;AACC,eAAK8W,mBAAL,CAAyB9W,UAAzB;AACA;;AACD,aAAK,iBAAL;AACC,eAAK+W,mBAAL,CAAyB/W,UAAzB;AACA;;AACD,aAAK,uBAAL;AACC,eAAKgX,yBAAL,CAA+BhX,UAA/B;AACA;;AACD,aAAK,oBAAL;AACC,eAAKiX,sBAAL,CAA4BjX,UAA5B;AACA;;AACD,aAAK,YAAL;AACC,eAAKkX,cAAL,CAAoBlX,UAApB;AACA;;AACD,aAAK,kBAAL;AACC,eAAKmX,oBAAL,CAA0BnX,UAA1B;AACA;;AACD,aAAK,mBAAL;AACC,eAAKoX,qBAAL,CAA2BpX,UAA3B;AACA;;AACD,aAAK,cAAL;AACC,eAAKqX,gBAAL,CAAsBrX,UAAtB;AACA;;AACD,aAAK,kBAAL;AACC,eAAKmW,oBAAL,CAA0BnW,UAA1B;AACA;;AACD,aAAK,eAAL;AACC,eAAKsX,iBAAL,CAAuBtX,UAAvB;AACA;;AACD,aAAK,kBAAL;AACC,eAAKuX,oBAAL,CAA0BvX,UAA1B;AACA;;AACD,aAAK,oBAAL;AACC,eAAKwX,sBAAL,CAA4BxX,UAA5B;AACA;;AACD,aAAK,eAAL;AACC,eAAKyX,iBAAL,CAAuBzX,UAAvB;AACA;;AACD,aAAK,0BAAL;AACC,eAAK0X,4BAAL,CAAkC1X,UAAlC;AACA;;AACD,aAAK,iBAAL;AACC,eAAK2X,mBAAL,CAAyB3X,UAAzB;AACA;;AACD,aAAK,gBAAL;AACC,eAAK4X,kBAAL,CAAwB5X,UAAxB;AACA;;AACD,aAAK,iBAAL;AACC,eAAK6X,mBAAL,CAAyB7X,UAAzB;AACA;;AACD,aAAK,kBAAL;AACC,eAAK8X,oBAAL,CAA0B9X,UAA1B;AACA;;AACD,aAAK,iBAAL;AACC,eAAK+X,mBAAL,CAAyB/X,UAAzB;AACA;AA3EF;AA6EA;;;WAED,6BAAoBA,UAApB,EAAgC;AAC/B,UAAI,KAAKqE,KAAL,CAAW4L,aAAX,KAA6B,IAAjC,EACC,KAAK/O,KAAL,CAAWsC,aAAX,CAAyBC,IAAzB,CAA8BzD,UAA9B;AACD,WAAK4P,cAAL,CAAoB5P,UAAU,CAACsK,QAA/B;AACA;;;WAED,6BAAoBtK,UAApB,EAAgC;AAC/B,UAAIA,UAAU,CAAC+O,QAAf,EAAyB;AACxB,aAAKiJ,eAAL,CAAqBhY,UAAU,CAAC+O,QAAhC;AACA;AACD;;;WAED,2BAAkB/O,UAAlB,EAA8B;AAC7B,UAAIA,UAAU,CAACsK,QAAf,EAAyB;AACxB,aAAKsF,cAAL,CAAoB5P,UAAU,CAACsK,QAA/B;AACA;AACD;;;WAED,8BAAqBtK,UAArB,EAAiC;AAChC,WACC,IAAIiY,SAAS,GAAG,CAAhB,EAAmB7H,GAAG,GAAGpQ,UAAU,CAACsW,UAAX,CAAsBxW,MADhD,EAECmY,SAAS,GAAG7H,GAFb,EAGC6H,SAAS,EAHV,EAIE;AACD,YAAM1B,IAAI,GAAGvW,UAAU,CAACsW,UAAX,CAAsB2B,SAAtB,CAAb;AACA,aAAKC,YAAL,CAAkB3B,IAAlB;AACA;AACD;;;WAED,sBAAaA,IAAb,EAAmB;AAClB,UAAIA,IAAI,CAACtW,IAAL,KAAc,eAAlB,EAAmC;AAClC,aAAK2P,cAAL,CAAoB2G,IAAI,CAACjM,QAAzB;AACA;AACA;;AACD,UAAIiM,IAAI,CAACvK,QAAT,EAAmB;AAClB,aAAK4D,cAAL,CAAoB2G,IAAI,CAACxG,GAAzB;AACA;;AACD,UAAIwG,IAAI,CAAC4B,SAAL,IAAkB5B,IAAI,CAACtR,KAAvB,IAAgCsR,IAAI,CAACtR,KAAL,CAAWhF,IAAX,KAAoB,YAAxD,EAAsE;AACrE,aAAKoE,KAAL,CAAW+T,WAAX,GAAyB7B,IAAI,CAACtR,KAAL,CAAWrF,IAApC;AACA,aAAKsX,cAAL,CAAoBX,IAAI,CAACtR,KAAzB;AACA,aAAKZ,KAAL,CAAW+T,WAAX,GAAyB,KAAzB;AACA,OAJD,MAIO;AACN,aAAKxI,cAAL,CAAoB2G,IAAI,CAACtR,KAAzB;AACA;AACD;;;WAED,gCAAuBjF,UAAvB,EAAmC;AAAA;;AAClC,UAAMgQ,WAAW,GAAG,KAAK3L,KAAL,CAAW4L,aAA/B;AACA,WAAK5L,KAAL,CAAW4L,aAAX,GAA2B,KAA3B;AACA,UAAMoI,WAAW,GAAGrY,UAAU,CAACuU,MAA/B,CAHkC,CAKlC;;AACA,UAAIvU,UAAU,CAACoU,EAAf,EAAmB;AAClBiE,QAAAA,WAAW,CAACjL,IAAZ,CAAiBpN,UAAU,CAACoU,EAAX,CAAcxU,IAA/B;AACA;;AAED,WAAK0U,eAAL,CAAqB,IAArB,EAA2B+D,WAA3B,EAAwC,YAAM;AAAA,oDACzBrY,UAAU,CAACuU,MADc;AAAA;;AAAA;AAC7C,iEAAuC;AAAA,gBAA5BtI,KAA4B;;AACtC,YAAA,OAAI,CAACiI,WAAL,CAAiBjI,KAAjB;AACA;AAH4C;AAAA;AAAA;AAAA;AAAA;;AAI7C,YAAIjM,UAAU,CAAC6P,IAAX,CAAgB5P,IAAhB,KAAyB,gBAA7B,EAA+C;AAC9C,UAAA,OAAI,CAACuU,UAAL,CAAgBxU,UAAU,CAAC6P,IAAX,CAAgBA,IAAhC;;AACA,cAAMmD,IAAI,GAAG,OAAI,CAACtO,aAAlB;;AACA,UAAA,OAAI,CAAC2L,gBAAL,CAAsBrQ,UAAU,CAAC6P,IAAjC;;AACA,UAAA,OAAI,CAACnL,aAAL,GAAqBsO,IAArB;;AACA,UAAA,OAAI,CAACzC,aAAL,CAAmBvQ,UAAU,CAAC6P,IAA9B;AACA,SAND,MAMO;AACN,UAAA,OAAI,CAACD,cAAL,CAAoB5P,UAAU,CAAC6P,IAA/B;AACA;AACD,OAbD;AAcA,WAAKxL,KAAL,CAAW4L,aAAX,GAA2BD,WAA3B;AACA;;;WAED,qCAA4BhQ,UAA5B,EAAwC;AAAA;;AACvC,UAAMgQ,WAAW,GAAG,KAAK3L,KAAL,CAAW4L,aAA/B;AACA,WAAK5L,KAAL,CAAW4L,aAAX,GAA2BD,WAAW,GAAG,OAAH,GAAa,KAAnD;AACA,WAAKsE,eAAL,CAAqB,KAArB,EAA4BtU,UAAU,CAACuU,MAAvC,EAA+C,YAAM;AAAA,qDAChCvU,UAAU,CAACuU,MADqB;AAAA;;AAAA;AACpD,oEAAuC;AAAA,gBAA5BtI,KAA4B;;AACtC,YAAA,OAAI,CAACiI,WAAL,CAAiBjI,KAAjB;AACA;AAHmD;AAAA;AAAA;AAAA;AAAA;;AAIpD,YAAIjM,UAAU,CAAC6P,IAAX,CAAgB5P,IAAhB,KAAyB,gBAA7B,EAA+C;AAC9C,UAAA,OAAI,CAACuU,UAAL,CAAgBxU,UAAU,CAAC6P,IAAX,CAAgBA,IAAhC;;AACA,cAAMmD,IAAI,GAAG,OAAI,CAACtO,aAAlB;;AACA,UAAA,OAAI,CAAC2L,gBAAL,CAAsBrQ,UAAU,CAAC6P,IAAjC;;AACA,UAAA,OAAI,CAACnL,aAAL,GAAqBsO,IAArB;;AACA,UAAA,OAAI,CAACzC,aAAL,CAAmBvQ,UAAU,CAAC6P,IAA9B;AACA,SAND,MAMO;AACN,UAAA,OAAI,CAACD,cAAL,CAAoB5P,UAAU,CAAC6P,IAA/B;AACA;AACD,OAbD;AAcA,WAAKxL,KAAL,CAAW4L,aAAX,GAA2BD,WAA3B;AACA;AAED;AACD;AACA;;;;WACC,gCAAuBhQ,UAAvB,EAAmC;AAClC,UAAI,CAACA,UAAU,CAACiN,WAAhB,EAA6B,OADK,CAElC;AACA;;AACA,UAAMqL,gBAAgB,GAAG,KAAK7T,aAAL,CAAmB,KAAKA,aAAL,CAAmB3E,MAAnB,GAA4B,CAA/C,CAAzB;;AACA,UACCwY,gBAAgB,KAAKtY,UAArB,IACCsY,gBAAgB,CAACrY,IAAjB,KAA0B,qBAA1B,IACAqY,gBAAgB,CAACtY,UAAjB,KAAgCA,UAHlC,EAIE;AACD,YAAMuY,GAAG,GAAG,KAAK9T,aAAL,CAAmB+K,GAAnB,EAAZ;;AADC,qDAEkBxP,UAAU,CAACiN,WAF7B;AAAA;;AAAA;AAED,oEAA2C;AAAA,gBAAhCjI,IAAgC;AAC1C,iBAAKP,aAAL,CAAmB2I,IAAnB,CAAwBpI,IAAxB;AACA,iBAAK4K,cAAL,CAAoB5K,IAApB;AACA,iBAAKP,aAAL,CAAmB+K,GAAnB;AACA;AANA;AAAA;AAAA;AAAA;AAAA;;AAOD,aAAK/K,aAAL,CAAmB2I,IAAnB,CAAwBmL,GAAxB;AACA,OAZD,MAYO;AACN,aAAKP,eAAL,CAAqBhY,UAAU,CAACiN,WAAhC;AACA;AACD;;;WAED,8BAAqBjN,UAArB,EAAiC;AAChC,WAAK4P,cAAL,CAAoB5P,UAAU,CAACsK,QAA/B;AACA;;;WAED,6BAAoBtK,UAApB,EAAgC;AAC/B,UAAIA,UAAU,CAAC0G,QAAX,KAAwB,QAA5B,EAAsC;AACrC,YAAMe,MAAM,GAAG,KAAK+C,sBAAL,CACd,KAAKtJ,KAAL,CAAWoC,MADG,EAEdtD,UAAU,CAACsK,QAFG,EAGdtK,UAHc,CAAf;AAKA,YAAIyH,MAAM,KAAK,IAAf,EAAqB;;AACrB,YAAIzH,UAAU,CAACsK,QAAX,CAAoBrK,IAApB,KAA6B,iBAAjC,EAAoD;AACnD,cAAMwH,OAAM,GAAG,KAAK+C,sBAAL,CACd,KAAKtJ,KAAL,CAAWoC,MADG,EAEdtD,UAAU,CAACsK,QAAX,CAAoBtK,UAFN,EAGdA,UAHc,CAAf;;AAKA,cAAIyH,OAAM,KAAK,IAAf,EAAqB;AACrB;AACD;;AACD,WAAKmI,cAAL,CAAoB5P,UAAU,CAACsK,QAA/B;AACA;;;WAED,iCAAwBtK,UAAxB,EAAoC;AACnC,WAAK4P,cAAL,CAAoB5P,UAAU,CAACuG,IAA/B;AACA,WAAKqJ,cAAL,CAAoB5P,UAAU,CAAC+G,KAA/B;AACA;;;WAED,8BAAqB/G,UAArB,EAAiC;AAChC,WAAKwY,uBAAL,CAA6BxY,UAA7B;AACA;;;WAED,+BAAsBA,UAAtB,EAAkC;AACjC,UAAMyH,MAAM,GAAG,KAAKvG,KAAL,CAAWgD,yBAAX,CAAqCT,IAArC,CAA0CzD,UAA1C,CAAf;;AACA,UAAIyH,MAAM,KAAKrH,SAAf,EAA0B;AACzB,aAAKoY,uBAAL,CAA6BxY,UAA7B;AACA,OAFD,MAEO;AACN,YAAIyH,MAAJ,EAAY;AACX,eAAKmI,cAAL,CAAoB5P,UAAU,CAAC+G,KAA/B;AACA;AACD;AACD;;;WAED,kCAAyB/G,UAAzB,EAAqC;AAAA;;AACpC,UAAIA,UAAU,CAACuG,IAAX,CAAgBtG,IAAhB,KAAyB,YAA7B,EAA2C;AAC1C,YAAMwV,gBAAgB,GAAG,KAAKC,mBAAL,CAAyB1V,UAAU,CAAC+G,KAApC,CAAzB;;AACA,YAAI0O,gBAAJ,EAAsB;AACrB,cACC,KAAKgD,gBAAL,CACC,KAAKvX,KAAL,CAAWgC,SADZ,EAECuS,gBAFD,EAGCzV,UAAU,CAAC+G,KAHZ,CADD,EAME;AACD;AACA,gBACC,CAAC,KAAK0R,gBAAL,CACA,KAAKvX,KAAL,CAAWiC,MADX,EAEAsS,gBAFA,EAGAzV,UAAU,CAAC+G,KAHX,CADF,EAME;AACD,mBAAK4O,WAAL,CACC3V,UAAU,CAACuG,IAAX,CAAgB3G,IADjB,EAEC,KAAKgG,eAAL,CAAqB6P,gBAArB,CAFD;AAIA;;AACD;AACA;AACD;;AACD,aAAK7F,cAAL,CAAoB5P,UAAU,CAAC+G,KAA/B;AACA,aAAKkO,YAAL,CAAkBjV,UAAU,CAACuG,IAA7B,EAAmC,UAAC3G,IAAD,EAAO4V,IAAP,EAAgB;AAClD,cAAI,CAAC,OAAI,CAACjL,gBAAL,CAAsB,OAAI,CAACrJ,KAAL,CAAWkC,MAAjC,EAAyCxD,IAAzC,EAA+CI,UAA/C,CAAL,EAAiE;AAChE,YAAA,OAAI,CAAC4P,cAAL,CAAoB5P,UAAU,CAACuG,IAA/B;AACA;AACD,SAJD;AAKA;AACA;;AACD,UAAIvG,UAAU,CAACuG,IAAX,CAAgBtG,IAAhB,CAAqByY,QAArB,CAA8B,SAA9B,CAAJ,EAA8C;AAC7C,aAAK9I,cAAL,CAAoB5P,UAAU,CAAC+G,KAA/B;AACA,aAAKkO,YAAL,CAAkBjV,UAAU,CAACuG,IAA7B,EAAmC,UAAC3G,IAAD,EAAO4V,IAAP,EAAgB;AAClD,cAAI,CAAC,OAAI,CAACjL,gBAAL,CAAsB,OAAI,CAACrJ,KAAL,CAAWkC,MAAjC,EAAyCxD,IAAzC,EAA+CI,UAA/C,CAAL,EAAiE;AAChE,YAAA,OAAI,CAACqU,cAAL,CAAoBzU,IAApB;AACA;AACD,SAJD;AAKA,aAAKsU,WAAL,CAAiBlU,UAAU,CAACuG,IAA5B;AACA,OARD,MAQO,IAAIvG,UAAU,CAACuG,IAAX,CAAgBtG,IAAhB,KAAyB,kBAA7B,EAAiD;AACvD,YAAM0Y,QAAQ,GAAG,KAAK5M,uBAAL,CAChB/L,UAAU,CAACuG,IADK,EAEhBzH,+BAFgB,CAAjB;;AAIA,YAAI6Z,QAAJ,EAAc;AACb,cACC,KAAKF,gBAAL,CACC,KAAKvX,KAAL,CAAWmC,iBADZ,EAECsV,QAAQ,CAAC/M,QAFV,EAGC5L,UAHD,EAIC2Y,QAAQ,CAAC9M,UAAT,EAJD,CADD,EAOE;AACD;AACA;AACD;;AACD,aAAK+D,cAAL,CAAoB5P,UAAU,CAAC+G,KAA/B;AACA,aAAK6I,cAAL,CAAoB5P,UAAU,CAACuG,IAA/B;AACA,OAnBM,MAmBA;AACN,aAAKqJ,cAAL,CAAoB5P,UAAU,CAAC+G,KAA/B;AACA,aAAK6I,cAAL,CAAoB5P,UAAU,CAACuG,IAA/B;AACA;AACD;;;WAED,mCAA0BvG,UAA1B,EAAsC;AACrC,UAAMyH,MAAM,GAAG,KAAKvG,KAAL,CAAW+C,6BAAX,CAAyCR,IAAzC,CAA8CzD,UAA9C,CAAf;;AACA,UAAIyH,MAAM,KAAKrH,SAAf,EAA0B;AACzB,aAAKwP,cAAL,CAAoB5P,UAAU,CAACuO,IAA/B;AACA,aAAKqB,cAAL,CAAoB5P,UAAU,CAACyO,UAA/B;;AACA,YAAIzO,UAAU,CAAC0O,SAAf,EAA0B;AACzB,eAAKkB,cAAL,CAAoB5P,UAAU,CAAC0O,SAA/B;AACA;AACD,OAND,MAMO;AACN,YAAIjH,MAAJ,EAAY;AACX,eAAKmI,cAAL,CAAoB5P,UAAU,CAACyO,UAA/B;AACA,SAFD,MAEO,IAAIzO,UAAU,CAAC0O,SAAf,EAA0B;AAChC,eAAKkB,cAAL,CAAoB5P,UAAU,CAAC0O,SAA/B;AACA;AACD;AACD;;;WAED,2BAAkB1O,UAAlB,EAA8B;AAC7B,UAAMyH,MAAM,GAAG,KAAK+C,sBAAL,CACd,KAAKtJ,KAAL,CAAW4C,GADG,EAEd9D,UAAU,CAAC0F,MAFG,EAGd1F,UAHc,CAAf;AAKA,UAAIyH,MAAM,KAAK,IAAf,EAAqB;AACrB,WAAKmI,cAAL,CAAoB5P,UAAU,CAAC0F,MAA/B;;AACA,UAAI1F,UAAU,CAAC2F,SAAf,EAA0B;AACzB,aAAKqS,eAAL,CAAqBhY,UAAU,CAAC2F,SAAhC;AACA;AACD;;;WAED,6BAAoB3F,UAApB,EAAgC;AAC/B,UAAIA,UAAU,CAACsK,QAAf,EAAyB;AACxB,aAAKsF,cAAL,CAAoB5P,UAAU,CAACsK,QAA/B;AACA;AACD;;;WAED,6BAAoBtK,UAApB,EAAgC;AAC/B,UAAIA,UAAU,CAACiN,WAAf,EAA4B;AAC3B,aAAK+K,eAAL,CAAqBhY,UAAU,CAACiN,WAAhC;AACA;AACD;;;WAED,sCAA6BjN,UAA7B,EAAyC;AACxC,UAAIA,UAAU,CAACyN,GAAf,EAAoB;AACnB,aAAKmC,cAAL,CAAoB5P,UAAU,CAACyN,GAA/B;AACA;;AACD,UAAIzN,UAAU,CAAC+M,KAAX,IAAoB/M,UAAU,CAAC+M,KAAX,CAAiBE,WAAzC,EAAsD;AACrD,aAAK+K,eAAL,CAAqBhY,UAAU,CAAC+M,KAAX,CAAiBE,WAAtC;AACA;AACD;;;WAED,6BAAoBjN,UAApB,EAAgC;AAC/B,WAAK4V,SAAL,CAAe5V,UAAf;AACA;AAED;AACD;AACA;;;;WACC,6BAAoBA,UAApB,EAAgC;AAC/B,UAAMyH,MAAM,GAAG,KAAKvG,KAAL,CAAW2C,gBAAX,CAA4BJ,IAA5B,CAAiCzD,UAAjC,CAAf;;AAEA,UAAIyH,MAAM,KAAKrH,SAAf,EAA0B;AACzB,YAAIJ,UAAU,CAACA,UAAX,CAAsBC,IAAtB,KAA+B,gBAAnC,EAAqD;AACpD,eAAK4W,kBAAL,CAAwB7W,UAAU,CAACA,UAAnC;AACA,SAFD,MAEO;AACN,eAAKmW,oBAAL,CAA0BnW,UAAU,CAACA,UAArC;AACA;AACD;AACD;;;WAED,mBAAU4Y,kBAAV,EAA8B7X,OAA9B,EAAuC8X,WAAvC,EAAoD;AAAA;;AACnD,UAAMC,UAAU,GAAG,SAAbA,UAAa,CAAAC,SAAS,EAAI;AAC/B,YAAMtD,gBAAgB,GAAG,OAAI,CAACC,mBAAL,CAAyBqD,SAAzB,CAAzB;;AACA,YAAItD,gBAAJ,EAAsB;AACrB,cACC,OAAI,CAACgD,gBAAL,CACC,OAAI,CAACvX,KAAL,CAAWgC,SADZ,EAECuS,gBAFD,EAGCsD,SAHD,CADD,EAME;AACD,gBACC,CAAC,OAAI,CAACN,gBAAL,CACA,OAAI,CAACvX,KAAL,CAAWiC,MADX,EAEAsS,gBAFA,EAGAsD,SAHA,CADF,EAME;AACD,qBAAO,OAAI,CAACnT,eAAL,CAAqB6P,gBAArB,CAAP;AACA;AACD;AACD;;AACD,QAAA,OAAI,CAAC7F,cAAL,CAAoBmJ,SAApB;AACA,OAtBD;;AAuBA,UAAQxE,MAAR,GAAyBqE,kBAAzB,CAAQrE,MAAR;AAAA,UAAgBtU,IAAhB,GAAyB2Y,kBAAzB,CAAgB3Y,IAAhB;AACA,UAAM+Y,KAAK,GAAG/Y,IAAI,KAAK,yBAAvB;AACA,UAAMgZ,UAAU,GAAGJ,WAAW,GAAGC,UAAU,CAACD,WAAD,CAAb,GAA6B,IAA3D;AACA,UAAMK,cAAc,GAAGnY,OAAO,CAACiO,GAAR,CAAY8J,UAAZ,CAAvB;AACA,UAAM9I,WAAW,GAAG,KAAK3L,KAAL,CAAW4L,aAA/B;AACA,WAAK5L,KAAL,CAAW4L,aAAX,GAA2BD,WAAW,IAAIgJ,KAAf,GAAuB,OAAvB,GAAiC,KAA5D;AACA,UAAMX,WAAW,GAAG9D,MAAM,CAAC4E,MAAP,CACnB,UAACxL,UAAD,EAAayL,GAAb;AAAA,eAAqB,CAACF,cAAc,CAACE,GAAD,CAApC;AAAA,OADmB,CAApB,CA9BmD,CAkCnD;;AACA,UAAIR,kBAAkB,CAACxE,EAAvB,EAA2B;AAC1BiE,QAAAA,WAAW,CAACjL,IAAZ,CAAiBwL,kBAAkB,CAACxE,EAAnB,CAAsBxU,IAAvC;AACA;;AAED,WAAK0U,eAAL,CAAqB,IAArB,EAA2B+D,WAA3B,EAAwC,YAAM;AAC7C,YAAIY,UAAU,IAAI,CAACD,KAAnB,EAA0B;AACzB,UAAA,OAAI,CAACrD,WAAL,CAAiB,MAAjB,EAAyBsD,UAAzB;AACA;;AACD,aAAK,IAAIpZ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqZ,cAAc,CAACpZ,MAAnC,EAA2CD,CAAC,EAA5C,EAAgD;AAC/C,cAAMwZ,OAAO,GAAGH,cAAc,CAACrZ,CAAD,CAA9B;AACA,cAAI,CAACwZ,OAAL,EAAc;AACd,cAAI,CAAC9E,MAAM,CAAC1U,CAAD,CAAP,IAAc0U,MAAM,CAAC1U,CAAD,CAAN,CAAUI,IAAV,KAAmB,YAArC,EAAmD;;AACnD,UAAA,OAAI,CAAC0V,WAAL,CAAiBpB,MAAM,CAAC1U,CAAD,CAAN,CAAUD,IAA3B,EAAiCyZ,OAAjC;AACA;;AACD,YAAIT,kBAAkB,CAAC/I,IAAnB,CAAwB5P,IAAxB,KAAiC,gBAArC,EAAuD;AACtD,UAAA,OAAI,CAACuU,UAAL,CAAgBoE,kBAAkB,CAAC/I,IAAnB,CAAwBA,IAAxC;;AACA,cAAMmD,IAAI,GAAG,OAAI,CAACtO,aAAlB;;AACA,UAAA,OAAI,CAAC2L,gBAAL,CAAsBuI,kBAAkB,CAAC/I,IAAzC;;AACA,UAAA,OAAI,CAACnL,aAAL,GAAqBsO,IAArB;;AACA,UAAA,OAAI,CAACzC,aAAL,CAAmBqI,kBAAkB,CAAC/I,IAAtC;AACA,SAND,MAMO;AACN,UAAA,OAAI,CAACD,cAAL,CAAoBgJ,kBAAkB,CAAC/I,IAAvC;AACA;AACD,OAnBD;AAoBA,WAAKxL,KAAL,CAAW4L,aAAX,GAA2BD,WAA3B;AACA;;;WAED,8BAAqBhQ,UAArB,EAAiC;AAChC,UAAIyH,MAAM,GAAG,KAAKvG,KAAL,CAAWqC,UAAX,CAAsBE,IAAtB,CAA2BzD,UAA3B,CAAb;AACA,UAAIyH,MAAM,KAAK,IAAf,EAAqB;AAErB,WAAKmI,cAAL,CAAoB5P,UAAU,CAACyU,MAA/B;AACA;;;WAED,4BAAmBzU,UAAnB,EAA+B;AAC9B,UAAMsZ,gBAAgB,GAAG,SAAnBA,gBAAmB,CAAA/R,EAAE,EAAI;AAC9B,eAAOA,EAAE,CAACgN,MAAH,CAAUrF,KAAV,CAAgB,UAAA/G,CAAC;AAAA,iBAAIA,CAAC,CAAClI,IAAF,KAAW,YAAf;AAAA,SAAjB,CAAP;AACA,OAFD;;AAGA,UACCD,UAAU,CAAC0F,MAAX,CAAkBzF,IAAlB,KAA2B,kBAA3B,IACAD,UAAU,CAAC0F,MAAX,CAAkBhG,MAAlB,CAAyBO,IAAzB,CAA8ByY,QAA9B,CAAuC,oBAAvC,CADA,IAEA,CAAC1Y,UAAU,CAAC0F,MAAX,CAAkBsG,QAFnB,KAGChM,UAAU,CAAC0F,MAAX,CAAkBvF,QAAlB,CAA2BP,IAA3B,KAAoC,MAApC,IACAI,UAAU,CAAC0F,MAAX,CAAkBvF,QAAlB,CAA2BP,IAA3B,KAAoC,MAJrC,KAKAI,UAAU,CAAC2F,SAAX,CAAqB7F,MAArB,GAA8B,CAL9B,IAMAwZ,gBAAgB,CAACtZ,UAAU,CAAC0F,MAAX,CAAkBhG,MAAnB,CAPjB,EAQE;AACD;AACA,aAAK6Z,SAAL,CACCvZ,UAAU,CAAC0F,MAAX,CAAkBhG,MADnB,EAECM,UAAU,CAAC2F,SAAX,CAAqBmD,KAArB,CAA2B,CAA3B,CAFD,EAGC9I,UAAU,CAAC2F,SAAX,CAAqB,CAArB,CAHD;AAKA,OAfD,MAeO,IACN3F,UAAU,CAAC0F,MAAX,CAAkBzF,IAAlB,CAAuByY,QAAvB,CAAgC,oBAAhC,KACAY,gBAAgB,CAACtZ,UAAU,CAAC0F,MAAZ,CAFV,EAGL;AACD;AACA,aAAK6T,SAAL,CAAevZ,UAAU,CAAC0F,MAA1B,EAAkC1F,UAAU,CAAC2F,SAA7C,EAAwD,IAAxD;AACA,OANM,MAMA;AACN,YAAI3F,UAAU,CAAC0F,MAAX,CAAkBzF,IAAlB,KAA2B,kBAA/B,EAAmD;AAClD,cAAMuZ,QAAQ,GAAG,KAAKzN,uBAAL,CAChB/L,UAAU,CAAC0F,MADK,EAEhB7G,oCAFgB,CAAjB;;AAIA,cAAI2a,QAAQ,IAAIA,QAAQ,CAACvZ,IAAT,KAAkB,MAAlC,EAA0C;AACzC,gBAAMwH,MAAM,GAAG,KAAKgR,gBAAL,CACd,KAAKvX,KAAL,CAAW0C,gCADG,EAEd4V,QAAQ,CAAC5N,QAFK,EAGd5L,UAHc,EAIdwZ,QAAQ,CAACC,gBAAT,EAJc,EAKdD,QAAQ,CAAC/V,IALK,EAMd+V,QAAQ,CAAC3N,UAAT,EANc,CAAf;AAQA,gBAAIpE,MAAM,KAAK,IAAf,EAAqB;AACrB;AACD;;AACD,YAAM/B,MAAM,GAAG,KAAKO,kBAAL,CAAwBjG,UAAU,CAAC0F,MAAnC,CAAf;;AACA,YAAIA,MAAM,CAACgI,YAAP,EAAJ,EAA2B;AAC1B,cAAMgM,OAAO,GAAG,KAAKjB,gBAAL,CACf,KAAKvX,KAAL,CAAWwC,eADI,EAEfgC,MAAM,CAACkG,QAFQ,EAGf5L,UAHe,EAIf0F,MAAM,CAACmG,UAAP,EAJe,CAAhB;AAMA,cAAI6N,OAAO,KAAK,IAAhB,EAAsB;AACtB,cAAMC,OAAO,GAAG,KAAKlB,gBAAL,CACf,KAAKvX,KAAL,CAAWuC,IADI,EAEfiC,MAAM,CAACiI,UAFQ,EAGf3N,UAHe,CAAhB;AAKA,cAAI2Z,OAAO,KAAK,IAAhB,EAAsB;AACtB;;AAED,YAAI3Z,UAAU,CAAC0F,MAAf,EAAuB;AACtB,cAAI1F,UAAU,CAAC0F,MAAX,CAAkBzF,IAAlB,KAA2B,kBAA/B,EAAmD;AAClD;AACA,iBAAK2P,cAAL,CAAoB5P,UAAU,CAAC0F,MAAX,CAAkBhG,MAAtC;AACA,gBAAIM,UAAU,CAAC0F,MAAX,CAAkBsG,QAAlB,KAA+B,IAAnC,EACC,KAAK4D,cAAL,CAAoB5P,UAAU,CAAC0F,MAAX,CAAkBvF,QAAtC;AACD,WALD,MAKO;AACN,iBAAKyP,cAAL,CAAoB5P,UAAU,CAAC0F,MAA/B;AACA;AACD;;AACD,YAAI1F,UAAU,CAAC2F,SAAf,EAA0B,KAAKqS,eAAL,CAAqBhY,UAAU,CAAC2F,SAAhC;AAC1B;AACD;;;WAED,8BAAqB3F,UAArB,EAAiC;AAAA;;AAChC,UAAMwZ,QAAQ,GAAG,KAAKzN,uBAAL,CAChB/L,UADgB,EAEhBjB,wBAFgB,CAAjB;;AAIA,UAAIya,QAAJ,EAAc;AACb,gBAAQA,QAAQ,CAACvZ,IAAjB;AACC,eAAK,YAAL;AAAmB;AAClB,kBAAMyZ,OAAO,GAAG,KAAKjB,gBAAL,CACf,KAAKvX,KAAL,CAAWlB,UADI,EAEfwZ,QAAQ,CAAC5Z,IAFM,EAGfI,UAHe,CAAhB;AAKA,kBAAI0Z,OAAO,KAAK,IAAhB,EAAsB;AACtB,kBAAME,OAAO,GAAGJ,QAAQ,CAAC3N,UAAT,EAAhB;AACA,kBAAM8N,OAAO,GAAG,KAAKlB,gBAAL,CACf,KAAKvX,KAAL,CAAW6C,qBADI,EAEfyV,QAAQ,CAAC5N,QAFM,EAGf5L,UAHe,EAIf4Z,OAJe,CAAhB;AAMA,kBAAID,OAAO,KAAK,IAAhB,EAAsB;AACtB,mBAAKE,sCAAL,CACC7Z,UADD,EAECwZ,QAAQ,CAAC5Z,IAFV,EAGC4Z,QAAQ,CAAC5N,QAHV,EAICgO,OAAO,CAAC9Q,KAAR,EAJD,EAKC;AAAA,uBACC,OAAI,CAAC2P,gBAAL,CACC,OAAI,CAACvX,KAAL,CAAW8C,8BADZ,EAECwV,QAAQ,CAAC5N,QAFV,EAGC5L,UAHD,EAIC4Z,OAJD,CADD;AAAA,eALD;AAaA;AACA;;AACD,eAAK,MAAL;AAAa;AACZ,kBAAMnS,MAAM,GAAG,KAAKgR,gBAAL,CACd,KAAKvX,KAAL,CAAWyC,4BADG,EAEd6V,QAAQ,CAAC5N,QAFK,EAGd5L,UAHc,EAIdwZ,QAAQ,CAACC,gBAAT,EAJc,EAKdD,QAAQ,CAAC/V,IALK,EAMd+V,QAAQ,CAAC3N,UAAT,EANc,CAAf;AAQA,kBAAIpE,MAAM,KAAK,IAAf,EAAqB,OATT,CAUZ;AACA;;AACA,mBAAKmI,cAAL,CAAoB4J,QAAQ,CAAC/V,IAA7B;AACA;AACA;AA7CF;AA+CA;;AACD,WAAKmM,cAAL,CAAoB5P,UAAU,CAACN,MAA/B;AACA,UAAIM,UAAU,CAACgM,QAAX,KAAwB,IAA5B,EAAkC,KAAK4D,cAAL,CAAoB5P,UAAU,CAACG,QAA/B;AAClC;;;WAED,gDACCH,UADD,EAECJ,IAFD,EAGCgM,QAHD,EAICgO,OAJD,EAKCE,WALD,EAME;AACD,UAAI9Z,UAAU,CAACN,MAAX,CAAkBO,IAAlB,KAA2B,kBAA/B,EAAmD;AAClD;AACA;AACA,YAAME,QAAQ,GACbH,UAAU,CAACG,QAAX,CAAoBP,IAApB,cAA+BI,UAAU,CAACG,QAAX,CAAoB8E,KAAnD,CADD;AAEArF,QAAAA,IAAI,GAAGA,IAAI,CAACkJ,KAAL,CAAW,CAAX,EAAc,CAAC3I,QAAQ,CAACL,MAAV,GAAmB,CAAjC,CAAP;AACA8Z,QAAAA,OAAO,CAACpK,GAAR;AACA,YAAM/H,MAAM,GAAG,KAAKgR,gBAAL,CACd,KAAKvX,KAAL,CAAWlB,UADG,EAEdJ,IAFc,EAGdI,UAAU,CAACN,MAHG,CAAf;AAKA,YAAI+H,MAAM,KAAK,IAAf,EAAqB;AACrB,aAAKoS,sCAAL,CACC7Z,UAAU,CAACN,MADZ,EAECE,IAFD,EAGCgM,QAHD,EAICgO,OAJD,EAKCE,WALD;AAOA,OApBD,MAoBO,IAAI,CAACA,WAAD,IAAgB,CAACA,WAAW,EAAhC,EAAoC;AAC1C,aAAKlK,cAAL,CAAoB5P,UAAU,CAACN,MAA/B;AACA;;AACD,UAAIM,UAAU,CAACgM,QAAX,KAAwB,IAA5B,EAAkC,KAAK4D,cAAL,CAAoB5P,UAAU,CAACG,QAA/B;AAClC;;;WAED,4BAAmBH,UAAnB,EAA+B;AAC9B,WAAKuK,gBAAL,CAAsB,KAAKrJ,KAAL,CAAWlB,UAAjC,EAA6C,MAA7C,EAAqDA,UAArD;AACA;;;WAED,wBAAeA,UAAf,EAA2B;AAC1B,WAAKuK,gBAAL,CAAsB,KAAKrJ,KAAL,CAAWlB,UAAjC,EAA6CA,UAAU,CAACJ,IAAxD,EAA8DI,UAA9D;AACA;AAED;AACD;AACA;;;;WACC,0BAAiB8L,YAAjB,EAA+B;AAC9B,WAAK5K,KAAL,CAAWlB,UAAX,CAAsB6E,GAAtB,CAA0B9E,WAAW,CAAC+L,YAAD,CAArC,EAAqDrI,IAArD,CAA0DqI,YAA1D;AACA;;;WAED,gCAAuByJ,OAAvB,EAAgCvQ,IAAhC,EAA+C;AAAA,wCAAN+U,IAAM;AAANA,QAAAA,IAAM;AAAA;;AAC9C,aAAO,KAAKC,kCAAL,cACNzE,OADM,EAENvQ,IAFM,EAGN5E,SAHM,EAINA,SAJM,SAKH2Z,IALG,EAAP;AAOA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,4CACCxE,OADD,EAECvQ,IAFD,EAGCiV,QAHD,EAICC,OAJD,EAME;AACD,UAAMvB,QAAQ,GAAG,KAAK5M,uBAAL,CAChB/G,IADgB,EAEhBlG,+BAFgB,CAAjB;;AAIA,UAAI6Z,QAAQ,KAAKvY,SAAjB,EAA4B;AAC3B,YAAMwZ,OAAO,GAAGjB,QAAQ,CAAC9M,UAAT,EAAhB;;AAD2B,2CANzBkO,IAMyB;AANzBA,UAAAA,IAMyB;AAAA;;AAE3B,eAAO,KAAKxO,4BAAL,cACNgK,OADM,EAENqE,OAAO,CAAC9Z,MAAR,KAAmB,CAAnB,GAAuB6Y,QAAQ,CAAC/M,QAAhC,GAA2C+M,QAAQ,CAAC/Y,IAF9C,EAGNqa,QAAQ,IACN,UAAAra,IAAI;AAAA,iBAAIqa,QAAQ,CAACra,IAAD,EAAO+Y,QAAQ,CAAC/M,QAAhB,EAA0B+M,QAAQ,CAAC9M,UAAnC,CAAZ;AAAA,SAJA,EAKNqO,OAAO,IAAK;AAAA,iBAAMA,OAAO,CAACvB,QAAQ,CAAC/Y,IAAV,CAAb;AAAA,SALN,SAMHma,IANG,EAAP;AAQA;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,0BAAiBxE,OAAjB,EAA0B3V,IAA1B,EAAyC;AAAA,yCAANma,IAAM;AAANA,QAAAA,IAAM;AAAA;;AACxC,aAAO,KAAKI,4BAAL,cACN5E,OADM,EAEN3V,IAFM,EAGNQ,SAHM,EAINA,SAJM,SAKH2Z,IALG,EAAP;AAOA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,0BAAiBxE,OAAjB,EAA0BjK,IAA1B,EAAyC;AAAA,yCAANyO,IAAM;AAANA,QAAAA,IAAM;AAAA;;AACxC,aAAO,KAAKxO,4BAAL,cACNgK,OADM,EAENjK,IAFM,EAGNlL,SAHM,EAINA,SAJM,SAKH2Z,IALG,EAAP;AAOA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,sCAA6BxE,OAA7B,EAAsCjK,IAAtC,EAA4C2O,QAA5C,EAAsDC,OAAtD,EAAwE;AACvE,UAAIta,IAAJ;;AADuE,yCAANma,IAAM;AAANA,QAAAA,IAAM;AAAA;;AAEvE,UAAI,OAAOzO,IAAP,KAAgB,QAApB,EAA8B;AAC7B1L,QAAAA,IAAI,GAAG0L,IAAP;AACA,OAFD,MAEO;AACN,YAAI,EAAEA,IAAI,YAAYpM,YAAlB,CAAJ,EAAqC;AACpC,cAAIgb,OAAO,KAAK9Z,SAAhB,EAA2B;AAC1B,mBAAO8Z,OAAO,EAAd;AACA;;AACD;AACA;;AACD,YAAI7a,OAAO,GAAGiM,IAAI,CAACjM,OAAnB;;AACA,eAAOA,OAAO,KAAKe,SAAnB,EAA8B;AAC7B,cAAMoL,MAAI,GAAG+J,OAAO,CAAC9J,GAAR,CAAYpM,OAAO,CAACoO,GAApB,CAAb;;AACA,cAAIjC,MAAI,KAAKpL,SAAb,EAAwB;AACvB,iBAAKuE,cAAL,GAAsBtF,OAAO,CAAC+a,IAA9B;;AACA,gBAAM3S,MAAM,GAAG+D,MAAI,CAAC/H,IAAL,OAAA+H,MAAI,EAASuO,IAAT,CAAnB;;AACA,iBAAKpV,cAAL,GAAsBvE,SAAtB;AACA,gBAAIqH,MAAM,KAAKrH,SAAf,EAA0B,OAAOqH,MAAP;AAC1B;;AACDpI,UAAAA,OAAO,GAAGA,OAAO,CAACiQ,IAAlB;AACA;;AACD,YAAIhE,IAAI,CAAClM,QAAL,KAAkB,IAAtB,EAA4B;AAC3B,cAAI8a,OAAO,KAAK9Z,SAAhB,EAA2B;AAC1B,mBAAO8Z,OAAO,EAAd;AACA;;AACD;AACA;;AACDta,QAAAA,IAAI,GAAG0L,IAAI,CAAClM,QAAZ;AACA;;AACD,UAAMoM,IAAI,GAAG+J,OAAO,CAAC9J,GAAR,CAAY7L,IAAZ,CAAb;;AACA,UAAI4L,IAAI,KAAKpL,SAAb,EAAwB;AACvB,YAAMqH,QAAM,GAAG+D,IAAI,CAAC/H,IAAL,OAAA+H,IAAI,EAASuO,IAAT,CAAnB;;AACA,YAAItS,QAAM,KAAKrH,SAAf,EAA0B,OAAOqH,QAAP;AAC1B;;AACD,UAAIwS,QAAQ,KAAK7Z,SAAjB,EAA4B;AAC3B,eAAO6Z,QAAQ,CAACra,IAAD,CAAf;AACA;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,sCAA6B2V,OAA7B,EAAsC3V,IAAtC,EAA4Cqa,QAA5C,EAAsDC,OAAtD,EAAwE;AAAA,yCAANH,IAAM;AAANA,QAAAA,IAAM;AAAA;;AACvE,aAAO,KAAKxO,4BAAL,cACNgK,OADM,EAEN,KAAK3P,eAAL,CAAqBhG,IAArB,CAFM,EAGNqa,QAHM,EAINC,OAJM,SAKHH,IALG,EAAP;AAOA;AAED;AACD;AACA;AACA;AACA;AACA;;;;WACC,iBAAQxF,MAAR,EAAgBhN,EAAhB,EAAoB;AAAA;;AACnB,UAAM8S,QAAQ,GAAG,KAAKhW,KAAtB;AACA,WAAKA,KAAL,GAAa;AACZ4L,QAAAA,aAAa,EAAEoK,QAAQ,CAACpK,aADZ;AAEZ4D,QAAAA,KAAK,EAAE,KAFK;AAGZuE,QAAAA,WAAW,EAAE,KAHD;AAIZkC,QAAAA,QAAQ,EAAED,QAAQ,CAACC,QAJP;AAKZC,QAAAA,OAAO,EAAEF,QAAQ,CAACE,OALN;AAMZC,QAAAA,WAAW,EAAEH,QAAQ,CAACG,WAAT,CAAqBC,WAArB;AAND,OAAb;AASA,WAAKC,gBAAL,CAAsB,MAAtB;AAEA,WAAKC,aAAL,CAAmBpG,MAAnB,EAA2B,UAACyB,KAAD,EAAQ/S,OAAR,EAAoB;AAC9C,QAAA,OAAI,CAACoR,cAAL,CAAoB2B,KAApB;AACA,OAFD;AAIAzO,MAAAA,EAAE;AAEF,WAAKlD,KAAL,GAAagW,QAAb;AACA;;;WAED,yBAAgBO,OAAhB,EAAyBrG,MAAzB,EAAiChN,EAAjC,EAAqC;AAAA;;AACpC,UAAM8S,QAAQ,GAAG,KAAKhW,KAAtB;AACA,WAAKA,KAAL,GAAa;AACZ4L,QAAAA,aAAa,EAAEoK,QAAQ,CAACpK,aADZ;AAEZ4D,QAAAA,KAAK,EAAE,KAFK;AAGZuE,QAAAA,WAAW,EAAE,KAHD;AAIZkC,QAAAA,QAAQ,EAAED,QAAQ,CAACC,QAJP;AAKZC,QAAAA,OAAO,EAAEF,QAAQ,CAACE,OALN;AAMZC,QAAAA,WAAW,EAAEH,QAAQ,CAACG,WAAT,CAAqBC,WAArB;AAND,OAAb;;AASA,UAAIG,OAAJ,EAAa;AACZ,aAAKF,gBAAL,CAAsB,MAAtB;AACA;;AAED,WAAKC,aAAL,CAAmBpG,MAAnB,EAA2B,UAACyB,KAAD,EAAQ/S,OAAR,EAAoB;AAC9C,QAAA,OAAI,CAACoR,cAAL,CAAoB2B,KAApB;AACA,OAFD;AAIAzO,MAAAA,EAAE;AAEF,WAAKlD,KAAL,GAAagW,QAAb;AACA;;;WAED,sBAAa9S,EAAb,EAAiB;AAChB,UAAM8S,QAAQ,GAAG,KAAKhW,KAAtB;AACA,WAAKA,KAAL,GAAa;AACZ4L,QAAAA,aAAa,EAAEoK,QAAQ,CAACpK,aADZ;AAEZ4D,QAAAA,KAAK,EAAEwG,QAAQ,CAACxG,KAFJ;AAGZuE,QAAAA,WAAW,EAAE,KAHD;AAIZkC,QAAAA,QAAQ,EAAED,QAAQ,CAACC,QAJP;AAKZC,QAAAA,OAAO,EAAEF,QAAQ,CAACE,OALN;AAMZC,QAAAA,WAAW,EAAEH,QAAQ,CAACG,WAAT,CAAqBC,WAArB;AAND,OAAb;AASAlT,MAAAA,EAAE;AAEF,WAAKlD,KAAL,GAAagW,QAAb;AACA;;;WAED,oBAAWnK,UAAX,EAAuB;AACtB,UAAM2K,SAAS,GACd3K,UAAU,CAACpQ,MAAX,IAAqB,CAArB,IACAoQ,UAAU,CAAC,CAAD,CAAV,CAAcjQ,IAAd,KAAuB,qBADvB,IAEAiQ,UAAU,CAAC,CAAD,CAAV,CAAclQ,UAAd,CAAyBC,IAAzB,KAAkC,SAHnC;;AAIA,UAAI4a,SAAS,IAAI3K,UAAU,CAAC,CAAD,CAAV,CAAclQ,UAAd,CAAyBiF,KAAzB,KAAmC,YAApD,EAAkE;AACjE,aAAKZ,KAAL,CAAWiW,QAAX,GAAsB,IAAtB;AACA;;AACD,UAAIO,SAAS,IAAI3K,UAAU,CAAC,CAAD,CAAV,CAAclQ,UAAd,CAAyBiF,KAAzB,KAAmC,SAApD,EAA+D;AAC9D,aAAKZ,KAAL,CAAWkW,OAAX,GAAqB,IAArB;AACA;AACD;;;WAED,uBAAcO,QAAd,EAAwB/F,OAAxB,EAAiC;AAAA,mDACV+F,QADU;AAAA;;AAAA;AAChC,kEAAgC;AAAA,cAArB7X,OAAqB;;AAC/B,cAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAChC,iBAAKgS,YAAL,CAAkBhS,OAAlB,EAA2B8R,OAA3B;AACA,WAFD,MAEO,IAAI9R,OAAJ,EAAa;AACnB8R,YAAAA,OAAO,CAAC9R,OAAD,CAAP;AACA;AACD;AAP+B;AAAA;AAAA;AAAA;AAAA;AAQhC;;;WAED,sBAAaA,OAAb,EAAsB8R,OAAtB,EAA+B;AAC9B,UAAI,CAAC9R,OAAL,EAAc;;AACd,cAAQA,OAAO,CAAChD,IAAhB;AACC,aAAK,cAAL;AACC,eAAK8a,iBAAL,CAAuB9X,OAAvB,EAAgC8R,OAAhC;AACA;;AACD,aAAK,mBAAL;AACC,eAAKiG,sBAAL,CAA4B/X,OAA5B,EAAqC8R,OAArC;AACA;;AACD,aAAK,YAAL;AACC,eAAKkG,eAAL,CAAqBhY,OAArB,EAA8B8R,OAA9B;AACA;;AACD,aAAK,eAAL;AACC,eAAKmG,kBAAL,CAAwBjY,OAAxB,EAAiC8R,OAAjC;AACA;;AACD,aAAK,aAAL;AACC,eAAKoG,gBAAL,CAAsBlY,OAAtB,EAA+B8R,OAA/B;AACA;;AACD,aAAK,UAAL;AACC,cAAI9R,OAAO,CAACkV,SAAR,IAAqBlV,OAAO,CAACgC,KAAR,CAAchF,IAAd,KAAuB,YAAhD,EAA8D;AAC7D,iBAAKoE,KAAL,CAAW+T,WAAX,GAAyBnV,OAAO,CAACgC,KAAR,CAAcrF,IAAvC;AACA,iBAAKqb,eAAL,CAAqBhY,OAAO,CAACgC,KAA7B,EAAoC8P,OAApC;AACA,iBAAK1Q,KAAL,CAAW+T,WAAX,GAAyB,KAAzB;AACA,WAJD,MAIO;AACN,iBAAKnD,YAAL,CAAkBhS,OAAO,CAACgC,KAA1B,EAAiC8P,OAAjC;AACA;;AACD;AAxBF;AA0BA;;;WAED,yBAAgB9R,OAAhB,EAAyB8R,OAAzB,EAAkC;AACjC,UAAI,CAAC,KAAKxK,gBAAL,CAAsB,KAAKrJ,KAAL,CAAW+B,OAAjC,EAA0CA,OAAO,CAACrD,IAAlD,EAAwDqD,OAAxD,CAAL,EAAuE;AACtE8R,QAAAA,OAAO,CAAC9R,OAAO,CAACrD,IAAT,EAAeqD,OAAf,CAAP;AACA;AACD;;;WAED,4BAAmBA,OAAnB,EAA4B8R,OAA5B,EAAqC;AACpC,WACC,IAAIkD,SAAS,GAAG,CAAhB,EAAmB7H,GAAG,GAAGnN,OAAO,CAACqT,UAAR,CAAmBxW,MAD7C,EAECmY,SAAS,GAAG7H,GAFb,EAGC6H,SAAS,EAHV,EAIE;AACD,YAAM1B,IAAI,GAAGtT,OAAO,CAACqT,UAAR,CAAmB2B,SAAnB,CAAb;AACA,aAAKhD,YAAL,CAAkBsB,IAAlB,EAAwBxB,OAAxB;AACA;AACD;;;WAED,2BAAkB9R,OAAlB,EAA2B8R,OAA3B,EAAoC;AACnC,WACC,IAAIqG,YAAY,GAAG,CAAnB,EAAsBhL,GAAG,GAAGnN,OAAO,CAAC8L,QAAR,CAAiBjP,MAD9C,EAECsb,YAAY,GAAGhL,GAFhB,EAGCgL,YAAY,EAHb,EAIE;AACD,YAAMnM,OAAO,GAAGhM,OAAO,CAAC8L,QAAR,CAAiBqM,YAAjB,CAAhB;AACA,aAAKnG,YAAL,CAAkBhG,OAAlB,EAA2B8F,OAA3B;AACA;AACD;;;WAED,0BAAiB9R,OAAjB,EAA0B8R,OAA1B,EAAmC;AAClC,WAAKE,YAAL,CAAkBhS,OAAO,CAACqH,QAA1B,EAAoCyK,OAApC;AACA;;;WAED,gCAAuB9R,OAAvB,EAAgC8R,OAAhC,EAAyC;AACxC,WAAKE,YAAL,CAAkBhS,OAAO,CAACsD,IAA1B,EAAgCwO,OAAhC;AACA;AAED;AACD;AACA;AACA;;;;WACC,4BAAmB/U,UAAnB,EAA+B;AAC9B,UAAI;AACH,YAAMwL,IAAI,GAAG,KAAKtK,KAAL,CAAWI,QAAX,CAAoBmK,GAApB,CAAwBzL,UAAU,CAACC,IAAnC,CAAb;;AACA,YAAIuL,IAAI,KAAKpL,SAAb,EAAwB;AACvB,cAAMqH,MAAM,GAAG+D,IAAI,CAAC/H,IAAL,CAAUzD,UAAV,CAAf;;AACA,cAAIyH,MAAM,KAAKrH,SAAf,EAA0B;AACzB,gBAAIqH,MAAJ,EAAY;AACXA,cAAAA,MAAM,CAAC0F,aAAP,CAAqBnN,UAArB;AACA;;AACD,mBAAOyH,MAAP;AACA;AACD;AACD,OAXD,CAWE,OAAO4T,CAAP,EAAU;AACXC,QAAAA,OAAO,CAACC,IAAR,CAAaF,CAAb,EADW,CAEX;AACA;;AACD,aAAO,IAAI1c,wBAAJ,GACLwG,QADK,CACInF,UAAU,CAACoF,KADf,EAEL+H,aAFK,CAESnN,UAFT,CAAP;AAGA;;;WAED,qBAAYA,UAAZ,EAAwB;AACvB,cAAQA,UAAU,CAACC,IAAnB;AACC,aAAK,kBAAL;AACC,cAAID,UAAU,CAAC0G,QAAX,KAAwB,GAA5B,EAAiC;AAChC,mBACC,KAAK8U,WAAL,CAAiBxb,UAAU,CAACuG,IAA5B,IACA,KAAKiV,WAAL,CAAiBxb,UAAU,CAAC+G,KAA5B,CAFD;AAIA;;AACD;;AACD,aAAK,SAAL;AACC,iBAAO/G,UAAU,CAACiF,KAAX,GAAmB,EAA1B;AAVF;;AAYA,YAAM,IAAIwW,KAAJ,CACLzb,UAAU,CAACC,IAAX,GAAkB,4CADb,CAAN;AAGA;;;WAED,+BAAsBD,UAAtB,EAAkC;AACjC,cAAQA,UAAU,CAACC,IAAnB;AACC,aAAK,kBAAL;AACC,cAAID,UAAU,CAAC0G,QAAX,KAAwB,GAA5B,EAAiC;AAChC,gBAAMH,IAAI,GAAG,KAAKmV,qBAAL,CAA2B1b,UAAU,CAACuG,IAAtC,CAAb;AACA,gBAAMQ,KAAK,GAAG,KAAK2U,qBAAL,CAA2B1b,UAAU,CAAC+G,KAAtC,CAAd;;AACA,gBAAIR,IAAI,CAACoV,IAAT,EAAe;AACd,qBAAO;AACNvW,gBAAAA,KAAK,EAAEmB,IAAI,CAACnB,KADN;AAENH,gBAAAA,KAAK,EAAEsB,IAAI,CAACtB,KAFN;AAGN0W,gBAAAA,IAAI,EAAE,IAHA;AAINC,gBAAAA,WAAW,EAAE;AAJP,eAAP;AAMA,aAPD,MAOO,IAAI7U,KAAK,CAAC4U,IAAV,EAAgB;AACtB,qBAAO;AACNvW,gBAAAA,KAAK,EAAE,CACNmB,IAAI,CAACnB,KAAL,CAAW,CAAX,CADM,EAEN2B,KAAK,CAAC3B,KAAN,GAAc2B,KAAK,CAAC3B,KAAN,CAAY,CAAZ,CAAd,GAA+BmB,IAAI,CAACnB,KAAL,CAAW,CAAX,CAFzB,CADD;AAKNH,gBAAAA,KAAK,EAAEsB,IAAI,CAACtB,KAAL,GAAa8B,KAAK,CAAC9B,KALpB;AAMN0W,gBAAAA,IAAI,EAAE,IANA;AAONC,gBAAAA,WAAW,EAAE;AAPP,eAAP;AASA,aAVM,MAUA;AACN,qBAAO;AACNxW,gBAAAA,KAAK,EAAE,CAACmB,IAAI,CAACnB,KAAL,CAAW,CAAX,CAAD,EAAgB2B,KAAK,CAAC3B,KAAN,CAAY,CAAZ,CAAhB,CADD;AAENH,gBAAAA,KAAK,EAAEsB,IAAI,CAACtB,KAAL,GAAa8B,KAAK,CAAC9B,KAFpB;AAGN0W,gBAAAA,IAAI,EAAE,KAHA;AAINC,gBAAAA,WAAW,EAAE;AAJP,eAAP;AAMA;AACD;;AACD;;AACD,aAAK,uBAAL;AAA8B;AAC7B,gBAAMnN,UAAU,GAAG,KAAKiN,qBAAL,CAA2B1b,UAAU,CAACyO,UAAtC,CAAnB;AACA,gBAAMC,SAAS,GAAG,KAAKgN,qBAAL,CAA2B1b,UAAU,CAAC0O,SAAtC,CAAlB;AACA,gBAAMI,KAAK,GAAG,EAAd;;AACA,gBAAIL,UAAU,CAACmN,WAAf,EAA4B;AAC3B9M,cAAAA,KAAK,CAAC1B,IAAN,OAAA0B,KAAK,qBAASL,UAAU,CAACmN,WAApB,EAAL;AACA,aAFD,MAEO,IAAI,CAACnN,UAAU,CAACkN,IAAhB,EAAsB;AAC5B7M,cAAAA,KAAK,CAAC1B,IAAN,CAAWqB,UAAX;AACA,aAFM,MAEA;AACN;AACA;;AACD,gBAAIC,SAAS,CAACkN,WAAd,EAA2B;AAC1B9M,cAAAA,KAAK,CAAC1B,IAAN,OAAA0B,KAAK,qBAASJ,SAAS,CAACkN,WAAnB,EAAL;AACA,aAFD,MAEO,IAAI,CAAClN,SAAS,CAACiN,IAAf,EAAqB;AAC3B7M,cAAAA,KAAK,CAAC1B,IAAN,CAAWsB,SAAX;AACA,aAFM,MAEA;AACN;AACA;;AACD,mBAAO;AACNtJ,cAAAA,KAAK,EAAEhF,SADD;AAEN6E,cAAAA,KAAK,EAAE,EAFD;AAGN0W,cAAAA,IAAI,EAAE,IAHA;AAINC,cAAAA,WAAW,EAAE9M;AAJP,aAAP;AAMA;;AACD,aAAK,SAAL;AACC,iBAAO;AACN1J,YAAAA,KAAK,EAAEpF,UAAU,CAACoF,KADZ;AAENH,YAAAA,KAAK,EAAEjF,UAAU,CAACiF,KAAX,GAAmB,EAFpB;AAGN0W,YAAAA,IAAI,EAAE,KAHA;AAINC,YAAAA,WAAW,EAAE;AAJP,WAAP;AA1DF;;AAiEA,aAAO;AACNxW,QAAAA,KAAK,EAAEhF,SADD;AAEN6E,QAAAA,KAAK,EAAE,EAFD;AAGN0W,QAAAA,IAAI,EAAE,IAHA;AAINC,QAAAA,WAAW,EAAE;AAJP,OAAP;AAMA;AAED;AACD;AACA;AACA;AACA;;;;WACC,eAAMnH,MAAN,EAAcnQ,KAAd,EAAqB;AACpB,UAAIuX,GAAJ;AACA,UAAItX,QAAJ;AACA,UAAMC,UAAU,GAAG,IAAIsX,GAAJ,EAAnB;;AACA,UAAIrH,MAAM,KAAK,IAAf,EAAqB;AACpB,cAAM,IAAIgH,KAAJ,CAAU,yBAAV,CAAN;AACA;;AACD,UAAIM,MAAM,CAACC,QAAP,CAAgBvH,MAAhB,CAAJ,EAA6B;AAC5BA,QAAAA,MAAM,GAAGA,MAAM,CAACwH,QAAP,CAAgB,OAAhB,CAAT;AACA;;AACD,UAAI,OAAOxH,MAAP,KAAkB,QAAtB,EAAgC;AAC/BoH,QAAAA,GAAG;AAAG;AAA4BpH,QAAAA,MAAlC;AACAlQ,QAAAA,QAAQ,GAAGkQ,MAAM,CAAClQ,QAAlB;AACA,OAHD,MAGO;AACNA,QAAAA,QAAQ,GAAG,EAAX;AACAsX,QAAAA,GAAG,GAAG5a,gBAAgB,CAACib,MAAjB,CAAwBzH,MAAxB,EAAgC;AACrChU,UAAAA,UAAU,EAAE,KAAKA,UADoB;AAErCE,UAAAA,SAAS,EAAE4D,QAF0B;AAGrC4X,UAAAA,mBAAmB,EAAE,6BAAAC,GAAG;AAAA,mBAAI5X,UAAU,CAAC6X,GAAX,CAAeD,GAAf,CAAJ;AAAA;AAHa,SAAhC,CAAN;AAKA;;AAED,UAAM/B,QAAQ,GAAG,KAAKhW,KAAtB;AACA,UAAMiY,QAAQ,GAAG,KAAKhY,KAAtB;AACA,UAAMiY,WAAW,GAAG,KAAKhY,QAAzB;AACA,UAAMiY,aAAa,GAAG,KAAKhY,UAA3B;AACA,UAAMiY,gBAAgB,GAAG,KAAKhY,aAA9B;AACA,UAAMiY,gBAAgB,GAAG,KAAKhY,aAA9B;AACA,WAAKL,KAAL,GAAa;AACZ4L,QAAAA,aAAa,EAAE,IADH;AAEZ4D,QAAAA,KAAK,EAAE,KAFK;AAGZuE,QAAAA,WAAW,EAAE,KAHD;AAIZkC,QAAAA,QAAQ,EAAE,KAJE;AAKZC,QAAAA,OAAO,EAAE,KALG;AAMZC,QAAAA,WAAW,EAAE,IAAIhc,UAAJ;AAND,OAAb;AAQA;;AACA,WAAK8F,KAAL,GAAaA,KAAb;AACA,WAAKC,QAAL,GAAgBA,QAAhB;AACA,WAAKC,UAAL,GAAkBA,UAAlB;AACA,WAAKC,aAAL,GAAqB,EAArB;AACA,WAAKC,aAAL,GAAqBtE,SAArB;;AACA,UAAI,KAAKc,KAAL,CAAWiD,OAAX,CAAmBV,IAAnB,CAAwBoY,GAAxB,EAA6BtX,QAA7B,MAA2CnE,SAA/C,EAA0D;AACzD,aAAKoU,UAAL,CAAgBqH,GAAG,CAAChM,IAApB;AACA,aAAKiD,iBAAL,CAAuB+I,GAAG,CAAChM,IAA3B;AACA,aAAKnL,aAAL,GAAqBtE,SAArB;AACA,aAAK6S,sBAAL,CAA4B4I,GAAG,CAAChM,IAAhC;AACA,aAAKnL,aAAL,GAAqBtE,SAArB;AACA,aAAK8S,cAAL,CAAoB2I,GAAG,CAAChM,IAAxB;AACA;;AACD,WAAK3O,KAAL,CAAWkD,MAAX,CAAkBX,IAAlB,CAAuBoY,GAAvB,EAA4BtX,QAA5B;AACA,WAAKF,KAAL,GAAagW,QAAb;AACA;;AACA,WAAK/V,KAAL,GAAagY,QAAb;AACA,WAAK/X,QAAL,GAAgBgY,WAAhB;AACA,WAAK/X,UAAL,GAAkBgY,aAAlB;AACA,WAAK/X,aAAL,GAAqBgY,gBAArB;AACA,WAAK/X,aAAL,GAAqBgY,gBAArB;AACA,aAAOpY,KAAP;AACA;;;WAED,kBAASmQ,MAAT,EAAiB;AAChB,UAAMoH,GAAG,GAAG5a,gBAAgB,CAACib,MAAjB,CAAwB,MAAMzH,MAAN,GAAe,GAAvC,EAA4C;AACvDhU,QAAAA,UAAU,EAAE,KAAKA,UADsC;AAEvDF,QAAAA,SAAS,EAAE;AAF4C,OAA5C,CAAZ;;AAIA,UAAIsb,GAAG,CAAChM,IAAJ,CAAS/P,MAAT,KAAoB,CAApB,IAAyB+b,GAAG,CAAChM,IAAJ,CAAS,CAAT,EAAY5P,IAAZ,KAAqB,qBAAlD,EAAyE;AACxE,cAAM,IAAIwb,KAAJ,CAAU,sCAAV,CAAN;AACA;;AACD,aAAO,KAAKxV,kBAAL,CAAwB4V,GAAG,CAAChM,IAAJ,CAAS,CAAT,EAAY7P,UAApC,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;;WACC,gBAAOgF,IAAP,EAAa2X,gBAAb,EAA+B;AAAA;;AAC9B,UAAI,CAAC3X,IAAL,EAAW,OAAO,IAAP;AACX,UAAMyC,MAAM,GAAG,KAAKvG,KAAL,CAAWQ,MAAX,CACbmD,GADa,CACTG,IAAI,CAAC/E,IADI,EAEbwD,IAFa,CAERuB,IAFQ,EAEF2X,gBAFE,CAAf;AAGA,UAAI,OAAOlV,MAAP,KAAkB,SAAtB,EAAiC,OAAOA,MAAP;;AACjC,cAAQzC,IAAI,CAAC/E,IAAb;AACC,aAAK,kBAAL;AACA,aAAK,iBAAL;AAAwB;AACvB,gBAAI+E,IAAI,CAAC6K,IAAL,CAAU5P,IAAV,KAAmB,WAAvB,EAAoC,OAAO,KAAP;;AACpC,gBAAI+E,IAAI,CAAC2K,UAAL,IAAmB,CAAC,KAAKjO,MAAL,CAAYsD,IAAI,CAAC2K,UAAjB,EAA6B3K,IAAI,CAACI,KAAL,CAAW,CAAX,CAA7B,CAAxB,EAAqE;AACpE,qBAAO,KAAP;AACA;;AACD,gBAAM0J,KAAK;AACV;AACC9J,YAAAA,IAAI,CAAC6K,IAAL,CAAUA,IAFZ;AAIA,mBAAOf,KAAK,CAACI,KAAN,CACN,UAAA0N,IAAI;AAAA,qBACH,CAAC,CAACA,IAAI,CAAC5Q,QAAN,IACA,CAAC4Q,IAAI,CAAC7M,GADN,IAEA,OAAI,CAACrO,MAAL,CAAYkb,IAAI,CAAC7M,GAAjB,EAAsB6M,IAAI,CAACxX,KAAL,CAAW,CAAX,CAAtB,CAFD,MAGC,CAACwX,IAAI,CAACC,MAAN,IACA,CAACD,IAAI,CAAC3X,KADN,IAEA,OAAI,CAACvD,MAAL,CACCkb,IAAI,CAAC3X,KADN,EAEC2X,IAAI,CAAC7M,GAAL,GAAW6M,IAAI,CAAC7M,GAAL,CAAS3K,KAAT,CAAe,CAAf,CAAX,GAA+BwX,IAAI,CAACxX,KAAL,CAAW,CAAX,CAFhC,CALD,CADG;AAAA,aADE,CAAP;AAYA;;AAED,aAAK,qBAAL;AACA,aAAK,oBAAL;AACA,aAAK,yBAAL;AACA,aAAK,SAAL;AACA,aAAK,mBAAL;AACC,iBAAO,IAAP;;AAED,aAAK,qBAAL;AACC,iBAAOJ,IAAI,CAACgQ,YAAL,CAAkB9F,KAAlB,CAAwB,UAAAsG,IAAI;AAAA,mBAClC,OAAI,CAAC9T,MAAL,CAAY8T,IAAI,CAACxB,IAAjB,EAAuBwB,IAAI,CAACpQ,KAAL,CAAW,CAAX,CAAvB,CADkC;AAAA,WAA5B,CAAP;;AAID,aAAK,uBAAL;AACC,iBACC,KAAK1D,MAAL,CAAYsD,IAAI,CAACuJ,IAAjB,EAAuBoO,gBAAvB,KACA,KAAKjb,MAAL,CAAYsD,IAAI,CAACyJ,UAAjB,EAA6BzJ,IAAI,CAACuJ,IAAL,CAAUnJ,KAAV,CAAgB,CAAhB,CAA7B,CADA,IAEA,KAAK1D,MAAL,CAAYsD,IAAI,CAAC0J,SAAjB,EAA4B1J,IAAI,CAACyJ,UAAL,CAAgBrJ,KAAhB,CAAsB,CAAtB,CAA5B,CAHD;;AAMD,aAAK,oBAAL;AACC,iBAAOJ,IAAI,CAACiI,WAAL,CAAiBiC,KAAjB,CAAuB,UAAAlK,IAAI,EAAI;AACrC,gBAAM8X,QAAQ,GAAG,OAAI,CAACpb,MAAL,CAAYsD,IAAZ,EAAkB2X,gBAAlB,CAAjB;;AACAA,YAAAA,gBAAgB,GAAG3X,IAAI,CAACI,KAAL,CAAW,CAAX,CAAnB;AACA,mBAAO0X,QAAP;AACA,WAJM,CAAP;;AAMD,aAAK,gBAAL;AAAuB;AACtB,gBAAMA,QAAQ,GACb9X,IAAI,CAACI,KAAL,CAAW,CAAX,IAAgBuX,gBAAhB,GAAmC,EAAnC,IACA,KAAKI,WAAL,CAAiB,CAACJ,gBAAD,EAAmB3X,IAAI,CAACI,KAAL,CAAW,CAAX,CAAnB,CAAjB,EAAoD4X,IAApD,CACC,UAAAC,OAAO;AAAA,qBACNA,OAAO,CAAChd,IAAR,KAAiB,OAAjB,IACA,wBAAwBsO,IAAxB,CAA6B0O,OAAO,CAAChY,KAArC,CAFM;AAAA,aADR,CAFD;AAOA,gBAAI,CAAC6X,QAAL,EAAe,OAAO,KAAP;AACfH,YAAAA,gBAAgB,GAAG3X,IAAI,CAACU,MAAL,CAAYN,KAAZ,CAAkB,CAAlB,CAAnB;AACA,mBAAOJ,IAAI,CAACW,SAAL,CAAeuJ,KAAf,CAAqB,UAAAzE,GAAG,EAAI;AAClC,kBAAIA,GAAG,CAACxK,IAAJ,KAAa,eAAjB,EAAkC,OAAO,KAAP;;AAClC,kBAAM6c,QAAQ,GAAG,OAAI,CAACpb,MAAL,CAAY+I,GAAZ,EAAiBkS,gBAAjB,CAAjB;;AACAA,cAAAA,gBAAgB,GAAGlS,GAAG,CAACrF,KAAJ,CAAU,CAAV,CAAnB;AACA,qBAAO0X,QAAP;AACA,aALM,CAAP;AAMA;AAnEF;;AAqEA,UAAMrN,SAAS,GAAG,KAAKxJ,kBAAL,CAAwBjB,IAAxB,CAAlB;AACA,aAAO,CAACyK,SAAS,CAACzI,oBAAV,EAAR;AACA;;;WAED,qBAAY5B,KAAZ,EAAmB;AAClB,kCAA+BA,KAA/B;AAAA,UAAO8X,UAAP;AAAA,UAAmBC,QAAnB;;AACA,UAAMC,OAAO,GAAG,SAAVA,OAAU,CAACH,OAAD,EAAUI,MAAV;AAAA,eAAqBJ,OAAO,CAAC7X,KAAR,CAAc,CAAd,IAAmBiY,MAAxC;AAAA,OAAhB;;AACA,UAAIjE,GAAG,GAAG3a,kBAAkB,CAAC6e,EAAnB,CAAsB,KAAK/Y,QAA3B,EAAqC2Y,UAArC,EAAiDE,OAAjD,CAAV;AACA,UAAIG,eAAe,GAAG,EAAtB;;AACA,aAAO,KAAKhZ,QAAL,CAAc6U,GAAd,KAAsB,KAAK7U,QAAL,CAAc6U,GAAd,EAAmBhU,KAAnB,CAAyB,CAAzB,KAA+B+X,QAA5D,EAAsE;AACrEI,QAAAA,eAAe,CAACnQ,IAAhB,CAAqB,KAAK7I,QAAL,CAAc6U,GAAd,CAArB;AACAA,QAAAA,GAAG;AACH;;AAED,aAAOmE,eAAP;AACA;AAED;AACD;AACA;AACA;;;;WACC,uBAAcnB,GAAd,EAAmB;AAClB,UAAM9D,gBAAgB,GAAG,KAAK7T,aAAL,CAAmB,KAAKA,aAAL,CAAmB3E,MAAnB,GAA4B,CAA/C,CAAzB;AACA,UAAIwY,gBAAgB,KAAKlY,SAAzB,EAAoC,MAAM,IAAIqb,KAAJ,CAAU,kBAAV,CAAN;AACpC,aACC;AACCnD,QAAAA,gBAAgB,CAAClT,KAAjB,CAAuB,CAAvB,MAA8BgX,GAA9B,IAAqC,KAAK5X,UAAL,CAAgBgZ,GAAhB,CAAoBpB,GAApB,CAAtC,IACA;AACA;AACC9D,QAAAA,gBAAgB,CAAClT,KAAjB,CAAuB,CAAvB,MAA8BgX,GAA9B,IACA;AACA,aAAK1X,aAAL,KAAuBtE,SAFvB,IAGA;AACA,aAAKoE,UAAL,CAAgBgZ,GAAhB,CAAoB,KAAK9Y,aAAL,CAAmBU,KAAnB,CAAyB,CAAzB,CAApB;AATF;AAWA;AAED;AACD;AACA;AACA;;;;WACC,0BAAiBgX,GAAjB,EAAsB;AACrB,WAAK5X,UAAL,CAAgBiZ,MAAhB,CAAuBrB,GAAvB;AACA;;;WAED,oCAA2BpX,IAA3B,EAAiC;AAChC,UAAMsT,gBAAgB,GAAG,KAAK7T,aAAL,CAAmB,KAAKA,aAAL,CAAmB3E,MAAnB,GAA4B,CAA/C,CAAzB;AACA,aACCkF,IAAI,KAAKsT,gBAAT,IACCA,gBAAgB,CAACrY,IAAjB,KAA0B,qBAA1B,IACAqY,gBAAgB,CAACtY,UAAjB,KAAgCgF,IAHlC;AAKA;;;WAED,oBAAWpF,IAAX,EAAiB6N,GAAjB,EAAsB;AACrB,UAAMnC,IAAI,GAAG,KAAKjH,KAAL,CAAWmW,WAAX,CAAuB/O,GAAvB,CAA2B7L,IAA3B,CAAb;;AACA,UAAI0L,IAAI,YAAYpM,YAApB,EAAkC;AACjC,YAAIG,OAAO,GAAGiM,IAAI,CAACjM,OAAnB;;AACA,eAAOA,OAAO,KAAKe,SAAnB,EAA8B;AAC7B,cAAIf,OAAO,CAACoO,GAAR,KAAgBA,GAApB,EAAyB,OAAOpO,OAAO,CAAC+a,IAAf;AACzB/a,UAAAA,OAAO,GAAGA,OAAO,CAACiQ,IAAlB;AACA;AACD;AACD;;;WAED,qBAAY1P,IAAZ,EAAkB6N,GAAlB,EAAuB2M,IAAvB,EAA6B;AAC5B,UAAMsD,OAAO,GAAG,KAAKrZ,KAAL,CAAWmW,WAAX,CAAuB/O,GAAvB,CAA2B7L,IAA3B,CAAhB;AACA;;AACA,UAAI+d,OAAJ;;AACA,UAAID,OAAO,KAAKtd,SAAhB,EAA2B;AAC1Bud,QAAAA,OAAO,GAAG,IAAIze,YAAJ,CAAiB,KAAKmF,KAAtB,EAA6BzE,IAA7B,EAAmC;AAC5C6N,UAAAA,GAAG,EAAHA,GAD4C;AAE5C2M,UAAAA,IAAI,EAAJA,IAF4C;AAG5C9K,UAAAA,IAAI,EAAElP;AAHsC,SAAnC,CAAV;AAKA,OAND,MAMO,IAAIsd,OAAO,YAAYxe,YAAvB,EAAqC;AAC3Cye,QAAAA,OAAO,GAAG,IAAIze,YAAJ,CAAiBwe,OAAO,CAACve,aAAzB,EAAwCue,OAAO,CAACte,QAAhD,EAA0D;AACnEqO,UAAAA,GAAG,EAAHA,GADmE;AAEnE2M,UAAAA,IAAI,EAAJA,IAFmE;AAGnE9K,UAAAA,IAAI,EAAEoO,OAAO,CAACre;AAHqD,SAA1D,CAAV;AAKA,OANM,MAMA;AACNse,QAAAA,OAAO,GAAG,IAAIze,YAAJ,CAAiBwe,OAAjB,EAA0B,IAA1B,EAAgC;AACzCjQ,UAAAA,GAAG,EAAHA,GADyC;AAEzC2M,UAAAA,IAAI,EAAJA,IAFyC;AAGzC9K,UAAAA,IAAI,EAAElP;AAHmC,SAAhC,CAAV;AAKA;;AACD,WAAKiE,KAAL,CAAWmW,WAAX,CAAuBoD,GAAvB,CAA2Bhe,IAA3B,EAAiC+d,OAAjC;AACA;;;WAED,wBAAe/d,IAAf,EAAqB;AACpB,UAAM8d,OAAO,GAAG,KAAKrZ,KAAL,CAAWmW,WAAX,CAAuB/O,GAAvB,CAA2B7L,IAA3B,CAAhB,CADoB,CAEpB;;AACA,UAAI8d,OAAO,YAAYxe,YAAnB,IAAmCwe,OAAO,CAACve,aAAR,KAA0B,KAAKkF,KAAtE,EACC;AACD,WAAKA,KAAL,CAAWmW,WAAX,CAAuBoD,GAAvB,CAA2Bhe,IAA3B,EAAiC,KAAKyE,KAAtC;AACA;;;WAED,0BAAiBzE,IAAjB,EAAuB;AACtB,WAAKyE,KAAL,CAAWmW,WAAX,CAAuBiD,MAAvB,CAA8B7d,IAA9B;AACA;;;WAED,2BAAkBA,IAAlB,EAAwB;AACvB,UAAM0L,IAAI,GAAG,KAAKjH,KAAL,CAAWmW,WAAX,CAAuB/O,GAAvB,CAA2B7L,IAA3B,CAAb;AACA,UAAI0L,IAAI,KAAKlL,SAAb,EAAwB,OAAO,KAAP;;AACxB,UAAIkL,IAAI,YAAYpM,YAApB,EAAkC;AACjC,eAAOoM,IAAI,CAAClM,QAAL,KAAkB,IAAzB;AACA;;AACD,aAAO,IAAP;AACA;AAED;AACD;AACA;AACA;;;;WACC,yBAAgBQ,IAAhB,EAAsB;AACrB,UAAMqF,KAAK,GAAG,KAAKZ,KAAL,CAAWmW,WAAX,CAAuB/O,GAAvB,CAA2B7L,IAA3B,CAAd;;AACA,UAAIqF,KAAK,KAAK7E,SAAd,EAAyB;AACxB,eAAOR,IAAP;AACA,OAFD,MAEO;AACN,eAAOqF,KAAP;AACA;AACD;AAED;AACD;AACA;AACA;AACA;;;;WACC,qBAAYrF,IAAZ,EAAkBie,YAAlB,EAAgC;AAC/B,UAAI,OAAOA,YAAP,KAAwB,QAA5B,EAAsC;AACrC,YAAIA,YAAY,KAAKje,IAArB,EAA2B;AAC1B,eAAKyE,KAAL,CAAWmW,WAAX,CAAuBiD,MAAvB,CAA8B7d,IAA9B;AACA,SAFD,MAEO;AACN,eAAKyE,KAAL,CAAWmW,WAAX,CAAuBoD,GAAvB,CACChe,IADD,EAEC,IAAIV,YAAJ,CAAiB,KAAKmF,KAAtB,EAA6BwZ,YAA7B,EAA2Czd,SAA3C,CAFD;AAIA;AACD,OATD,MASO;AACN,aAAKiE,KAAL,CAAWmW,WAAX,CAAuBoD,GAAvB,CAA2Bhe,IAA3B,EAAiCie,YAAjC;AACA;AACD;;;WAED,6BAAoBzY,KAApB,EAA2B;AAC1B,UAAMb,QAAQ,GAAG,KAAKwY,WAAL,CAAiB3X,KAAjB,CAAjB;;AACA,UAAIb,QAAQ,CAACzE,MAAT,KAAoB,CAAxB,EAA2B;AAC1B,eAAOgB,qBAAP;AACA;;AACD,UAAIC,OAAO,GAAG,EAAd;AACA,UAAIC,MAAM,GAAG,EAAb;;AAN0B,mDAOJuD,QAPI;AAAA;;AAAA;AAO1B,kEAAgC;AAAA,cAArB0Y,OAAqB;AAC/B,cAAQhY,KAAR,GAAkBgY,OAAlB,CAAQhY,KAAR;;AACA,cAAIA,KAAK,IAAIrE,oBAAoB,CAAC2N,IAArB,CAA0BtJ,KAA1B,CAAb,EAA+C;AAC9C;AACA,gBAAI;AACH,kBAAM6Y,GAAG,GAAGvf,EAAE,CAACwf,eAAH,+BAA0C9Y,KAA1C,YAAZ;AACA9D,cAAAA,MAAM,CAACiC,MAAP,CAAcrC,OAAd,EAAuB+c,GAAvB;AACA,aAHD,CAGE,OAAOzC,CAAP,EAAU;AACXA,cAAAA,CAAC,CAAC4B,OAAF,GAAYA,OAAZ;AACAjc,cAAAA,MAAM,CAACoM,IAAP,CAAYiO,CAAZ;AACA;AACD;AACD;AAnByB;AAAA;AAAA;AAAA;AAAA;;AAoB1B,aAAO;AAAEta,QAAAA,OAAO,EAAPA,OAAF;AAAWC,QAAAA,MAAM,EAANA;AAAX,OAAP;AACA;AAED;AACD;AACA;AACA;;;;WACC,sCAA6BhB,UAA7B,EAAyC;AACxC;AACA,UAAIgF,IAAI,GAAGhF,UAAX;AACA,UAAM4Z,OAAO,GAAG,EAAhB;;AACA,aAAO5U,IAAI,CAAC/E,IAAL,KAAc,kBAArB,EAAyC;AACxC,YAAI+E,IAAI,CAACgH,QAAT,EAAmB;AAClB,cAAIhH,IAAI,CAAC7E,QAAL,CAAcF,IAAd,KAAuB,SAA3B,EAAsC;AACtC2Z,UAAAA,OAAO,CAACxM,IAAR,WAAgBpI,IAAI,CAAC7E,QAAL,CAAc8E,KAA9B;AACA,SAHD,MAGO;AACN,cAAID,IAAI,CAAC7E,QAAL,CAAcF,IAAd,KAAuB,YAA3B,EAAyC;AACzC2Z,UAAAA,OAAO,CAACxM,IAAR,CAAapI,IAAI,CAAC7E,QAAL,CAAcP,IAA3B;AACA;;AACDoF,QAAAA,IAAI,GAAGA,IAAI,CAACtF,MAAZ;AACA;;AACD,aAAO;AACNka,QAAAA,OAAO,EAAPA,OADM;AAENla,QAAAA,MAAM,EAAEsF;AAFF,OAAP;AAIA;AAED;AACD;AACA;AACA;;;;WACC,iCAAwBgZ,OAAxB,EAAiC;AAChC,UAAM1S,IAAI,GAAG,KAAK1F,eAAL,CAAqBoY,OAArB,CAAb;AACA,UAAIpe,IAAJ;;AACA,UAAI0L,IAAI,YAAYpM,YAApB,EAAkC;AACjCU,QAAAA,IAAI,GAAG0L,IAAI,CAAClM,QAAZ;AACA,YAAI,OAAOQ,IAAP,KAAgB,QAApB,EAA8B,OAAOQ,SAAP;AAC9B,OAHD,MAGO,IAAI,OAAOkL,IAAP,KAAgB,QAApB,EAA8B;AACpC,eAAOlL,SAAP;AACA,OAFM,MAEA;AACNR,QAAAA,IAAI,GAAG0L,IAAP;AACA;;AACD,aAAO;AAAEA,QAAAA,IAAI,EAAJA,IAAF;AAAQ1L,QAAAA,IAAI,EAAJA;AAAR,OAAP;AACA;AAED;;AACA;;AAEA;AACD;AACA;AACA;AACA;;;;WACC,iCAAwBI,UAAxB,EAAoCie,YAApC,EAAkD;AACjD,kCAA4B,KAAKC,4BAAL,CAAkCle,UAAlC,CAA5B;AAAA,UAAQN,MAAR,yBAAQA,MAAR;AAAA,UAAgBka,OAAhB,yBAAgBA,OAAhB;;AACA,cAAQla,MAAM,CAACO,IAAf;AACC,aAAK,gBAAL;AAAuB;AACtB,gBAAI,CAACge,YAAY,GAAGpf,oCAAhB,MAA0D,CAA9D,EACC,OAAOuB,SAAP;AACD,gBAAIsF,MAAM,GAAGhG,MAAM,CAACgG,MAApB;AACA,gBAAIyY,WAAW,GAAGvf,WAAlB;;AACA,gBAAI8G,MAAM,CAACzF,IAAP,KAAgB,kBAApB,EAAwC;AAAA,2CAEtC,KAAKie,4BAAL,CAAkCxY,MAAlC,CAFsC;;AAC5BA,cAAAA,MAD4B,0BACpChG,MADoC;AACXye,cAAAA,WADW,0BACpBvE,OADoB;AAGvC;;AACD,gBAAMwE,QAAQ,GAAGre,WAAW,CAAC2F,MAAD,CAA5B;AACA,gBAAI,CAAC0Y,QAAL,EAAe,OAAOhe,SAAP;AACf,gBAAMqH,MAAM,GAAG,KAAK4W,uBAAL,CAA6BD,QAA7B,CAAf;AACA,gBAAI,CAAC3W,MAAL,EAAa,OAAOrH,SAAP;AACb,gBAAcwL,QAAd,GAA+CnE,MAA/C,CAAQ6D,IAAR;AAAA,gBAA8BgT,YAA9B,GAA+C7W,MAA/C,CAAwB7H,IAAxB;AACA,gBAAM2e,UAAU,GAAG9e,sBAAsB,CAAC6e,YAAD,EAAeH,WAAf,CAAzC;AACA,mBAAO;AACNle,cAAAA,IAAI,EAAE,MADA;AAENwD,cAAAA,IAAI,EAAE/D,MAFA;AAGN6e,cAAAA,UAAU,EAAVA,UAHM;AAIN3S,cAAAA,QAAQ,EAARA,QAJM;AAKN6N,cAAAA,gBAAgB,EAAE/a,OAAO,CAAC;AAAA,uBAAMyf,WAAW,CAAChQ,OAAZ,EAAN;AAAA,eAAD,CALnB;AAMNvO,cAAAA,IAAI,EAAEH,sBAAsB,WAAI8e,UAAJ,SAAoB3E,OAApB,CANtB;AAON/N,cAAAA,UAAU,EAAEnN,OAAO,CAAC;AAAA,uBAAMkb,OAAO,CAACzL,OAAR,EAAN;AAAA,eAAD;AAPb,aAAP;AASA;;AACD,aAAK,YAAL;AACA,aAAK,cAAL;AACA,aAAK,gBAAL;AAAuB;AACtB,gBAAI,CAAC8P,YAAY,GAAGnf,+BAAhB,MAAqD,CAAzD,EACC,OAAOsB,SAAP;;AACD,gBAAMge,SAAQ,GAAGre,WAAW,CAACL,MAAD,CAA5B;;AACA,gBAAI,CAAC0e,SAAL,EAAe,OAAOhe,SAAP;;AAEf,gBAAMqH,QAAM,GAAG,KAAK4W,uBAAL,CAA6BD,SAA7B,CAAf;;AACA,gBAAI,CAAC3W,QAAL,EAAa,OAAOrH,SAAP;AACb,gBAAcwL,SAAd,GAA+CnE,QAA/C,CAAQ6D,IAAR;AAAA,gBAA8BgT,aAA9B,GAA+C7W,QAA/C,CAAwB7H,IAAxB;AACA,mBAAO;AACNK,cAAAA,IAAI,EAAE,YADA;AAENL,cAAAA,IAAI,EAAEH,sBAAsB,CAAC6e,aAAD,EAAe1E,OAAf,CAFtB;AAGNhO,cAAAA,QAAQ,EAARA,SAHM;AAINC,cAAAA,UAAU,EAAEnN,OAAO,CAAC;AAAA,uBAAMkb,OAAO,CAACzL,OAAR,EAAN;AAAA,eAAD;AAJb,aAAP;AAMA;AA3CF;AA6CA;AAED;AACD;AACA;AACA;;;;WACC,8BAAqBnO,UAArB,EAAiC;AAChC,aAAO,KAAK+L,uBAAL,CACN/L,UADM,EAENlB,+BAFM,CAAP;AAIA;AAED;AACD;AACA;AACA;AACA;;;;WACC,gBAAc6c,IAAd,EAAoB5a,OAApB,EAA6B;AAC5B,UAAMd,IAAI,GAAGc,OAAO,GAAGA,OAAO,CAACN,UAAX,GAAwB,QAA5C;AACA;;AACA,UAAM+d,aAAa,iDACfne,oBADe;AAElBoe,QAAAA,0BAA0B,EAAExe,IAAI,KAAK;AAFnB,SAGfc,OAHe;AAIlBN,QAAAA,UAAU,EAAER,IAAI,KAAK,MAAT,GAAkB,QAAlB,GAA6BA;AAJvB,QAAnB;AAOA;;;AACA,UAAI4b,GAAJ;AACA,UAAI6C,KAAJ;AACA,UAAIC,KAAK,GAAG,KAAZ;;AACA,UAAI;AACH9C,QAAAA,GAAG;AAAG;AAAwB7c,QAAAA,MAAM,CAAC4f,KAAP,CAAajD,IAAb,EAAmB6C,aAAnB,CAA9B;AACA,OAFD,CAEE,OAAOnD,CAAP,EAAU;AACXqD,QAAAA,KAAK,GAAGrD,CAAR;AACAsD,QAAAA,KAAK,GAAG,IAAR;AACA;;AAED,UAAIA,KAAK,IAAI1e,IAAI,KAAK,MAAtB,EAA8B;AAC7Bue,QAAAA,aAAa,CAAC/d,UAAd,GAA2B,QAA3B;;AACA,YAAI,EAAE,gCAAgCM,OAAlC,CAAJ,EAAgD;AAC/Cyd,UAAAA,aAAa,CAACC,0BAAd,GAA2C,IAA3C;AACA;;AACD,YAAII,KAAK,CAAC3V,OAAN,CAAcsV,aAAa,CAAC7d,SAA5B,CAAJ,EAA4C;AAC3C6d,UAAAA,aAAa,CAAC7d,SAAd,CAAwBb,MAAxB,GAAiC,CAAjC;AACA;;AACD,YAAI;AACH+b,UAAAA,GAAG;AAAG;AAAwB7c,UAAAA,MAAM,CAAC4f,KAAP,CAAajD,IAAb,EAAmB6C,aAAnB,CAA9B;AACAG,UAAAA,KAAK,GAAG,KAAR;AACA,SAHD,CAGE,OAAOtD,CAAP,EAAU,CACX;AACA;AACA;AACD;;AAED,UAAIsD,KAAJ,EAAW;AACV,cAAMD,KAAN;AACA;;AAED;AAAO;AAA4B7C,QAAAA;AAAnC;AACA;;;;EAjiH6B1d,M;;AAoiH/B2gB,MAAM,CAACC,OAAP,GAAiB9d,gBAAjB;AACA6d,MAAM,CAACC,OAAP,CAAehgB,wBAAf,GAA0CA,wBAA1C;AACA+f,MAAM,CAACC,OAAP,CAAejgB,+BAAf,GACCA,+BADD;AAEAggB,MAAM,CAACC,OAAP,CAAelgB,oCAAf,GACCA,oCADD","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { Parser: AcornParser } = require(\"acorn\");\nconst { importAssertions } = require(\"acorn-import-assertions\");\nconst { SyncBailHook, HookMap } = require(\"tapable\");\nconst vm = require(\"vm\");\nconst Parser = require(\"../Parser\");\nconst StackedMap = require(\"../util/StackedMap\");\nconst binarySearchBounds = require(\"../util/binarySearchBounds\");\nconst memoize = require(\"../util/memoize\");\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\n\n/** @typedef {import(\"acorn\").Options} AcornOptions */\n/** @typedef {import(\"estree\").ArrayExpression} ArrayExpressionNode */\n/** @typedef {import(\"estree\").BinaryExpression} BinaryExpressionNode */\n/** @typedef {import(\"estree\").BlockStatement} BlockStatementNode */\n/** @typedef {import(\"estree\").SequenceExpression} SequenceExpressionNode */\n/** @typedef {import(\"estree\").CallExpression} CallExpressionNode */\n/** @typedef {import(\"estree\").ClassDeclaration} ClassDeclarationNode */\n/** @typedef {import(\"estree\").ClassExpression} ClassExpressionNode */\n/** @typedef {import(\"estree\").Comment} CommentNode */\n/** @typedef {import(\"estree\").ConditionalExpression} ConditionalExpressionNode */\n/** @typedef {import(\"estree\").Declaration} DeclarationNode */\n/** @typedef {import(\"estree\").PrivateIdentifier} PrivateIdentifierNode */\n/** @typedef {import(\"estree\").PropertyDefinition} PropertyDefinitionNode */\n/** @typedef {import(\"estree\").Expression} ExpressionNode */\n/** @typedef {import(\"estree\").Identifier} IdentifierNode */\n/** @typedef {import(\"estree\").IfStatement} IfStatementNode */\n/** @typedef {import(\"estree\").LabeledStatement} LabeledStatementNode */\n/** @typedef {import(\"estree\").Literal} LiteralNode */\n/** @typedef {import(\"estree\").LogicalExpression} LogicalExpressionNode */\n/** @typedef {import(\"estree\").ChainExpression} ChainExpressionNode */\n/** @typedef {import(\"estree\").MemberExpression} MemberExpressionNode */\n/** @typedef {import(\"estree\").MetaProperty} MetaPropertyNode */\n/** @typedef {import(\"estree\").MethodDefinition} MethodDefinitionNode */\n/** @typedef {import(\"estree\").ModuleDeclaration} ModuleDeclarationNode */\n/** @typedef {import(\"estree\").NewExpression} NewExpressionNode */\n/** @typedef {import(\"estree\").Node} AnyNode */\n/** @typedef {import(\"estree\").Program} ProgramNode */\n/** @typedef {import(\"estree\").Statement} StatementNode */\n/** @typedef {import(\"estree\").ImportDeclaration} ImportDeclarationNode */\n/** @typedef {import(\"estree\").ExportNamedDeclaration} ExportNamedDeclarationNode */\n/** @typedef {import(\"estree\").ExportDefaultDeclaration} ExportDefaultDeclarationNode */\n/** @typedef {import(\"estree\").ExportAllDeclaration} ExportAllDeclarationNode */\n/** @typedef {import(\"estree\").Super} SuperNode */\n/** @typedef {import(\"estree\").TaggedTemplateExpression} TaggedTemplateExpressionNode */\n/** @typedef {import(\"estree\").TemplateLiteral} TemplateLiteralNode */\n/** @typedef {import(\"estree\").ThisExpression} ThisExpressionNode */\n/** @typedef {import(\"estree\").UnaryExpression} UnaryExpressionNode */\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclaratorNode */\n/** @template T @typedef {import(\"tapable\").AsArray<T>} AsArray<T> */\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n/** @typedef {import(\"../Parser\").PreparsedAst} PreparsedAst */\n/** @typedef {{declaredScope: ScopeInfo, freeName: string | true, tagInfo: TagInfo | undefined}} VariableInfoInterface */\n/** @typedef {{ name: string | VariableInfo, rootInfo: string | VariableInfo, getMembers: () => string[] }} GetInfoResult */\n\nconst EMPTY_ARRAY = [];\nconst ALLOWED_MEMBER_TYPES_CALL_EXPRESSION = 0b01;\nconst ALLOWED_MEMBER_TYPES_EXPRESSION = 0b10;\nconst ALLOWED_MEMBER_TYPES_ALL = 0b11;\n\n// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\n\nconst parser = AcornParser.extend(importAssertions);\n\nclass VariableInfo {\n\t/**\n\t * @param {ScopeInfo} declaredScope scope in which the variable is declared\n\t * @param {string | true} freeName which free name the variable aliases, or true when none\n\t * @param {TagInfo | undefined} tagInfo info about tags\n\t */\n\tconstructor(declaredScope, freeName, tagInfo) {\n\t\tthis.declaredScope = declaredScope;\n\t\tthis.freeName = freeName;\n\t\tthis.tagInfo = tagInfo;\n\t}\n}\n\n/** @typedef {string | ScopeInfo | VariableInfo} ExportedVariableInfo */\n/** @typedef {LiteralNode | string | null | undefined} ImportSource */\n/** @typedef {Omit<AcornOptions, \"sourceType\" | \"ecmaVersion\"> & { sourceType: \"module\" | \"script\" | \"auto\", ecmaVersion?: AcornOptions[\"ecmaVersion\"] }} ParseOptions */\n\n/**\n * @typedef {Object} TagInfo\n * @property {any} tag\n * @property {any} data\n * @property {TagInfo | undefined} next\n */\n\n/**\n * @typedef {Object} ScopeInfo\n * @property {StackedMap<string, VariableInfo | ScopeInfo>} definitions\n * @property {boolean | \"arrow\"} topLevelScope\n * @property {boolean} inShorthand\n * @property {boolean} isStrict\n * @property {boolean} isAsmJs\n * @property {boolean} inTry\n */\n\nconst joinRanges = (startRange, endRange) => {\n\tif (!endRange) return startRange;\n\tif (!startRange) return endRange;\n\treturn [startRange[0], endRange[1]];\n};\n\nconst objectAndMembersToName = (object, membersReversed) => {\n\tlet name = object;\n\tfor (let i = membersReversed.length - 1; i >= 0; i--) {\n\t\tname = name + \".\" + membersReversed[i];\n\t}\n\treturn name;\n};\n\nconst getRootName = expression => {\n\tswitch (expression.type) {\n\t\tcase \"Identifier\":\n\t\t\treturn expression.name;\n\t\tcase \"ThisExpression\":\n\t\t\treturn \"this\";\n\t\tcase \"MetaProperty\":\n\t\t\treturn `${expression.meta.name}.${expression.property.name}`;\n\t\tdefault:\n\t\t\treturn undefined;\n\t}\n};\n\n/** @type {AcornOptions} */\nconst defaultParserOptions = {\n\tranges: true,\n\tlocations: true,\n\tecmaVersion: \"latest\",\n\tsourceType: \"module\",\n\t// https://github.com/tc39/proposal-hashbang\n\tallowHashBang: true,\n\tonComment: null\n};\n\n// regexp to match at least one \"magic comment\"\nconst webpackCommentRegExp = new RegExp(/(^|\\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);\n\nconst EMPTY_COMMENT_OPTIONS = {\n\toptions: null,\n\terrors: null\n};\n\nclass JavascriptParser extends Parser {\n\t/**\n\t * @param {\"module\" | \"script\" | \"auto\"} sourceType default source type\n\t */\n\tconstructor(sourceType = \"auto\") {\n\t\tsuper();\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {HookMap<SyncBailHook<[UnaryExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluateTypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluate: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode | MetaPropertyNode], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluateIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluateDefinedIdentifier: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[CallExpressionNode, BasicEvaluatedExpression | undefined], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluateCallExpressionMember: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"param\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode | DeclarationNode | PrivateIdentifierNode, number], boolean | void>>} */\n\t\t\tisPure: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"commentsStartPosition\"])\n\t\t\t),\n\t\t\t/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */\n\t\t\tpreStatement: new SyncBailHook([\"statement\"]),\n\n\t\t\t/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */\n\t\t\tblockPreStatement: new SyncBailHook([\"declaration\"]),\n\t\t\t/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */\n\t\t\tstatement: new SyncBailHook([\"statement\"]),\n\t\t\t/** @type {SyncBailHook<[IfStatementNode], boolean | void>} */\n\t\t\tstatementIf: new SyncBailHook([\"statement\"]),\n\t\t\t/** @type {SyncBailHook<[ExpressionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */\n\t\t\tclassExtendsExpression: new SyncBailHook([\n\t\t\t\t\"expression\",\n\t\t\t\t\"classDefinition\"\n\t\t\t]),\n\t\t\t/** @type {SyncBailHook<[MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */\n\t\t\tclassBodyElement: new SyncBailHook([\"element\", \"classDefinition\"]),\n\t\t\t/** @type {SyncBailHook<[ExpressionNode, MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */\n\t\t\tclassBodyValue: new SyncBailHook([\n\t\t\t\t\"expression\",\n\t\t\t\t\"element\",\n\t\t\t\t\"classDefinition\"\n\t\t\t]),\n\t\t\t/** @type {HookMap<SyncBailHook<[LabeledStatementNode], boolean | void>>} */\n\t\t\tlabel: new HookMap(() => new SyncBailHook([\"statement\"])),\n\t\t\t/** @type {SyncBailHook<[ImportDeclarationNode, ImportSource], boolean | void>} */\n\t\t\timport: new SyncBailHook([\"statement\", \"source\"]),\n\t\t\t/** @type {SyncBailHook<[ImportDeclarationNode, ImportSource, string, string], boolean | void>} */\n\t\t\timportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"source\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"identifierName\"\n\t\t\t]),\n\t\t\t/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode], boolean | void>} */\n\t\t\texport: new SyncBailHook([\"statement\"]),\n\t\t\t/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource], boolean | void>} */\n\t\t\texportImport: new SyncBailHook([\"statement\", \"source\"]),\n\t\t\t/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, DeclarationNode], boolean | void>} */\n\t\t\texportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n\t\t\t/** @type {SyncBailHook<[ExportDefaultDeclarationNode, DeclarationNode], boolean | void>} */\n\t\t\texportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n\t\t\t/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, string, string, number | undefined], boolean | void>} */\n\t\t\texportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"identifierName\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"index\"\n\t\t\t]),\n\t\t\t/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource, string, string, number | undefined], boolean | void>} */\n\t\t\texportImportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"source\",\n\t\t\t\t\"identifierName\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"index\"\n\t\t\t]),\n\t\t\t/** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */\n\t\t\tpreDeclarator: new SyncBailHook([\"declarator\", \"statement\"]),\n\t\t\t/** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */\n\t\t\tdeclarator: new SyncBailHook([\"declarator\", \"statement\"]),\n\t\t\t/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n\t\t\tvarDeclaration: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n\t\t\tvarDeclarationLet: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n\t\t\tvarDeclarationConst: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n\t\t\tvarDeclarationVar: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[IdentifierNode], boolean | void>>} */\n\t\t\tpattern: new HookMap(() => new SyncBailHook([\"pattern\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n\t\t\tcanRename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n\t\t\trename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[import(\"estree\").AssignmentExpression], boolean | void>>} */\n\t\t\tassign: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[import(\"estree\").AssignmentExpression, string[]], boolean | void>>} */\n\t\t\tassignMemberChain: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"members\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n\t\t\ttypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n\t\t\timportCall: new SyncBailHook([\"expression\"]),\n\t\t\t/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n\t\t\ttopLevelAwait: new SyncBailHook([\"expression\"]),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n\t\t\tcall: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** Something like \"a.b()\" */\n\t\t\t/** @type {HookMap<SyncBailHook<[CallExpressionNode, string[]], boolean | void>>} */\n\t\t\tcallMemberChain: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"members\"])\n\t\t\t),\n\t\t\t/** Something like \"a.b().c.d\" */\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */\n\t\t\tmemberChainOfCallMemberChain: new HookMap(\n\t\t\t\t() =>\n\t\t\t\t\tnew SyncBailHook([\n\t\t\t\t\t\t\"expression\",\n\t\t\t\t\t\t\"calleeMembers\",\n\t\t\t\t\t\t\"callExpression\",\n\t\t\t\t\t\t\"members\"\n\t\t\t\t\t])\n\t\t\t),\n\t\t\t/** Something like \"a.b().c.d()\"\" */\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */\n\t\t\tcallMemberChainOfCallMemberChain: new HookMap(\n\t\t\t\t() =>\n\t\t\t\t\tnew SyncBailHook([\n\t\t\t\t\t\t\"expression\",\n\t\t\t\t\t\t\"calleeMembers\",\n\t\t\t\t\t\t\"innerCallExpression\",\n\t\t\t\t\t\t\"members\"\n\t\t\t\t\t])\n\t\t\t),\n\t\t\t/** @type {SyncBailHook<[ChainExpressionNode], boolean | void>} */\n\t\t\toptionalChaining: new SyncBailHook([\"optionalChaining\"]),\n\t\t\t/** @type {HookMap<SyncBailHook<[NewExpressionNode], boolean | void>>} */\n\t\t\tnew: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n\t\t\texpression: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode, string[]], boolean | void>>} */\n\t\t\texpressionMemberChain: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"members\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode, string[]], boolean | void>>} */\n\t\t\tunhandledExpressionMemberChain: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"members\"])\n\t\t\t),\n\t\t\t/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n\t\t\texpressionConditionalOperator: new SyncBailHook([\"expression\"]),\n\t\t\t/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n\t\t\texpressionLogicalOperator: new SyncBailHook([\"expression\"]),\n\t\t\t/** @type {SyncBailHook<[ProgramNode, CommentNode[]], boolean | void>} */\n\t\t\tprogram: new SyncBailHook([\"ast\", \"comments\"]),\n\t\t\t/** @type {SyncBailHook<[ProgramNode, CommentNode[]], boolean | void>} */\n\t\t\tfinish: new SyncBailHook([\"ast\", \"comments\"])\n\t\t});\n\t\tthis.sourceType = sourceType;\n\t\t/** @type {ScopeInfo} */\n\t\tthis.scope = undefined;\n\t\t/** @type {ParserState} */\n\t\tthis.state = undefined;\n\t\tthis.comments = undefined;\n\t\tthis.semicolons = undefined;\n\t\t/** @type {(StatementNode|ExpressionNode)[]} */\n\t\tthis.statementPath = undefined;\n\t\tthis.prevStatement = undefined;\n\t\tthis.currentTagData = undefined;\n\t\tthis._initializeEvaluating();\n\t}\n\n\t_initializeEvaluating() {\n\t\tthis.hooks.evaluate.for(\"Literal\").tap(\"JavascriptParser\", _expr => {\n\t\t\tconst expr = /** @type {LiteralNode} */ (_expr);\n\n\t\t\tswitch (typeof expr.value) {\n\t\t\t\tcase \"number\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setNumber(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"bigint\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBigInt(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"boolean\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t\tif (expr.value === null) {\n\t\t\t\treturn new BasicEvaluatedExpression().setNull().setRange(expr.range);\n\t\t\t}\n\t\t\tif (expr.value instanceof RegExp) {\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setRegExp(expr.value)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"NewExpression\").tap(\"JavascriptParser\", _expr => {\n\t\t\tconst expr = /** @type {NewExpressionNode} */ (_expr);\n\t\t\tconst callee = expr.callee;\n\t\t\tif (\n\t\t\t\tcallee.type !== \"Identifier\" ||\n\t\t\t\tcallee.name !== \"RegExp\" ||\n\t\t\t\texpr.arguments.length > 2 ||\n\t\t\t\tthis.getVariableInfo(\"RegExp\") !== \"RegExp\"\n\t\t\t)\n\t\t\t\treturn;\n\n\t\t\tlet regExp, flags;\n\t\t\tconst arg1 = expr.arguments[0];\n\n\t\t\tif (arg1) {\n\t\t\t\tif (arg1.type === \"SpreadElement\") return;\n\n\t\t\t\tconst evaluatedRegExp = this.evaluateExpression(arg1);\n\n\t\t\t\tif (!evaluatedRegExp) return;\n\n\t\t\t\tregExp = evaluatedRegExp.asString();\n\n\t\t\t\tif (!regExp) return;\n\t\t\t} else {\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setRegExp(new RegExp(\"\"))\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\n\t\t\tconst arg2 = expr.arguments[1];\n\n\t\t\tif (arg2) {\n\t\t\t\tif (arg2.type === \"SpreadElement\") return;\n\n\t\t\t\tconst evaluatedFlags = this.evaluateExpression(arg2);\n\n\t\t\t\tif (!evaluatedFlags) return;\n\n\t\t\t\tif (!evaluatedFlags.isUndefined()) {\n\t\t\t\t\tflags = evaluatedFlags.asString();\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tflags === undefined ||\n\t\t\t\t\t\t!BasicEvaluatedExpression.isValidRegExpFlags(flags)\n\t\t\t\t\t)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))\n\t\t\t\t.setRange(expr.range);\n\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"LogicalExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {LogicalExpressionNode} */ (_expr);\n\n\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\tif (!left) return;\n\t\t\t\tlet returnRight = false;\n\t\t\t\t/** @type {boolean|undefined} */\n\t\t\t\tlet allowedRight;\n\t\t\t\tif (expr.operator === \"&&\") {\n\t\t\t\t\tconst leftAsBool = left.asBool();\n\t\t\t\t\tif (leftAsBool === false) return left.setRange(expr.range);\n\t\t\t\t\treturnRight = leftAsBool === true;\n\t\t\t\t\tallowedRight = false;\n\t\t\t\t} else if (expr.operator === \"||\") {\n\t\t\t\t\tconst leftAsBool = left.asBool();\n\t\t\t\t\tif (leftAsBool === true) return left.setRange(expr.range);\n\t\t\t\t\treturnRight = leftAsBool === false;\n\t\t\t\t\tallowedRight = true;\n\t\t\t\t} else if (expr.operator === \"??\") {\n\t\t\t\t\tconst leftAsNullish = left.asNullish();\n\t\t\t\t\tif (leftAsNullish === false) return left.setRange(expr.range);\n\t\t\t\t\tif (leftAsNullish !== true) return;\n\t\t\t\t\treturnRight = true;\n\t\t\t\t} else return;\n\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\tif (!right) return;\n\t\t\t\tif (returnRight) {\n\t\t\t\t\tif (left.couldHaveSideEffects()) right.setSideEffects();\n\t\t\t\t\treturn right.setRange(expr.range);\n\t\t\t\t}\n\n\t\t\t\tconst asBool = right.asBool();\n\n\t\t\t\tif (allowedRight === true && asBool === true) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setRange(expr.range)\n\t\t\t\t\t\t.setTruthy();\n\t\t\t\t} else if (allowedRight === false && asBool === false) {\n\t\t\t\t\treturn new BasicEvaluatedExpression().setRange(expr.range).setFalsy();\n\t\t\t\t}\n\t\t\t});\n\n\t\tconst valueAsExpression = (value, expr, sideEffects) => {\n\t\t\tswitch (typeof value) {\n\t\t\t\tcase \"boolean\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(value)\n\t\t\t\t\t\t.setSideEffects(sideEffects)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"number\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setNumber(value)\n\t\t\t\t\t\t.setSideEffects(sideEffects)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"bigint\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBigInt(value)\n\t\t\t\t\t\t.setSideEffects(sideEffects)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(value)\n\t\t\t\t\t\t.setSideEffects(sideEffects)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t};\n\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"BinaryExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {BinaryExpressionNode} */ (_expr);\n\n\t\t\t\tconst handleConstOperation = fn => {\n\t\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\t\tif (!left || !left.isCompileTimeValue()) return;\n\n\t\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\t\tif (!right || !right.isCompileTimeValue()) return;\n\n\t\t\t\t\tconst result = fn(\n\t\t\t\t\t\tleft.asCompileTimeValue(),\n\t\t\t\t\t\tright.asCompileTimeValue()\n\t\t\t\t\t);\n\t\t\t\t\treturn valueAsExpression(\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\texpr,\n\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t);\n\t\t\t\t};\n\n\t\t\t\tconst isAlwaysDifferent = (a, b) =>\n\t\t\t\t\t(a === true && b === false) || (a === false && b === true);\n\n\t\t\t\tconst handleTemplateStringCompare = (left, right, res, eql) => {\n\t\t\t\t\tconst getPrefix = parts => {\n\t\t\t\t\t\tlet value = \"\";\n\t\t\t\t\t\tfor (const p of parts) {\n\t\t\t\t\t\t\tconst v = p.asString();\n\t\t\t\t\t\t\tif (v !== undefined) value += v;\n\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t};\n\t\t\t\t\tconst getSuffix = parts => {\n\t\t\t\t\t\tlet value = \"\";\n\t\t\t\t\t\tfor (let i = parts.length - 1; i >= 0; i--) {\n\t\t\t\t\t\t\tconst v = parts[i].asString();\n\t\t\t\t\t\t\tif (v !== undefined) value = v + value;\n\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t};\n\t\t\t\t\tconst leftPrefix = getPrefix(left.parts);\n\t\t\t\t\tconst rightPrefix = getPrefix(right.parts);\n\t\t\t\t\tconst leftSuffix = getSuffix(left.parts);\n\t\t\t\t\tconst rightSuffix = getSuffix(right.parts);\n\t\t\t\t\tconst lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);\n\t\t\t\t\tconst lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);\n\t\t\t\t\tif (\n\t\t\t\t\t\tleftPrefix.slice(0, lenPrefix) !==\n\t\t\t\t\t\t\trightPrefix.slice(0, lenPrefix) ||\n\t\t\t\t\t\tleftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(!eql)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tconst handleStrictEqualityComparison = eql => {\n\t\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\t\tif (!left) return;\n\t\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\t\tif (!right) return;\n\t\t\t\t\tconst res = new BasicEvaluatedExpression();\n\t\t\t\t\tres.setRange(expr.range);\n\n\t\t\t\t\tconst leftConst = left.isCompileTimeValue();\n\t\t\t\t\tconst rightConst = right.isCompileTimeValue();\n\n\t\t\t\t\tif (leftConst && rightConst) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(\n\t\t\t\t\t\t\t\teql ===\n\t\t\t\t\t\t\t\t\t(left.asCompileTimeValue() === right.asCompileTimeValue())\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (left.isArray() && right.isArray()) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(!eql)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (left.isTemplateString() && right.isTemplateString()) {\n\t\t\t\t\t\treturn handleTemplateStringCompare(left, right, res, eql);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst leftPrimitive = left.isPrimitiveType();\n\t\t\t\t\tconst rightPrimitive = right.isPrimitiveType();\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t// Primitive !== Object or\n\t\t\t\t\t\t// compile-time object types are never equal to something at runtime\n\t\t\t\t\t\t(leftPrimitive === false &&\n\t\t\t\t\t\t\t(leftConst || rightPrimitive === true)) ||\n\t\t\t\t\t\t(rightPrimitive === false &&\n\t\t\t\t\t\t\t(rightConst || leftPrimitive === true)) ||\n\t\t\t\t\t\t// Different nullish or boolish status also means not equal\n\t\t\t\t\t\tisAlwaysDifferent(left.asBool(), right.asBool()) ||\n\t\t\t\t\t\tisAlwaysDifferent(left.asNullish(), right.asNullish())\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(!eql)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tconst handleAbstractEqualityComparison = eql => {\n\t\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\t\tif (!left) return;\n\t\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\t\tif (!right) return;\n\t\t\t\t\tconst res = new BasicEvaluatedExpression();\n\t\t\t\t\tres.setRange(expr.range);\n\n\t\t\t\t\tconst leftConst = left.isCompileTimeValue();\n\t\t\t\t\tconst rightConst = right.isCompileTimeValue();\n\n\t\t\t\t\tif (leftConst && rightConst) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(\n\t\t\t\t\t\t\t\teql ===\n\t\t\t\t\t\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\t\t\t\t\t\t(left.asCompileTimeValue() == right.asCompileTimeValue())\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (left.isArray() && right.isArray()) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(!eql)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (left.isTemplateString() && right.isTemplateString()) {\n\t\t\t\t\t\treturn handleTemplateStringCompare(left, right, res, eql);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tif (expr.operator === \"+\") {\n\t\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\t\tif (!left) return;\n\t\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\t\tif (!right) return;\n\t\t\t\t\tconst res = new BasicEvaluatedExpression();\n\t\t\t\t\tif (left.isString()) {\n\t\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\t\tres.setString(left.string + right.string);\n\t\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\t\tres.setString(left.string + right.number);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tright.isWrapped() &&\n\t\t\t\t\t\t\tright.prefix &&\n\t\t\t\t\t\t\tright.prefix.isString()\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// \"left\" + (\"prefix\" + inner + \"postfix\")\n\t\t\t\t\t\t\t// => (\"leftPrefix\" + inner + \"postfix\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t\t.setString(left.string + right.prefix.string)\n\t\t\t\t\t\t\t\t\t.setRange(joinRanges(left.range, right.prefix.range)),\n\t\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t\t// \"left\" + ([null] + inner + \"postfix\")\n\t\t\t\t\t\t\t// => (\"left\" + inner + \"postfix\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// \"left\" + expr\n\t\t\t\t\t\t\t// => (\"left\" + expr + \"\")\n\t\t\t\t\t\t\tres.setWrapped(left, null, [right]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (left.isNumber()) {\n\t\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\t\tres.setString(left.number + right.string);\n\t\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\t\tres.setNumber(left.number + right.number);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (left.isBigInt()) {\n\t\t\t\t\t\tif (right.isBigInt()) {\n\t\t\t\t\t\t\tres.setBigInt(left.bigint + right.bigint);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (left.isWrapped()) {\n\t\t\t\t\t\tif (left.postfix && left.postfix.isString() && right.isString()) {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + \"postfix\") + \"right\"\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + \"postfixRight\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t\t.setString(left.postfix.string + right.string)\n\t\t\t\t\t\t\t\t\t.setRange(joinRanges(left.postfix.range, right.range)),\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tleft.postfix &&\n\t\t\t\t\t\t\tleft.postfix.isString() &&\n\t\t\t\t\t\t\tright.isNumber()\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + \"postfix\") + 123\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + \"postfix123\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t\t.setString(left.postfix.string + right.number)\n\t\t\t\t\t\t\t\t\t.setRange(joinRanges(left.postfix.range, right.range)),\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (right.isString()) {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + [null]) + \"right\"\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + \"right\")\n\t\t\t\t\t\t\tres.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n\t\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + [null]) + 123\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + \"123\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t\t.setString(right.number + \"\")\n\t\t\t\t\t\t\t\t\t.setRange(right.range),\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t\t// (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n\t\t\t\t\t\t\t// (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t\tright.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t\t\t\t.concat(left.postfix ? [left.postfix] : [])\n\t\t\t\t\t\t\t\t\t\t.concat(right.prefix ? [right.prefix] : [])\n\t\t\t\t\t\t\t\t\t\t.concat(right.wrappedInnerExpressions)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + postfix) + expr\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + postfix + expr + [null])\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions.concat(\n\t\t\t\t\t\t\t\t\t\tleft.postfix ? [left.postfix, right] : [right]\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\t\t// left + \"right\"\n\t\t\t\t\t\t\t// => ([null] + left + \"right\")\n\t\t\t\t\t\t\tres.setWrapped(null, right, [left]);\n\t\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t\t// left + (prefix + inner + \"postfix\")\n\t\t\t\t\t\t\t// => ([null] + left + prefix + inner + \"postfix\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\t\tright.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t\t(right.prefix ? [left, right.prefix] : [left]).concat(\n\t\t\t\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (left.couldHaveSideEffects() || right.couldHaveSideEffects())\n\t\t\t\t\t\tres.setSideEffects();\n\t\t\t\t\tres.setRange(expr.range);\n\t\t\t\t\treturn res;\n\t\t\t\t} else if (expr.operator === \"-\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l - r);\n\t\t\t\t} else if (expr.operator === \"*\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l * r);\n\t\t\t\t} else if (expr.operator === \"/\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l / r);\n\t\t\t\t} else if (expr.operator === \"**\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l ** r);\n\t\t\t\t} else if (expr.operator === \"===\") {\n\t\t\t\t\treturn handleStrictEqualityComparison(true);\n\t\t\t\t} else if (expr.operator === \"==\") {\n\t\t\t\t\treturn handleAbstractEqualityComparison(true);\n\t\t\t\t} else if (expr.operator === \"!==\") {\n\t\t\t\t\treturn handleStrictEqualityComparison(false);\n\t\t\t\t} else if (expr.operator === \"!=\") {\n\t\t\t\t\treturn handleAbstractEqualityComparison(false);\n\t\t\t\t} else if (expr.operator === \"&\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l & r);\n\t\t\t\t} else if (expr.operator === \"|\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l | r);\n\t\t\t\t} else if (expr.operator === \"^\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l ^ r);\n\t\t\t\t} else if (expr.operator === \">>>\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l >>> r);\n\t\t\t\t} else if (expr.operator === \">>\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l >> r);\n\t\t\t\t} else if (expr.operator === \"<<\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l << r);\n\t\t\t\t} else if (expr.operator === \"<\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l < r);\n\t\t\t\t} else if (expr.operator === \">\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l > r);\n\t\t\t\t} else if (expr.operator === \"<=\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l <= r);\n\t\t\t\t} else if (expr.operator === \">=\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l >= r);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"UnaryExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {UnaryExpressionNode} */ (_expr);\n\n\t\t\t\tconst handleConstOperation = fn => {\n\t\t\t\t\tconst argument = this.evaluateExpression(expr.argument);\n\t\t\t\t\tif (!argument || !argument.isCompileTimeValue()) return;\n\t\t\t\t\tconst result = fn(argument.asCompileTimeValue());\n\t\t\t\t\treturn valueAsExpression(\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\texpr,\n\t\t\t\t\t\targument.couldHaveSideEffects()\n\t\t\t\t\t);\n\t\t\t\t};\n\n\t\t\t\tif (expr.operator === \"typeof\") {\n\t\t\t\t\tswitch (expr.argument.type) {\n\t\t\t\t\t\tcase \"Identifier\": {\n\t\t\t\t\t\t\tconst res = this.callHooksForName(\n\t\t\t\t\t\t\t\tthis.hooks.evaluateTypeof,\n\t\t\t\t\t\t\t\texpr.argument.name,\n\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"MetaProperty\": {\n\t\t\t\t\t\t\tconst res = this.callHooksForName(\n\t\t\t\t\t\t\t\tthis.hooks.evaluateTypeof,\n\t\t\t\t\t\t\t\tgetRootName(expr.argument),\n\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"MemberExpression\": {\n\t\t\t\t\t\t\tconst res = this.callHooksForExpression(\n\t\t\t\t\t\t\t\tthis.hooks.evaluateTypeof,\n\t\t\t\t\t\t\t\texpr.argument,\n\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"ChainExpression\": {\n\t\t\t\t\t\t\tconst res = this.callHooksForExpression(\n\t\t\t\t\t\t\t\tthis.hooks.evaluateTypeof,\n\t\t\t\t\t\t\t\texpr.argument.expression,\n\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"FunctionExpression\": {\n\t\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(\"function\")\n\t\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst arg = this.evaluateExpression(expr.argument);\n\t\t\t\t\tif (arg.isUnknown()) return;\n\t\t\t\t\tif (arg.isString()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"string\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isWrapped()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"string\")\n\t\t\t\t\t\t\t.setSideEffects()\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isUndefined()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"undefined\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isNumber()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"number\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isBigInt()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"bigint\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isBoolean()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"boolean\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"object\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isArray()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"object\")\n\t\t\t\t\t\t\t.setSideEffects(arg.couldHaveSideEffects())\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t} else if (expr.operator === \"!\") {\n\t\t\t\t\tconst argument = this.evaluateExpression(expr.argument);\n\t\t\t\t\tif (!argument) return;\n\t\t\t\t\tconst bool = argument.asBool();\n\t\t\t\t\tif (typeof bool !== \"boolean\") return;\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(!bool)\n\t\t\t\t\t\t.setSideEffects(argument.couldHaveSideEffects())\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t} else if (expr.operator === \"~\") {\n\t\t\t\t\treturn handleConstOperation(v => ~v);\n\t\t\t\t} else if (expr.operator === \"+\") {\n\t\t\t\t\treturn handleConstOperation(v => +v);\n\t\t\t\t} else if (expr.operator === \"-\") {\n\t\t\t\t\treturn handleConstOperation(v => -v);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.hooks.evaluateTypeof.for(\"undefined\").tap(\"JavascriptParser\", expr => {\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setString(\"undefined\")\n\t\t\t\t.setRange(expr.range);\n\t\t});\n\t\tthis.hooks.evaluate.for(\"Identifier\").tap(\"JavascriptParser\", expr => {\n\t\t\tif (/** @type {IdentifierNode} */ (expr).name === \"undefined\") {\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setUndefined()\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t});\n\t\t/**\n\t\t * @param {string} exprType expression type name\n\t\t * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info\n\t\t * @returns {void}\n\t\t */\n\t\tconst tapEvaluateWithVariableInfo = (exprType, getInfo) => {\n\t\t\t/** @type {ExpressionNode | undefined} */\n\t\t\tlet cachedExpression = undefined;\n\t\t\t/** @type {GetInfoResult | undefined} */\n\t\t\tlet cachedInfo = undefined;\n\t\t\tthis.hooks.evaluate.for(exprType).tap(\"JavascriptParser\", expr => {\n\t\t\t\tconst expression = /** @type {MemberExpressionNode} */ (expr);\n\n\t\t\t\tconst info = getInfo(expr);\n\t\t\t\tif (info !== undefined) {\n\t\t\t\t\treturn this.callHooksForInfoWithFallback(\n\t\t\t\t\t\tthis.hooks.evaluateIdentifier,\n\t\t\t\t\t\tinfo.name,\n\t\t\t\t\t\tname => {\n\t\t\t\t\t\t\tcachedExpression = expression;\n\t\t\t\t\t\t\tcachedInfo = info;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tname => {\n\t\t\t\t\t\t\tconst hook = this.hooks.evaluateDefinedIdentifier.get(name);\n\t\t\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\t\t\treturn hook.call(expression);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\texpression\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.hooks.evaluate\n\t\t\t\t.for(exprType)\n\t\t\t\t.tap({ name: \"JavascriptParser\", stage: 100 }, expr => {\n\t\t\t\t\tconst info = cachedExpression === expr ? cachedInfo : getInfo(expr);\n\t\t\t\t\tif (info !== undefined) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setIdentifier(info.name, info.rootInfo, info.getMembers)\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tthis.hooks.finish.tap(\"JavascriptParser\", () => {\n\t\t\t\t// Cleanup for GC\n\t\t\t\tcachedExpression = cachedInfo = undefined;\n\t\t\t});\n\t\t};\n\t\ttapEvaluateWithVariableInfo(\"Identifier\", expr => {\n\t\t\tconst info = this.getVariableInfo(\n\t\t\t\t/** @type {IdentifierNode} */ (expr).name\n\t\t\t);\n\t\t\tif (\n\t\t\t\ttypeof info === \"string\" ||\n\t\t\t\t(info instanceof VariableInfo && typeof info.freeName === \"string\")\n\t\t\t) {\n\t\t\t\treturn { name: info, rootInfo: info, getMembers: () => [] };\n\t\t\t}\n\t\t});\n\t\ttapEvaluateWithVariableInfo(\"ThisExpression\", expr => {\n\t\t\tconst info = this.getVariableInfo(\"this\");\n\t\t\tif (\n\t\t\t\ttypeof info === \"string\" ||\n\t\t\t\t(info instanceof VariableInfo && typeof info.freeName === \"string\")\n\t\t\t) {\n\t\t\t\treturn { name: info, rootInfo: info, getMembers: () => [] };\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"MetaProperty\").tap(\"JavascriptParser\", expr => {\n\t\t\tconst metaProperty = /** @type {MetaPropertyNode} */ (expr);\n\n\t\t\treturn this.callHooksForName(\n\t\t\t\tthis.hooks.evaluateIdentifier,\n\t\t\t\tgetRootName(expr),\n\t\t\t\tmetaProperty\n\t\t\t);\n\t\t});\n\t\ttapEvaluateWithVariableInfo(\"MemberExpression\", expr =>\n\t\t\tthis.getMemberExpressionInfo(\n\t\t\t\t/** @type {MemberExpressionNode} */ (expr),\n\t\t\t\tALLOWED_MEMBER_TYPES_EXPRESSION\n\t\t\t)\n\t\t);\n\n\t\tthis.hooks.evaluate.for(\"CallExpression\").tap(\"JavascriptParser\", _expr => {\n\t\t\tconst expr = /** @type {CallExpressionNode} */ (_expr);\n\t\t\tif (\n\t\t\t\texpr.callee.type !== \"MemberExpression\" ||\n\t\t\t\texpr.callee.property.type !==\n\t\t\t\t\t(expr.callee.computed ? \"Literal\" : \"Identifier\")\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// type Super also possible here\n\t\t\tconst param = this.evaluateExpression(\n\t\t\t\t/** @type {ExpressionNode} */ (expr.callee.object)\n\t\t\t);\n\t\t\tif (!param) return;\n\t\t\tconst property =\n\t\t\t\texpr.callee.property.type === \"Literal\"\n\t\t\t\t\t? `${expr.callee.property.value}`\n\t\t\t\t\t: expr.callee.property.name;\n\t\t\tconst hook = this.hooks.evaluateCallExpressionMember.get(property);\n\t\t\tif (hook !== undefined) {\n\t\t\t\treturn hook.call(expr, param);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"indexOf\")\n\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length === 0) return;\n\t\t\t\tconst [arg1, arg2] = expr.arguments;\n\t\t\t\tif (arg1.type === \"SpreadElement\") return;\n\t\t\t\tconst arg1Eval = this.evaluateExpression(arg1);\n\t\t\t\tif (!arg1Eval.isString()) return;\n\t\t\t\tconst arg1Value = arg1Eval.string;\n\n\t\t\t\tlet result;\n\t\t\t\tif (arg2) {\n\t\t\t\t\tif (arg2.type === \"SpreadElement\") return;\n\t\t\t\t\tconst arg2Eval = this.evaluateExpression(arg2);\n\t\t\t\t\tif (!arg2Eval.isNumber()) return;\n\t\t\t\t\tresult = param.string.indexOf(arg1Value, arg2Eval.number);\n\t\t\t\t} else {\n\t\t\t\t\tresult = param.string.indexOf(arg1Value);\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setNumber(result)\n\t\t\t\t\t.setSideEffects(param.couldHaveSideEffects())\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"replace\")\n\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length !== 2) return;\n\t\t\t\tif (expr.arguments[0].type === \"SpreadElement\") return;\n\t\t\t\tif (expr.arguments[1].type === \"SpreadElement\") return;\n\t\t\t\tlet arg1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\tlet arg2 = this.evaluateExpression(expr.arguments[1]);\n\t\t\t\tif (!arg1.isString() && !arg1.isRegExp()) return;\n\t\t\t\tconst arg1Value = arg1.regExp || arg1.string;\n\t\t\t\tif (!arg2.isString()) return;\n\t\t\t\tconst arg2Value = arg2.string;\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setString(param.string.replace(arg1Value, arg2Value))\n\t\t\t\t\t.setSideEffects(param.couldHaveSideEffects())\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\t[\"substr\", \"substring\", \"slice\"].forEach(fn => {\n\t\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t\t.for(fn)\n\t\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\t\tif (!param.isString()) return;\n\t\t\t\t\tlet arg1;\n\t\t\t\t\tlet result,\n\t\t\t\t\t\tstr = param.string;\n\t\t\t\t\tswitch (expr.arguments.length) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tif (expr.arguments[0].type === \"SpreadElement\") return;\n\t\t\t\t\t\t\targ1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\t\t\t\tif (!arg1.isNumber()) return;\n\t\t\t\t\t\t\tresult = str[fn](arg1.number);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\tif (expr.arguments[0].type === \"SpreadElement\") return;\n\t\t\t\t\t\t\tif (expr.arguments[1].type === \"SpreadElement\") return;\n\t\t\t\t\t\t\targ1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\t\t\t\tconst arg2 = this.evaluateExpression(expr.arguments[1]);\n\t\t\t\t\t\t\tif (!arg1.isNumber()) return;\n\t\t\t\t\t\t\tif (!arg2.isNumber()) return;\n\t\t\t\t\t\t\tresult = str[fn](arg1.number, arg2.number);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(result)\n\t\t\t\t\t\t.setSideEffects(param.couldHaveSideEffects())\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t});\n\t\t});\n\n\t\t/**\n\t\t * @param {\"cooked\" | \"raw\"} kind kind of values to get\n\t\t * @param {TemplateLiteralNode} templateLiteralExpr TemplateLiteral expr\n\t\t * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n\t\t */\n\t\tconst getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {\n\t\t\t/** @type {BasicEvaluatedExpression[]} */\n\t\t\tconst quasis = [];\n\t\t\t/** @type {BasicEvaluatedExpression[]} */\n\t\t\tconst parts = [];\n\n\t\t\tfor (let i = 0; i < templateLiteralExpr.quasis.length; i++) {\n\t\t\t\tconst quasiExpr = templateLiteralExpr.quasis[i];\n\t\t\t\tconst quasi = quasiExpr.value[kind];\n\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tconst prevExpr = parts[parts.length - 1];\n\t\t\t\t\tconst expr = this.evaluateExpression(\n\t\t\t\t\t\ttemplateLiteralExpr.expressions[i - 1]\n\t\t\t\t\t);\n\t\t\t\t\tconst exprAsString = expr.asString();\n\t\t\t\t\tif (\n\t\t\t\t\t\ttypeof exprAsString === \"string\" &&\n\t\t\t\t\t\t!expr.couldHaveSideEffects()\n\t\t\t\t\t) {\n\t\t\t\t\t\t// We can merge quasi + expr + quasi when expr\n\t\t\t\t\t\t// is a const string\n\n\t\t\t\t\t\tprevExpr.setString(prevExpr.string + exprAsString + quasi);\n\t\t\t\t\t\tprevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);\n\t\t\t\t\t\t// We unset the expression as it doesn't match to a single expression\n\t\t\t\t\t\tprevExpr.setExpression(undefined);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tparts.push(expr);\n\t\t\t\t}\n\n\t\t\t\tconst part = new BasicEvaluatedExpression()\n\t\t\t\t\t.setString(quasi)\n\t\t\t\t\t.setRange(quasiExpr.range)\n\t\t\t\t\t.setExpression(quasiExpr);\n\t\t\t\tquasis.push(part);\n\t\t\t\tparts.push(part);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tquasis,\n\t\t\t\tparts\n\t\t\t};\n\t\t};\n\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"TemplateLiteral\")\n\t\t\t.tap(\"JavascriptParser\", _node => {\n\t\t\t\tconst node = /** @type {TemplateLiteralNode} */ (_node);\n\n\t\t\t\tconst { quasis, parts } = getSimplifiedTemplateResult(\"cooked\", node);\n\t\t\t\tif (parts.length === 1) {\n\t\t\t\t\treturn parts[0].setRange(node.range);\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setTemplateString(quasis, parts, \"cooked\")\n\t\t\t\t\t.setRange(node.range);\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"TaggedTemplateExpression\")\n\t\t\t.tap(\"JavascriptParser\", _node => {\n\t\t\t\tconst node = /** @type {TaggedTemplateExpressionNode} */ (_node);\n\t\t\t\tconst tag = this.evaluateExpression(node.tag);\n\n\t\t\t\tif (tag.isIdentifier() && tag.identifier === \"String.raw\") {\n\t\t\t\t\tconst { quasis, parts } = getSimplifiedTemplateResult(\n\t\t\t\t\t\t\"raw\",\n\t\t\t\t\t\tnode.quasi\n\t\t\t\t\t);\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setTemplateString(quasis, parts, \"raw\")\n\t\t\t\t\t\t.setRange(node.range);\n\t\t\t\t}\n\t\t\t});\n\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"concat\")\n\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\tif (!param.isString() && !param.isWrapped()) return;\n\n\t\t\t\tlet stringSuffix = null;\n\t\t\t\tlet hasUnknownParams = false;\n\t\t\t\tconst innerExpressions = [];\n\t\t\t\tfor (let i = expr.arguments.length - 1; i >= 0; i--) {\n\t\t\t\t\tconst arg = expr.arguments[i];\n\t\t\t\t\tif (arg.type === \"SpreadElement\") return;\n\t\t\t\t\tconst argExpr = this.evaluateExpression(arg);\n\t\t\t\t\tif (\n\t\t\t\t\t\thasUnknownParams ||\n\t\t\t\t\t\t(!argExpr.isString() && !argExpr.isNumber())\n\t\t\t\t\t) {\n\t\t\t\t\t\thasUnknownParams = true;\n\t\t\t\t\t\tinnerExpressions.push(argExpr);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst value = argExpr.isString()\n\t\t\t\t\t\t? argExpr.string\n\t\t\t\t\t\t: \"\" + argExpr.number;\n\n\t\t\t\t\tconst newString = value + (stringSuffix ? stringSuffix.string : \"\");\n\t\t\t\t\tconst newRange = [\n\t\t\t\t\t\targExpr.range[0],\n\t\t\t\t\t\t(stringSuffix || argExpr).range[1]\n\t\t\t\t\t];\n\t\t\t\t\tstringSuffix = new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(newString)\n\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t(stringSuffix && stringSuffix.couldHaveSideEffects()) ||\n\t\t\t\t\t\t\t\targExpr.couldHaveSideEffects()\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.setRange(newRange);\n\t\t\t\t}\n\n\t\t\t\tif (hasUnknownParams) {\n\t\t\t\t\tconst prefix = param.isString() ? param : param.prefix;\n\t\t\t\t\tconst inner =\n\t\t\t\t\t\tparam.isWrapped() && param.wrappedInnerExpressions\n\t\t\t\t\t\t\t? param.wrappedInnerExpressions.concat(innerExpressions.reverse())\n\t\t\t\t\t\t\t: innerExpressions.reverse();\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setWrapped(prefix, stringSuffix, inner)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t} else if (param.isWrapped()) {\n\t\t\t\t\tconst postfix = stringSuffix || param.postfix;\n\t\t\t\t\tconst inner = param.wrappedInnerExpressions\n\t\t\t\t\t\t? param.wrappedInnerExpressions.concat(innerExpressions.reverse())\n\t\t\t\t\t\t: innerExpressions.reverse();\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setWrapped(param.prefix, postfix, inner)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t} else {\n\t\t\t\t\tconst newString =\n\t\t\t\t\t\tparam.string + (stringSuffix ? stringSuffix.string : \"\");\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(newString)\n\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t(stringSuffix && stringSuffix.couldHaveSideEffects()) ||\n\t\t\t\t\t\t\t\tparam.couldHaveSideEffects()\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"split\")\n\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length !== 1) return;\n\t\t\t\tif (expr.arguments[0].type === \"SpreadElement\") return;\n\t\t\t\tlet result;\n\t\t\t\tconst arg = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\tif (arg.isString()) {\n\t\t\t\t\tresult = param.string.split(arg.string);\n\t\t\t\t} else if (arg.isRegExp()) {\n\t\t\t\t\tresult = param.string.split(arg.regExp);\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setArray(result)\n\t\t\t\t\t.setSideEffects(param.couldHaveSideEffects())\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"ConditionalExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {ConditionalExpressionNode} */ (_expr);\n\n\t\t\t\tconst condition = this.evaluateExpression(expr.test);\n\t\t\t\tconst conditionValue = condition.asBool();\n\t\t\t\tlet res;\n\t\t\t\tif (conditionValue === undefined) {\n\t\t\t\t\tconst consequent = this.evaluateExpression(expr.consequent);\n\t\t\t\t\tconst alternate = this.evaluateExpression(expr.alternate);\n\t\t\t\t\tif (!consequent || !alternate) return;\n\t\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\t\tif (consequent.isConditional()) {\n\t\t\t\t\t\tres.setOptions(consequent.options);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres.setOptions([consequent]);\n\t\t\t\t\t}\n\t\t\t\t\tif (alternate.isConditional()) {\n\t\t\t\t\t\tres.addOptions(alternate.options);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres.addOptions([alternate]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tres = this.evaluateExpression(\n\t\t\t\t\t\tconditionValue ? expr.consequent : expr.alternate\n\t\t\t\t\t);\n\t\t\t\t\tif (condition.couldHaveSideEffects()) res.setSideEffects();\n\t\t\t\t}\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"ArrayExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {ArrayExpressionNode} */ (_expr);\n\n\t\t\t\tconst items = expr.elements.map(element => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\telement !== null &&\n\t\t\t\t\t\telement.type !== \"SpreadElement\" &&\n\t\t\t\t\t\tthis.evaluateExpression(element)\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t\tif (!items.every(Boolean)) return;\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setItems(items)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"ChainExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {ChainExpressionNode} */ (_expr);\n\t\t\t\t/** @type {ExpressionNode[]} */\n\t\t\t\tconst optionalExpressionsStack = [];\n\t\t\t\t/** @type {ExpressionNode|SuperNode} */\n\t\t\t\tlet next = expr.expression;\n\n\t\t\t\twhile (\n\t\t\t\t\tnext.type === \"MemberExpression\" ||\n\t\t\t\t\tnext.type === \"CallExpression\"\n\t\t\t\t) {\n\t\t\t\t\tif (next.type === \"MemberExpression\") {\n\t\t\t\t\t\tif (next.optional) {\n\t\t\t\t\t\t\t// SuperNode can not be optional\n\t\t\t\t\t\t\toptionalExpressionsStack.push(\n\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (next.object)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext = next.object;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (next.optional) {\n\t\t\t\t\t\t\t// SuperNode can not be optional\n\t\t\t\t\t\t\toptionalExpressionsStack.push(\n\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (next.callee)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext = next.callee;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile (optionalExpressionsStack.length > 0) {\n\t\t\t\t\tconst expression = optionalExpressionsStack.pop();\n\t\t\t\t\tconst evaluated = this.evaluateExpression(expression);\n\n\t\t\t\t\tif (evaluated && evaluated.asNullish()) {\n\t\t\t\t\t\treturn evaluated.setRange(_expr.range);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this.evaluateExpression(expr.expression);\n\t\t\t});\n\t}\n\n\tgetRenameIdentifier(expr) {\n\t\tconst result = this.evaluateExpression(expr);\n\t\tif (result && result.isIdentifier()) {\n\t\t\treturn result.identifier;\n\t\t}\n\t}\n\n\t/**\n\t * @param {ClassExpressionNode | ClassDeclarationNode} classy a class node\n\t * @returns {void}\n\t */\n\twalkClass(classy) {\n\t\tif (classy.superClass) {\n\t\t\tif (!this.hooks.classExtendsExpression.call(classy.superClass, classy)) {\n\t\t\t\tthis.walkExpression(classy.superClass);\n\t\t\t}\n\t\t}\n\t\tif (classy.body && classy.body.type === \"ClassBody\") {\n\t\t\tfor (const classElement of /** @type {TODO} */ (classy.body.body)) {\n\t\t\t\tif (!this.hooks.classBodyElement.call(classElement, classy)) {\n\t\t\t\t\tif (classElement.computed && classElement.key) {\n\t\t\t\t\t\tthis.walkExpression(classElement.key);\n\t\t\t\t\t}\n\t\t\t\t\tif (classElement.value) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!this.hooks.classBodyValue.call(\n\t\t\t\t\t\t\t\tclassElement.value,\n\t\t\t\t\t\t\t\tclassElement,\n\t\t\t\t\t\t\t\tclassy\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\t\t\t\t\t\tthis.scope.topLevelScope = false;\n\t\t\t\t\t\t\tthis.walkExpression(classElement.value);\n\t\t\t\t\t\t\tthis.scope.topLevelScope = wasTopLevel;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Pre walking iterates the scope for variable declarations\n\tpreWalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.preWalkStatement(statement);\n\t\t}\n\t}\n\n\t// Block pre walking iterates the scope for block variable declarations\n\tblockPreWalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.blockPreWalkStatement(statement);\n\t\t}\n\t}\n\n\t// Walking iterates the statements and expressions and processes them\n\twalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.walkStatement(statement);\n\t\t}\n\t}\n\n\tpreWalkStatement(statement) {\n\t\tthis.statementPath.push(statement);\n\t\tif (this.hooks.preStatement.call(statement)) {\n\t\t\tthis.prevStatement = this.statementPath.pop();\n\t\t\treturn;\n\t\t}\n\t\tswitch (statement.type) {\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tthis.preWalkBlockStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\t\tthis.preWalkDoWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\t\tthis.preWalkForInStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tthis.preWalkForOfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tthis.preWalkForStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.preWalkFunctionDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tthis.preWalkIfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tthis.preWalkLabeledStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tthis.preWalkSwitchStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tthis.preWalkTryStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.preWalkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WhileStatement\":\n\t\t\t\tthis.preWalkWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WithStatement\":\n\t\t\t\tthis.preWalkWithStatement(statement);\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.prevStatement = this.statementPath.pop();\n\t}\n\n\tblockPreWalkStatement(statement) {\n\t\tthis.statementPath.push(statement);\n\t\tif (this.hooks.blockPreStatement.call(statement)) {\n\t\t\tthis.prevStatement = this.statementPath.pop();\n\t\t\treturn;\n\t\t}\n\t\tswitch (statement.type) {\n\t\t\tcase \"ImportDeclaration\":\n\t\t\t\tthis.blockPreWalkImportDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportAllDeclaration\":\n\t\t\t\tthis.blockPreWalkExportAllDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.blockPreWalkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.blockPreWalkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.blockPreWalkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.blockPreWalkClassDeclaration(statement);\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.prevStatement = this.statementPath.pop();\n\t}\n\n\twalkStatement(statement) {\n\t\tthis.statementPath.push(statement);\n\t\tif (this.hooks.statement.call(statement) !== undefined) {\n\t\t\tthis.prevStatement = this.statementPath.pop();\n\t\t\treturn;\n\t\t}\n\t\tswitch (statement.type) {\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tthis.walkBlockStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.walkClassDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\t\tthis.walkDoWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.walkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.walkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExpressionStatement\":\n\t\t\t\tthis.walkExpressionStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\t\tthis.walkForInStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tthis.walkForOfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tthis.walkForStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.walkFunctionDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tthis.walkIfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tthis.walkLabeledStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ReturnStatement\":\n\t\t\t\tthis.walkReturnStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tthis.walkSwitchStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ThrowStatement\":\n\t\t\t\tthis.walkThrowStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tthis.walkTryStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.walkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WhileStatement\":\n\t\t\t\tthis.walkWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WithStatement\":\n\t\t\t\tthis.walkWithStatement(statement);\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.prevStatement = this.statementPath.pop();\n\t}\n\n\t/**\n\t * Walks a statements that is nested within a parent statement\n\t * and can potentially be a non-block statement.\n\t * This enforces the nested statement to never be in ASI position.\n\t * @param {StatementNode} statement the nested statement\n\t * @returns {void}\n\t */\n\twalkNestedStatement(statement) {\n\t\tthis.prevStatement = undefined;\n\t\tthis.walkStatement(statement);\n\t}\n\n\t// Real Statements\n\tpreWalkBlockStatement(statement) {\n\t\tthis.preWalkStatements(statement.body);\n\t}\n\n\twalkBlockStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tconst body = statement.body;\n\t\t\tconst prev = this.prevStatement;\n\t\t\tthis.blockPreWalkStatements(body);\n\t\t\tthis.prevStatement = prev;\n\t\t\tthis.walkStatements(body);\n\t\t});\n\t}\n\n\twalkExpressionStatement(statement) {\n\t\tthis.walkExpression(statement.expression);\n\t}\n\n\tpreWalkIfStatement(statement) {\n\t\tthis.preWalkStatement(statement.consequent);\n\t\tif (statement.alternate) {\n\t\t\tthis.preWalkStatement(statement.alternate);\n\t\t}\n\t}\n\n\twalkIfStatement(statement) {\n\t\tconst result = this.hooks.statementIf.call(statement);\n\t\tif (result === undefined) {\n\t\t\tthis.walkExpression(statement.test);\n\t\t\tthis.walkNestedStatement(statement.consequent);\n\t\t\tif (statement.alternate) {\n\t\t\t\tthis.walkNestedStatement(statement.alternate);\n\t\t\t}\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkNestedStatement(statement.consequent);\n\t\t\t} else if (statement.alternate) {\n\t\t\t\tthis.walkNestedStatement(statement.alternate);\n\t\t\t}\n\t\t}\n\t}\n\n\tpreWalkLabeledStatement(statement) {\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\twalkLabeledStatement(statement) {\n\t\tconst hook = this.hooks.label.get(statement.label.name);\n\t\tif (hook !== undefined) {\n\t\t\tconst result = hook.call(statement);\n\t\t\tif (result === true) return;\n\t\t}\n\t\tthis.walkNestedStatement(statement.body);\n\t}\n\n\tpreWalkWithStatement(statement) {\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\twalkWithStatement(statement) {\n\t\tthis.walkExpression(statement.object);\n\t\tthis.walkNestedStatement(statement.body);\n\t}\n\n\tpreWalkSwitchStatement(statement) {\n\t\tthis.preWalkSwitchCases(statement.cases);\n\t}\n\n\twalkSwitchStatement(statement) {\n\t\tthis.walkExpression(statement.discriminant);\n\t\tthis.walkSwitchCases(statement.cases);\n\t}\n\n\twalkTerminatingStatement(statement) {\n\t\tif (statement.argument) this.walkExpression(statement.argument);\n\t}\n\n\twalkReturnStatement(statement) {\n\t\tthis.walkTerminatingStatement(statement);\n\t}\n\n\twalkThrowStatement(statement) {\n\t\tthis.walkTerminatingStatement(statement);\n\t}\n\n\tpreWalkTryStatement(statement) {\n\t\tthis.preWalkStatement(statement.block);\n\t\tif (statement.handler) this.preWalkCatchClause(statement.handler);\n\t\tif (statement.finializer) this.preWalkStatement(statement.finializer);\n\t}\n\n\twalkTryStatement(statement) {\n\t\tif (this.scope.inTry) {\n\t\t\tthis.walkStatement(statement.block);\n\t\t} else {\n\t\t\tthis.scope.inTry = true;\n\t\t\tthis.walkStatement(statement.block);\n\t\t\tthis.scope.inTry = false;\n\t\t}\n\t\tif (statement.handler) this.walkCatchClause(statement.handler);\n\t\tif (statement.finalizer) this.walkStatement(statement.finalizer);\n\t}\n\n\tpreWalkWhileStatement(statement) {\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\twalkWhileStatement(statement) {\n\t\tthis.walkExpression(statement.test);\n\t\tthis.walkNestedStatement(statement.body);\n\t}\n\n\tpreWalkDoWhileStatement(statement) {\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\twalkDoWhileStatement(statement) {\n\t\tthis.walkNestedStatement(statement.body);\n\t\tthis.walkExpression(statement.test);\n\t}\n\n\tpreWalkForStatement(statement) {\n\t\tif (statement.init) {\n\t\t\tif (statement.init.type === \"VariableDeclaration\") {\n\t\t\t\tthis.preWalkStatement(statement.init);\n\t\t\t}\n\t\t}\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\twalkForStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.init) {\n\t\t\t\tif (statement.init.type === \"VariableDeclaration\") {\n\t\t\t\t\tthis.blockPreWalkVariableDeclaration(statement.init);\n\t\t\t\t\tthis.prevStatement = undefined;\n\t\t\t\t\tthis.walkStatement(statement.init);\n\t\t\t\t} else {\n\t\t\t\t\tthis.walkExpression(statement.init);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (statement.test) {\n\t\t\t\tthis.walkExpression(statement.test);\n\t\t\t}\n\t\t\tif (statement.update) {\n\t\t\t\tthis.walkExpression(statement.update);\n\t\t\t}\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.blockPreWalkStatements(body.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkNestedStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\tpreWalkForInStatement(statement) {\n\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\tthis.preWalkVariableDeclaration(statement.left);\n\t\t}\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\twalkForInStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\t\tthis.blockPreWalkVariableDeclaration(statement.left);\n\t\t\t\tthis.walkVariableDeclaration(statement.left);\n\t\t\t} else {\n\t\t\t\tthis.walkPattern(statement.left);\n\t\t\t}\n\t\t\tthis.walkExpression(statement.right);\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.blockPreWalkStatements(body.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkNestedStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\tpreWalkForOfStatement(statement) {\n\t\tif (statement.await && this.scope.topLevelScope === true) {\n\t\t\tthis.hooks.topLevelAwait.call(statement);\n\t\t}\n\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\tthis.preWalkVariableDeclaration(statement.left);\n\t\t}\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\twalkForOfStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\t\tthis.blockPreWalkVariableDeclaration(statement.left);\n\t\t\t\tthis.walkVariableDeclaration(statement.left);\n\t\t\t} else {\n\t\t\t\tthis.walkPattern(statement.left);\n\t\t\t}\n\t\t\tthis.walkExpression(statement.right);\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.blockPreWalkStatements(body.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkNestedStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\t// Declarations\n\tpreWalkFunctionDeclaration(statement) {\n\t\tif (statement.id) {\n\t\t\tthis.defineVariable(statement.id.name);\n\t\t}\n\t}\n\n\twalkFunctionDeclaration(statement) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tthis.inFunctionScope(true, statement.params, () => {\n\t\t\tfor (const param of statement.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (statement.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(statement.body.body);\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(statement.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatement(statement.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(statement.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\tblockPreWalkImportDeclaration(statement) {\n\t\tconst source = statement.source.value;\n\t\tthis.hooks.import.call(statement, source);\n\t\tfor (const specifier of statement.specifiers) {\n\t\t\tconst name = specifier.local.name;\n\t\t\tswitch (specifier.type) {\n\t\t\t\tcase \"ImportDefaultSpecifier\":\n\t\t\t\t\tif (\n\t\t\t\t\t\t!this.hooks.importSpecifier.call(statement, source, \"default\", name)\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ImportSpecifier\":\n\t\t\t\t\tif (\n\t\t\t\t\t\t!this.hooks.importSpecifier.call(\n\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\tspecifier.imported.name,\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ImportNamespaceSpecifier\":\n\t\t\t\t\tif (!this.hooks.importSpecifier.call(statement, source, null, name)) {\n\t\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.defineVariable(name);\n\t\t\t}\n\t\t}\n\t}\n\n\tenterDeclaration(declaration, onIdent) {\n\t\tswitch (declaration.type) {\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tfor (const declarator of declaration.declarations) {\n\t\t\t\t\tswitch (declarator.type) {\n\t\t\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\t\t\tthis.enterPattern(declarator.id, onIdent);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.enterPattern(declaration.id, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.enterPattern(declaration.id, onIdent);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tblockPreWalkExportNamedDeclaration(statement) {\n\t\tlet source;\n\t\tif (statement.source) {\n\t\t\tsource = statement.source.value;\n\t\t\tthis.hooks.exportImport.call(statement, source);\n\t\t} else {\n\t\t\tthis.hooks.export.call(statement);\n\t\t}\n\t\tif (statement.declaration) {\n\t\t\tif (\n\t\t\t\t!this.hooks.exportDeclaration.call(statement, statement.declaration)\n\t\t\t) {\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(statement.declaration);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.blockPreWalkStatement(statement.declaration);\n\t\t\t\tlet index = 0;\n\t\t\t\tthis.enterDeclaration(statement.declaration, def => {\n\t\t\t\t\tthis.hooks.exportSpecifier.call(statement, def, def, index++);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (statement.specifiers) {\n\t\t\tfor (\n\t\t\t\tlet specifierIndex = 0;\n\t\t\t\tspecifierIndex < statement.specifiers.length;\n\t\t\t\tspecifierIndex++\n\t\t\t) {\n\t\t\t\tconst specifier = statement.specifiers[specifierIndex];\n\t\t\t\tswitch (specifier.type) {\n\t\t\t\t\tcase \"ExportSpecifier\": {\n\t\t\t\t\t\tconst name = specifier.exported.name;\n\t\t\t\t\t\tif (source) {\n\t\t\t\t\t\t\tthis.hooks.exportImportSpecifier.call(\n\t\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\tspecifier.local.name,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tspecifierIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\t\tspecifier.local.name,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tspecifierIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twalkExportNamedDeclaration(statement) {\n\t\tif (statement.declaration) {\n\t\t\tthis.walkStatement(statement.declaration);\n\t\t}\n\t}\n\n\tblockPreWalkExportDefaultDeclaration(statement) {\n\t\tconst prev = this.prevStatement;\n\t\tthis.preWalkStatement(statement.declaration);\n\t\tthis.prevStatement = prev;\n\t\tthis.blockPreWalkStatement(statement.declaration);\n\t\tif (\n\t\t\tstatement.declaration.id &&\n\t\t\tstatement.declaration.type !== \"FunctionExpression\" &&\n\t\t\tstatement.declaration.type !== \"ClassExpression\"\n\t\t) {\n\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\tstatement,\n\t\t\t\tstatement.declaration.id.name,\n\t\t\t\t\"default\",\n\t\t\t\tundefined\n\t\t\t);\n\t\t}\n\t}\n\n\twalkExportDefaultDeclaration(statement) {\n\t\tthis.hooks.export.call(statement);\n\t\tif (\n\t\t\tstatement.declaration.id &&\n\t\t\tstatement.declaration.type !== \"FunctionExpression\" &&\n\t\t\tstatement.declaration.type !== \"ClassExpression\"\n\t\t) {\n\t\t\tif (\n\t\t\t\t!this.hooks.exportDeclaration.call(statement, statement.declaration)\n\t\t\t) {\n\t\t\t\tthis.walkStatement(statement.declaration);\n\t\t\t}\n\t\t} else {\n\t\t\t// Acorn parses `export default function() {}` as `FunctionDeclaration` and\n\t\t\t// `export default class {}` as `ClassDeclaration`, both with `id = null`.\n\t\t\t// These nodes must be treated as expressions.\n\t\t\tif (\n\t\t\t\tstatement.declaration.type === \"FunctionDeclaration\" ||\n\t\t\t\tstatement.declaration.type === \"ClassDeclaration\"\n\t\t\t) {\n\t\t\t\tthis.walkStatement(statement.declaration);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(statement.declaration);\n\t\t\t}\n\t\t\tif (!this.hooks.exportExpression.call(statement, statement.declaration)) {\n\t\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\t\tstatement,\n\t\t\t\t\tstatement.declaration,\n\t\t\t\t\t\"default\",\n\t\t\t\t\tundefined\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tblockPreWalkExportAllDeclaration(statement) {\n\t\tconst source = statement.source.value;\n\t\tconst name = statement.exported ? statement.exported.name : null;\n\t\tthis.hooks.exportImport.call(statement, source);\n\t\tthis.hooks.exportImportSpecifier.call(statement, source, null, name, 0);\n\t}\n\n\tpreWalkVariableDeclaration(statement) {\n\t\tif (statement.kind !== \"var\") return;\n\t\tthis._preWalkVariableDeclaration(statement, this.hooks.varDeclarationVar);\n\t}\n\n\tblockPreWalkVariableDeclaration(statement) {\n\t\tif (statement.kind === \"var\") return;\n\t\tconst hookMap =\n\t\t\tstatement.kind === \"const\"\n\t\t\t\t? this.hooks.varDeclarationConst\n\t\t\t\t: this.hooks.varDeclarationLet;\n\t\tthis._preWalkVariableDeclaration(statement, hookMap);\n\t}\n\n\t_preWalkVariableDeclaration(statement, hookMap) {\n\t\tfor (const declarator of statement.declarations) {\n\t\t\tswitch (declarator.type) {\n\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\tif (!this.hooks.preDeclarator.call(declarator, statement)) {\n\t\t\t\t\t\tthis.enterPattern(declarator.id, (name, decl) => {\n\t\t\t\t\t\t\tlet hook = hookMap.get(name);\n\t\t\t\t\t\t\tif (hook === undefined || !hook.call(decl)) {\n\t\t\t\t\t\t\t\thook = this.hooks.varDeclaration.get(name);\n\t\t\t\t\t\t\t\tif (hook === undefined || !hook.call(decl)) {\n\t\t\t\t\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twalkVariableDeclaration(statement) {\n\t\tfor (const declarator of statement.declarations) {\n\t\t\tswitch (declarator.type) {\n\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\tconst renameIdentifier =\n\t\t\t\t\t\tdeclarator.init && this.getRenameIdentifier(declarator.init);\n\t\t\t\t\tif (renameIdentifier && declarator.id.type === \"Identifier\") {\n\t\t\t\t\t\tconst hook = this.hooks.canRename.get(renameIdentifier);\n\t\t\t\t\t\tif (hook !== undefined && hook.call(declarator.init)) {\n\t\t\t\t\t\t\t// renaming with \"var a = b;\"\n\t\t\t\t\t\t\tconst hook = this.hooks.rename.get(renameIdentifier);\n\t\t\t\t\t\t\tif (hook === undefined || !hook.call(declarator.init)) {\n\t\t\t\t\t\t\t\tthis.setVariable(declarator.id.name, renameIdentifier);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!this.hooks.declarator.call(declarator, statement)) {\n\t\t\t\t\t\tthis.walkPattern(declarator.id);\n\t\t\t\t\t\tif (declarator.init) this.walkExpression(declarator.init);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tblockPreWalkClassDeclaration(statement) {\n\t\tif (statement.id) {\n\t\t\tthis.defineVariable(statement.id.name);\n\t\t}\n\t}\n\n\twalkClassDeclaration(statement) {\n\t\tthis.walkClass(statement);\n\t}\n\n\tpreWalkSwitchCases(switchCases) {\n\t\tfor (let index = 0, len = switchCases.length; index < len; index++) {\n\t\t\tconst switchCase = switchCases[index];\n\t\t\tthis.preWalkStatements(switchCase.consequent);\n\t\t}\n\t}\n\n\twalkSwitchCases(switchCases) {\n\t\tthis.inBlockScope(() => {\n\t\t\tconst len = switchCases.length;\n\n\t\t\t// we need to pre walk all statements first since we can have invalid code\n\t\t\t// import A from \"module\";\n\t\t\t// switch(1) {\n\t\t\t//    case 1:\n\t\t\t//      console.log(A); // should fail at runtime\n\t\t\t//    case 2:\n\t\t\t//      const A = 1;\n\t\t\t// }\n\t\t\tfor (let index = 0; index < len; index++) {\n\t\t\t\tconst switchCase = switchCases[index];\n\n\t\t\t\tif (switchCase.consequent.length > 0) {\n\t\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\t\tthis.blockPreWalkStatements(switchCase.consequent);\n\t\t\t\t\tthis.prevStatement = prev;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let index = 0; index < len; index++) {\n\t\t\t\tconst switchCase = switchCases[index];\n\n\t\t\t\tif (switchCase.test) {\n\t\t\t\t\tthis.walkExpression(switchCase.test);\n\t\t\t\t}\n\t\t\t\tif (switchCase.consequent.length > 0) {\n\t\t\t\t\tthis.walkStatements(switchCase.consequent);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpreWalkCatchClause(catchClause) {\n\t\tthis.preWalkStatement(catchClause.body);\n\t}\n\n\twalkCatchClause(catchClause) {\n\t\tthis.inBlockScope(() => {\n\t\t\t// Error binding is optional in catch clause since ECMAScript 2019\n\t\t\tif (catchClause.param !== null) {\n\t\t\t\tthis.enterPattern(catchClause.param, ident => {\n\t\t\t\t\tthis.defineVariable(ident);\n\t\t\t\t});\n\t\t\t\tthis.walkPattern(catchClause.param);\n\t\t\t}\n\t\t\tconst prev = this.prevStatement;\n\t\t\tthis.blockPreWalkStatement(catchClause.body);\n\t\t\tthis.prevStatement = prev;\n\t\t\tthis.walkStatement(catchClause.body);\n\t\t});\n\t}\n\n\twalkPattern(pattern) {\n\t\tswitch (pattern.type) {\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tthis.walkArrayPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tthis.walkAssignmentPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"MemberExpression\":\n\t\t\t\tthis.walkMemberExpression(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tthis.walkObjectPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tthis.walkRestElement(pattern);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twalkAssignmentPattern(pattern) {\n\t\tthis.walkExpression(pattern.right);\n\t\tthis.walkPattern(pattern.left);\n\t}\n\n\twalkObjectPattern(pattern) {\n\t\tfor (let i = 0, len = pattern.properties.length; i < len; i++) {\n\t\t\tconst prop = pattern.properties[i];\n\t\t\tif (prop) {\n\t\t\t\tif (prop.computed) this.walkExpression(prop.key);\n\t\t\t\tif (prop.value) this.walkPattern(prop.value);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkArrayPattern(pattern) {\n\t\tfor (let i = 0, len = pattern.elements.length; i < len; i++) {\n\t\t\tconst element = pattern.elements[i];\n\t\t\tif (element) this.walkPattern(element);\n\t\t}\n\t}\n\n\twalkRestElement(pattern) {\n\t\tthis.walkPattern(pattern.argument);\n\t}\n\n\twalkExpressions(expressions) {\n\t\tfor (const expression of expressions) {\n\t\t\tif (expression) {\n\t\t\t\tthis.walkExpression(expression);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkExpression(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"ArrayExpression\":\n\t\t\t\tthis.walkArrayExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ArrowFunctionExpression\":\n\t\t\t\tthis.walkArrowFunctionExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentExpression\":\n\t\t\t\tthis.walkAssignmentExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"AwaitExpression\":\n\t\t\t\tthis.walkAwaitExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tthis.walkBinaryExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"CallExpression\":\n\t\t\t\tthis.walkCallExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ChainExpression\":\n\t\t\t\tthis.walkChainExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassExpression\":\n\t\t\t\tthis.walkClassExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ConditionalExpression\":\n\t\t\t\tthis.walkConditionalExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionExpression\":\n\t\t\t\tthis.walkFunctionExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"Identifier\":\n\t\t\t\tthis.walkIdentifier(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ImportExpression\":\n\t\t\t\tthis.walkImportExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"LogicalExpression\":\n\t\t\t\tthis.walkLogicalExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"MetaProperty\":\n\t\t\t\tthis.walkMetaProperty(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"MemberExpression\":\n\t\t\t\tthis.walkMemberExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"NewExpression\":\n\t\t\t\tthis.walkNewExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectExpression\":\n\t\t\t\tthis.walkObjectExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"SequenceExpression\":\n\t\t\t\tthis.walkSequenceExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"SpreadElement\":\n\t\t\t\tthis.walkSpreadElement(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"TaggedTemplateExpression\":\n\t\t\t\tthis.walkTaggedTemplateExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"TemplateLiteral\":\n\t\t\t\tthis.walkTemplateLiteral(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ThisExpression\":\n\t\t\t\tthis.walkThisExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"UnaryExpression\":\n\t\t\t\tthis.walkUnaryExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"UpdateExpression\":\n\t\t\t\tthis.walkUpdateExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"YieldExpression\":\n\t\t\t\tthis.walkYieldExpression(expression);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twalkAwaitExpression(expression) {\n\t\tif (this.scope.topLevelScope === true)\n\t\t\tthis.hooks.topLevelAwait.call(expression);\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkArrayExpression(expression) {\n\t\tif (expression.elements) {\n\t\t\tthis.walkExpressions(expression.elements);\n\t\t}\n\t}\n\n\twalkSpreadElement(expression) {\n\t\tif (expression.argument) {\n\t\t\tthis.walkExpression(expression.argument);\n\t\t}\n\t}\n\n\twalkObjectExpression(expression) {\n\t\tfor (\n\t\t\tlet propIndex = 0, len = expression.properties.length;\n\t\t\tpropIndex < len;\n\t\t\tpropIndex++\n\t\t) {\n\t\t\tconst prop = expression.properties[propIndex];\n\t\t\tthis.walkProperty(prop);\n\t\t}\n\t}\n\n\twalkProperty(prop) {\n\t\tif (prop.type === \"SpreadElement\") {\n\t\t\tthis.walkExpression(prop.argument);\n\t\t\treturn;\n\t\t}\n\t\tif (prop.computed) {\n\t\t\tthis.walkExpression(prop.key);\n\t\t}\n\t\tif (prop.shorthand && prop.value && prop.value.type === \"Identifier\") {\n\t\t\tthis.scope.inShorthand = prop.value.name;\n\t\t\tthis.walkIdentifier(prop.value);\n\t\t\tthis.scope.inShorthand = false;\n\t\t} else {\n\t\t\tthis.walkExpression(prop.value);\n\t\t}\n\t}\n\n\twalkFunctionExpression(expression) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tconst scopeParams = expression.params;\n\n\t\t// Add function name in scope for recursive calls\n\t\tif (expression.id) {\n\t\t\tscopeParams.push(expression.id.name);\n\t\t}\n\n\t\tthis.inFunctionScope(true, scopeParams, () => {\n\t\t\tfor (const param of expression.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (expression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(expression.body.body);\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(expression.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatement(expression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(expression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\twalkArrowFunctionExpression(expression) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = wasTopLevel ? \"arrow\" : false;\n\t\tthis.inFunctionScope(false, expression.params, () => {\n\t\t\tfor (const param of expression.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (expression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(expression.body.body);\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(expression.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatement(expression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(expression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\t/**\n\t * @param {SequenceExpressionNode} expression the sequence\n\t */\n\twalkSequenceExpression(expression) {\n\t\tif (!expression.expressions) return;\n\t\t// We treat sequence expressions like statements when they are one statement level\n\t\t// This has some benefits for optimizations that only work on statement level\n\t\tconst currentStatement = this.statementPath[this.statementPath.length - 1];\n\t\tif (\n\t\t\tcurrentStatement === expression ||\n\t\t\t(currentStatement.type === \"ExpressionStatement\" &&\n\t\t\t\tcurrentStatement.expression === expression)\n\t\t) {\n\t\t\tconst old = this.statementPath.pop();\n\t\t\tfor (const expr of expression.expressions) {\n\t\t\t\tthis.statementPath.push(expr);\n\t\t\t\tthis.walkExpression(expr);\n\t\t\t\tthis.statementPath.pop();\n\t\t\t}\n\t\t\tthis.statementPath.push(old);\n\t\t} else {\n\t\t\tthis.walkExpressions(expression.expressions);\n\t\t}\n\t}\n\n\twalkUpdateExpression(expression) {\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkUnaryExpression(expression) {\n\t\tif (expression.operator === \"typeof\") {\n\t\t\tconst result = this.callHooksForExpression(\n\t\t\t\tthis.hooks.typeof,\n\t\t\t\texpression.argument,\n\t\t\t\texpression\n\t\t\t);\n\t\t\tif (result === true) return;\n\t\t\tif (expression.argument.type === \"ChainExpression\") {\n\t\t\t\tconst result = this.callHooksForExpression(\n\t\t\t\t\tthis.hooks.typeof,\n\t\t\t\t\texpression.argument.expression,\n\t\t\t\t\texpression\n\t\t\t\t);\n\t\t\t\tif (result === true) return;\n\t\t\t}\n\t\t}\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkLeftRightExpression(expression) {\n\t\tthis.walkExpression(expression.left);\n\t\tthis.walkExpression(expression.right);\n\t}\n\n\twalkBinaryExpression(expression) {\n\t\tthis.walkLeftRightExpression(expression);\n\t}\n\n\twalkLogicalExpression(expression) {\n\t\tconst result = this.hooks.expressionLogicalOperator.call(expression);\n\t\tif (result === undefined) {\n\t\t\tthis.walkLeftRightExpression(expression);\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkExpression(expression.right);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkAssignmentExpression(expression) {\n\t\tif (expression.left.type === \"Identifier\") {\n\t\t\tconst renameIdentifier = this.getRenameIdentifier(expression.right);\n\t\t\tif (renameIdentifier) {\n\t\t\t\tif (\n\t\t\t\t\tthis.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.canRename,\n\t\t\t\t\t\trenameIdentifier,\n\t\t\t\t\t\texpression.right\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\t// renaming \"a = b;\"\n\t\t\t\t\tif (\n\t\t\t\t\t\t!this.callHooksForInfo(\n\t\t\t\t\t\t\tthis.hooks.rename,\n\t\t\t\t\t\t\trenameIdentifier,\n\t\t\t\t\t\t\texpression.right\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.setVariable(\n\t\t\t\t\t\t\texpression.left.name,\n\t\t\t\t\t\t\tthis.getVariableInfo(renameIdentifier)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.walkExpression(expression.right);\n\t\t\tthis.enterPattern(expression.left, (name, decl) => {\n\t\t\t\tif (!this.callHooksForName(this.hooks.assign, name, expression)) {\n\t\t\t\t\tthis.walkExpression(expression.left);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tif (expression.left.type.endsWith(\"Pattern\")) {\n\t\t\tthis.walkExpression(expression.right);\n\t\t\tthis.enterPattern(expression.left, (name, decl) => {\n\t\t\t\tif (!this.callHooksForName(this.hooks.assign, name, expression)) {\n\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.walkPattern(expression.left);\n\t\t} else if (expression.left.type === \"MemberExpression\") {\n\t\t\tconst exprName = this.getMemberExpressionInfo(\n\t\t\t\texpression.left,\n\t\t\t\tALLOWED_MEMBER_TYPES_EXPRESSION\n\t\t\t);\n\t\t\tif (exprName) {\n\t\t\t\tif (\n\t\t\t\t\tthis.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.assignMemberChain,\n\t\t\t\t\t\texprName.rootInfo,\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\texprName.getMembers()\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.walkExpression(expression.right);\n\t\t\tthis.walkExpression(expression.left);\n\t\t} else {\n\t\t\tthis.walkExpression(expression.right);\n\t\t\tthis.walkExpression(expression.left);\n\t\t}\n\t}\n\n\twalkConditionalExpression(expression) {\n\t\tconst result = this.hooks.expressionConditionalOperator.call(expression);\n\t\tif (result === undefined) {\n\t\t\tthis.walkExpression(expression.test);\n\t\t\tthis.walkExpression(expression.consequent);\n\t\t\tif (expression.alternate) {\n\t\t\t\tthis.walkExpression(expression.alternate);\n\t\t\t}\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkExpression(expression.consequent);\n\t\t\t} else if (expression.alternate) {\n\t\t\t\tthis.walkExpression(expression.alternate);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkNewExpression(expression) {\n\t\tconst result = this.callHooksForExpression(\n\t\t\tthis.hooks.new,\n\t\t\texpression.callee,\n\t\t\texpression\n\t\t);\n\t\tif (result === true) return;\n\t\tthis.walkExpression(expression.callee);\n\t\tif (expression.arguments) {\n\t\t\tthis.walkExpressions(expression.arguments);\n\t\t}\n\t}\n\n\twalkYieldExpression(expression) {\n\t\tif (expression.argument) {\n\t\t\tthis.walkExpression(expression.argument);\n\t\t}\n\t}\n\n\twalkTemplateLiteral(expression) {\n\t\tif (expression.expressions) {\n\t\t\tthis.walkExpressions(expression.expressions);\n\t\t}\n\t}\n\n\twalkTaggedTemplateExpression(expression) {\n\t\tif (expression.tag) {\n\t\t\tthis.walkExpression(expression.tag);\n\t\t}\n\t\tif (expression.quasi && expression.quasi.expressions) {\n\t\t\tthis.walkExpressions(expression.quasi.expressions);\n\t\t}\n\t}\n\n\twalkClassExpression(expression) {\n\t\tthis.walkClass(expression);\n\t}\n\n\t/**\n\t * @param {ChainExpressionNode} expression expression\n\t */\n\twalkChainExpression(expression) {\n\t\tconst result = this.hooks.optionalChaining.call(expression);\n\n\t\tif (result === undefined) {\n\t\t\tif (expression.expression.type === \"CallExpression\") {\n\t\t\t\tthis.walkCallExpression(expression.expression);\n\t\t\t} else {\n\t\t\t\tthis.walkMemberExpression(expression.expression);\n\t\t\t}\n\t\t}\n\t}\n\n\t_walkIIFE(functionExpression, options, currentThis) {\n\t\tconst getVarInfo = argOrThis => {\n\t\t\tconst renameIdentifier = this.getRenameIdentifier(argOrThis);\n\t\t\tif (renameIdentifier) {\n\t\t\t\tif (\n\t\t\t\t\tthis.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.canRename,\n\t\t\t\t\t\trenameIdentifier,\n\t\t\t\t\t\targOrThis\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!this.callHooksForInfo(\n\t\t\t\t\t\t\tthis.hooks.rename,\n\t\t\t\t\t\t\trenameIdentifier,\n\t\t\t\t\t\t\targOrThis\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn this.getVariableInfo(renameIdentifier);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.walkExpression(argOrThis);\n\t\t};\n\t\tconst { params, type } = functionExpression;\n\t\tconst arrow = type === \"ArrowFunctionExpression\";\n\t\tconst renameThis = currentThis ? getVarInfo(currentThis) : null;\n\t\tconst varInfoForArgs = options.map(getVarInfo);\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = wasTopLevel && arrow ? \"arrow\" : false;\n\t\tconst scopeParams = params.filter(\n\t\t\t(identifier, idx) => !varInfoForArgs[idx]\n\t\t);\n\n\t\t// Add function name in scope for recursive calls\n\t\tif (functionExpression.id) {\n\t\t\tscopeParams.push(functionExpression.id.name);\n\t\t}\n\n\t\tthis.inFunctionScope(true, scopeParams, () => {\n\t\t\tif (renameThis && !arrow) {\n\t\t\t\tthis.setVariable(\"this\", renameThis);\n\t\t\t}\n\t\t\tfor (let i = 0; i < varInfoForArgs.length; i++) {\n\t\t\t\tconst varInfo = varInfoForArgs[i];\n\t\t\t\tif (!varInfo) continue;\n\t\t\t\tif (!params[i] || params[i].type !== \"Identifier\") continue;\n\t\t\t\tthis.setVariable(params[i].name, varInfo);\n\t\t\t}\n\t\t\tif (functionExpression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(functionExpression.body.body);\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(functionExpression.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatement(functionExpression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(functionExpression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\twalkImportExpression(expression) {\n\t\tlet result = this.hooks.importCall.call(expression);\n\t\tif (result === true) return;\n\n\t\tthis.walkExpression(expression.source);\n\t}\n\n\twalkCallExpression(expression) {\n\t\tconst isSimpleFunction = fn => {\n\t\t\treturn fn.params.every(p => p.type === \"Identifier\");\n\t\t};\n\t\tif (\n\t\t\texpression.callee.type === \"MemberExpression\" &&\n\t\t\texpression.callee.object.type.endsWith(\"FunctionExpression\") &&\n\t\t\t!expression.callee.computed &&\n\t\t\t(expression.callee.property.name === \"call\" ||\n\t\t\t\texpression.callee.property.name === \"bind\") &&\n\t\t\texpression.arguments.length > 0 &&\n\t\t\tisSimpleFunction(expression.callee.object)\n\t\t) {\n\t\t\t// (function() { }.call/bind(?, ))\n\t\t\tthis._walkIIFE(\n\t\t\t\texpression.callee.object,\n\t\t\t\texpression.arguments.slice(1),\n\t\t\t\texpression.arguments[0]\n\t\t\t);\n\t\t} else if (\n\t\t\texpression.callee.type.endsWith(\"FunctionExpression\") &&\n\t\t\tisSimpleFunction(expression.callee)\n\t\t) {\n\t\t\t// (function() { }())\n\t\t\tthis._walkIIFE(expression.callee, expression.arguments, null);\n\t\t} else {\n\t\t\tif (expression.callee.type === \"MemberExpression\") {\n\t\t\t\tconst exprInfo = this.getMemberExpressionInfo(\n\t\t\t\t\texpression.callee,\n\t\t\t\t\tALLOWED_MEMBER_TYPES_CALL_EXPRESSION\n\t\t\t\t);\n\t\t\t\tif (exprInfo && exprInfo.type === \"call\") {\n\t\t\t\t\tconst result = this.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.callMemberChainOfCallMemberChain,\n\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\texprInfo.getCalleeMembers(),\n\t\t\t\t\t\texprInfo.call,\n\t\t\t\t\t\texprInfo.getMembers()\n\t\t\t\t\t);\n\t\t\t\t\tif (result === true) return;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst callee = this.evaluateExpression(expression.callee);\n\t\t\tif (callee.isIdentifier()) {\n\t\t\t\tconst result1 = this.callHooksForInfo(\n\t\t\t\t\tthis.hooks.callMemberChain,\n\t\t\t\t\tcallee.rootInfo,\n\t\t\t\t\texpression,\n\t\t\t\t\tcallee.getMembers()\n\t\t\t\t);\n\t\t\t\tif (result1 === true) return;\n\t\t\t\tconst result2 = this.callHooksForInfo(\n\t\t\t\t\tthis.hooks.call,\n\t\t\t\t\tcallee.identifier,\n\t\t\t\t\texpression\n\t\t\t\t);\n\t\t\t\tif (result2 === true) return;\n\t\t\t}\n\n\t\t\tif (expression.callee) {\n\t\t\t\tif (expression.callee.type === \"MemberExpression\") {\n\t\t\t\t\t// because of call context we need to walk the call context as expression\n\t\t\t\t\tthis.walkExpression(expression.callee.object);\n\t\t\t\t\tif (expression.callee.computed === true)\n\t\t\t\t\t\tthis.walkExpression(expression.callee.property);\n\t\t\t\t} else {\n\t\t\t\t\tthis.walkExpression(expression.callee);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (expression.arguments) this.walkExpressions(expression.arguments);\n\t\t}\n\t}\n\n\twalkMemberExpression(expression) {\n\t\tconst exprInfo = this.getMemberExpressionInfo(\n\t\t\texpression,\n\t\t\tALLOWED_MEMBER_TYPES_ALL\n\t\t);\n\t\tif (exprInfo) {\n\t\t\tswitch (exprInfo.type) {\n\t\t\t\tcase \"expression\": {\n\t\t\t\t\tconst result1 = this.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.expression,\n\t\t\t\t\t\texprInfo.name,\n\t\t\t\t\t\texpression\n\t\t\t\t\t);\n\t\t\t\t\tif (result1 === true) return;\n\t\t\t\t\tconst members = exprInfo.getMembers();\n\t\t\t\t\tconst result2 = this.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.expressionMemberChain,\n\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\tmembers\n\t\t\t\t\t);\n\t\t\t\t\tif (result2 === true) return;\n\t\t\t\t\tthis.walkMemberExpressionWithExpressionName(\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\texprInfo.name,\n\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\tmembers.slice(),\n\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\tthis.callHooksForInfo(\n\t\t\t\t\t\t\t\tthis.hooks.unhandledExpressionMemberChain,\n\t\t\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\t\t\texpression,\n\t\t\t\t\t\t\t\tmembers\n\t\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcase \"call\": {\n\t\t\t\t\tconst result = this.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.memberChainOfCallMemberChain,\n\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\texprInfo.getCalleeMembers(),\n\t\t\t\t\t\texprInfo.call,\n\t\t\t\t\t\texprInfo.getMembers()\n\t\t\t\t\t);\n\t\t\t\t\tif (result === true) return;\n\t\t\t\t\t// Fast skip over the member chain as we already called memberChainOfCallMemberChain\n\t\t\t\t\t// and call computed property are literals anyway\n\t\t\t\t\tthis.walkExpression(exprInfo.call);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.walkExpression(expression.object);\n\t\tif (expression.computed === true) this.walkExpression(expression.property);\n\t}\n\n\twalkMemberExpressionWithExpressionName(\n\t\texpression,\n\t\tname,\n\t\trootInfo,\n\t\tmembers,\n\t\tonUnhandled\n\t) {\n\t\tif (expression.object.type === \"MemberExpression\") {\n\t\t\t// optimize the case where expression.object is a MemberExpression too.\n\t\t\t// we can keep info here when calling walkMemberExpression directly\n\t\t\tconst property =\n\t\t\t\texpression.property.name || `${expression.property.value}`;\n\t\t\tname = name.slice(0, -property.length - 1);\n\t\t\tmembers.pop();\n\t\t\tconst result = this.callHooksForInfo(\n\t\t\t\tthis.hooks.expression,\n\t\t\t\tname,\n\t\t\t\texpression.object\n\t\t\t);\n\t\t\tif (result === true) return;\n\t\t\tthis.walkMemberExpressionWithExpressionName(\n\t\t\t\texpression.object,\n\t\t\t\tname,\n\t\t\t\trootInfo,\n\t\t\t\tmembers,\n\t\t\t\tonUnhandled\n\t\t\t);\n\t\t} else if (!onUnhandled || !onUnhandled()) {\n\t\t\tthis.walkExpression(expression.object);\n\t\t}\n\t\tif (expression.computed === true) this.walkExpression(expression.property);\n\t}\n\n\twalkThisExpression(expression) {\n\t\tthis.callHooksForName(this.hooks.expression, \"this\", expression);\n\t}\n\n\twalkIdentifier(expression) {\n\t\tthis.callHooksForName(this.hooks.expression, expression.name, expression);\n\t}\n\n\t/**\n\t * @param {MetaPropertyNode} metaProperty meta property\n\t */\n\twalkMetaProperty(metaProperty) {\n\t\tthis.hooks.expression.for(getRootName(metaProperty)).call(metaProperty);\n\t}\n\n\tcallHooksForExpression(hookMap, expr, ...args) {\n\t\treturn this.callHooksForExpressionWithFallback(\n\t\t\thookMap,\n\t\t\texpr,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n\t * @param {MemberExpressionNode} expr expression info\n\t * @param {function(string, string | ScopeInfo | VariableInfo, function(): string[]): any} fallback callback when variable in not handled by hooks\n\t * @param {function(string): any} defined callback when variable is defined\n\t * @param {AsArray<T>} args args for the hook\n\t * @returns {R} result of hook\n\t */\n\tcallHooksForExpressionWithFallback(\n\t\thookMap,\n\t\texpr,\n\t\tfallback,\n\t\tdefined,\n\t\t...args\n\t) {\n\t\tconst exprName = this.getMemberExpressionInfo(\n\t\t\texpr,\n\t\t\tALLOWED_MEMBER_TYPES_EXPRESSION\n\t\t);\n\t\tif (exprName !== undefined) {\n\t\t\tconst members = exprName.getMembers();\n\t\t\treturn this.callHooksForInfoWithFallback(\n\t\t\t\thookMap,\n\t\t\t\tmembers.length === 0 ? exprName.rootInfo : exprName.name,\n\t\t\t\tfallback &&\n\t\t\t\t\t(name => fallback(name, exprName.rootInfo, exprName.getMembers)),\n\t\t\t\tdefined && (() => defined(exprName.name)),\n\t\t\t\t...args\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n\t * @param {string} name key in map\n\t * @param {AsArray<T>} args args for the hook\n\t * @returns {R} result of hook\n\t */\n\tcallHooksForName(hookMap, name, ...args) {\n\t\treturn this.callHooksForNameWithFallback(\n\t\t\thookMap,\n\t\t\tname,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks that should be called\n\t * @param {ExportedVariableInfo} info variable info\n\t * @param  {AsArray<T>} args args for the hook\n\t * @returns {R} result of hook\n\t */\n\tcallHooksForInfo(hookMap, info, ...args) {\n\t\treturn this.callHooksForInfoWithFallback(\n\t\t\thookMap,\n\t\t\tinfo,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n\t * @param {ExportedVariableInfo} info variable info\n\t * @param {function(string): any} fallback callback when variable in not handled by hooks\n\t * @param {function(): any} defined callback when variable is defined\n\t * @param {AsArray<T>} args args for the hook\n\t * @returns {R} result of hook\n\t */\n\tcallHooksForInfoWithFallback(hookMap, info, fallback, defined, ...args) {\n\t\tlet name;\n\t\tif (typeof info === \"string\") {\n\t\t\tname = info;\n\t\t} else {\n\t\t\tif (!(info instanceof VariableInfo)) {\n\t\t\t\tif (defined !== undefined) {\n\t\t\t\t\treturn defined();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet tagInfo = info.tagInfo;\n\t\t\twhile (tagInfo !== undefined) {\n\t\t\t\tconst hook = hookMap.get(tagInfo.tag);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\tthis.currentTagData = tagInfo.data;\n\t\t\t\t\tconst result = hook.call(...args);\n\t\t\t\t\tthis.currentTagData = undefined;\n\t\t\t\t\tif (result !== undefined) return result;\n\t\t\t\t}\n\t\t\t\ttagInfo = tagInfo.next;\n\t\t\t}\n\t\t\tif (info.freeName === true) {\n\t\t\t\tif (defined !== undefined) {\n\t\t\t\t\treturn defined();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tname = info.freeName;\n\t\t}\n\t\tconst hook = hookMap.get(name);\n\t\tif (hook !== undefined) {\n\t\t\tconst result = hook.call(...args);\n\t\t\tif (result !== undefined) return result;\n\t\t}\n\t\tif (fallback !== undefined) {\n\t\t\treturn fallback(name);\n\t\t}\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n\t * @param {string} name key in map\n\t * @param {function(string): any} fallback callback when variable in not handled by hooks\n\t * @param {function(): any} defined callback when variable is defined\n\t * @param {AsArray<T>} args args for the hook\n\t * @returns {R} result of hook\n\t */\n\tcallHooksForNameWithFallback(hookMap, name, fallback, defined, ...args) {\n\t\treturn this.callHooksForInfoWithFallback(\n\t\t\thookMap,\n\t\t\tthis.getVariableInfo(name),\n\t\t\tfallback,\n\t\t\tdefined,\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * @deprecated\n\t * @param {any} params scope params\n\t * @param {function(): void} fn inner function\n\t * @returns {void}\n\t */\n\tinScope(params, fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild()\n\t\t};\n\n\t\tthis.undefineVariable(\"this\");\n\n\t\tthis.enterPatterns(params, (ident, pattern) => {\n\t\t\tthis.defineVariable(ident);\n\t\t});\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\tinFunctionScope(hasThis, params, fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild()\n\t\t};\n\n\t\tif (hasThis) {\n\t\t\tthis.undefineVariable(\"this\");\n\t\t}\n\n\t\tthis.enterPatterns(params, (ident, pattern) => {\n\t\t\tthis.defineVariable(ident);\n\t\t});\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\tinBlockScope(fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: oldScope.inTry,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild()\n\t\t};\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\tdetectMode(statements) {\n\t\tconst isLiteral =\n\t\t\tstatements.length >= 1 &&\n\t\t\tstatements[0].type === \"ExpressionStatement\" &&\n\t\t\tstatements[0].expression.type === \"Literal\";\n\t\tif (isLiteral && statements[0].expression.value === \"use strict\") {\n\t\t\tthis.scope.isStrict = true;\n\t\t}\n\t\tif (isLiteral && statements[0].expression.value === \"use asm\") {\n\t\t\tthis.scope.isAsmJs = true;\n\t\t}\n\t}\n\n\tenterPatterns(patterns, onIdent) {\n\t\tfor (const pattern of patterns) {\n\t\t\tif (typeof pattern !== \"string\") {\n\t\t\t\tthis.enterPattern(pattern, onIdent);\n\t\t\t} else if (pattern) {\n\t\t\t\tonIdent(pattern);\n\t\t\t}\n\t\t}\n\t}\n\n\tenterPattern(pattern, onIdent) {\n\t\tif (!pattern) return;\n\t\tswitch (pattern.type) {\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tthis.enterArrayPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tthis.enterAssignmentPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"Identifier\":\n\t\t\t\tthis.enterIdentifier(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tthis.enterObjectPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tthis.enterRestElement(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"Property\":\n\t\t\t\tif (pattern.shorthand && pattern.value.type === \"Identifier\") {\n\t\t\t\t\tthis.scope.inShorthand = pattern.value.name;\n\t\t\t\t\tthis.enterIdentifier(pattern.value, onIdent);\n\t\t\t\t\tthis.scope.inShorthand = false;\n\t\t\t\t} else {\n\t\t\t\t\tthis.enterPattern(pattern.value, onIdent);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tenterIdentifier(pattern, onIdent) {\n\t\tif (!this.callHooksForName(this.hooks.pattern, pattern.name, pattern)) {\n\t\t\tonIdent(pattern.name, pattern);\n\t\t}\n\t}\n\n\tenterObjectPattern(pattern, onIdent) {\n\t\tfor (\n\t\t\tlet propIndex = 0, len = pattern.properties.length;\n\t\t\tpropIndex < len;\n\t\t\tpropIndex++\n\t\t) {\n\t\t\tconst prop = pattern.properties[propIndex];\n\t\t\tthis.enterPattern(prop, onIdent);\n\t\t}\n\t}\n\n\tenterArrayPattern(pattern, onIdent) {\n\t\tfor (\n\t\t\tlet elementIndex = 0, len = pattern.elements.length;\n\t\t\telementIndex < len;\n\t\t\telementIndex++\n\t\t) {\n\t\t\tconst element = pattern.elements[elementIndex];\n\t\t\tthis.enterPattern(element, onIdent);\n\t\t}\n\t}\n\n\tenterRestElement(pattern, onIdent) {\n\t\tthis.enterPattern(pattern.argument, onIdent);\n\t}\n\n\tenterAssignmentPattern(pattern, onIdent) {\n\t\tthis.enterPattern(pattern.left, onIdent);\n\t}\n\n\t/**\n\t * @param {ExpressionNode} expression expression node\n\t * @returns {BasicEvaluatedExpression | undefined} evaluation result\n\t */\n\tevaluateExpression(expression) {\n\t\ttry {\n\t\t\tconst hook = this.hooks.evaluate.get(expression.type);\n\t\t\tif (hook !== undefined) {\n\t\t\t\tconst result = hook.call(expression);\n\t\t\t\tif (result !== undefined) {\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tresult.setExpression(expression);\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.warn(e);\n\t\t\t// ignore error\n\t\t}\n\t\treturn new BasicEvaluatedExpression()\n\t\t\t.setRange(expression.range)\n\t\t\t.setExpression(expression);\n\t}\n\n\tparseString(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tif (expression.operator === \"+\") {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tthis.parseString(expression.left) +\n\t\t\t\t\t\tthis.parseString(expression.right)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"Literal\":\n\t\t\t\treturn expression.value + \"\";\n\t\t}\n\t\tthrow new Error(\n\t\t\texpression.type + \" is not supported as parameter for require\"\n\t\t);\n\t}\n\n\tparseCalculatedString(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tif (expression.operator === \"+\") {\n\t\t\t\t\tconst left = this.parseCalculatedString(expression.left);\n\t\t\t\t\tconst right = this.parseCalculatedString(expression.right);\n\t\t\t\t\tif (left.code) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: left.range,\n\t\t\t\t\t\t\tvalue: left.value,\n\t\t\t\t\t\t\tcode: true,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (right.code) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: [\n\t\t\t\t\t\t\t\tleft.range[0],\n\t\t\t\t\t\t\t\tright.range ? right.range[1] : left.range[1]\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tvalue: left.value + right.value,\n\t\t\t\t\t\t\tcode: true,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: [left.range[0], right.range[1]],\n\t\t\t\t\t\t\tvalue: left.value + right.value,\n\t\t\t\t\t\t\tcode: false,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"ConditionalExpression\": {\n\t\t\t\tconst consequent = this.parseCalculatedString(expression.consequent);\n\t\t\t\tconst alternate = this.parseCalculatedString(expression.alternate);\n\t\t\t\tconst items = [];\n\t\t\t\tif (consequent.conditional) {\n\t\t\t\t\titems.push(...consequent.conditional);\n\t\t\t\t} else if (!consequent.code) {\n\t\t\t\t\titems.push(consequent);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (alternate.conditional) {\n\t\t\t\t\titems.push(...alternate.conditional);\n\t\t\t\t} else if (!alternate.code) {\n\t\t\t\t\titems.push(alternate);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\trange: undefined,\n\t\t\t\t\tvalue: \"\",\n\t\t\t\t\tcode: true,\n\t\t\t\t\tconditional: items\n\t\t\t\t};\n\t\t\t}\n\t\t\tcase \"Literal\":\n\t\t\t\treturn {\n\t\t\t\t\trange: expression.range,\n\t\t\t\t\tvalue: expression.value + \"\",\n\t\t\t\t\tcode: false,\n\t\t\t\t\tconditional: false\n\t\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\trange: undefined,\n\t\t\tvalue: \"\",\n\t\t\tcode: true,\n\t\t\tconditional: false\n\t\t};\n\t}\n\n\t/**\n\t * @param {string | Buffer | PreparsedAst} source the source to parse\n\t * @param {ParserState} state the parser state\n\t * @returns {ParserState} the parser state\n\t */\n\tparse(source, state) {\n\t\tlet ast;\n\t\tlet comments;\n\t\tconst semicolons = new Set();\n\t\tif (source === null) {\n\t\t\tthrow new Error(\"source must not be null\");\n\t\t}\n\t\tif (Buffer.isBuffer(source)) {\n\t\t\tsource = source.toString(\"utf-8\");\n\t\t}\n\t\tif (typeof source === \"object\") {\n\t\t\tast = /** @type {ProgramNode} */ (source);\n\t\t\tcomments = source.comments;\n\t\t} else {\n\t\t\tcomments = [];\n\t\t\tast = JavascriptParser._parse(source, {\n\t\t\t\tsourceType: this.sourceType,\n\t\t\t\tonComment: comments,\n\t\t\t\tonInsertedSemicolon: pos => semicolons.add(pos)\n\t\t\t});\n\t\t}\n\n\t\tconst oldScope = this.scope;\n\t\tconst oldState = this.state;\n\t\tconst oldComments = this.comments;\n\t\tconst oldSemicolons = this.semicolons;\n\t\tconst oldStatementPath = this.statementPath;\n\t\tconst oldPrevStatement = this.prevStatement;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: true,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: false,\n\t\t\tisAsmJs: false,\n\t\t\tdefinitions: new StackedMap()\n\t\t};\n\t\t/** @type {ParserState} */\n\t\tthis.state = state;\n\t\tthis.comments = comments;\n\t\tthis.semicolons = semicolons;\n\t\tthis.statementPath = [];\n\t\tthis.prevStatement = undefined;\n\t\tif (this.hooks.program.call(ast, comments) === undefined) {\n\t\t\tthis.detectMode(ast.body);\n\t\t\tthis.preWalkStatements(ast.body);\n\t\t\tthis.prevStatement = undefined;\n\t\t\tthis.blockPreWalkStatements(ast.body);\n\t\t\tthis.prevStatement = undefined;\n\t\t\tthis.walkStatements(ast.body);\n\t\t}\n\t\tthis.hooks.finish.call(ast, comments);\n\t\tthis.scope = oldScope;\n\t\t/** @type {ParserState} */\n\t\tthis.state = oldState;\n\t\tthis.comments = oldComments;\n\t\tthis.semicolons = oldSemicolons;\n\t\tthis.statementPath = oldStatementPath;\n\t\tthis.prevStatement = oldPrevStatement;\n\t\treturn state;\n\t}\n\n\tevaluate(source) {\n\t\tconst ast = JavascriptParser._parse(\"(\" + source + \")\", {\n\t\t\tsourceType: this.sourceType,\n\t\t\tlocations: false\n\t\t});\n\t\tif (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n\t\t\tthrow new Error(\"evaluate: Source is not a expression\");\n\t\t}\n\t\treturn this.evaluateExpression(ast.body[0].expression);\n\t}\n\n\t/**\n\t * @param {ExpressionNode | DeclarationNode | PrivateIdentifierNode | null | undefined} expr an expression\n\t * @param {number} commentsStartPos source position from which annotation comments are checked\n\t * @returns {boolean} true, when the expression is pure\n\t */\n\tisPure(expr, commentsStartPos) {\n\t\tif (!expr) return true;\n\t\tconst result = this.hooks.isPure\n\t\t\t.for(expr.type)\n\t\t\t.call(expr, commentsStartPos);\n\t\tif (typeof result === \"boolean\") return result;\n\t\tswitch (expr.type) {\n\t\t\tcase \"ClassDeclaration\":\n\t\t\tcase \"ClassExpression\": {\n\t\t\t\tif (expr.body.type !== \"ClassBody\") return false;\n\t\t\t\tif (expr.superClass && !this.isPure(expr.superClass, expr.range[0])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tconst items =\n\t\t\t\t\t/** @type {(MethodDefinitionNode | PropertyDefinitionNode)[]} */ (\n\t\t\t\t\t\texpr.body.body\n\t\t\t\t\t);\n\t\t\t\treturn items.every(\n\t\t\t\t\titem =>\n\t\t\t\t\t\t(!item.computed ||\n\t\t\t\t\t\t\t!item.key ||\n\t\t\t\t\t\t\tthis.isPure(item.key, item.range[0])) &&\n\t\t\t\t\t\t(!item.static ||\n\t\t\t\t\t\t\t!item.value ||\n\t\t\t\t\t\t\tthis.isPure(\n\t\t\t\t\t\t\t\titem.value,\n\t\t\t\t\t\t\t\titem.key ? item.key.range[1] : item.range[0]\n\t\t\t\t\t\t\t))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\tcase \"FunctionExpression\":\n\t\t\tcase \"ArrowFunctionExpression\":\n\t\t\tcase \"Literal\":\n\t\t\tcase \"PrivateIdentifier\":\n\t\t\t\treturn true;\n\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\treturn expr.declarations.every(decl =>\n\t\t\t\t\tthis.isPure(decl.init, decl.range[0])\n\t\t\t\t);\n\n\t\t\tcase \"ConditionalExpression\":\n\t\t\t\treturn (\n\t\t\t\t\tthis.isPure(expr.test, commentsStartPos) &&\n\t\t\t\t\tthis.isPure(expr.consequent, expr.test.range[1]) &&\n\t\t\t\t\tthis.isPure(expr.alternate, expr.consequent.range[1])\n\t\t\t\t);\n\n\t\t\tcase \"SequenceExpression\":\n\t\t\t\treturn expr.expressions.every(expr => {\n\t\t\t\t\tconst pureFlag = this.isPure(expr, commentsStartPos);\n\t\t\t\t\tcommentsStartPos = expr.range[1];\n\t\t\t\t\treturn pureFlag;\n\t\t\t\t});\n\n\t\t\tcase \"CallExpression\": {\n\t\t\t\tconst pureFlag =\n\t\t\t\t\texpr.range[0] - commentsStartPos > 12 &&\n\t\t\t\t\tthis.getComments([commentsStartPos, expr.range[0]]).some(\n\t\t\t\t\t\tcomment =>\n\t\t\t\t\t\t\tcomment.type === \"Block\" &&\n\t\t\t\t\t\t\t/^\\s*(#|@)__PURE__\\s*$/.test(comment.value)\n\t\t\t\t\t);\n\t\t\t\tif (!pureFlag) return false;\n\t\t\t\tcommentsStartPos = expr.callee.range[1];\n\t\t\t\treturn expr.arguments.every(arg => {\n\t\t\t\t\tif (arg.type === \"SpreadElement\") return false;\n\t\t\t\t\tconst pureFlag = this.isPure(arg, commentsStartPos);\n\t\t\t\t\tcommentsStartPos = arg.range[1];\n\t\t\t\t\treturn pureFlag;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tconst evaluated = this.evaluateExpression(expr);\n\t\treturn !evaluated.couldHaveSideEffects();\n\t}\n\n\tgetComments(range) {\n\t\tconst [rangeStart, rangeEnd] = range;\n\t\tconst compare = (comment, needle) => comment.range[0] - needle;\n\t\tlet idx = binarySearchBounds.ge(this.comments, rangeStart, compare);\n\t\tlet commentsInRange = [];\n\t\twhile (this.comments[idx] && this.comments[idx].range[1] <= rangeEnd) {\n\t\t\tcommentsInRange.push(this.comments[idx]);\n\t\t\tidx++;\n\t\t}\n\n\t\treturn commentsInRange;\n\t}\n\n\t/**\n\t * @param {number} pos source code position\n\t * @returns {boolean} true when a semicolon has been inserted before this position, false if not\n\t */\n\tisAsiPosition(pos) {\n\t\tconst currentStatement = this.statementPath[this.statementPath.length - 1];\n\t\tif (currentStatement === undefined) throw new Error(\"Not in statement\");\n\t\treturn (\n\t\t\t// Either asking directly for the end position of the current statement\n\t\t\t(currentStatement.range[1] === pos && this.semicolons.has(pos)) ||\n\t\t\t// Or asking for the start position of the current statement,\n\t\t\t// here we have to check multiple things\n\t\t\t(currentStatement.range[0] === pos &&\n\t\t\t\t// is there a previous statement which might be relevant?\n\t\t\t\tthis.prevStatement !== undefined &&\n\t\t\t\t// is the end position of the previous statement an ASI position?\n\t\t\t\tthis.semicolons.has(this.prevStatement.range[1]))\n\t\t);\n\t}\n\n\t/**\n\t * @param {number} pos source code position\n\t * @returns {void}\n\t */\n\tunsetAsiPosition(pos) {\n\t\tthis.semicolons.delete(pos);\n\t}\n\n\tisStatementLevelExpression(expr) {\n\t\tconst currentStatement = this.statementPath[this.statementPath.length - 1];\n\t\treturn (\n\t\t\texpr === currentStatement ||\n\t\t\t(currentStatement.type === \"ExpressionStatement\" &&\n\t\t\t\tcurrentStatement.expression === expr)\n\t\t);\n\t}\n\n\tgetTagData(name, tag) {\n\t\tconst info = this.scope.definitions.get(name);\n\t\tif (info instanceof VariableInfo) {\n\t\t\tlet tagInfo = info.tagInfo;\n\t\t\twhile (tagInfo !== undefined) {\n\t\t\t\tif (tagInfo.tag === tag) return tagInfo.data;\n\t\t\t\ttagInfo = tagInfo.next;\n\t\t\t}\n\t\t}\n\t}\n\n\ttagVariable(name, tag, data) {\n\t\tconst oldInfo = this.scope.definitions.get(name);\n\t\t/** @type {VariableInfo} */\n\t\tlet newInfo;\n\t\tif (oldInfo === undefined) {\n\t\t\tnewInfo = new VariableInfo(this.scope, name, {\n\t\t\t\ttag,\n\t\t\t\tdata,\n\t\t\t\tnext: undefined\n\t\t\t});\n\t\t} else if (oldInfo instanceof VariableInfo) {\n\t\t\tnewInfo = new VariableInfo(oldInfo.declaredScope, oldInfo.freeName, {\n\t\t\t\ttag,\n\t\t\t\tdata,\n\t\t\t\tnext: oldInfo.tagInfo\n\t\t\t});\n\t\t} else {\n\t\t\tnewInfo = new VariableInfo(oldInfo, true, {\n\t\t\t\ttag,\n\t\t\t\tdata,\n\t\t\t\tnext: undefined\n\t\t\t});\n\t\t}\n\t\tthis.scope.definitions.set(name, newInfo);\n\t}\n\n\tdefineVariable(name) {\n\t\tconst oldInfo = this.scope.definitions.get(name);\n\t\t// Don't redefine variable in same scope to keep existing tags\n\t\tif (oldInfo instanceof VariableInfo && oldInfo.declaredScope === this.scope)\n\t\t\treturn;\n\t\tthis.scope.definitions.set(name, this.scope);\n\t}\n\n\tundefineVariable(name) {\n\t\tthis.scope.definitions.delete(name);\n\t}\n\n\tisVariableDefined(name) {\n\t\tconst info = this.scope.definitions.get(name);\n\t\tif (info === undefined) return false;\n\t\tif (info instanceof VariableInfo) {\n\t\t\treturn info.freeName === true;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {string} name variable name\n\t * @returns {ExportedVariableInfo} info for this variable\n\t */\n\tgetVariableInfo(name) {\n\t\tconst value = this.scope.definitions.get(name);\n\t\tif (value === undefined) {\n\t\t\treturn name;\n\t\t} else {\n\t\t\treturn value;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} name variable name\n\t * @param {ExportedVariableInfo} variableInfo new info for this variable\n\t * @returns {void}\n\t */\n\tsetVariable(name, variableInfo) {\n\t\tif (typeof variableInfo === \"string\") {\n\t\t\tif (variableInfo === name) {\n\t\t\t\tthis.scope.definitions.delete(name);\n\t\t\t} else {\n\t\t\t\tthis.scope.definitions.set(\n\t\t\t\t\tname,\n\t\t\t\t\tnew VariableInfo(this.scope, variableInfo, undefined)\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.scope.definitions.set(name, variableInfo);\n\t\t}\n\t}\n\n\tparseCommentOptions(range) {\n\t\tconst comments = this.getComments(range);\n\t\tif (comments.length === 0) {\n\t\t\treturn EMPTY_COMMENT_OPTIONS;\n\t\t}\n\t\tlet options = {};\n\t\tlet errors = [];\n\t\tfor (const comment of comments) {\n\t\t\tconst { value } = comment;\n\t\t\tif (value && webpackCommentRegExp.test(value)) {\n\t\t\t\t// try compile only if webpack options comment is present\n\t\t\t\ttry {\n\t\t\t\t\tconst val = vm.runInNewContext(`(function(){return {${value}};})()`);\n\t\t\t\t\tObject.assign(options, val);\n\t\t\t\t} catch (e) {\n\t\t\t\t\te.comment = comment;\n\t\t\t\t\terrors.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { options, errors };\n\t}\n\n\t/**\n\t * @param {MemberExpressionNode} expression a member expression\n\t * @returns {{ members: string[], object: ExpressionNode | SuperNode }} member names (reverse order) and remaining object\n\t */\n\textractMemberExpressionChain(expression) {\n\t\t/** @type {AnyNode} */\n\t\tlet expr = expression;\n\t\tconst members = [];\n\t\twhile (expr.type === \"MemberExpression\") {\n\t\t\tif (expr.computed) {\n\t\t\t\tif (expr.property.type !== \"Literal\") break;\n\t\t\t\tmembers.push(`${expr.property.value}`);\n\t\t\t} else {\n\t\t\t\tif (expr.property.type !== \"Identifier\") break;\n\t\t\t\tmembers.push(expr.property.name);\n\t\t\t}\n\t\t\texpr = expr.object;\n\t\t}\n\t\treturn {\n\t\t\tmembers,\n\t\t\tobject: expr\n\t\t};\n\t}\n\n\t/**\n\t * @param {string} varName variable name\n\t * @returns {{name: string, info: VariableInfo | string}} name of the free variable and variable info for that\n\t */\n\tgetFreeInfoFromVariable(varName) {\n\t\tconst info = this.getVariableInfo(varName);\n\t\tlet name;\n\t\tif (info instanceof VariableInfo) {\n\t\t\tname = info.freeName;\n\t\t\tif (typeof name !== \"string\") return undefined;\n\t\t} else if (typeof info !== \"string\") {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tname = info;\n\t\t}\n\t\treturn { info, name };\n\t}\n\n\t/** @typedef {{ type: \"call\", call: CallExpressionNode, calleeName: string, rootInfo: string | VariableInfo, getCalleeMembers: () => string[], name: string, getMembers: () => string[]}} CallExpressionInfo */\n\t/** @typedef {{ type: \"expression\", rootInfo: string | VariableInfo, name: string, getMembers: () => string[]}} ExpressionExpressionInfo */\n\n\t/**\n\t * @param {MemberExpressionNode} expression a member expression\n\t * @param {number} allowedTypes which types should be returned, presented in bit mask\n\t * @returns {CallExpressionInfo | ExpressionExpressionInfo | undefined} expression info\n\t */\n\tgetMemberExpressionInfo(expression, allowedTypes) {\n\t\tconst { object, members } = this.extractMemberExpressionChain(expression);\n\t\tswitch (object.type) {\n\t\t\tcase \"CallExpression\": {\n\t\t\t\tif ((allowedTypes & ALLOWED_MEMBER_TYPES_CALL_EXPRESSION) === 0)\n\t\t\t\t\treturn undefined;\n\t\t\t\tlet callee = object.callee;\n\t\t\t\tlet rootMembers = EMPTY_ARRAY;\n\t\t\t\tif (callee.type === \"MemberExpression\") {\n\t\t\t\t\t({ object: callee, members: rootMembers } =\n\t\t\t\t\t\tthis.extractMemberExpressionChain(callee));\n\t\t\t\t}\n\t\t\t\tconst rootName = getRootName(callee);\n\t\t\t\tif (!rootName) return undefined;\n\t\t\t\tconst result = this.getFreeInfoFromVariable(rootName);\n\t\t\t\tif (!result) return undefined;\n\t\t\t\tconst { info: rootInfo, name: resolvedRoot } = result;\n\t\t\t\tconst calleeName = objectAndMembersToName(resolvedRoot, rootMembers);\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"call\",\n\t\t\t\t\tcall: object,\n\t\t\t\t\tcalleeName,\n\t\t\t\t\trootInfo,\n\t\t\t\t\tgetCalleeMembers: memoize(() => rootMembers.reverse()),\n\t\t\t\t\tname: objectAndMembersToName(`${calleeName}()`, members),\n\t\t\t\t\tgetMembers: memoize(() => members.reverse())\n\t\t\t\t};\n\t\t\t}\n\t\t\tcase \"Identifier\":\n\t\t\tcase \"MetaProperty\":\n\t\t\tcase \"ThisExpression\": {\n\t\t\t\tif ((allowedTypes & ALLOWED_MEMBER_TYPES_EXPRESSION) === 0)\n\t\t\t\t\treturn undefined;\n\t\t\t\tconst rootName = getRootName(object);\n\t\t\t\tif (!rootName) return undefined;\n\n\t\t\t\tconst result = this.getFreeInfoFromVariable(rootName);\n\t\t\t\tif (!result) return undefined;\n\t\t\t\tconst { info: rootInfo, name: resolvedRoot } = result;\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"expression\",\n\t\t\t\t\tname: objectAndMembersToName(resolvedRoot, members),\n\t\t\t\t\trootInfo,\n\t\t\t\t\tgetMembers: memoize(() => members.reverse())\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {MemberExpressionNode} expression an expression\n\t * @returns {{ name: string, rootInfo: ExportedVariableInfo, getMembers: () => string[]}} name info\n\t */\n\tgetNameForExpression(expression) {\n\t\treturn this.getMemberExpressionInfo(\n\t\t\texpression,\n\t\t\tALLOWED_MEMBER_TYPES_EXPRESSION\n\t\t);\n\t}\n\n\t/**\n\t * @param {string} code source code\n\t * @param {ParseOptions} options parsing options\n\t * @returns {ProgramNode} parsed ast\n\t */\n\tstatic _parse(code, options) {\n\t\tconst type = options ? options.sourceType : \"module\";\n\t\t/** @type {AcornOptions} */\n\t\tconst parserOptions = {\n\t\t\t...defaultParserOptions,\n\t\t\tallowReturnOutsideFunction: type === \"script\",\n\t\t\t...options,\n\t\t\tsourceType: type === \"auto\" ? \"module\" : type\n\t\t};\n\n\t\t/** @type {AnyNode} */\n\t\tlet ast;\n\t\tlet error;\n\t\tlet threw = false;\n\t\ttry {\n\t\t\tast = /** @type {AnyNode} */ (parser.parse(code, parserOptions));\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t\tthrew = true;\n\t\t}\n\n\t\tif (threw && type === \"auto\") {\n\t\t\tparserOptions.sourceType = \"script\";\n\t\t\tif (!(\"allowReturnOutsideFunction\" in options)) {\n\t\t\t\tparserOptions.allowReturnOutsideFunction = true;\n\t\t\t}\n\t\t\tif (Array.isArray(parserOptions.onComment)) {\n\t\t\t\tparserOptions.onComment.length = 0;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tast = /** @type {AnyNode} */ (parser.parse(code, parserOptions));\n\t\t\t\tthrew = false;\n\t\t\t} catch (e) {\n\t\t\t\t// we use the error from first parse try\n\t\t\t\t// so nothing to do here\n\t\t\t}\n\t\t}\n\n\t\tif (threw) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn /** @type {ProgramNode} */ (ast);\n\t}\n}\n\nmodule.exports = JavascriptParser;\nmodule.exports.ALLOWED_MEMBER_TYPES_ALL = ALLOWED_MEMBER_TYPES_ALL;\nmodule.exports.ALLOWED_MEMBER_TYPES_EXPRESSION =\n\tALLOWED_MEMBER_TYPES_EXPRESSION;\nmodule.exports.ALLOWED_MEMBER_TYPES_CALL_EXPRESSION =\n\tALLOWED_MEMBER_TYPES_CALL_EXPRESSION;\n"]},"metadata":{},"sourceType":"script"}