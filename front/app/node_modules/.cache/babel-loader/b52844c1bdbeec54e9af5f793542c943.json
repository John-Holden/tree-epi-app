{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _require = require(\"../OptimizationStages\"),\n    STAGE_ADVANCED = _require.STAGE_ADVANCED;\n\nvar createSchemaValidation = require(\"../util/create-schema-validation\");\n/** @typedef {import(\"../../declarations/plugins/optimize/MinChunkSizePlugin\").MinChunkSizePluginOptions} MinChunkSizePluginOptions */\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n\nvar validate = createSchemaValidation(require(\"../../schemas/plugins/optimize/MinChunkSizePlugin.check.js\"), function () {\n  return require(\"../../schemas/plugins/optimize/MinChunkSizePlugin.json\");\n}, {\n  name: \"Min Chunk Size Plugin\",\n  baseDataPath: \"options\"\n});\n\nvar MinChunkSizePlugin = /*#__PURE__*/function () {\n  /**\n   * @param {MinChunkSizePluginOptions} options options object\n   */\n  function MinChunkSizePlugin(options) {\n    _classCallCheck(this, MinChunkSizePlugin);\n\n    validate(options);\n    this.options = options;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  _createClass(MinChunkSizePlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var options = this.options;\n      var minChunkSize = options.minChunkSize;\n      compiler.hooks.compilation.tap(\"MinChunkSizePlugin\", function (compilation) {\n        compilation.hooks.optimizeChunks.tap({\n          name: \"MinChunkSizePlugin\",\n          stage: STAGE_ADVANCED\n        }, function (chunks) {\n          var chunkGraph = compilation.chunkGraph;\n          var equalOptions = {\n            chunkOverhead: 1,\n            entryChunkMultiplicator: 1\n          };\n          var chunkSizesMap = new Map();\n          /** @type {[Chunk, Chunk][]} */\n\n          var combinations = [];\n          /** @type {Chunk[]} */\n\n          var smallChunks = [];\n          var visitedChunks = [];\n\n          var _iterator = _createForOfIteratorHelper(chunks),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var a = _step.value;\n\n              // check if one of the chunks sizes is smaller than the minChunkSize\n              // and filter pairs that can NOT be integrated!\n              if (chunkGraph.getChunkSize(a, equalOptions) < minChunkSize) {\n                smallChunks.push(a);\n\n                var _iterator2 = _createForOfIteratorHelper(visitedChunks),\n                    _step2;\n\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    var b = _step2.value;\n                    if (chunkGraph.canChunksBeIntegrated(b, a)) combinations.push([b, a]);\n                  }\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n              } else {\n                var _iterator3 = _createForOfIteratorHelper(smallChunks),\n                    _step3;\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    var _b = _step3.value;\n                    if (chunkGraph.canChunksBeIntegrated(_b, a)) combinations.push([_b, a]);\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n              }\n\n              chunkSizesMap.set(a, chunkGraph.getChunkSize(a, options));\n              visitedChunks.push(a);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          var sortedSizeFilteredExtendedPairCombinations = combinations.map(function (pair) {\n            // extend combination pairs with size and integrated size\n            var a = chunkSizesMap.get(pair[0]);\n            var b = chunkSizesMap.get(pair[1]);\n            var ab = chunkGraph.getIntegratedChunksSize(pair[0], pair[1], options);\n            /** @type {[number, number, Chunk, Chunk]} */\n\n            var extendedPair = [a + b - ab, ab, pair[0], pair[1]];\n            return extendedPair;\n          }).sort(function (a, b) {\n            // sadly javascript does an in place sort here\n            // sort by size\n            var diff = b[0] - a[0];\n            if (diff !== 0) return diff;\n            return a[1] - b[1];\n          });\n          if (sortedSizeFilteredExtendedPairCombinations.length === 0) return;\n          var pair = sortedSizeFilteredExtendedPairCombinations[0];\n          chunkGraph.integrateChunks(pair[2], pair[3]);\n          compilation.chunks.delete(pair[3]);\n          return true;\n        });\n      });\n    }\n  }]);\n\n  return MinChunkSizePlugin;\n}();\n\nmodule.exports = MinChunkSizePlugin;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/optimize/MinChunkSizePlugin.js"],"names":["require","STAGE_ADVANCED","createSchemaValidation","validate","name","baseDataPath","MinChunkSizePlugin","options","compiler","minChunkSize","hooks","compilation","tap","optimizeChunks","stage","chunks","chunkGraph","equalOptions","chunkOverhead","entryChunkMultiplicator","chunkSizesMap","Map","combinations","smallChunks","visitedChunks","a","getChunkSize","push","b","canChunksBeIntegrated","set","sortedSizeFilteredExtendedPairCombinations","map","pair","get","ab","getIntegratedChunksSize","extendedPair","sort","diff","length","integrateChunks","delete","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { STAGE_ADVANCED } = require(\"../OptimizationStages\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/MinChunkSizePlugin\").MinChunkSizePluginOptions} MinChunkSizePluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/optimize/MinChunkSizePlugin.check.js\"),\n\t() => require(\"../../schemas/plugins/optimize/MinChunkSizePlugin.json\"),\n\t{\n\t\tname: \"Min Chunk Size Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\nclass MinChunkSizePlugin {\n\t/**\n\t * @param {MinChunkSizePluginOptions} options options object\n\t */\n\tconstructor(options) {\n\t\tvalidate(options);\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst options = this.options;\n\t\tconst minChunkSize = options.minChunkSize;\n\t\tcompiler.hooks.compilation.tap(\"MinChunkSizePlugin\", compilation => {\n\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t{\n\t\t\t\t\tname: \"MinChunkSizePlugin\",\n\t\t\t\t\tstage: STAGE_ADVANCED\n\t\t\t\t},\n\t\t\t\tchunks => {\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\tconst equalOptions = {\n\t\t\t\t\t\tchunkOverhead: 1,\n\t\t\t\t\t\tentryChunkMultiplicator: 1\n\t\t\t\t\t};\n\n\t\t\t\t\tconst chunkSizesMap = new Map();\n\t\t\t\t\t/** @type {[Chunk, Chunk][]} */\n\t\t\t\t\tconst combinations = [];\n\t\t\t\t\t/** @type {Chunk[]} */\n\t\t\t\t\tconst smallChunks = [];\n\t\t\t\t\tconst visitedChunks = [];\n\t\t\t\t\tfor (const a of chunks) {\n\t\t\t\t\t\t// check if one of the chunks sizes is smaller than the minChunkSize\n\t\t\t\t\t\t// and filter pairs that can NOT be integrated!\n\t\t\t\t\t\tif (chunkGraph.getChunkSize(a, equalOptions) < minChunkSize) {\n\t\t\t\t\t\t\tsmallChunks.push(a);\n\t\t\t\t\t\t\tfor (const b of visitedChunks) {\n\t\t\t\t\t\t\t\tif (chunkGraph.canChunksBeIntegrated(b, a))\n\t\t\t\t\t\t\t\t\tcombinations.push([b, a]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (const b of smallChunks) {\n\t\t\t\t\t\t\t\tif (chunkGraph.canChunksBeIntegrated(b, a))\n\t\t\t\t\t\t\t\t\tcombinations.push([b, a]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchunkSizesMap.set(a, chunkGraph.getChunkSize(a, options));\n\t\t\t\t\t\tvisitedChunks.push(a);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst sortedSizeFilteredExtendedPairCombinations = combinations\n\t\t\t\t\t\t.map(pair => {\n\t\t\t\t\t\t\t// extend combination pairs with size and integrated size\n\t\t\t\t\t\t\tconst a = chunkSizesMap.get(pair[0]);\n\t\t\t\t\t\t\tconst b = chunkSizesMap.get(pair[1]);\n\t\t\t\t\t\t\tconst ab = chunkGraph.getIntegratedChunksSize(\n\t\t\t\t\t\t\t\tpair[0],\n\t\t\t\t\t\t\t\tpair[1],\n\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t/** @type {[number, number, Chunk, Chunk]} */\n\t\t\t\t\t\t\tconst extendedPair = [a + b - ab, ab, pair[0], pair[1]];\n\t\t\t\t\t\t\treturn extendedPair;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.sort((a, b) => {\n\t\t\t\t\t\t\t// sadly javascript does an in place sort here\n\t\t\t\t\t\t\t// sort by size\n\t\t\t\t\t\t\tconst diff = b[0] - a[0];\n\t\t\t\t\t\t\tif (diff !== 0) return diff;\n\t\t\t\t\t\t\treturn a[1] - b[1];\n\t\t\t\t\t\t});\n\n\t\t\t\t\tif (sortedSizeFilteredExtendedPairCombinations.length === 0) return;\n\n\t\t\t\t\tconst pair = sortedSizeFilteredExtendedPairCombinations[0];\n\n\t\t\t\t\tchunkGraph.integrateChunks(pair[2], pair[3]);\n\t\t\t\t\tcompilation.chunks.delete(pair[3]);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = MinChunkSizePlugin;\n"]},"metadata":{},"sourceType":"script"}