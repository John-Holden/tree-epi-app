{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _objectSpread = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _require = require(\"tapable\"),\n    SyncBailHook = _require.SyncBailHook;\n\nvar _require2 = require(\"webpack-sources\"),\n    RawSource = _require2.RawSource;\n\nvar ChunkGraph = require(\"./ChunkGraph\");\n\nvar Compilation = require(\"./Compilation\");\n\nvar HotUpdateChunk = require(\"./HotUpdateChunk\");\n\nvar NormalModule = require(\"./NormalModule\");\n\nvar RuntimeGlobals = require(\"./RuntimeGlobals\");\n\nvar WebpackError = require(\"./WebpackError\");\n\nvar ConstDependency = require(\"./dependencies/ConstDependency\");\n\nvar ImportMetaHotAcceptDependency = require(\"./dependencies/ImportMetaHotAcceptDependency\");\n\nvar ImportMetaHotDeclineDependency = require(\"./dependencies/ImportMetaHotDeclineDependency\");\n\nvar ModuleHotAcceptDependency = require(\"./dependencies/ModuleHotAcceptDependency\");\n\nvar ModuleHotDeclineDependency = require(\"./dependencies/ModuleHotDeclineDependency\");\n\nvar HotModuleReplacementRuntimeModule = require(\"./hmr/HotModuleReplacementRuntimeModule\");\n\nvar JavascriptParser = require(\"./javascript/JavascriptParser\");\n\nvar _require3 = require(\"./javascript/JavascriptParserHelpers\"),\n    evaluateToIdentifier = _require3.evaluateToIdentifier;\n\nvar _require4 = require(\"./util/SetHelpers\"),\n    find = _require4.find,\n    isSubset = _require4.isSubset;\n\nvar TupleSet = require(\"./util/TupleSet\");\n\nvar _require5 = require(\"./util/comparators\"),\n    compareModulesById = _require5.compareModulesById;\n\nvar _require6 = require(\"./util/runtime\"),\n    getRuntimeKey = _require6.getRuntimeKey,\n    keyToRuntime = _require6.keyToRuntime,\n    forEachRuntime = _require6.forEachRuntime,\n    mergeRuntimeOwned = _require6.mergeRuntimeOwned,\n    subtractRuntime = _require6.subtractRuntime,\n    intersectRuntime = _require6.intersectRuntime;\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./RuntimeModule\")} RuntimeModule */\n\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {Object} HMRJavascriptParserHooks\n * @property {SyncBailHook<[TODO, string[]], void>} hotAcceptCallback\n * @property {SyncBailHook<[TODO, string[]], void>} hotAcceptWithoutCallback\n */\n\n/** @type {WeakMap<JavascriptParser, HMRJavascriptParserHooks>} */\n\n\nvar parserHooksMap = new WeakMap();\n\nvar HotModuleReplacementPlugin = /*#__PURE__*/function () {\n  function HotModuleReplacementPlugin(options) {\n    _classCallCheck(this, HotModuleReplacementPlugin);\n\n    this.options = options || {};\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  _createClass(HotModuleReplacementPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var backCompat = compiler._backCompat;\n      if (compiler.options.output.strictModuleErrorHandling === undefined) compiler.options.output.strictModuleErrorHandling = true;\n      var runtimeRequirements = [RuntimeGlobals.module];\n\n      var createAcceptHandler = function createAcceptHandler(parser, ParamDependency) {\n        var _HotModuleReplacement = HotModuleReplacementPlugin.getParserHooks(parser),\n            hotAcceptCallback = _HotModuleReplacement.hotAcceptCallback,\n            hotAcceptWithoutCallback = _HotModuleReplacement.hotAcceptWithoutCallback;\n\n        return function (expr) {\n          var module = parser.state.module;\n          var dep = new ConstDependency(\"\".concat(module.moduleArgument, \".hot.accept\"), expr.callee.range, runtimeRequirements);\n          dep.loc = expr.loc;\n          module.addPresentationalDependency(dep);\n          module.buildInfo.moduleConcatenationBailout = \"Hot Module Replacement\";\n\n          if (expr.arguments.length >= 1) {\n            var arg = parser.evaluateExpression(expr.arguments[0]);\n            var params = [];\n            var requests = [];\n\n            if (arg.isString()) {\n              params = [arg];\n            } else if (arg.isArray()) {\n              params = arg.items.filter(function (param) {\n                return param.isString();\n              });\n            }\n\n            if (params.length > 0) {\n              params.forEach(function (param, idx) {\n                var request = param.string;\n                var dep = new ParamDependency(request, param.range);\n                dep.optional = true;\n                dep.loc = Object.create(expr.loc);\n                dep.loc.index = idx;\n                module.addDependency(dep);\n                requests.push(request);\n              });\n\n              if (expr.arguments.length > 1) {\n                hotAcceptCallback.call(expr.arguments[1], requests);\n\n                for (var i = 1; i < expr.arguments.length; i++) {\n                  parser.walkExpression(expr.arguments[i]);\n                }\n\n                return true;\n              } else {\n                hotAcceptWithoutCallback.call(expr, requests);\n                return true;\n              }\n            }\n          }\n\n          parser.walkExpressions(expr.arguments);\n          return true;\n        };\n      };\n\n      var createDeclineHandler = function createDeclineHandler(parser, ParamDependency) {\n        return function (expr) {\n          var module = parser.state.module;\n          var dep = new ConstDependency(\"\".concat(module.moduleArgument, \".hot.decline\"), expr.callee.range, runtimeRequirements);\n          dep.loc = expr.loc;\n          module.addPresentationalDependency(dep);\n          module.buildInfo.moduleConcatenationBailout = \"Hot Module Replacement\";\n\n          if (expr.arguments.length === 1) {\n            var arg = parser.evaluateExpression(expr.arguments[0]);\n            var params = [];\n\n            if (arg.isString()) {\n              params = [arg];\n            } else if (arg.isArray()) {\n              params = arg.items.filter(function (param) {\n                return param.isString();\n              });\n            }\n\n            params.forEach(function (param, idx) {\n              var dep = new ParamDependency(param.string, param.range);\n              dep.optional = true;\n              dep.loc = Object.create(expr.loc);\n              dep.loc.index = idx;\n              module.addDependency(dep);\n            });\n          }\n\n          return true;\n        };\n      };\n\n      var createHMRExpressionHandler = function createHMRExpressionHandler(parser) {\n        return function (expr) {\n          var module = parser.state.module;\n          var dep = new ConstDependency(\"\".concat(module.moduleArgument, \".hot\"), expr.range, runtimeRequirements);\n          dep.loc = expr.loc;\n          module.addPresentationalDependency(dep);\n          module.buildInfo.moduleConcatenationBailout = \"Hot Module Replacement\";\n          return true;\n        };\n      };\n\n      var applyModuleHot = function applyModuleHot(parser) {\n        parser.hooks.evaluateIdentifier.for(\"module.hot\").tap({\n          name: \"HotModuleReplacementPlugin\",\n          before: \"NodeStuffPlugin\"\n        }, function (expr) {\n          return evaluateToIdentifier(\"module.hot\", \"module\", function () {\n            return [\"hot\"];\n          }, true)(expr);\n        });\n        parser.hooks.call.for(\"module.hot.accept\").tap(\"HotModuleReplacementPlugin\", createAcceptHandler(parser, ModuleHotAcceptDependency));\n        parser.hooks.call.for(\"module.hot.decline\").tap(\"HotModuleReplacementPlugin\", createDeclineHandler(parser, ModuleHotDeclineDependency));\n        parser.hooks.expression.for(\"module.hot\").tap(\"HotModuleReplacementPlugin\", createHMRExpressionHandler(parser));\n      };\n\n      var applyImportMetaHot = function applyImportMetaHot(parser) {\n        parser.hooks.evaluateIdentifier.for(\"import.meta.webpackHot\").tap(\"HotModuleReplacementPlugin\", function (expr) {\n          return evaluateToIdentifier(\"import.meta.webpackHot\", \"import.meta\", function () {\n            return [\"webpackHot\"];\n          }, true)(expr);\n        });\n        parser.hooks.call.for(\"import.meta.webpackHot.accept\").tap(\"HotModuleReplacementPlugin\", createAcceptHandler(parser, ImportMetaHotAcceptDependency));\n        parser.hooks.call.for(\"import.meta.webpackHot.decline\").tap(\"HotModuleReplacementPlugin\", createDeclineHandler(parser, ImportMetaHotDeclineDependency));\n        parser.hooks.expression.for(\"import.meta.webpackHot\").tap(\"HotModuleReplacementPlugin\", createHMRExpressionHandler(parser));\n      };\n\n      compiler.hooks.compilation.tap(\"HotModuleReplacementPlugin\", function (compilation, _ref) {\n        var normalModuleFactory = _ref.normalModuleFactory;\n        // This applies the HMR plugin only to the targeted compiler\n        // It should not affect child compilations\n        if (compilation.compiler !== compiler) return; //#region module.hot.* API\n\n        compilation.dependencyFactories.set(ModuleHotAcceptDependency, normalModuleFactory);\n        compilation.dependencyTemplates.set(ModuleHotAcceptDependency, new ModuleHotAcceptDependency.Template());\n        compilation.dependencyFactories.set(ModuleHotDeclineDependency, normalModuleFactory);\n        compilation.dependencyTemplates.set(ModuleHotDeclineDependency, new ModuleHotDeclineDependency.Template()); //#endregion\n        //#region import.meta.webpackHot.* API\n\n        compilation.dependencyFactories.set(ImportMetaHotAcceptDependency, normalModuleFactory);\n        compilation.dependencyTemplates.set(ImportMetaHotAcceptDependency, new ImportMetaHotAcceptDependency.Template());\n        compilation.dependencyFactories.set(ImportMetaHotDeclineDependency, normalModuleFactory);\n        compilation.dependencyTemplates.set(ImportMetaHotDeclineDependency, new ImportMetaHotDeclineDependency.Template()); //#endregion\n\n        var hotIndex = 0;\n        var fullHashChunkModuleHashes = {};\n        var chunkModuleHashes = {};\n        compilation.hooks.record.tap(\"HotModuleReplacementPlugin\", function (compilation, records) {\n          if (records.hash === compilation.hash) return;\n          var chunkGraph = compilation.chunkGraph;\n          records.hash = compilation.hash;\n          records.hotIndex = hotIndex;\n          records.fullHashChunkModuleHashes = fullHashChunkModuleHashes;\n          records.chunkModuleHashes = chunkModuleHashes;\n          records.chunkHashes = {};\n          records.chunkRuntime = {};\n\n          var _iterator = _createForOfIteratorHelper(compilation.chunks),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var chunk = _step.value;\n              records.chunkHashes[chunk.id] = chunk.hash;\n              records.chunkRuntime[chunk.id] = getRuntimeKey(chunk.runtime);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          records.chunkModuleIds = {};\n\n          var _iterator2 = _createForOfIteratorHelper(compilation.chunks),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _chunk = _step2.value;\n              records.chunkModuleIds[_chunk.id] = Array.from(chunkGraph.getOrderedChunkModulesIterable(_chunk, compareModulesById(chunkGraph)), function (m) {\n                return chunkGraph.getModuleId(m);\n              });\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        });\n        /** @type {TupleSet<[Module, Chunk]>} */\n\n        var updatedModules = new TupleSet();\n        /** @type {TupleSet<[Module, Chunk]>} */\n\n        var fullHashModules = new TupleSet();\n        /** @type {TupleSet<[Module, RuntimeSpec]>} */\n\n        var nonCodeGeneratedModules = new TupleSet();\n        compilation.hooks.fullHash.tap(\"HotModuleReplacementPlugin\", function (hash) {\n          var chunkGraph = compilation.chunkGraph;\n          var records = compilation.records;\n\n          var _iterator3 = _createForOfIteratorHelper(compilation.chunks),\n              _step3;\n\n          try {\n            var _loop = function _loop() {\n              var chunk = _step3.value;\n\n              var getModuleHash = function getModuleHash(module) {\n                if (compilation.codeGenerationResults.has(module, chunk.runtime)) {\n                  return compilation.codeGenerationResults.getHash(module, chunk.runtime);\n                } else {\n                  nonCodeGeneratedModules.add(module, chunk.runtime);\n                  return chunkGraph.getModuleHash(module, chunk.runtime);\n                }\n              };\n\n              var fullHashModulesInThisChunk = chunkGraph.getChunkFullHashModulesSet(chunk);\n\n              if (fullHashModulesInThisChunk !== undefined) {\n                var _iterator4 = _createForOfIteratorHelper(fullHashModulesInThisChunk),\n                    _step4;\n\n                try {\n                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                    var _module = _step4.value;\n                    fullHashModules.add(_module, chunk);\n                  }\n                } catch (err) {\n                  _iterator4.e(err);\n                } finally {\n                  _iterator4.f();\n                }\n              }\n\n              var modules = chunkGraph.getChunkModulesIterable(chunk);\n\n              if (modules !== undefined) {\n                if (records.chunkModuleHashes) {\n                  if (fullHashModulesInThisChunk !== undefined) {\n                    var _iterator5 = _createForOfIteratorHelper(modules),\n                        _step5;\n\n                    try {\n                      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                        var _module2 = _step5.value;\n                        var key = \"\".concat(chunk.id, \"|\").concat(_module2.identifier());\n\n                        var _hash = getModuleHash(_module2);\n\n                        if (fullHashModulesInThisChunk.has(\n                        /** @type {RuntimeModule} */\n                        _module2)) {\n                          if (records.fullHashChunkModuleHashes[key] !== _hash) {\n                            updatedModules.add(_module2, chunk);\n                          }\n\n                          fullHashChunkModuleHashes[key] = _hash;\n                        } else {\n                          if (records.chunkModuleHashes[key] !== _hash) {\n                            updatedModules.add(_module2, chunk);\n                          }\n\n                          chunkModuleHashes[key] = _hash;\n                        }\n                      }\n                    } catch (err) {\n                      _iterator5.e(err);\n                    } finally {\n                      _iterator5.f();\n                    }\n                  } else {\n                    var _iterator6 = _createForOfIteratorHelper(modules),\n                        _step6;\n\n                    try {\n                      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                        var _module3 = _step6.value;\n\n                        var _key = \"\".concat(chunk.id, \"|\").concat(_module3.identifier());\n\n                        var _hash2 = getModuleHash(_module3);\n\n                        if (records.chunkModuleHashes[_key] !== _hash2) {\n                          updatedModules.add(_module3, chunk);\n                        }\n\n                        chunkModuleHashes[_key] = _hash2;\n                      }\n                    } catch (err) {\n                      _iterator6.e(err);\n                    } finally {\n                      _iterator6.f();\n                    }\n                  }\n                } else {\n                  if (fullHashModulesInThisChunk !== undefined) {\n                    var _iterator7 = _createForOfIteratorHelper(modules),\n                        _step7;\n\n                    try {\n                      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                        var _module4 = _step7.value;\n\n                        var _key2 = \"\".concat(chunk.id, \"|\").concat(_module4.identifier());\n\n                        var _hash3 = getModuleHash(_module4);\n\n                        if (fullHashModulesInThisChunk.has(\n                        /** @type {RuntimeModule} */\n                        _module4)) {\n                          fullHashChunkModuleHashes[_key2] = _hash3;\n                        } else {\n                          chunkModuleHashes[_key2] = _hash3;\n                        }\n                      }\n                    } catch (err) {\n                      _iterator7.e(err);\n                    } finally {\n                      _iterator7.f();\n                    }\n                  } else {\n                    var _iterator8 = _createForOfIteratorHelper(modules),\n                        _step8;\n\n                    try {\n                      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                        var _module5 = _step8.value;\n\n                        var _key3 = \"\".concat(chunk.id, \"|\").concat(_module5.identifier());\n\n                        var _hash4 = getModuleHash(_module5);\n\n                        chunkModuleHashes[_key3] = _hash4;\n                      }\n                    } catch (err) {\n                      _iterator8.e(err);\n                    } finally {\n                      _iterator8.f();\n                    }\n                  }\n                }\n              }\n            };\n\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              _loop();\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n\n          hotIndex = records.hotIndex || 0;\n          if (updatedModules.size > 0) hotIndex++;\n          hash.update(\"\".concat(hotIndex));\n        });\n        compilation.hooks.processAssets.tap({\n          name: \"HotModuleReplacementPlugin\",\n          stage: Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL\n        }, function () {\n          var chunkGraph = compilation.chunkGraph;\n          var records = compilation.records;\n          if (records.hash === compilation.hash) return;\n\n          if (!records.chunkModuleHashes || !records.chunkHashes || !records.chunkModuleIds) {\n            return;\n          }\n\n          var _iterator9 = _createForOfIteratorHelper(fullHashModules),\n              _step9;\n\n          try {\n            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n              var _step9$value = _slicedToArray(_step9.value, 2),\n                  _module7 = _step9$value[0],\n                  chunk = _step9$value[1];\n\n              var _key4 = \"\".concat(chunk.id, \"|\").concat(_module7.identifier());\n\n              var hash = nonCodeGeneratedModules.has(_module7, chunk.runtime) ? chunkGraph.getModuleHash(_module7, chunk.runtime) : compilation.codeGenerationResults.getHash(_module7, chunk.runtime);\n\n              if (records.chunkModuleHashes[_key4] !== hash) {\n                updatedModules.add(_module7, chunk);\n              }\n\n              chunkModuleHashes[_key4] = hash;\n            }\n            /** @type {Map<string, { updatedChunkIds: Set<string|number>, removedChunkIds: Set<string|number>, removedModules: Set<Module>, filename: string, assetInfo: AssetInfo }>} */\n\n          } catch (err) {\n            _iterator9.e(err);\n          } finally {\n            _iterator9.f();\n          }\n\n          var hotUpdateMainContentByRuntime = new Map();\n          var allOldRuntime;\n\n          for (var _i = 0, _Object$keys = Object.keys(records.chunkRuntime); _i < _Object$keys.length; _i++) {\n            var key = _Object$keys[_i];\n            var runtime = keyToRuntime(records.chunkRuntime[key]);\n            allOldRuntime = mergeRuntimeOwned(allOldRuntime, runtime);\n          }\n\n          forEachRuntime(allOldRuntime, function (runtime) {\n            var _compilation$getPathW = compilation.getPathWithInfo(compilation.outputOptions.hotUpdateMainFilename, {\n              hash: records.hash,\n              runtime: runtime\n            }),\n                filename = _compilation$getPathW.path,\n                assetInfo = _compilation$getPathW.info;\n\n            hotUpdateMainContentByRuntime.set(runtime, {\n              updatedChunkIds: new Set(),\n              removedChunkIds: new Set(),\n              removedModules: new Set(),\n              filename: filename,\n              assetInfo: assetInfo\n            });\n          });\n          if (hotUpdateMainContentByRuntime.size === 0) return; // Create a list of all active modules to verify which modules are removed completely\n\n          /** @type {Map<number|string, Module>} */\n\n          var allModules = new Map();\n\n          var _iterator10 = _createForOfIteratorHelper(compilation.modules),\n              _step10;\n\n          try {\n            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n              var _module8 = _step10.value;\n              var id = chunkGraph.getModuleId(_module8);\n              allModules.set(id, _module8);\n            } // List of completely removed modules\n\n            /** @type {Set<string | number>} */\n\n          } catch (err) {\n            _iterator10.e(err);\n          } finally {\n            _iterator10.f();\n          }\n\n          var completelyRemovedModules = new Set();\n\n          var _loop2 = function _loop2() {\n            var key = _Object$keys2[_i2];\n            var oldRuntime = keyToRuntime(records.chunkRuntime[key]);\n            /** @type {Module[]} */\n\n            var remainingModules = []; // Check which modules are removed\n\n            var _iterator11 = _createForOfIteratorHelper(records.chunkModuleIds[key]),\n                _step11;\n\n            try {\n              for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                var id = _step11.value;\n\n                var _module6 = allModules.get(id);\n\n                if (_module6 === undefined) {\n                  completelyRemovedModules.add(id);\n                } else {\n                  remainingModules.push(_module6);\n                }\n              }\n            } catch (err) {\n              _iterator11.e(err);\n            } finally {\n              _iterator11.f();\n            }\n\n            var chunkId = void 0;\n            var newModules = void 0;\n            var newRuntimeModules = void 0;\n            var newFullHashModules = void 0;\n            var newDependentHashModules = void 0;\n            var newRuntime = void 0;\n            var removedFromRuntime = void 0;\n            var currentChunk = find(compilation.chunks, function (chunk) {\n              return \"\".concat(chunk.id) === key;\n            });\n\n            if (currentChunk) {\n              chunkId = currentChunk.id;\n              newRuntime = intersectRuntime(currentChunk.runtime, allOldRuntime);\n              if (newRuntime === undefined) return \"continue\";\n              newModules = chunkGraph.getChunkModules(currentChunk).filter(function (module) {\n                return updatedModules.has(module, currentChunk);\n              });\n              newRuntimeModules = Array.from(chunkGraph.getChunkRuntimeModulesIterable(currentChunk)).filter(function (module) {\n                return updatedModules.has(module, currentChunk);\n              });\n\n              var _fullHashModules = chunkGraph.getChunkFullHashModulesIterable(currentChunk);\n\n              newFullHashModules = _fullHashModules && Array.from(_fullHashModules).filter(function (module) {\n                return updatedModules.has(module, currentChunk);\n              });\n              var dependentHashModules = chunkGraph.getChunkDependentHashModulesIterable(currentChunk);\n              newDependentHashModules = dependentHashModules && Array.from(dependentHashModules).filter(function (module) {\n                return updatedModules.has(module, currentChunk);\n              });\n              removedFromRuntime = subtractRuntime(oldRuntime, newRuntime);\n            } else {\n              // chunk has completely removed\n              chunkId = \"\".concat(+key) === key ? +key : key;\n              removedFromRuntime = oldRuntime;\n              newRuntime = oldRuntime;\n            }\n\n            if (removedFromRuntime) {\n              // chunk was removed from some runtimes\n              forEachRuntime(removedFromRuntime, function (runtime) {\n                hotUpdateMainContentByRuntime.get(runtime).removedChunkIds.add(chunkId);\n              }); // dispose modules from the chunk in these runtimes\n              // where they are no longer in this runtime\n\n              var _iterator12 = _createForOfIteratorHelper(remainingModules),\n                  _step12;\n\n              try {\n                var _loop3 = function _loop3() {\n                  var module = _step12.value;\n                  var moduleKey = \"\".concat(key, \"|\").concat(module.identifier());\n                  var oldHash = records.chunkModuleHashes[moduleKey];\n                  var runtimes = chunkGraph.getModuleRuntimes(module);\n\n                  if (oldRuntime === newRuntime && runtimes.has(newRuntime)) {\n                    // Module is still in the same runtime combination\n                    var hash = nonCodeGeneratedModules.has(module, newRuntime) ? chunkGraph.getModuleHash(module, newRuntime) : compilation.codeGenerationResults.getHash(module, newRuntime);\n\n                    if (hash !== oldHash) {\n                      if (module.type === \"runtime\") {\n                        newRuntimeModules = newRuntimeModules || [];\n                        newRuntimeModules.push(\n                        /** @type {RuntimeModule} */\n                        module);\n                      } else {\n                        newModules = newModules || [];\n                        newModules.push(module);\n                      }\n                    }\n                  } else {\n                    // module is no longer in this runtime combination\n                    // We (incorrectly) assume that it's not in an overlapping runtime combination\n                    // and dispose it from the main runtimes the chunk was removed from\n                    forEachRuntime(removedFromRuntime, function (runtime) {\n                      // If the module is still used in this runtime, do not dispose it\n                      // This could create a bad runtime state where the module is still loaded,\n                      // but no chunk which contains it. This means we don't receive further HMR updates\n                      // to this module and that's bad.\n                      // TODO force load one of the chunks which contains the module\n                      var _iterator13 = _createForOfIteratorHelper(runtimes),\n                          _step13;\n\n                      try {\n                        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n                          var moduleRuntime = _step13.value;\n\n                          if (typeof moduleRuntime === \"string\") {\n                            if (moduleRuntime === runtime) return;\n                          } else if (moduleRuntime !== undefined) {\n                            if (moduleRuntime.has(runtime)) return;\n                          }\n                        }\n                      } catch (err) {\n                        _iterator13.e(err);\n                      } finally {\n                        _iterator13.f();\n                      }\n\n                      hotUpdateMainContentByRuntime.get(runtime).removedModules.add(module);\n                    });\n                  }\n                };\n\n                for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                  _loop3();\n                }\n              } catch (err) {\n                _iterator12.e(err);\n              } finally {\n                _iterator12.f();\n              }\n            }\n\n            if (newModules && newModules.length > 0 || newRuntimeModules && newRuntimeModules.length > 0) {\n              var hotUpdateChunk = new HotUpdateChunk();\n              if (backCompat) ChunkGraph.setChunkGraphForChunk(hotUpdateChunk, chunkGraph);\n              hotUpdateChunk.id = chunkId;\n              hotUpdateChunk.runtime = newRuntime;\n\n              if (currentChunk) {\n                var _iterator14 = _createForOfIteratorHelper(currentChunk.groupsIterable),\n                    _step14;\n\n                try {\n                  for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n                    var group = _step14.value;\n                    hotUpdateChunk.addGroup(group);\n                  }\n                } catch (err) {\n                  _iterator14.e(err);\n                } finally {\n                  _iterator14.f();\n                }\n              }\n\n              chunkGraph.attachModules(hotUpdateChunk, newModules || []);\n              chunkGraph.attachRuntimeModules(hotUpdateChunk, newRuntimeModules || []);\n\n              if (newFullHashModules) {\n                chunkGraph.attachFullHashModules(hotUpdateChunk, newFullHashModules);\n              }\n\n              if (newDependentHashModules) {\n                chunkGraph.attachDependentHashModules(hotUpdateChunk, newDependentHashModules);\n              }\n\n              var renderManifest = compilation.getRenderManifest({\n                chunk: hotUpdateChunk,\n                hash: records.hash,\n                fullHash: records.hash,\n                outputOptions: compilation.outputOptions,\n                moduleTemplates: compilation.moduleTemplates,\n                dependencyTemplates: compilation.dependencyTemplates,\n                codeGenerationResults: compilation.codeGenerationResults,\n                runtimeTemplate: compilation.runtimeTemplate,\n                moduleGraph: compilation.moduleGraph,\n                chunkGraph: chunkGraph\n              });\n\n              var _iterator15 = _createForOfIteratorHelper(renderManifest),\n                  _step15;\n\n              try {\n                for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n                  var entry = _step15.value;\n\n                  /** @type {string} */\n                  var filename = void 0;\n                  /** @type {AssetInfo} */\n\n                  var assetInfo = void 0;\n\n                  if (\"filename\" in entry) {\n                    filename = entry.filename;\n                    assetInfo = entry.info;\n                  } else {\n                    var _compilation$getPathW2 = compilation.getPathWithInfo(entry.filenameTemplate, entry.pathOptions);\n\n                    filename = _compilation$getPathW2.path;\n                    assetInfo = _compilation$getPathW2.info;\n                  }\n\n                  var source = entry.render();\n                  compilation.additionalChunkAssets.push(filename);\n                  compilation.emitAsset(filename, source, _objectSpread({\n                    hotModuleReplacement: true\n                  }, assetInfo));\n\n                  if (currentChunk) {\n                    currentChunk.files.add(filename);\n                    compilation.hooks.chunkAsset.call(currentChunk, filename);\n                  }\n                }\n              } catch (err) {\n                _iterator15.e(err);\n              } finally {\n                _iterator15.f();\n              }\n\n              forEachRuntime(newRuntime, function (runtime) {\n                hotUpdateMainContentByRuntime.get(runtime).updatedChunkIds.add(chunkId);\n              });\n            }\n          };\n\n          for (var _i2 = 0, _Object$keys2 = Object.keys(records.chunkHashes); _i2 < _Object$keys2.length; _i2++) {\n            var _ret = _loop2();\n\n            if (_ret === \"continue\") continue;\n          }\n\n          var completelyRemovedModulesArray = Array.from(completelyRemovedModules);\n          var hotUpdateMainContentByFilename = new Map();\n\n          var _iterator16 = _createForOfIteratorHelper(hotUpdateMainContentByRuntime.values()),\n              _step16;\n\n          try {\n            for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n              var _step16$value = _step16.value,\n                  removedChunkIds = _step16$value.removedChunkIds,\n                  removedModules = _step16$value.removedModules,\n                  updatedChunkIds = _step16$value.updatedChunkIds,\n                  filename = _step16$value.filename,\n                  assetInfo = _step16$value.assetInfo;\n              var old = hotUpdateMainContentByFilename.get(filename);\n\n              if (old && (!isSubset(old.removedChunkIds, removedChunkIds) || !isSubset(old.removedModules, removedModules) || !isSubset(old.updatedChunkIds, updatedChunkIds))) {\n                compilation.warnings.push(new WebpackError(\"HotModuleReplacementPlugin\\nThe configured output.hotUpdateMainFilename doesn't lead to unique filenames per runtime and HMR update differs between runtimes.\\nThis might lead to incorrect runtime behavior of the applied update.\\nTo fix this, make sure to include [runtime] in the output.hotUpdateMainFilename option, or use the default config.\"));\n\n                var _iterator18 = _createForOfIteratorHelper(removedChunkIds),\n                    _step18;\n\n                try {\n                  for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n                    var chunkId = _step18.value;\n                    old.removedChunkIds.add(chunkId);\n                  }\n                } catch (err) {\n                  _iterator18.e(err);\n                } finally {\n                  _iterator18.f();\n                }\n\n                var _iterator19 = _createForOfIteratorHelper(removedModules),\n                    _step19;\n\n                try {\n                  for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                    var _chunkId = _step19.value;\n                    old.removedModules.add(_chunkId);\n                  }\n                } catch (err) {\n                  _iterator19.e(err);\n                } finally {\n                  _iterator19.f();\n                }\n\n                var _iterator20 = _createForOfIteratorHelper(updatedChunkIds),\n                    _step20;\n\n                try {\n                  for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n                    var _chunkId2 = _step20.value;\n                    old.updatedChunkIds.add(_chunkId2);\n                  }\n                } catch (err) {\n                  _iterator20.e(err);\n                } finally {\n                  _iterator20.f();\n                }\n\n                continue;\n              }\n\n              hotUpdateMainContentByFilename.set(filename, {\n                removedChunkIds: removedChunkIds,\n                removedModules: removedModules,\n                updatedChunkIds: updatedChunkIds,\n                assetInfo: assetInfo\n              });\n            }\n          } catch (err) {\n            _iterator16.e(err);\n          } finally {\n            _iterator16.f();\n          }\n\n          var _iterator17 = _createForOfIteratorHelper(hotUpdateMainContentByFilename),\n              _step17;\n\n          try {\n            for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n              var _step17$value = _slicedToArray(_step17.value, 2),\n                  _filename = _step17$value[0],\n                  _step17$value$ = _step17$value[1],\n                  _removedChunkIds = _step17$value$.removedChunkIds,\n                  _removedModules = _step17$value$.removedModules,\n                  _updatedChunkIds = _step17$value$.updatedChunkIds,\n                  _assetInfo = _step17$value$.assetInfo;\n\n              var hotUpdateMainJson = {\n                c: Array.from(_updatedChunkIds),\n                r: Array.from(_removedChunkIds),\n                m: _removedModules.size === 0 ? completelyRemovedModulesArray : completelyRemovedModulesArray.concat(Array.from(_removedModules, function (m) {\n                  return chunkGraph.getModuleId(m);\n                }))\n              };\n              var source = new RawSource(JSON.stringify(hotUpdateMainJson));\n              compilation.emitAsset(_filename, source, _objectSpread({\n                hotModuleReplacement: true\n              }, _assetInfo));\n            }\n          } catch (err) {\n            _iterator17.e(err);\n          } finally {\n            _iterator17.f();\n          }\n        });\n        compilation.hooks.additionalTreeRuntimeRequirements.tap(\"HotModuleReplacementPlugin\", function (chunk, runtimeRequirements) {\n          runtimeRequirements.add(RuntimeGlobals.hmrDownloadManifest);\n          runtimeRequirements.add(RuntimeGlobals.hmrDownloadUpdateHandlers);\n          runtimeRequirements.add(RuntimeGlobals.interceptModuleExecution);\n          runtimeRequirements.add(RuntimeGlobals.moduleCache);\n          compilation.addRuntimeModule(chunk, new HotModuleReplacementRuntimeModule());\n        });\n        normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"HotModuleReplacementPlugin\", function (parser) {\n          applyModuleHot(parser);\n          applyImportMetaHot(parser);\n        });\n        normalModuleFactory.hooks.parser.for(\"javascript/dynamic\").tap(\"HotModuleReplacementPlugin\", function (parser) {\n          applyModuleHot(parser);\n        });\n        normalModuleFactory.hooks.parser.for(\"javascript/esm\").tap(\"HotModuleReplacementPlugin\", function (parser) {\n          applyImportMetaHot(parser);\n        });\n        NormalModule.getCompilationHooks(compilation).loader.tap(\"HotModuleReplacementPlugin\", function (context) {\n          context.hot = true;\n        });\n      });\n    }\n  }], [{\n    key: \"getParserHooks\",\n    value:\n    /**\n     * @param {JavascriptParser} parser the parser\n     * @returns {HMRJavascriptParserHooks} the attached hooks\n     */\n    function getParserHooks(parser) {\n      if (!(parser instanceof JavascriptParser)) {\n        throw new TypeError(\"The 'parser' argument must be an instance of JavascriptParser\");\n      }\n\n      var hooks = parserHooksMap.get(parser);\n\n      if (hooks === undefined) {\n        hooks = {\n          hotAcceptCallback: new SyncBailHook([\"expression\", \"requests\"]),\n          hotAcceptWithoutCallback: new SyncBailHook([\"expression\", \"requests\"])\n        };\n        parserHooksMap.set(parser, hooks);\n      }\n\n      return hooks;\n    }\n  }]);\n\n  return HotModuleReplacementPlugin;\n}();\n\nmodule.exports = HotModuleReplacementPlugin;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/HotModuleReplacementPlugin.js"],"names":["require","SyncBailHook","RawSource","ChunkGraph","Compilation","HotUpdateChunk","NormalModule","RuntimeGlobals","WebpackError","ConstDependency","ImportMetaHotAcceptDependency","ImportMetaHotDeclineDependency","ModuleHotAcceptDependency","ModuleHotDeclineDependency","HotModuleReplacementRuntimeModule","JavascriptParser","evaluateToIdentifier","find","isSubset","TupleSet","compareModulesById","getRuntimeKey","keyToRuntime","forEachRuntime","mergeRuntimeOwned","subtractRuntime","intersectRuntime","parserHooksMap","WeakMap","HotModuleReplacementPlugin","options","compiler","backCompat","_backCompat","output","strictModuleErrorHandling","undefined","runtimeRequirements","module","createAcceptHandler","parser","ParamDependency","getParserHooks","hotAcceptCallback","hotAcceptWithoutCallback","expr","state","dep","moduleArgument","callee","range","loc","addPresentationalDependency","buildInfo","moduleConcatenationBailout","arguments","length","arg","evaluateExpression","params","requests","isString","isArray","items","filter","param","forEach","idx","request","string","optional","Object","create","index","addDependency","push","call","i","walkExpression","walkExpressions","createDeclineHandler","createHMRExpressionHandler","applyModuleHot","hooks","evaluateIdentifier","for","tap","name","before","expression","applyImportMetaHot","compilation","normalModuleFactory","dependencyFactories","set","dependencyTemplates","Template","hotIndex","fullHashChunkModuleHashes","chunkModuleHashes","record","records","hash","chunkGraph","chunkHashes","chunkRuntime","chunks","chunk","id","runtime","chunkModuleIds","Array","from","getOrderedChunkModulesIterable","m","getModuleId","updatedModules","fullHashModules","nonCodeGeneratedModules","fullHash","getModuleHash","codeGenerationResults","has","getHash","add","fullHashModulesInThisChunk","getChunkFullHashModulesSet","modules","getChunkModulesIterable","key","identifier","size","update","processAssets","stage","PROCESS_ASSETS_STAGE_ADDITIONAL","hotUpdateMainContentByRuntime","Map","allOldRuntime","keys","getPathWithInfo","outputOptions","hotUpdateMainFilename","filename","path","assetInfo","info","updatedChunkIds","Set","removedChunkIds","removedModules","allModules","completelyRemovedModules","oldRuntime","remainingModules","get","chunkId","newModules","newRuntimeModules","newFullHashModules","newDependentHashModules","newRuntime","removedFromRuntime","currentChunk","getChunkModules","getChunkRuntimeModulesIterable","getChunkFullHashModulesIterable","dependentHashModules","getChunkDependentHashModulesIterable","moduleKey","oldHash","runtimes","getModuleRuntimes","type","moduleRuntime","hotUpdateChunk","setChunkGraphForChunk","groupsIterable","group","addGroup","attachModules","attachRuntimeModules","attachFullHashModules","attachDependentHashModules","renderManifest","getRenderManifest","moduleTemplates","runtimeTemplate","moduleGraph","entry","filenameTemplate","pathOptions","source","render","additionalChunkAssets","emitAsset","hotModuleReplacement","files","chunkAsset","completelyRemovedModulesArray","hotUpdateMainContentByFilename","values","old","warnings","hotUpdateMainJson","c","r","concat","JSON","stringify","additionalTreeRuntimeRequirements","hmrDownloadManifest","hmrDownloadUpdateHandlers","interceptModuleExecution","moduleCache","addRuntimeModule","getCompilationHooks","loader","context","hot","TypeError","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { SyncBailHook } = require(\"tapable\");\nconst { RawSource } = require(\"webpack-sources\");\nconst ChunkGraph = require(\"./ChunkGraph\");\nconst Compilation = require(\"./Compilation\");\nconst HotUpdateChunk = require(\"./HotUpdateChunk\");\nconst NormalModule = require(\"./NormalModule\");\nconst RuntimeGlobals = require(\"./RuntimeGlobals\");\nconst WebpackError = require(\"./WebpackError\");\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\nconst ImportMetaHotAcceptDependency = require(\"./dependencies/ImportMetaHotAcceptDependency\");\nconst ImportMetaHotDeclineDependency = require(\"./dependencies/ImportMetaHotDeclineDependency\");\nconst ModuleHotAcceptDependency = require(\"./dependencies/ModuleHotAcceptDependency\");\nconst ModuleHotDeclineDependency = require(\"./dependencies/ModuleHotDeclineDependency\");\nconst HotModuleReplacementRuntimeModule = require(\"./hmr/HotModuleReplacementRuntimeModule\");\nconst JavascriptParser = require(\"./javascript/JavascriptParser\");\nconst {\n\tevaluateToIdentifier\n} = require(\"./javascript/JavascriptParserHelpers\");\nconst { find, isSubset } = require(\"./util/SetHelpers\");\nconst TupleSet = require(\"./util/TupleSet\");\nconst { compareModulesById } = require(\"./util/comparators\");\nconst {\n\tgetRuntimeKey,\n\tkeyToRuntime,\n\tforEachRuntime,\n\tmergeRuntimeOwned,\n\tsubtractRuntime,\n\tintersectRuntime\n} = require(\"./util/runtime\");\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./RuntimeModule\")} RuntimeModule */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {Object} HMRJavascriptParserHooks\n * @property {SyncBailHook<[TODO, string[]], void>} hotAcceptCallback\n * @property {SyncBailHook<[TODO, string[]], void>} hotAcceptWithoutCallback\n */\n\n/** @type {WeakMap<JavascriptParser, HMRJavascriptParserHooks>} */\nconst parserHooksMap = new WeakMap();\n\nclass HotModuleReplacementPlugin {\n\t/**\n\t * @param {JavascriptParser} parser the parser\n\t * @returns {HMRJavascriptParserHooks} the attached hooks\n\t */\n\tstatic getParserHooks(parser) {\n\t\tif (!(parser instanceof JavascriptParser)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t\"The 'parser' argument must be an instance of JavascriptParser\"\n\t\t\t);\n\t\t}\n\t\tlet hooks = parserHooksMap.get(parser);\n\t\tif (hooks === undefined) {\n\t\t\thooks = {\n\t\t\t\thotAcceptCallback: new SyncBailHook([\"expression\", \"requests\"]),\n\t\t\t\thotAcceptWithoutCallback: new SyncBailHook([\"expression\", \"requests\"])\n\t\t\t};\n\t\t\tparserHooksMap.set(parser, hooks);\n\t\t}\n\t\treturn hooks;\n\t}\n\n\tconstructor(options) {\n\t\tthis.options = options || {};\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst { _backCompat: backCompat } = compiler;\n\t\tif (compiler.options.output.strictModuleErrorHandling === undefined)\n\t\t\tcompiler.options.output.strictModuleErrorHandling = true;\n\t\tconst runtimeRequirements = [RuntimeGlobals.module];\n\n\t\tconst createAcceptHandler = (parser, ParamDependency) => {\n\t\t\tconst { hotAcceptCallback, hotAcceptWithoutCallback } =\n\t\t\t\tHotModuleReplacementPlugin.getParserHooks(parser);\n\n\t\t\treturn expr => {\n\t\t\t\tconst module = parser.state.module;\n\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t`${module.moduleArgument}.hot.accept`,\n\t\t\t\t\texpr.callee.range,\n\t\t\t\t\truntimeRequirements\n\t\t\t\t);\n\t\t\t\tdep.loc = expr.loc;\n\t\t\t\tmodule.addPresentationalDependency(dep);\n\t\t\t\tmodule.buildInfo.moduleConcatenationBailout = \"Hot Module Replacement\";\n\t\t\t\tif (expr.arguments.length >= 1) {\n\t\t\t\t\tconst arg = parser.evaluateExpression(expr.arguments[0]);\n\t\t\t\t\tlet params = [];\n\t\t\t\t\tlet requests = [];\n\t\t\t\t\tif (arg.isString()) {\n\t\t\t\t\t\tparams = [arg];\n\t\t\t\t\t} else if (arg.isArray()) {\n\t\t\t\t\t\tparams = arg.items.filter(param => param.isString());\n\t\t\t\t\t}\n\t\t\t\t\tif (params.length > 0) {\n\t\t\t\t\t\tparams.forEach((param, idx) => {\n\t\t\t\t\t\t\tconst request = param.string;\n\t\t\t\t\t\t\tconst dep = new ParamDependency(request, param.range);\n\t\t\t\t\t\t\tdep.optional = true;\n\t\t\t\t\t\t\tdep.loc = Object.create(expr.loc);\n\t\t\t\t\t\t\tdep.loc.index = idx;\n\t\t\t\t\t\t\tmodule.addDependency(dep);\n\t\t\t\t\t\t\trequests.push(request);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (expr.arguments.length > 1) {\n\t\t\t\t\t\t\thotAcceptCallback.call(expr.arguments[1], requests);\n\t\t\t\t\t\t\tfor (let i = 1; i < expr.arguments.length; i++) {\n\t\t\t\t\t\t\t\tparser.walkExpression(expr.arguments[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\thotAcceptWithoutCallback.call(expr, requests);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparser.walkExpressions(expr.arguments);\n\t\t\t\treturn true;\n\t\t\t};\n\t\t};\n\n\t\tconst createDeclineHandler = (parser, ParamDependency) => expr => {\n\t\t\tconst module = parser.state.module;\n\t\t\tconst dep = new ConstDependency(\n\t\t\t\t`${module.moduleArgument}.hot.decline`,\n\t\t\t\texpr.callee.range,\n\t\t\t\truntimeRequirements\n\t\t\t);\n\t\t\tdep.loc = expr.loc;\n\t\t\tmodule.addPresentationalDependency(dep);\n\t\t\tmodule.buildInfo.moduleConcatenationBailout = \"Hot Module Replacement\";\n\t\t\tif (expr.arguments.length === 1) {\n\t\t\t\tconst arg = parser.evaluateExpression(expr.arguments[0]);\n\t\t\t\tlet params = [];\n\t\t\t\tif (arg.isString()) {\n\t\t\t\t\tparams = [arg];\n\t\t\t\t} else if (arg.isArray()) {\n\t\t\t\t\tparams = arg.items.filter(param => param.isString());\n\t\t\t\t}\n\t\t\t\tparams.forEach((param, idx) => {\n\t\t\t\t\tconst dep = new ParamDependency(param.string, param.range);\n\t\t\t\t\tdep.optional = true;\n\t\t\t\t\tdep.loc = Object.create(expr.loc);\n\t\t\t\t\tdep.loc.index = idx;\n\t\t\t\t\tmodule.addDependency(dep);\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t\tconst createHMRExpressionHandler = parser => expr => {\n\t\t\tconst module = parser.state.module;\n\t\t\tconst dep = new ConstDependency(\n\t\t\t\t`${module.moduleArgument}.hot`,\n\t\t\t\texpr.range,\n\t\t\t\truntimeRequirements\n\t\t\t);\n\t\t\tdep.loc = expr.loc;\n\t\t\tmodule.addPresentationalDependency(dep);\n\t\t\tmodule.buildInfo.moduleConcatenationBailout = \"Hot Module Replacement\";\n\t\t\treturn true;\n\t\t};\n\n\t\tconst applyModuleHot = parser => {\n\t\t\tparser.hooks.evaluateIdentifier.for(\"module.hot\").tap(\n\t\t\t\t{\n\t\t\t\t\tname: \"HotModuleReplacementPlugin\",\n\t\t\t\t\tbefore: \"NodeStuffPlugin\"\n\t\t\t\t},\n\t\t\t\texpr => {\n\t\t\t\t\treturn evaluateToIdentifier(\n\t\t\t\t\t\t\"module.hot\",\n\t\t\t\t\t\t\"module\",\n\t\t\t\t\t\t() => [\"hot\"],\n\t\t\t\t\t\ttrue\n\t\t\t\t\t)(expr);\n\t\t\t\t}\n\t\t\t);\n\t\t\tparser.hooks.call\n\t\t\t\t.for(\"module.hot.accept\")\n\t\t\t\t.tap(\n\t\t\t\t\t\"HotModuleReplacementPlugin\",\n\t\t\t\t\tcreateAcceptHandler(parser, ModuleHotAcceptDependency)\n\t\t\t\t);\n\t\t\tparser.hooks.call\n\t\t\t\t.for(\"module.hot.decline\")\n\t\t\t\t.tap(\n\t\t\t\t\t\"HotModuleReplacementPlugin\",\n\t\t\t\t\tcreateDeclineHandler(parser, ModuleHotDeclineDependency)\n\t\t\t\t);\n\t\t\tparser.hooks.expression\n\t\t\t\t.for(\"module.hot\")\n\t\t\t\t.tap(\"HotModuleReplacementPlugin\", createHMRExpressionHandler(parser));\n\t\t};\n\n\t\tconst applyImportMetaHot = parser => {\n\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t.for(\"import.meta.webpackHot\")\n\t\t\t\t.tap(\"HotModuleReplacementPlugin\", expr => {\n\t\t\t\t\treturn evaluateToIdentifier(\n\t\t\t\t\t\t\"import.meta.webpackHot\",\n\t\t\t\t\t\t\"import.meta\",\n\t\t\t\t\t\t() => [\"webpackHot\"],\n\t\t\t\t\t\ttrue\n\t\t\t\t\t)(expr);\n\t\t\t\t});\n\t\t\tparser.hooks.call\n\t\t\t\t.for(\"import.meta.webpackHot.accept\")\n\t\t\t\t.tap(\n\t\t\t\t\t\"HotModuleReplacementPlugin\",\n\t\t\t\t\tcreateAcceptHandler(parser, ImportMetaHotAcceptDependency)\n\t\t\t\t);\n\t\t\tparser.hooks.call\n\t\t\t\t.for(\"import.meta.webpackHot.decline\")\n\t\t\t\t.tap(\n\t\t\t\t\t\"HotModuleReplacementPlugin\",\n\t\t\t\t\tcreateDeclineHandler(parser, ImportMetaHotDeclineDependency)\n\t\t\t\t);\n\t\t\tparser.hooks.expression\n\t\t\t\t.for(\"import.meta.webpackHot\")\n\t\t\t\t.tap(\"HotModuleReplacementPlugin\", createHMRExpressionHandler(parser));\n\t\t};\n\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"HotModuleReplacementPlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\t// This applies the HMR plugin only to the targeted compiler\n\t\t\t\t// It should not affect child compilations\n\t\t\t\tif (compilation.compiler !== compiler) return;\n\n\t\t\t\t//#region module.hot.* API\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tModuleHotAcceptDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tModuleHotAcceptDependency,\n\t\t\t\t\tnew ModuleHotAcceptDependency.Template()\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tModuleHotDeclineDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tModuleHotDeclineDependency,\n\t\t\t\t\tnew ModuleHotDeclineDependency.Template()\n\t\t\t\t);\n\t\t\t\t//#endregion\n\n\t\t\t\t//#region import.meta.webpackHot.* API\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tImportMetaHotAcceptDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tImportMetaHotAcceptDependency,\n\t\t\t\t\tnew ImportMetaHotAcceptDependency.Template()\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tImportMetaHotDeclineDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tImportMetaHotDeclineDependency,\n\t\t\t\t\tnew ImportMetaHotDeclineDependency.Template()\n\t\t\t\t);\n\t\t\t\t//#endregion\n\n\t\t\t\tlet hotIndex = 0;\n\t\t\t\tconst fullHashChunkModuleHashes = {};\n\t\t\t\tconst chunkModuleHashes = {};\n\n\t\t\t\tcompilation.hooks.record.tap(\n\t\t\t\t\t\"HotModuleReplacementPlugin\",\n\t\t\t\t\t(compilation, records) => {\n\t\t\t\t\t\tif (records.hash === compilation.hash) return;\n\t\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\t\trecords.hash = compilation.hash;\n\t\t\t\t\t\trecords.hotIndex = hotIndex;\n\t\t\t\t\t\trecords.fullHashChunkModuleHashes = fullHashChunkModuleHashes;\n\t\t\t\t\t\trecords.chunkModuleHashes = chunkModuleHashes;\n\t\t\t\t\t\trecords.chunkHashes = {};\n\t\t\t\t\t\trecords.chunkRuntime = {};\n\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\trecords.chunkHashes[chunk.id] = chunk.hash;\n\t\t\t\t\t\t\trecords.chunkRuntime[chunk.id] = getRuntimeKey(chunk.runtime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trecords.chunkModuleIds = {};\n\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\trecords.chunkModuleIds[chunk.id] = Array.from(\n\t\t\t\t\t\t\t\tchunkGraph.getOrderedChunkModulesIterable(\n\t\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\t\tcompareModulesById(chunkGraph)\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tm => chunkGraph.getModuleId(m)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\t/** @type {TupleSet<[Module, Chunk]>} */\n\t\t\t\tconst updatedModules = new TupleSet();\n\t\t\t\t/** @type {TupleSet<[Module, Chunk]>} */\n\t\t\t\tconst fullHashModules = new TupleSet();\n\t\t\t\t/** @type {TupleSet<[Module, RuntimeSpec]>} */\n\t\t\t\tconst nonCodeGeneratedModules = new TupleSet();\n\t\t\t\tcompilation.hooks.fullHash.tap(\"HotModuleReplacementPlugin\", hash => {\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\tconst records = compilation.records;\n\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\tconst getModuleHash = module => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcompilation.codeGenerationResults.has(module, chunk.runtime)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\treturn compilation.codeGenerationResults.getHash(\n\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\tchunk.runtime\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnonCodeGeneratedModules.add(module, chunk.runtime);\n\t\t\t\t\t\t\t\treturn chunkGraph.getModuleHash(module, chunk.runtime);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst fullHashModulesInThisChunk =\n\t\t\t\t\t\t\tchunkGraph.getChunkFullHashModulesSet(chunk);\n\t\t\t\t\t\tif (fullHashModulesInThisChunk !== undefined) {\n\t\t\t\t\t\t\tfor (const module of fullHashModulesInThisChunk) {\n\t\t\t\t\t\t\t\tfullHashModules.add(module, chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst modules = chunkGraph.getChunkModulesIterable(chunk);\n\t\t\t\t\t\tif (modules !== undefined) {\n\t\t\t\t\t\t\tif (records.chunkModuleHashes) {\n\t\t\t\t\t\t\t\tif (fullHashModulesInThisChunk !== undefined) {\n\t\t\t\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\t\t\t\tconst key = `${chunk.id}|${module.identifier()}`;\n\t\t\t\t\t\t\t\t\t\tconst hash = getModuleHash(module);\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\tfullHashModulesInThisChunk.has(\n\t\t\t\t\t\t\t\t\t\t\t\t/** @type {RuntimeModule} */ (module)\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tif (records.fullHashChunkModuleHashes[key] !== hash) {\n\t\t\t\t\t\t\t\t\t\t\t\tupdatedModules.add(module, chunk);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tfullHashChunkModuleHashes[key] = hash;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tif (records.chunkModuleHashes[key] !== hash) {\n\t\t\t\t\t\t\t\t\t\t\t\tupdatedModules.add(module, chunk);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tchunkModuleHashes[key] = hash;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\t\t\t\tconst key = `${chunk.id}|${module.identifier()}`;\n\t\t\t\t\t\t\t\t\t\tconst hash = getModuleHash(module);\n\t\t\t\t\t\t\t\t\t\tif (records.chunkModuleHashes[key] !== hash) {\n\t\t\t\t\t\t\t\t\t\t\tupdatedModules.add(module, chunk);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tchunkModuleHashes[key] = hash;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (fullHashModulesInThisChunk !== undefined) {\n\t\t\t\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\t\t\t\tconst key = `${chunk.id}|${module.identifier()}`;\n\t\t\t\t\t\t\t\t\t\tconst hash = getModuleHash(module);\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\tfullHashModulesInThisChunk.has(\n\t\t\t\t\t\t\t\t\t\t\t\t/** @type {RuntimeModule} */ (module)\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tfullHashChunkModuleHashes[key] = hash;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tchunkModuleHashes[key] = hash;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\t\t\t\tconst key = `${chunk.id}|${module.identifier()}`;\n\t\t\t\t\t\t\t\t\t\tconst hash = getModuleHash(module);\n\t\t\t\t\t\t\t\t\t\tchunkModuleHashes[key] = hash;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\thotIndex = records.hotIndex || 0;\n\t\t\t\t\tif (updatedModules.size > 0) hotIndex++;\n\n\t\t\t\t\thash.update(`${hotIndex}`);\n\t\t\t\t});\n\t\t\t\tcompilation.hooks.processAssets.tap(\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"HotModuleReplacementPlugin\",\n\t\t\t\t\t\tstage: Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL\n\t\t\t\t\t},\n\t\t\t\t\t() => {\n\t\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\t\tconst records = compilation.records;\n\t\t\t\t\t\tif (records.hash === compilation.hash) return;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!records.chunkModuleHashes ||\n\t\t\t\t\t\t\t!records.chunkHashes ||\n\t\t\t\t\t\t\t!records.chunkModuleIds\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const [module, chunk] of fullHashModules) {\n\t\t\t\t\t\t\tconst key = `${chunk.id}|${module.identifier()}`;\n\t\t\t\t\t\t\tconst hash = nonCodeGeneratedModules.has(module, chunk.runtime)\n\t\t\t\t\t\t\t\t? chunkGraph.getModuleHash(module, chunk.runtime)\n\t\t\t\t\t\t\t\t: compilation.codeGenerationResults.getHash(\n\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\tchunk.runtime\n\t\t\t\t\t\t\t\t  );\n\t\t\t\t\t\t\tif (records.chunkModuleHashes[key] !== hash) {\n\t\t\t\t\t\t\t\tupdatedModules.add(module, chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchunkModuleHashes[key] = hash;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/** @type {Map<string, { updatedChunkIds: Set<string|number>, removedChunkIds: Set<string|number>, removedModules: Set<Module>, filename: string, assetInfo: AssetInfo }>} */\n\t\t\t\t\t\tconst hotUpdateMainContentByRuntime = new Map();\n\t\t\t\t\t\tlet allOldRuntime;\n\t\t\t\t\t\tfor (const key of Object.keys(records.chunkRuntime)) {\n\t\t\t\t\t\t\tconst runtime = keyToRuntime(records.chunkRuntime[key]);\n\t\t\t\t\t\t\tallOldRuntime = mergeRuntimeOwned(allOldRuntime, runtime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforEachRuntime(allOldRuntime, runtime => {\n\t\t\t\t\t\t\tconst { path: filename, info: assetInfo } =\n\t\t\t\t\t\t\t\tcompilation.getPathWithInfo(\n\t\t\t\t\t\t\t\t\tcompilation.outputOptions.hotUpdateMainFilename,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\thash: records.hash,\n\t\t\t\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\thotUpdateMainContentByRuntime.set(runtime, {\n\t\t\t\t\t\t\t\tupdatedChunkIds: new Set(),\n\t\t\t\t\t\t\t\tremovedChunkIds: new Set(),\n\t\t\t\t\t\t\t\tremovedModules: new Set(),\n\t\t\t\t\t\t\t\tfilename,\n\t\t\t\t\t\t\t\tassetInfo\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (hotUpdateMainContentByRuntime.size === 0) return;\n\n\t\t\t\t\t\t// Create a list of all active modules to verify which modules are removed completely\n\t\t\t\t\t\t/** @type {Map<number|string, Module>} */\n\t\t\t\t\t\tconst allModules = new Map();\n\t\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t\tconst id = chunkGraph.getModuleId(module);\n\t\t\t\t\t\t\tallModules.set(id, module);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// List of completely removed modules\n\t\t\t\t\t\t/** @type {Set<string | number>} */\n\t\t\t\t\t\tconst completelyRemovedModules = new Set();\n\n\t\t\t\t\t\tfor (const key of Object.keys(records.chunkHashes)) {\n\t\t\t\t\t\t\tconst oldRuntime = keyToRuntime(records.chunkRuntime[key]);\n\t\t\t\t\t\t\t/** @type {Module[]} */\n\t\t\t\t\t\t\tconst remainingModules = [];\n\t\t\t\t\t\t\t// Check which modules are removed\n\t\t\t\t\t\t\tfor (const id of records.chunkModuleIds[key]) {\n\t\t\t\t\t\t\t\tconst module = allModules.get(id);\n\t\t\t\t\t\t\t\tif (module === undefined) {\n\t\t\t\t\t\t\t\t\tcompletelyRemovedModules.add(id);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tremainingModules.push(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlet chunkId;\n\t\t\t\t\t\t\tlet newModules;\n\t\t\t\t\t\t\tlet newRuntimeModules;\n\t\t\t\t\t\t\tlet newFullHashModules;\n\t\t\t\t\t\t\tlet newDependentHashModules;\n\t\t\t\t\t\t\tlet newRuntime;\n\t\t\t\t\t\t\tlet removedFromRuntime;\n\t\t\t\t\t\t\tconst currentChunk = find(\n\t\t\t\t\t\t\t\tcompilation.chunks,\n\t\t\t\t\t\t\t\tchunk => `${chunk.id}` === key\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (currentChunk) {\n\t\t\t\t\t\t\t\tchunkId = currentChunk.id;\n\t\t\t\t\t\t\t\tnewRuntime = intersectRuntime(\n\t\t\t\t\t\t\t\t\tcurrentChunk.runtime,\n\t\t\t\t\t\t\t\t\tallOldRuntime\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (newRuntime === undefined) continue;\n\t\t\t\t\t\t\t\tnewModules = chunkGraph\n\t\t\t\t\t\t\t\t\t.getChunkModules(currentChunk)\n\t\t\t\t\t\t\t\t\t.filter(module => updatedModules.has(module, currentChunk));\n\t\t\t\t\t\t\t\tnewRuntimeModules = Array.from(\n\t\t\t\t\t\t\t\t\tchunkGraph.getChunkRuntimeModulesIterable(currentChunk)\n\t\t\t\t\t\t\t\t).filter(module => updatedModules.has(module, currentChunk));\n\t\t\t\t\t\t\t\tconst fullHashModules =\n\t\t\t\t\t\t\t\t\tchunkGraph.getChunkFullHashModulesIterable(currentChunk);\n\t\t\t\t\t\t\t\tnewFullHashModules =\n\t\t\t\t\t\t\t\t\tfullHashModules &&\n\t\t\t\t\t\t\t\t\tArray.from(fullHashModules).filter(module =>\n\t\t\t\t\t\t\t\t\t\tupdatedModules.has(module, currentChunk)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tconst dependentHashModules =\n\t\t\t\t\t\t\t\t\tchunkGraph.getChunkDependentHashModulesIterable(currentChunk);\n\t\t\t\t\t\t\t\tnewDependentHashModules =\n\t\t\t\t\t\t\t\t\tdependentHashModules &&\n\t\t\t\t\t\t\t\t\tArray.from(dependentHashModules).filter(module =>\n\t\t\t\t\t\t\t\t\t\tupdatedModules.has(module, currentChunk)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tremovedFromRuntime = subtractRuntime(oldRuntime, newRuntime);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// chunk has completely removed\n\t\t\t\t\t\t\t\tchunkId = `${+key}` === key ? +key : key;\n\t\t\t\t\t\t\t\tremovedFromRuntime = oldRuntime;\n\t\t\t\t\t\t\t\tnewRuntime = oldRuntime;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (removedFromRuntime) {\n\t\t\t\t\t\t\t\t// chunk was removed from some runtimes\n\t\t\t\t\t\t\t\tforEachRuntime(removedFromRuntime, runtime => {\n\t\t\t\t\t\t\t\t\thotUpdateMainContentByRuntime\n\t\t\t\t\t\t\t\t\t\t.get(runtime)\n\t\t\t\t\t\t\t\t\t\t.removedChunkIds.add(chunkId);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t// dispose modules from the chunk in these runtimes\n\t\t\t\t\t\t\t\t// where they are no longer in this runtime\n\t\t\t\t\t\t\t\tfor (const module of remainingModules) {\n\t\t\t\t\t\t\t\t\tconst moduleKey = `${key}|${module.identifier()}`;\n\t\t\t\t\t\t\t\t\tconst oldHash = records.chunkModuleHashes[moduleKey];\n\t\t\t\t\t\t\t\t\tconst runtimes = chunkGraph.getModuleRuntimes(module);\n\t\t\t\t\t\t\t\t\tif (oldRuntime === newRuntime && runtimes.has(newRuntime)) {\n\t\t\t\t\t\t\t\t\t\t// Module is still in the same runtime combination\n\t\t\t\t\t\t\t\t\t\tconst hash = nonCodeGeneratedModules.has(module, newRuntime)\n\t\t\t\t\t\t\t\t\t\t\t? chunkGraph.getModuleHash(module, newRuntime)\n\t\t\t\t\t\t\t\t\t\t\t: compilation.codeGenerationResults.getHash(\n\t\t\t\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnewRuntime\n\t\t\t\t\t\t\t\t\t\t\t  );\n\t\t\t\t\t\t\t\t\t\tif (hash !== oldHash) {\n\t\t\t\t\t\t\t\t\t\t\tif (module.type === \"runtime\") {\n\t\t\t\t\t\t\t\t\t\t\t\tnewRuntimeModules = newRuntimeModules || [];\n\t\t\t\t\t\t\t\t\t\t\t\tnewRuntimeModules.push(\n\t\t\t\t\t\t\t\t\t\t\t\t\t/** @type {RuntimeModule} */ (module)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tnewModules = newModules || [];\n\t\t\t\t\t\t\t\t\t\t\t\tnewModules.push(module);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t// module is no longer in this runtime combination\n\t\t\t\t\t\t\t\t\t\t// We (incorrectly) assume that it's not in an overlapping runtime combination\n\t\t\t\t\t\t\t\t\t\t// and dispose it from the main runtimes the chunk was removed from\n\t\t\t\t\t\t\t\t\t\tforEachRuntime(removedFromRuntime, runtime => {\n\t\t\t\t\t\t\t\t\t\t\t// If the module is still used in this runtime, do not dispose it\n\t\t\t\t\t\t\t\t\t\t\t// This could create a bad runtime state where the module is still loaded,\n\t\t\t\t\t\t\t\t\t\t\t// but no chunk which contains it. This means we don't receive further HMR updates\n\t\t\t\t\t\t\t\t\t\t\t// to this module and that's bad.\n\t\t\t\t\t\t\t\t\t\t\t// TODO force load one of the chunks which contains the module\n\t\t\t\t\t\t\t\t\t\t\tfor (const moduleRuntime of runtimes) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (typeof moduleRuntime === \"string\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (moduleRuntime === runtime) return;\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (moduleRuntime !== undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (moduleRuntime.has(runtime)) return;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\thotUpdateMainContentByRuntime\n\t\t\t\t\t\t\t\t\t\t\t\t.get(runtime)\n\t\t\t\t\t\t\t\t\t\t\t\t.removedModules.add(module);\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t(newModules && newModules.length > 0) ||\n\t\t\t\t\t\t\t\t(newRuntimeModules && newRuntimeModules.length > 0)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst hotUpdateChunk = new HotUpdateChunk();\n\t\t\t\t\t\t\t\tif (backCompat)\n\t\t\t\t\t\t\t\t\tChunkGraph.setChunkGraphForChunk(hotUpdateChunk, chunkGraph);\n\t\t\t\t\t\t\t\thotUpdateChunk.id = chunkId;\n\t\t\t\t\t\t\t\thotUpdateChunk.runtime = newRuntime;\n\t\t\t\t\t\t\t\tif (currentChunk) {\n\t\t\t\t\t\t\t\t\tfor (const group of currentChunk.groupsIterable)\n\t\t\t\t\t\t\t\t\t\thotUpdateChunk.addGroup(group);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tchunkGraph.attachModules(hotUpdateChunk, newModules || []);\n\t\t\t\t\t\t\t\tchunkGraph.attachRuntimeModules(\n\t\t\t\t\t\t\t\t\thotUpdateChunk,\n\t\t\t\t\t\t\t\t\tnewRuntimeModules || []\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (newFullHashModules) {\n\t\t\t\t\t\t\t\t\tchunkGraph.attachFullHashModules(\n\t\t\t\t\t\t\t\t\t\thotUpdateChunk,\n\t\t\t\t\t\t\t\t\t\tnewFullHashModules\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (newDependentHashModules) {\n\t\t\t\t\t\t\t\t\tchunkGraph.attachDependentHashModules(\n\t\t\t\t\t\t\t\t\t\thotUpdateChunk,\n\t\t\t\t\t\t\t\t\t\tnewDependentHashModules\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst renderManifest = compilation.getRenderManifest({\n\t\t\t\t\t\t\t\t\tchunk: hotUpdateChunk,\n\t\t\t\t\t\t\t\t\thash: records.hash,\n\t\t\t\t\t\t\t\t\tfullHash: records.hash,\n\t\t\t\t\t\t\t\t\toutputOptions: compilation.outputOptions,\n\t\t\t\t\t\t\t\t\tmoduleTemplates: compilation.moduleTemplates,\n\t\t\t\t\t\t\t\t\tdependencyTemplates: compilation.dependencyTemplates,\n\t\t\t\t\t\t\t\t\tcodeGenerationResults: compilation.codeGenerationResults,\n\t\t\t\t\t\t\t\t\truntimeTemplate: compilation.runtimeTemplate,\n\t\t\t\t\t\t\t\t\tmoduleGraph: compilation.moduleGraph,\n\t\t\t\t\t\t\t\t\tchunkGraph\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tfor (const entry of renderManifest) {\n\t\t\t\t\t\t\t\t\t/** @type {string} */\n\t\t\t\t\t\t\t\t\tlet filename;\n\t\t\t\t\t\t\t\t\t/** @type {AssetInfo} */\n\t\t\t\t\t\t\t\t\tlet assetInfo;\n\t\t\t\t\t\t\t\t\tif (\"filename\" in entry) {\n\t\t\t\t\t\t\t\t\t\tfilename = entry.filename;\n\t\t\t\t\t\t\t\t\t\tassetInfo = entry.info;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t({ path: filename, info: assetInfo } =\n\t\t\t\t\t\t\t\t\t\t\tcompilation.getPathWithInfo(\n\t\t\t\t\t\t\t\t\t\t\t\tentry.filenameTemplate,\n\t\t\t\t\t\t\t\t\t\t\t\tentry.pathOptions\n\t\t\t\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst source = entry.render();\n\t\t\t\t\t\t\t\t\tcompilation.additionalChunkAssets.push(filename);\n\t\t\t\t\t\t\t\t\tcompilation.emitAsset(filename, source, {\n\t\t\t\t\t\t\t\t\t\thotModuleReplacement: true,\n\t\t\t\t\t\t\t\t\t\t...assetInfo\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tif (currentChunk) {\n\t\t\t\t\t\t\t\t\t\tcurrentChunk.files.add(filename);\n\t\t\t\t\t\t\t\t\t\tcompilation.hooks.chunkAsset.call(currentChunk, filename);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tforEachRuntime(newRuntime, runtime => {\n\t\t\t\t\t\t\t\t\thotUpdateMainContentByRuntime\n\t\t\t\t\t\t\t\t\t\t.get(runtime)\n\t\t\t\t\t\t\t\t\t\t.updatedChunkIds.add(chunkId);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst completelyRemovedModulesArray = Array.from(\n\t\t\t\t\t\t\tcompletelyRemovedModules\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst hotUpdateMainContentByFilename = new Map();\n\t\t\t\t\t\tfor (const {\n\t\t\t\t\t\t\tremovedChunkIds,\n\t\t\t\t\t\t\tremovedModules,\n\t\t\t\t\t\t\tupdatedChunkIds,\n\t\t\t\t\t\t\tfilename,\n\t\t\t\t\t\t\tassetInfo\n\t\t\t\t\t\t} of hotUpdateMainContentByRuntime.values()) {\n\t\t\t\t\t\t\tconst old = hotUpdateMainContentByFilename.get(filename);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\told &&\n\t\t\t\t\t\t\t\t(!isSubset(old.removedChunkIds, removedChunkIds) ||\n\t\t\t\t\t\t\t\t\t!isSubset(old.removedModules, removedModules) ||\n\t\t\t\t\t\t\t\t\t!isSubset(old.updatedChunkIds, updatedChunkIds))\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tcompilation.warnings.push(\n\t\t\t\t\t\t\t\t\tnew WebpackError(`HotModuleReplacementPlugin\nThe configured output.hotUpdateMainFilename doesn't lead to unique filenames per runtime and HMR update differs between runtimes.\nThis might lead to incorrect runtime behavior of the applied update.\nTo fix this, make sure to include [runtime] in the output.hotUpdateMainFilename option, or use the default config.`)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tfor (const chunkId of removedChunkIds)\n\t\t\t\t\t\t\t\t\told.removedChunkIds.add(chunkId);\n\t\t\t\t\t\t\t\tfor (const chunkId of removedModules)\n\t\t\t\t\t\t\t\t\told.removedModules.add(chunkId);\n\t\t\t\t\t\t\t\tfor (const chunkId of updatedChunkIds)\n\t\t\t\t\t\t\t\t\told.updatedChunkIds.add(chunkId);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thotUpdateMainContentByFilename.set(filename, {\n\t\t\t\t\t\t\t\tremovedChunkIds,\n\t\t\t\t\t\t\t\tremovedModules,\n\t\t\t\t\t\t\t\tupdatedChunkIds,\n\t\t\t\t\t\t\t\tassetInfo\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const [\n\t\t\t\t\t\t\tfilename,\n\t\t\t\t\t\t\t{ removedChunkIds, removedModules, updatedChunkIds, assetInfo }\n\t\t\t\t\t\t] of hotUpdateMainContentByFilename) {\n\t\t\t\t\t\t\tconst hotUpdateMainJson = {\n\t\t\t\t\t\t\t\tc: Array.from(updatedChunkIds),\n\t\t\t\t\t\t\t\tr: Array.from(removedChunkIds),\n\t\t\t\t\t\t\t\tm:\n\t\t\t\t\t\t\t\t\tremovedModules.size === 0\n\t\t\t\t\t\t\t\t\t\t? completelyRemovedModulesArray\n\t\t\t\t\t\t\t\t\t\t: completelyRemovedModulesArray.concat(\n\t\t\t\t\t\t\t\t\t\t\t\tArray.from(removedModules, m =>\n\t\t\t\t\t\t\t\t\t\t\t\t\tchunkGraph.getModuleId(m)\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tconst source = new RawSource(JSON.stringify(hotUpdateMainJson));\n\t\t\t\t\t\t\tcompilation.emitAsset(filename, source, {\n\t\t\t\t\t\t\t\thotModuleReplacement: true,\n\t\t\t\t\t\t\t\t...assetInfo\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tcompilation.hooks.additionalTreeRuntimeRequirements.tap(\n\t\t\t\t\t\"HotModuleReplacementPlugin\",\n\t\t\t\t\t(chunk, runtimeRequirements) => {\n\t\t\t\t\t\truntimeRequirements.add(RuntimeGlobals.hmrDownloadManifest);\n\t\t\t\t\t\truntimeRequirements.add(RuntimeGlobals.hmrDownloadUpdateHandlers);\n\t\t\t\t\t\truntimeRequirements.add(RuntimeGlobals.interceptModuleExecution);\n\t\t\t\t\t\truntimeRequirements.add(RuntimeGlobals.moduleCache);\n\t\t\t\t\t\tcompilation.addRuntimeModule(\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tnew HotModuleReplacementRuntimeModule()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/auto\")\n\t\t\t\t\t.tap(\"HotModuleReplacementPlugin\", parser => {\n\t\t\t\t\t\tapplyModuleHot(parser);\n\t\t\t\t\t\tapplyImportMetaHot(parser);\n\t\t\t\t\t});\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/dynamic\")\n\t\t\t\t\t.tap(\"HotModuleReplacementPlugin\", parser => {\n\t\t\t\t\t\tapplyModuleHot(parser);\n\t\t\t\t\t});\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/esm\")\n\t\t\t\t\t.tap(\"HotModuleReplacementPlugin\", parser => {\n\t\t\t\t\t\tapplyImportMetaHot(parser);\n\t\t\t\t\t});\n\n\t\t\t\tNormalModule.getCompilationHooks(compilation).loader.tap(\n\t\t\t\t\t\"HotModuleReplacementPlugin\",\n\t\t\t\t\tcontext => {\n\t\t\t\t\t\tcontext.hot = true;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = HotModuleReplacementPlugin;\n"]},"metadata":{},"sourceType":"script"}