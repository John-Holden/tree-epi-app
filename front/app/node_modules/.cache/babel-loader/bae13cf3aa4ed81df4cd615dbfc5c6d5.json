{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/** @typedef {import(\"./Dependency\")} Dependency */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * Module itself is not connected, but transitive modules are connected transitively.\n */\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar TRANSITIVE_ONLY = Symbol(\"transitive only\");\n/**\n * While determining the active state, this flag is used to signal a circular connection.\n */\n\nvar CIRCULAR_CONNECTION = Symbol(\"circular connection\");\n/** @typedef {boolean | typeof TRANSITIVE_ONLY | typeof CIRCULAR_CONNECTION} ConnectionState */\n\n/**\n * @param {ConnectionState} a first\n * @param {ConnectionState} b second\n * @returns {ConnectionState} merged\n */\n\nvar addConnectionStates = function addConnectionStates(a, b) {\n  if (a === true || b === true) return true;\n  if (a === false) return b;\n  if (b === false) return a;\n  if (a === TRANSITIVE_ONLY) return b;\n  if (b === TRANSITIVE_ONLY) return a;\n  return a;\n};\n/**\n * @param {ConnectionState} a first\n * @param {ConnectionState} b second\n * @returns {ConnectionState} intersected\n */\n\n\nvar intersectConnectionStates = function intersectConnectionStates(a, b) {\n  if (a === false || b === false) return false;\n  if (a === true) return b;\n  if (b === true) return a;\n  if (a === CIRCULAR_CONNECTION) return b;\n  if (b === CIRCULAR_CONNECTION) return a;\n  return a;\n};\n\nvar ModuleGraphConnection = /*#__PURE__*/function () {\n  /**\n   * @param {Module|null} originModule the referencing module\n   * @param {Dependency|null} dependency the referencing dependency\n   * @param {Module} module the referenced module\n   * @param {string=} explanation some extra detail\n   * @param {boolean=} weak the reference is weak\n   * @param {false | function(ModuleGraphConnection, RuntimeSpec): ConnectionState=} condition condition for the connection\n   */\n  function ModuleGraphConnection(originModule, dependency, module, explanation) {\n    var weak = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    var condition = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n\n    _classCallCheck(this, ModuleGraphConnection);\n\n    this.originModule = originModule;\n    this.resolvedOriginModule = originModule;\n    this.dependency = dependency;\n    this.resolvedModule = module;\n    this.module = module;\n    this.weak = weak;\n    this.conditional = !!condition;\n    this._active = condition !== false;\n    /** @type {function(ModuleGraphConnection, RuntimeSpec): ConnectionState} */\n\n    this.condition = condition || undefined;\n    /** @type {Set<string>} */\n\n    this.explanations = undefined;\n\n    if (explanation) {\n      this.explanations = new Set();\n      this.explanations.add(explanation);\n    }\n  }\n\n  _createClass(ModuleGraphConnection, [{\n    key: \"clone\",\n    value: function clone() {\n      var clone = new ModuleGraphConnection(this.resolvedOriginModule, this.dependency, this.resolvedModule, undefined, this.weak, this.condition);\n      clone.originModule = this.originModule;\n      clone.module = this.module;\n      clone.conditional = this.conditional;\n      clone._active = this._active;\n      if (this.explanations) clone.explanations = new Set(this.explanations);\n      return clone;\n    }\n    /**\n     * @param {function(ModuleGraphConnection, RuntimeSpec): ConnectionState} condition condition for the connection\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addCondition\",\n    value: function addCondition(condition) {\n      if (this.conditional) {\n        var old = this.condition;\n\n        this.condition = function (c, r) {\n          return intersectConnectionStates(old(c, r), condition(c, r));\n        };\n      } else if (this._active) {\n        this.conditional = true;\n        this.condition = condition;\n      }\n    }\n    /**\n     * @param {string} explanation the explanation to add\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addExplanation\",\n    value: function addExplanation(explanation) {\n      if (this.explanations === undefined) {\n        this.explanations = new Set();\n      }\n\n      this.explanations.add(explanation);\n    }\n  }, {\n    key: \"explanation\",\n    get: function get() {\n      if (this.explanations === undefined) return \"\";\n      return Array.from(this.explanations).join(\" \");\n    } // TODO webpack 5 remove\n\n  }, {\n    key: \"active\",\n    get: function get() {\n      throw new Error(\"Use getActiveState instead\");\n    }\n    /**\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {boolean} true, if the connection is active\n     */\n    ,\n    set: function set(value) {\n      throw new Error(\"Use setActive instead\");\n    }\n  }, {\n    key: \"isActive\",\n    value: function isActive(runtime) {\n      if (!this.conditional) return this._active;\n      return this.condition(this, runtime) !== false;\n    }\n    /**\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {boolean} true, if the connection is active\n     */\n\n  }, {\n    key: \"isTargetActive\",\n    value: function isTargetActive(runtime) {\n      if (!this.conditional) return this._active;\n      return this.condition(this, runtime) === true;\n    }\n    /**\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {ConnectionState} true: fully active, false: inactive, TRANSITIVE: direct module inactive, but transitive connection maybe active\n     */\n\n  }, {\n    key: \"getActiveState\",\n    value: function getActiveState(runtime) {\n      if (!this.conditional) return this._active;\n      return this.condition(this, runtime);\n    }\n    /**\n     * @param {boolean} value active or not\n     * @returns {void}\n     */\n\n  }, {\n    key: \"setActive\",\n    value: function setActive(value) {\n      this.conditional = false;\n      this._active = value;\n    }\n  }]);\n\n  return ModuleGraphConnection;\n}();\n/** @typedef {typeof TRANSITIVE_ONLY} TRANSITIVE_ONLY */\n\n/** @typedef {typeof CIRCULAR_CONNECTION} CIRCULAR_CONNECTION */\n\n\nmodule.exports = ModuleGraphConnection;\nmodule.exports.addConnectionStates = addConnectionStates;\nmodule.exports.TRANSITIVE_ONLY =\n/** @type {typeof TRANSITIVE_ONLY} */\nTRANSITIVE_ONLY;\nmodule.exports.CIRCULAR_CONNECTION =\n/** @type {typeof CIRCULAR_CONNECTION} */\nCIRCULAR_CONNECTION;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/ModuleGraphConnection.js"],"names":["TRANSITIVE_ONLY","Symbol","CIRCULAR_CONNECTION","addConnectionStates","a","b","intersectConnectionStates","ModuleGraphConnection","originModule","dependency","module","explanation","weak","condition","undefined","resolvedOriginModule","resolvedModule","conditional","_active","explanations","Set","add","clone","old","c","r","Array","from","join","Error","value","runtime","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * Module itself is not connected, but transitive modules are connected transitively.\n */\nconst TRANSITIVE_ONLY = Symbol(\"transitive only\");\n\n/**\n * While determining the active state, this flag is used to signal a circular connection.\n */\nconst CIRCULAR_CONNECTION = Symbol(\"circular connection\");\n\n/** @typedef {boolean | typeof TRANSITIVE_ONLY | typeof CIRCULAR_CONNECTION} ConnectionState */\n\n/**\n * @param {ConnectionState} a first\n * @param {ConnectionState} b second\n * @returns {ConnectionState} merged\n */\nconst addConnectionStates = (a, b) => {\n\tif (a === true || b === true) return true;\n\tif (a === false) return b;\n\tif (b === false) return a;\n\tif (a === TRANSITIVE_ONLY) return b;\n\tif (b === TRANSITIVE_ONLY) return a;\n\treturn a;\n};\n\n/**\n * @param {ConnectionState} a first\n * @param {ConnectionState} b second\n * @returns {ConnectionState} intersected\n */\nconst intersectConnectionStates = (a, b) => {\n\tif (a === false || b === false) return false;\n\tif (a === true) return b;\n\tif (b === true) return a;\n\tif (a === CIRCULAR_CONNECTION) return b;\n\tif (b === CIRCULAR_CONNECTION) return a;\n\treturn a;\n};\n\nclass ModuleGraphConnection {\n\t/**\n\t * @param {Module|null} originModule the referencing module\n\t * @param {Dependency|null} dependency the referencing dependency\n\t * @param {Module} module the referenced module\n\t * @param {string=} explanation some extra detail\n\t * @param {boolean=} weak the reference is weak\n\t * @param {false | function(ModuleGraphConnection, RuntimeSpec): ConnectionState=} condition condition for the connection\n\t */\n\tconstructor(\n\t\toriginModule,\n\t\tdependency,\n\t\tmodule,\n\t\texplanation,\n\t\tweak = false,\n\t\tcondition = undefined\n\t) {\n\t\tthis.originModule = originModule;\n\t\tthis.resolvedOriginModule = originModule;\n\t\tthis.dependency = dependency;\n\t\tthis.resolvedModule = module;\n\t\tthis.module = module;\n\t\tthis.weak = weak;\n\t\tthis.conditional = !!condition;\n\t\tthis._active = condition !== false;\n\t\t/** @type {function(ModuleGraphConnection, RuntimeSpec): ConnectionState} */\n\t\tthis.condition = condition || undefined;\n\t\t/** @type {Set<string>} */\n\t\tthis.explanations = undefined;\n\t\tif (explanation) {\n\t\t\tthis.explanations = new Set();\n\t\t\tthis.explanations.add(explanation);\n\t\t}\n\t}\n\n\tclone() {\n\t\tconst clone = new ModuleGraphConnection(\n\t\t\tthis.resolvedOriginModule,\n\t\t\tthis.dependency,\n\t\t\tthis.resolvedModule,\n\t\t\tundefined,\n\t\t\tthis.weak,\n\t\t\tthis.condition\n\t\t);\n\t\tclone.originModule = this.originModule;\n\t\tclone.module = this.module;\n\t\tclone.conditional = this.conditional;\n\t\tclone._active = this._active;\n\t\tif (this.explanations) clone.explanations = new Set(this.explanations);\n\t\treturn clone;\n\t}\n\n\t/**\n\t * @param {function(ModuleGraphConnection, RuntimeSpec): ConnectionState} condition condition for the connection\n\t * @returns {void}\n\t */\n\taddCondition(condition) {\n\t\tif (this.conditional) {\n\t\t\tconst old = this.condition;\n\t\t\tthis.condition = (c, r) =>\n\t\t\t\tintersectConnectionStates(old(c, r), condition(c, r));\n\t\t} else if (this._active) {\n\t\t\tthis.conditional = true;\n\t\t\tthis.condition = condition;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} explanation the explanation to add\n\t * @returns {void}\n\t */\n\taddExplanation(explanation) {\n\t\tif (this.explanations === undefined) {\n\t\t\tthis.explanations = new Set();\n\t\t}\n\t\tthis.explanations.add(explanation);\n\t}\n\n\tget explanation() {\n\t\tif (this.explanations === undefined) return \"\";\n\t\treturn Array.from(this.explanations).join(\" \");\n\t}\n\n\t// TODO webpack 5 remove\n\tget active() {\n\t\tthrow new Error(\"Use getActiveState instead\");\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {boolean} true, if the connection is active\n\t */\n\tisActive(runtime) {\n\t\tif (!this.conditional) return this._active;\n\t\treturn this.condition(this, runtime) !== false;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {boolean} true, if the connection is active\n\t */\n\tisTargetActive(runtime) {\n\t\tif (!this.conditional) return this._active;\n\t\treturn this.condition(this, runtime) === true;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {ConnectionState} true: fully active, false: inactive, TRANSITIVE: direct module inactive, but transitive connection maybe active\n\t */\n\tgetActiveState(runtime) {\n\t\tif (!this.conditional) return this._active;\n\t\treturn this.condition(this, runtime);\n\t}\n\n\t/**\n\t * @param {boolean} value active or not\n\t * @returns {void}\n\t */\n\tsetActive(value) {\n\t\tthis.conditional = false;\n\t\tthis._active = value;\n\t}\n\n\tset active(value) {\n\t\tthrow new Error(\"Use setActive instead\");\n\t}\n}\n\n/** @typedef {typeof TRANSITIVE_ONLY} TRANSITIVE_ONLY */\n/** @typedef {typeof CIRCULAR_CONNECTION} CIRCULAR_CONNECTION */\n\nmodule.exports = ModuleGraphConnection;\nmodule.exports.addConnectionStates = addConnectionStates;\nmodule.exports.TRANSITIVE_ONLY = /** @type {typeof TRANSITIVE_ONLY} */ (\n\tTRANSITIVE_ONLY\n);\nmodule.exports.CIRCULAR_CONNECTION = /** @type {typeof CIRCULAR_CONNECTION} */ (\n\tCIRCULAR_CONNECTION\n);\n"]},"metadata":{},"sourceType":"script"}