{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar RuntimeGlobals = require(\"./RuntimeGlobals\");\n\nvar WebpackError = require(\"./WebpackError\");\n\nvar ConstDependency = require(\"./dependencies/ConstDependency\");\n\nvar BasicEvaluatedExpression = require(\"./javascript/BasicEvaluatedExpression\");\n\nvar _require = require(\"./javascript/JavascriptParserHelpers\"),\n    evaluateToString = _require.evaluateToString,\n    toConstantDependency = _require.toConstantDependency;\n\nvar createHash = require(\"./util/createHash\");\n/** @typedef {import(\"estree\").Expression} Expression */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./NormalModule\")} NormalModule */\n\n/** @typedef {import(\"./RuntimeTemplate\")} RuntimeTemplate */\n\n/** @typedef {import(\"./javascript/JavascriptParser\")} JavascriptParser */\n\n/** @typedef {null|undefined|RegExp|Function|string|number|boolean|bigint|undefined} CodeValuePrimitive */\n\n/** @typedef {RecursiveArrayOrRecord<CodeValuePrimitive|RuntimeValue>} CodeValue */\n\n/**\n * @typedef {Object} RuntimeValueOptions\n * @property {string[]=} fileDependencies\n * @property {string[]=} contextDependencies\n * @property {string[]=} missingDependencies\n * @property {string[]=} buildDependencies\n * @property {string|function(): string=} version\n */\n\n\nvar RuntimeValue = /*#__PURE__*/function () {\n  /**\n   * @param {function({ module: NormalModule, key: string, readonly version: string | undefined }): CodeValuePrimitive} fn generator function\n   * @param {true | string[] | RuntimeValueOptions=} options options\n   */\n  function RuntimeValue(fn, options) {\n    _classCallCheck(this, RuntimeValue);\n\n    this.fn = fn;\n\n    if (Array.isArray(options)) {\n      options = {\n        fileDependencies: options\n      };\n    }\n\n    this.options = options || {};\n  }\n\n  _createClass(RuntimeValue, [{\n    key: \"fileDependencies\",\n    get: function get() {\n      return this.options === true ? true : this.options.fileDependencies;\n    }\n    /**\n     * @param {JavascriptParser} parser the parser\n     * @param {Map<string, string | Set<string>>} valueCacheVersions valueCacheVersions\n     * @param {string} key the defined key\n     * @returns {CodeValuePrimitive} code\n     */\n\n  }, {\n    key: \"exec\",\n    value: function exec(parser, valueCacheVersions, key) {\n      var buildInfo = parser.state.module.buildInfo;\n\n      if (this.options === true) {\n        buildInfo.cacheable = false;\n      } else {\n        if (this.options.fileDependencies) {\n          var _iterator = _createForOfIteratorHelper(this.options.fileDependencies),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var dep = _step.value;\n              buildInfo.fileDependencies.add(dep);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n\n        if (this.options.contextDependencies) {\n          var _iterator2 = _createForOfIteratorHelper(this.options.contextDependencies),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _dep = _step2.value;\n              buildInfo.contextDependencies.add(_dep);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n\n        if (this.options.missingDependencies) {\n          var _iterator3 = _createForOfIteratorHelper(this.options.missingDependencies),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _dep2 = _step3.value;\n              buildInfo.missingDependencies.add(_dep2);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n\n        if (this.options.buildDependencies) {\n          var _iterator4 = _createForOfIteratorHelper(this.options.buildDependencies),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _dep3 = _step4.value;\n              buildInfo.buildDependencies.add(_dep3);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n      }\n\n      return this.fn({\n        module: parser.state.module,\n        key: key,\n\n        get version() {\n          return (\n            /** @type {string} */\n            valueCacheVersions.get(VALUE_DEP_PREFIX + key)\n          );\n        }\n\n      });\n    }\n  }, {\n    key: \"getCacheVersion\",\n    value: function getCacheVersion() {\n      return this.options === true ? undefined : (typeof this.options.version === \"function\" ? this.options.version() : this.options.version) || \"unset\";\n    }\n  }]);\n\n  return RuntimeValue;\n}();\n/**\n * @param {any[]|{[k: string]: any}} obj obj\n * @param {JavascriptParser} parser Parser\n * @param {Map<string, string | Set<string>>} valueCacheVersions valueCacheVersions\n * @param {string} key the defined key\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {boolean|undefined|null=} asiSafe asi safe (undefined: unknown, null: unneeded)\n * @returns {string} code converted to string that evaluates\n */\n\n\nvar stringifyObj = function stringifyObj(obj, parser, valueCacheVersions, key, runtimeTemplate, asiSafe) {\n  var code;\n  var arr = Array.isArray(obj);\n\n  if (arr) {\n    code = \"[\".concat(obj.map(function (code) {\n      return toCode(code, parser, valueCacheVersions, key, runtimeTemplate, null);\n    }).join(\",\"), \"]\");\n  } else {\n    code = \"{\".concat(Object.keys(obj).map(function (key) {\n      var code = obj[key];\n      return JSON.stringify(key) + \":\" + toCode(code, parser, valueCacheVersions, key, runtimeTemplate, null);\n    }).join(\",\"), \"}\");\n  }\n\n  switch (asiSafe) {\n    case null:\n      return code;\n\n    case true:\n      return arr ? code : \"(\".concat(code, \")\");\n\n    case false:\n      return arr ? \";\".concat(code) : \";(\".concat(code, \")\");\n\n    default:\n      return \"/*#__PURE__*/Object(\".concat(code, \")\");\n  }\n};\n/**\n * Convert code to a string that evaluates\n * @param {CodeValue} code Code to evaluate\n * @param {JavascriptParser} parser Parser\n * @param {Map<string, string | Set<string>>} valueCacheVersions valueCacheVersions\n * @param {string} key the defined key\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {boolean|undefined|null=} asiSafe asi safe (undefined: unknown, null: unneeded)\n * @returns {string} code converted to string that evaluates\n */\n\n\nvar toCode = function toCode(code, parser, valueCacheVersions, key, runtimeTemplate, asiSafe) {\n  if (code === null) {\n    return \"null\";\n  }\n\n  if (code === undefined) {\n    return \"undefined\";\n  }\n\n  if (Object.is(code, -0)) {\n    return \"-0\";\n  }\n\n  if (code instanceof RuntimeValue) {\n    return toCode(code.exec(parser, valueCacheVersions, key), parser, valueCacheVersions, key, runtimeTemplate, asiSafe);\n  }\n\n  if (code instanceof RegExp && code.toString) {\n    return code.toString();\n  }\n\n  if (typeof code === \"function\" && code.toString) {\n    return \"(\" + code.toString() + \")\";\n  }\n\n  if (typeof code === \"object\") {\n    return stringifyObj(code, parser, valueCacheVersions, key, runtimeTemplate, asiSafe);\n  }\n\n  if (typeof code === \"bigint\") {\n    return runtimeTemplate.supportsBigIntLiteral() ? \"\".concat(code, \"n\") : \"BigInt(\\\"\".concat(code, \"\\\")\");\n  }\n\n  return code + \"\";\n};\n\nvar toCacheVersion = function toCacheVersion(code) {\n  if (code === null) {\n    return \"null\";\n  }\n\n  if (code === undefined) {\n    return \"undefined\";\n  }\n\n  if (Object.is(code, -0)) {\n    return \"-0\";\n  }\n\n  if (code instanceof RuntimeValue) {\n    return code.getCacheVersion();\n  }\n\n  if (code instanceof RegExp && code.toString) {\n    return code.toString();\n  }\n\n  if (typeof code === \"function\" && code.toString) {\n    return \"(\" + code.toString() + \")\";\n  }\n\n  if (typeof code === \"object\") {\n    var items = Object.keys(code).map(function (key) {\n      return {\n        key: key,\n        value: toCacheVersion(code[key])\n      };\n    });\n    if (items.some(function (_ref) {\n      var value = _ref.value;\n      return value === undefined;\n    })) return undefined;\n    return \"{\".concat(items.map(function (_ref2) {\n      var key = _ref2.key,\n          value = _ref2.value;\n      return \"\".concat(key, \": \").concat(value);\n    }).join(\", \"), \"}\");\n  }\n\n  if (typeof code === \"bigint\") {\n    return \"\".concat(code, \"n\");\n  }\n\n  return code + \"\";\n};\n\nvar VALUE_DEP_PREFIX = \"webpack/DefinePlugin \";\nvar VALUE_DEP_MAIN = \"webpack/DefinePlugin_hash\";\n\nvar DefinePlugin = /*#__PURE__*/function () {\n  /**\n   * Create a new define plugin\n   * @param {Record<string, CodeValue>} definitions A map of global object definitions\n   */\n  function DefinePlugin(definitions) {\n    _classCallCheck(this, DefinePlugin);\n\n    this.definitions = definitions;\n  }\n  /**\n   * @param {function({ module: NormalModule, key: string, readonly version: string | undefined }): CodeValuePrimitive} fn generator function\n   * @param {true | string[] | RuntimeValueOptions=} options options\n   * @returns {RuntimeValue} runtime value\n   */\n\n\n  _createClass(DefinePlugin, [{\n    key: \"apply\",\n    value:\n    /**\n     * Apply the plugin\n     * @param {Compiler} compiler the compiler instance\n     * @returns {void}\n     */\n    function apply(compiler) {\n      var definitions = this.definitions;\n      compiler.hooks.compilation.tap(\"DefinePlugin\", function (compilation, _ref3) {\n        var normalModuleFactory = _ref3.normalModuleFactory;\n        compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());\n        var runtimeTemplate = compilation.runtimeTemplate;\n        var mainHash = createHash(compilation.outputOptions.hashFunction);\n        mainHash.update(\n        /** @type {string} */\n        compilation.valueCacheVersions.get(VALUE_DEP_MAIN) || \"\");\n        /**\n         * Handler\n         * @param {JavascriptParser} parser Parser\n         * @returns {void}\n         */\n\n        var handler = function handler(parser) {\n          var mainValue = compilation.valueCacheVersions.get(VALUE_DEP_MAIN);\n          parser.hooks.program.tap(\"DefinePlugin\", function () {\n            var buildInfo = parser.state.module.buildInfo;\n            if (!buildInfo.valueDependencies) buildInfo.valueDependencies = new Map();\n            buildInfo.valueDependencies.set(VALUE_DEP_MAIN, mainValue);\n          });\n\n          var addValueDependency = function addValueDependency(key) {\n            var buildInfo = parser.state.module.buildInfo;\n            buildInfo.valueDependencies.set(VALUE_DEP_PREFIX + key, compilation.valueCacheVersions.get(VALUE_DEP_PREFIX + key));\n          };\n\n          var withValueDependency = function withValueDependency(key, fn) {\n            return function () {\n              addValueDependency(key);\n              return fn.apply(void 0, arguments);\n            };\n          };\n          /**\n           * Walk definitions\n           * @param {Object} definitions Definitions map\n           * @param {string} prefix Prefix string\n           * @returns {void}\n           */\n\n\n          var walkDefinitions = function walkDefinitions(definitions, prefix) {\n            Object.keys(definitions).forEach(function (key) {\n              var code = definitions[key];\n\n              if (code && typeof code === \"object\" && !(code instanceof RuntimeValue) && !(code instanceof RegExp)) {\n                walkDefinitions(code, prefix + key + \".\");\n                applyObjectDefine(prefix + key, code);\n                return;\n              }\n\n              applyDefineKey(prefix, key);\n              applyDefine(prefix + key, code);\n            });\n          };\n          /**\n           * Apply define key\n           * @param {string} prefix Prefix\n           * @param {string} key Key\n           * @returns {void}\n           */\n\n\n          var applyDefineKey = function applyDefineKey(prefix, key) {\n            var splittedKey = key.split(\".\");\n            splittedKey.slice(1).forEach(function (_, i) {\n              var fullKey = prefix + splittedKey.slice(0, i + 1).join(\".\");\n              parser.hooks.canRename.for(fullKey).tap(\"DefinePlugin\", function () {\n                addValueDependency(key);\n                return true;\n              });\n            });\n          };\n          /**\n           * Apply Code\n           * @param {string} key Key\n           * @param {CodeValue} code Code\n           * @returns {void}\n           */\n\n\n          var applyDefine = function applyDefine(key, code) {\n            var originalKey = key;\n            var isTypeof = /^typeof\\s+/.test(key);\n            if (isTypeof) key = key.replace(/^typeof\\s+/, \"\");\n            var recurse = false;\n            var recurseTypeof = false;\n\n            if (!isTypeof) {\n              parser.hooks.canRename.for(key).tap(\"DefinePlugin\", function () {\n                addValueDependency(originalKey);\n                return true;\n              });\n              parser.hooks.evaluateIdentifier.for(key).tap(\"DefinePlugin\", function (expr) {\n                /**\n                 * this is needed in case there is a recursion in the DefinePlugin\n                 * to prevent an endless recursion\n                 * e.g.: new DefinePlugin({\n                 * \"a\": \"b\",\n                 * \"b\": \"a\"\n                 * });\n                 */\n                if (recurse) return;\n                addValueDependency(originalKey);\n                recurse = true;\n                var res = parser.evaluate(toCode(code, parser, compilation.valueCacheVersions, key, runtimeTemplate, null));\n                recurse = false;\n                res.setRange(expr.range);\n                return res;\n              });\n              parser.hooks.expression.for(key).tap(\"DefinePlugin\", function (expr) {\n                addValueDependency(originalKey);\n                var strCode = toCode(code, parser, compilation.valueCacheVersions, originalKey, runtimeTemplate, !parser.isAsiPosition(expr.range[0]));\n\n                if (/__webpack_require__\\s*(!?\\.)/.test(strCode)) {\n                  return toConstantDependency(parser, strCode, [RuntimeGlobals.require])(expr);\n                } else if (/__webpack_require__/.test(strCode)) {\n                  return toConstantDependency(parser, strCode, [RuntimeGlobals.requireScope])(expr);\n                } else {\n                  return toConstantDependency(parser, strCode)(expr);\n                }\n              });\n            }\n\n            parser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", function (expr) {\n              /**\n               * this is needed in case there is a recursion in the DefinePlugin\n               * to prevent an endless recursion\n               * e.g.: new DefinePlugin({\n               * \"typeof a\": \"typeof b\",\n               * \"typeof b\": \"typeof a\"\n               * });\n               */\n              if (recurseTypeof) return;\n              recurseTypeof = true;\n              addValueDependency(originalKey);\n              var codeCode = toCode(code, parser, compilation.valueCacheVersions, originalKey, runtimeTemplate, null);\n              var typeofCode = isTypeof ? codeCode : \"typeof (\" + codeCode + \")\";\n              var res = parser.evaluate(typeofCode);\n              recurseTypeof = false;\n              res.setRange(expr.range);\n              return res;\n            });\n            parser.hooks.typeof.for(key).tap(\"DefinePlugin\", function (expr) {\n              addValueDependency(originalKey);\n              var codeCode = toCode(code, parser, compilation.valueCacheVersions, originalKey, runtimeTemplate, null);\n              var typeofCode = isTypeof ? codeCode : \"typeof (\" + codeCode + \")\";\n              var res = parser.evaluate(typeofCode);\n              if (!res.isString()) return;\n              return toConstantDependency(parser, JSON.stringify(res.string)).bind(parser)(expr);\n            });\n          };\n          /**\n           * Apply Object\n           * @param {string} key Key\n           * @param {Object} obj Object\n           * @returns {void}\n           */\n\n\n          var applyObjectDefine = function applyObjectDefine(key, obj) {\n            parser.hooks.canRename.for(key).tap(\"DefinePlugin\", function () {\n              addValueDependency(key);\n              return true;\n            });\n            parser.hooks.evaluateIdentifier.for(key).tap(\"DefinePlugin\", function (expr) {\n              addValueDependency(key);\n              return new BasicEvaluatedExpression().setTruthy().setSideEffects(false).setRange(expr.range);\n            });\n            parser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", withValueDependency(key, evaluateToString(\"object\")));\n            parser.hooks.expression.for(key).tap(\"DefinePlugin\", function (expr) {\n              addValueDependency(key);\n              var strCode = stringifyObj(obj, parser, compilation.valueCacheVersions, key, runtimeTemplate, !parser.isAsiPosition(expr.range[0]));\n\n              if (/__webpack_require__\\s*(!?\\.)/.test(strCode)) {\n                return toConstantDependency(parser, strCode, [RuntimeGlobals.require])(expr);\n              } else if (/__webpack_require__/.test(strCode)) {\n                return toConstantDependency(parser, strCode, [RuntimeGlobals.requireScope])(expr);\n              } else {\n                return toConstantDependency(parser, strCode)(expr);\n              }\n            });\n            parser.hooks.typeof.for(key).tap(\"DefinePlugin\", withValueDependency(key, toConstantDependency(parser, JSON.stringify(\"object\"))));\n          };\n\n          walkDefinitions(definitions, \"\");\n        };\n\n        normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"DefinePlugin\", handler);\n        normalModuleFactory.hooks.parser.for(\"javascript/dynamic\").tap(\"DefinePlugin\", handler);\n        normalModuleFactory.hooks.parser.for(\"javascript/esm\").tap(\"DefinePlugin\", handler);\n        /**\n         * Walk definitions\n         * @param {Object} definitions Definitions map\n         * @param {string} prefix Prefix string\n         * @returns {void}\n         */\n\n        var walkDefinitionsForValues = function walkDefinitionsForValues(definitions, prefix) {\n          Object.keys(definitions).forEach(function (key) {\n            var code = definitions[key];\n            var version = toCacheVersion(code);\n            var name = VALUE_DEP_PREFIX + prefix + key;\n            mainHash.update(\"|\" + prefix + key);\n            var oldVersion = compilation.valueCacheVersions.get(name);\n\n            if (oldVersion === undefined) {\n              compilation.valueCacheVersions.set(name, version);\n            } else if (oldVersion !== version) {\n              var warning = new WebpackError(\"DefinePlugin\\nConflicting values for '\".concat(prefix + key, \"'\"));\n              warning.details = \"'\".concat(oldVersion, \"' !== '\").concat(version, \"'\");\n              warning.hideStack = true;\n              compilation.warnings.push(warning);\n            }\n\n            if (code && typeof code === \"object\" && !(code instanceof RuntimeValue) && !(code instanceof RegExp)) {\n              walkDefinitionsForValues(code, prefix + key + \".\");\n            }\n          });\n        };\n\n        walkDefinitionsForValues(definitions, \"\");\n        compilation.valueCacheVersions.set(VALUE_DEP_MAIN,\n        /** @type {string} */\n        mainHash.digest(\"hex\").slice(0, 8));\n      });\n    }\n  }], [{\n    key: \"runtimeValue\",\n    value: function runtimeValue(fn, options) {\n      return new RuntimeValue(fn, options);\n    }\n  }]);\n\n  return DefinePlugin;\n}();\n\nmodule.exports = DefinePlugin;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/DefinePlugin.js"],"names":["RuntimeGlobals","require","WebpackError","ConstDependency","BasicEvaluatedExpression","evaluateToString","toConstantDependency","createHash","RuntimeValue","fn","options","Array","isArray","fileDependencies","parser","valueCacheVersions","key","buildInfo","state","module","cacheable","dep","add","contextDependencies","missingDependencies","buildDependencies","version","get","VALUE_DEP_PREFIX","undefined","stringifyObj","obj","runtimeTemplate","asiSafe","code","arr","map","toCode","join","Object","keys","JSON","stringify","is","exec","RegExp","toString","supportsBigIntLiteral","toCacheVersion","getCacheVersion","items","value","some","VALUE_DEP_MAIN","DefinePlugin","definitions","compiler","hooks","compilation","tap","normalModuleFactory","dependencyTemplates","set","Template","mainHash","outputOptions","hashFunction","update","handler","mainValue","program","valueDependencies","Map","addValueDependency","withValueDependency","walkDefinitions","prefix","forEach","applyObjectDefine","applyDefineKey","applyDefine","splittedKey","split","slice","_","i","fullKey","canRename","for","originalKey","isTypeof","test","replace","recurse","recurseTypeof","evaluateIdentifier","expr","res","evaluate","setRange","range","expression","strCode","isAsiPosition","requireScope","evaluateTypeof","codeCode","typeofCode","typeof","isString","string","bind","setTruthy","setSideEffects","walkDefinitionsForValues","name","oldVersion","warning","details","hideStack","warnings","push","digest","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"./RuntimeGlobals\");\nconst WebpackError = require(\"./WebpackError\");\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\nconst BasicEvaluatedExpression = require(\"./javascript/BasicEvaluatedExpression\");\nconst {\n\tevaluateToString,\n\ttoConstantDependency\n} = require(\"./javascript/JavascriptParserHelpers\");\nconst createHash = require(\"./util/createHash\");\n\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./NormalModule\")} NormalModule */\n/** @typedef {import(\"./RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"./javascript/JavascriptParser\")} JavascriptParser */\n\n/** @typedef {null|undefined|RegExp|Function|string|number|boolean|bigint|undefined} CodeValuePrimitive */\n/** @typedef {RecursiveArrayOrRecord<CodeValuePrimitive|RuntimeValue>} CodeValue */\n\n/**\n * @typedef {Object} RuntimeValueOptions\n * @property {string[]=} fileDependencies\n * @property {string[]=} contextDependencies\n * @property {string[]=} missingDependencies\n * @property {string[]=} buildDependencies\n * @property {string|function(): string=} version\n */\n\nclass RuntimeValue {\n\t/**\n\t * @param {function({ module: NormalModule, key: string, readonly version: string | undefined }): CodeValuePrimitive} fn generator function\n\t * @param {true | string[] | RuntimeValueOptions=} options options\n\t */\n\tconstructor(fn, options) {\n\t\tthis.fn = fn;\n\t\tif (Array.isArray(options)) {\n\t\t\toptions = {\n\t\t\t\tfileDependencies: options\n\t\t\t};\n\t\t}\n\t\tthis.options = options || {};\n\t}\n\n\tget fileDependencies() {\n\t\treturn this.options === true ? true : this.options.fileDependencies;\n\t}\n\n\t/**\n\t * @param {JavascriptParser} parser the parser\n\t * @param {Map<string, string | Set<string>>} valueCacheVersions valueCacheVersions\n\t * @param {string} key the defined key\n\t * @returns {CodeValuePrimitive} code\n\t */\n\texec(parser, valueCacheVersions, key) {\n\t\tconst buildInfo = parser.state.module.buildInfo;\n\t\tif (this.options === true) {\n\t\t\tbuildInfo.cacheable = false;\n\t\t} else {\n\t\t\tif (this.options.fileDependencies) {\n\t\t\t\tfor (const dep of this.options.fileDependencies) {\n\t\t\t\t\tbuildInfo.fileDependencies.add(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.options.contextDependencies) {\n\t\t\t\tfor (const dep of this.options.contextDependencies) {\n\t\t\t\t\tbuildInfo.contextDependencies.add(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.options.missingDependencies) {\n\t\t\t\tfor (const dep of this.options.missingDependencies) {\n\t\t\t\t\tbuildInfo.missingDependencies.add(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.options.buildDependencies) {\n\t\t\t\tfor (const dep of this.options.buildDependencies) {\n\t\t\t\t\tbuildInfo.buildDependencies.add(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.fn({\n\t\t\tmodule: parser.state.module,\n\t\t\tkey,\n\t\t\tget version() {\n\t\t\t\treturn /** @type {string} */ (\n\t\t\t\t\tvalueCacheVersions.get(VALUE_DEP_PREFIX + key)\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t}\n\n\tgetCacheVersion() {\n\t\treturn this.options === true\n\t\t\t? undefined\n\t\t\t: (typeof this.options.version === \"function\"\n\t\t\t\t\t? this.options.version()\n\t\t\t\t\t: this.options.version) || \"unset\";\n\t}\n}\n\n/**\n * @param {any[]|{[k: string]: any}} obj obj\n * @param {JavascriptParser} parser Parser\n * @param {Map<string, string | Set<string>>} valueCacheVersions valueCacheVersions\n * @param {string} key the defined key\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {boolean|undefined|null=} asiSafe asi safe (undefined: unknown, null: unneeded)\n * @returns {string} code converted to string that evaluates\n */\nconst stringifyObj = (\n\tobj,\n\tparser,\n\tvalueCacheVersions,\n\tkey,\n\truntimeTemplate,\n\tasiSafe\n) => {\n\tlet code;\n\tlet arr = Array.isArray(obj);\n\tif (arr) {\n\t\tcode = `[${obj\n\t\t\t.map(code =>\n\t\t\t\ttoCode(code, parser, valueCacheVersions, key, runtimeTemplate, null)\n\t\t\t)\n\t\t\t.join(\",\")}]`;\n\t} else {\n\t\tcode = `{${Object.keys(obj)\n\t\t\t.map(key => {\n\t\t\t\tconst code = obj[key];\n\t\t\t\treturn (\n\t\t\t\t\tJSON.stringify(key) +\n\t\t\t\t\t\":\" +\n\t\t\t\t\ttoCode(code, parser, valueCacheVersions, key, runtimeTemplate, null)\n\t\t\t\t);\n\t\t\t})\n\t\t\t.join(\",\")}}`;\n\t}\n\n\tswitch (asiSafe) {\n\t\tcase null:\n\t\t\treturn code;\n\t\tcase true:\n\t\t\treturn arr ? code : `(${code})`;\n\t\tcase false:\n\t\t\treturn arr ? `;${code}` : `;(${code})`;\n\t\tdefault:\n\t\t\treturn `/*#__PURE__*/Object(${code})`;\n\t}\n};\n\n/**\n * Convert code to a string that evaluates\n * @param {CodeValue} code Code to evaluate\n * @param {JavascriptParser} parser Parser\n * @param {Map<string, string | Set<string>>} valueCacheVersions valueCacheVersions\n * @param {string} key the defined key\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {boolean|undefined|null=} asiSafe asi safe (undefined: unknown, null: unneeded)\n * @returns {string} code converted to string that evaluates\n */\nconst toCode = (\n\tcode,\n\tparser,\n\tvalueCacheVersions,\n\tkey,\n\truntimeTemplate,\n\tasiSafe\n) => {\n\tif (code === null) {\n\t\treturn \"null\";\n\t}\n\tif (code === undefined) {\n\t\treturn \"undefined\";\n\t}\n\tif (Object.is(code, -0)) {\n\t\treturn \"-0\";\n\t}\n\tif (code instanceof RuntimeValue) {\n\t\treturn toCode(\n\t\t\tcode.exec(parser, valueCacheVersions, key),\n\t\t\tparser,\n\t\t\tvalueCacheVersions,\n\t\t\tkey,\n\t\t\truntimeTemplate,\n\t\t\tasiSafe\n\t\t);\n\t}\n\tif (code instanceof RegExp && code.toString) {\n\t\treturn code.toString();\n\t}\n\tif (typeof code === \"function\" && code.toString) {\n\t\treturn \"(\" + code.toString() + \")\";\n\t}\n\tif (typeof code === \"object\") {\n\t\treturn stringifyObj(\n\t\t\tcode,\n\t\t\tparser,\n\t\t\tvalueCacheVersions,\n\t\t\tkey,\n\t\t\truntimeTemplate,\n\t\t\tasiSafe\n\t\t);\n\t}\n\tif (typeof code === \"bigint\") {\n\t\treturn runtimeTemplate.supportsBigIntLiteral()\n\t\t\t? `${code}n`\n\t\t\t: `BigInt(\"${code}\")`;\n\t}\n\treturn code + \"\";\n};\n\nconst toCacheVersion = code => {\n\tif (code === null) {\n\t\treturn \"null\";\n\t}\n\tif (code === undefined) {\n\t\treturn \"undefined\";\n\t}\n\tif (Object.is(code, -0)) {\n\t\treturn \"-0\";\n\t}\n\tif (code instanceof RuntimeValue) {\n\t\treturn code.getCacheVersion();\n\t}\n\tif (code instanceof RegExp && code.toString) {\n\t\treturn code.toString();\n\t}\n\tif (typeof code === \"function\" && code.toString) {\n\t\treturn \"(\" + code.toString() + \")\";\n\t}\n\tif (typeof code === \"object\") {\n\t\tconst items = Object.keys(code).map(key => ({\n\t\t\tkey,\n\t\t\tvalue: toCacheVersion(code[key])\n\t\t}));\n\t\tif (items.some(({ value }) => value === undefined)) return undefined;\n\t\treturn `{${items.map(({ key, value }) => `${key}: ${value}`).join(\", \")}}`;\n\t}\n\tif (typeof code === \"bigint\") {\n\t\treturn `${code}n`;\n\t}\n\treturn code + \"\";\n};\n\nconst VALUE_DEP_PREFIX = \"webpack/DefinePlugin \";\nconst VALUE_DEP_MAIN = \"webpack/DefinePlugin_hash\";\n\nclass DefinePlugin {\n\t/**\n\t * Create a new define plugin\n\t * @param {Record<string, CodeValue>} definitions A map of global object definitions\n\t */\n\tconstructor(definitions) {\n\t\tthis.definitions = definitions;\n\t}\n\n\t/**\n\t * @param {function({ module: NormalModule, key: string, readonly version: string | undefined }): CodeValuePrimitive} fn generator function\n\t * @param {true | string[] | RuntimeValueOptions=} options options\n\t * @returns {RuntimeValue} runtime value\n\t */\n\tstatic runtimeValue(fn, options) {\n\t\treturn new RuntimeValue(fn, options);\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst definitions = this.definitions;\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"DefinePlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tConstDependency,\n\t\t\t\t\tnew ConstDependency.Template()\n\t\t\t\t);\n\t\t\t\tconst { runtimeTemplate } = compilation;\n\n\t\t\t\tconst mainHash = createHash(compilation.outputOptions.hashFunction);\n\t\t\t\tmainHash.update(\n\t\t\t\t\t/** @type {string} */ (\n\t\t\t\t\t\tcompilation.valueCacheVersions.get(VALUE_DEP_MAIN)\n\t\t\t\t\t) || \"\"\n\t\t\t\t);\n\n\t\t\t\t/**\n\t\t\t\t * Handler\n\t\t\t\t * @param {JavascriptParser} parser Parser\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst handler = parser => {\n\t\t\t\t\tconst mainValue = compilation.valueCacheVersions.get(VALUE_DEP_MAIN);\n\t\t\t\t\tparser.hooks.program.tap(\"DefinePlugin\", () => {\n\t\t\t\t\t\tconst { buildInfo } = parser.state.module;\n\t\t\t\t\t\tif (!buildInfo.valueDependencies)\n\t\t\t\t\t\t\tbuildInfo.valueDependencies = new Map();\n\t\t\t\t\t\tbuildInfo.valueDependencies.set(VALUE_DEP_MAIN, mainValue);\n\t\t\t\t\t});\n\n\t\t\t\t\tconst addValueDependency = key => {\n\t\t\t\t\t\tconst { buildInfo } = parser.state.module;\n\t\t\t\t\t\tbuildInfo.valueDependencies.set(\n\t\t\t\t\t\t\tVALUE_DEP_PREFIX + key,\n\t\t\t\t\t\t\tcompilation.valueCacheVersions.get(VALUE_DEP_PREFIX + key)\n\t\t\t\t\t\t);\n\t\t\t\t\t};\n\n\t\t\t\t\tconst withValueDependency =\n\t\t\t\t\t\t(key, fn) =>\n\t\t\t\t\t\t(...args) => {\n\t\t\t\t\t\t\taddValueDependency(key);\n\t\t\t\t\t\t\treturn fn(...args);\n\t\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Walk definitions\n\t\t\t\t\t * @param {Object} definitions Definitions map\n\t\t\t\t\t * @param {string} prefix Prefix string\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst walkDefinitions = (definitions, prefix) => {\n\t\t\t\t\t\tObject.keys(definitions).forEach(key => {\n\t\t\t\t\t\t\tconst code = definitions[key];\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcode &&\n\t\t\t\t\t\t\t\ttypeof code === \"object\" &&\n\t\t\t\t\t\t\t\t!(code instanceof RuntimeValue) &&\n\t\t\t\t\t\t\t\t!(code instanceof RegExp)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\twalkDefinitions(code, prefix + key + \".\");\n\t\t\t\t\t\t\t\tapplyObjectDefine(prefix + key, code);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tapplyDefineKey(prefix, key);\n\t\t\t\t\t\t\tapplyDefine(prefix + key, code);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply define key\n\t\t\t\t\t * @param {string} prefix Prefix\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyDefineKey = (prefix, key) => {\n\t\t\t\t\t\tconst splittedKey = key.split(\".\");\n\t\t\t\t\t\tsplittedKey.slice(1).forEach((_, i) => {\n\t\t\t\t\t\t\tconst fullKey = prefix + splittedKey.slice(0, i + 1).join(\".\");\n\t\t\t\t\t\t\tparser.hooks.canRename.for(fullKey).tap(\"DefinePlugin\", () => {\n\t\t\t\t\t\t\t\taddValueDependency(key);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply Code\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @param {CodeValue} code Code\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyDefine = (key, code) => {\n\t\t\t\t\t\tconst originalKey = key;\n\t\t\t\t\t\tconst isTypeof = /^typeof\\s+/.test(key);\n\t\t\t\t\t\tif (isTypeof) key = key.replace(/^typeof\\s+/, \"\");\n\t\t\t\t\t\tlet recurse = false;\n\t\t\t\t\t\tlet recurseTypeof = false;\n\t\t\t\t\t\tif (!isTypeof) {\n\t\t\t\t\t\t\tparser.hooks.canRename.for(key).tap(\"DefinePlugin\", () => {\n\t\t\t\t\t\t\t\taddValueDependency(originalKey);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t\t.tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t * this is needed in case there is a recursion in the DefinePlugin\n\t\t\t\t\t\t\t\t\t * to prevent an endless recursion\n\t\t\t\t\t\t\t\t\t * e.g.: new DefinePlugin({\n\t\t\t\t\t\t\t\t\t * \"a\": \"b\",\n\t\t\t\t\t\t\t\t\t * \"b\": \"a\"\n\t\t\t\t\t\t\t\t\t * });\n\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\tif (recurse) return;\n\t\t\t\t\t\t\t\t\taddValueDependency(originalKey);\n\t\t\t\t\t\t\t\t\trecurse = true;\n\t\t\t\t\t\t\t\t\tconst res = parser.evaluate(\n\t\t\t\t\t\t\t\t\t\ttoCode(\n\t\t\t\t\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\t\t\tcompilation.valueCacheVersions,\n\t\t\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\trecurse = false;\n\t\t\t\t\t\t\t\t\tres.setRange(expr.range);\n\t\t\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tparser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t\taddValueDependency(originalKey);\n\t\t\t\t\t\t\t\tconst strCode = toCode(\n\t\t\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\tcompilation.valueCacheVersions,\n\t\t\t\t\t\t\t\t\toriginalKey,\n\t\t\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\t\t\t!parser.isAsiPosition(expr.range[0])\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (/__webpack_require__\\s*(!?\\.)/.test(strCode)) {\n\t\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode, [\n\t\t\t\t\t\t\t\t\t\tRuntimeGlobals.require\n\t\t\t\t\t\t\t\t\t])(expr);\n\t\t\t\t\t\t\t\t} else if (/__webpack_require__/.test(strCode)) {\n\t\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode, [\n\t\t\t\t\t\t\t\t\t\tRuntimeGlobals.requireScope\n\t\t\t\t\t\t\t\t\t])(expr);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode)(expr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * this is needed in case there is a recursion in the DefinePlugin\n\t\t\t\t\t\t\t * to prevent an endless recursion\n\t\t\t\t\t\t\t * e.g.: new DefinePlugin({\n\t\t\t\t\t\t\t * \"typeof a\": \"typeof b\",\n\t\t\t\t\t\t\t * \"typeof b\": \"typeof a\"\n\t\t\t\t\t\t\t * });\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (recurseTypeof) return;\n\t\t\t\t\t\t\trecurseTypeof = true;\n\t\t\t\t\t\t\taddValueDependency(originalKey);\n\t\t\t\t\t\t\tconst codeCode = toCode(\n\t\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tcompilation.valueCacheVersions,\n\t\t\t\t\t\t\t\toriginalKey,\n\t\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst typeofCode = isTypeof\n\t\t\t\t\t\t\t\t? codeCode\n\t\t\t\t\t\t\t\t: \"typeof (\" + codeCode + \")\";\n\t\t\t\t\t\t\tconst res = parser.evaluate(typeofCode);\n\t\t\t\t\t\t\trecurseTypeof = false;\n\t\t\t\t\t\t\tres.setRange(expr.range);\n\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.typeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\taddValueDependency(originalKey);\n\t\t\t\t\t\t\tconst codeCode = toCode(\n\t\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tcompilation.valueCacheVersions,\n\t\t\t\t\t\t\t\toriginalKey,\n\t\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst typeofCode = isTypeof\n\t\t\t\t\t\t\t\t? codeCode\n\t\t\t\t\t\t\t\t: \"typeof (\" + codeCode + \")\";\n\t\t\t\t\t\t\tconst res = parser.evaluate(typeofCode);\n\t\t\t\t\t\t\tif (!res.isString()) return;\n\t\t\t\t\t\t\treturn toConstantDependency(\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tJSON.stringify(res.string)\n\t\t\t\t\t\t\t).bind(parser)(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply Object\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @param {Object} obj Object\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyObjectDefine = (key, obj) => {\n\t\t\t\t\t\tparser.hooks.canRename.for(key).tap(\"DefinePlugin\", () => {\n\t\t\t\t\t\t\taddValueDependency(key);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t\taddValueDependency(key);\n\t\t\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t\t.setTruthy()\n\t\t\t\t\t\t\t\t\t.setSideEffects(false)\n\t\t\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.evaluateTypeof\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\n\t\t\t\t\t\t\t\t\"DefinePlugin\",\n\t\t\t\t\t\t\t\twithValueDependency(key, evaluateToString(\"object\"))\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tparser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\taddValueDependency(key);\n\t\t\t\t\t\t\tconst strCode = stringifyObj(\n\t\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tcompilation.valueCacheVersions,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\t\t!parser.isAsiPosition(expr.range[0])\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif (/__webpack_require__\\s*(!?\\.)/.test(strCode)) {\n\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode, [\n\t\t\t\t\t\t\t\t\tRuntimeGlobals.require\n\t\t\t\t\t\t\t\t])(expr);\n\t\t\t\t\t\t\t} else if (/__webpack_require__/.test(strCode)) {\n\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode, [\n\t\t\t\t\t\t\t\t\tRuntimeGlobals.requireScope\n\t\t\t\t\t\t\t\t])(expr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode)(expr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.typeof\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\n\t\t\t\t\t\t\t\t\"DefinePlugin\",\n\t\t\t\t\t\t\t\twithValueDependency(\n\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\ttoConstantDependency(parser, JSON.stringify(\"object\"))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t};\n\n\t\t\t\t\twalkDefinitions(definitions, \"\");\n\t\t\t\t};\n\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/auto\")\n\t\t\t\t\t.tap(\"DefinePlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/dynamic\")\n\t\t\t\t\t.tap(\"DefinePlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/esm\")\n\t\t\t\t\t.tap(\"DefinePlugin\", handler);\n\n\t\t\t\t/**\n\t\t\t\t * Walk definitions\n\t\t\t\t * @param {Object} definitions Definitions map\n\t\t\t\t * @param {string} prefix Prefix string\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst walkDefinitionsForValues = (definitions, prefix) => {\n\t\t\t\t\tObject.keys(definitions).forEach(key => {\n\t\t\t\t\t\tconst code = definitions[key];\n\t\t\t\t\t\tconst version = toCacheVersion(code);\n\t\t\t\t\t\tconst name = VALUE_DEP_PREFIX + prefix + key;\n\t\t\t\t\t\tmainHash.update(\"|\" + prefix + key);\n\t\t\t\t\t\tconst oldVersion = compilation.valueCacheVersions.get(name);\n\t\t\t\t\t\tif (oldVersion === undefined) {\n\t\t\t\t\t\t\tcompilation.valueCacheVersions.set(name, version);\n\t\t\t\t\t\t} else if (oldVersion !== version) {\n\t\t\t\t\t\t\tconst warning = new WebpackError(\n\t\t\t\t\t\t\t\t`DefinePlugin\\nConflicting values for '${prefix + key}'`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\twarning.details = `'${oldVersion}' !== '${version}'`;\n\t\t\t\t\t\t\twarning.hideStack = true;\n\t\t\t\t\t\t\tcompilation.warnings.push(warning);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tcode &&\n\t\t\t\t\t\t\ttypeof code === \"object\" &&\n\t\t\t\t\t\t\t!(code instanceof RuntimeValue) &&\n\t\t\t\t\t\t\t!(code instanceof RegExp)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\twalkDefinitionsForValues(code, prefix + key + \".\");\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\twalkDefinitionsForValues(definitions, \"\");\n\n\t\t\t\tcompilation.valueCacheVersions.set(\n\t\t\t\t\tVALUE_DEP_MAIN,\n\t\t\t\t\t/** @type {string} */ (mainHash.digest(\"hex\").slice(0, 8))\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = DefinePlugin;\n"]},"metadata":{},"sourceType":"script"}