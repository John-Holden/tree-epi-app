{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/john/tree-epidemic-sim-front-end/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar asyncLib = require(\"neo-async\");\n\nvar ChunkGraph = require(\"../ChunkGraph\");\n\nvar ModuleGraph = require(\"../ModuleGraph\");\n\nvar _require = require(\"../OptimizationStages\"),\n    STAGE_DEFAULT = _require.STAGE_DEFAULT;\n\nvar HarmonyImportDependency = require(\"../dependencies/HarmonyImportDependency\");\n\nvar _require2 = require(\"../util/comparators\"),\n    compareModulesByIdentifier = _require2.compareModulesByIdentifier;\n\nvar _require3 = require(\"../util/runtime\"),\n    intersectRuntime = _require3.intersectRuntime,\n    mergeRuntimeOwned = _require3.mergeRuntimeOwned,\n    filterRuntime = _require3.filterRuntime,\n    runtimeToString = _require3.runtimeToString,\n    mergeRuntime = _require3.mergeRuntime;\n\nvar ConcatenatedModule = require(\"./ConcatenatedModule\");\n/** @typedef {import(\"../Compilation\")} Compilation */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../RequestShortener\")} RequestShortener */\n\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {Object} Statistics\n * @property {number} cached\n * @property {number} alreadyInConfig\n * @property {number} invalidModule\n * @property {number} incorrectChunks\n * @property {number} incorrectDependency\n * @property {number} incorrectModuleDependency\n * @property {number} incorrectChunksOfImporter\n * @property {number} incorrectRuntimeCondition\n * @property {number} importerFailed\n * @property {number} added\n */\n\n\nvar formatBailoutReason = function formatBailoutReason(msg) {\n  return \"ModuleConcatenation bailout: \" + msg;\n};\n\nvar ModuleConcatenationPlugin = /*#__PURE__*/function () {\n  function ModuleConcatenationPlugin(options) {\n    _classCallCheck(this, ModuleConcatenationPlugin);\n\n    if (typeof options !== \"object\") options = {};\n    this.options = options;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  _createClass(ModuleConcatenationPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var _this = this;\n\n      var backCompat = compiler._backCompat;\n      compiler.hooks.compilation.tap(\"ModuleConcatenationPlugin\", function (compilation) {\n        var moduleGraph = compilation.moduleGraph;\n        var bailoutReasonMap = new Map();\n\n        var setBailoutReason = function setBailoutReason(module, reason) {\n          setInnerBailoutReason(module, reason);\n          moduleGraph.getOptimizationBailout(module).push(typeof reason === \"function\" ? function (rs) {\n            return formatBailoutReason(reason(rs));\n          } : formatBailoutReason(reason));\n        };\n\n        var setInnerBailoutReason = function setInnerBailoutReason(module, reason) {\n          bailoutReasonMap.set(module, reason);\n        };\n\n        var getInnerBailoutReason = function getInnerBailoutReason(module, requestShortener) {\n          var reason = bailoutReasonMap.get(module);\n          if (typeof reason === \"function\") return reason(requestShortener);\n          return reason;\n        };\n\n        var formatBailoutWarning = function formatBailoutWarning(module, problem) {\n          return function (requestShortener) {\n            if (typeof problem === \"function\") {\n              return formatBailoutReason(\"Cannot concat with \".concat(module.readableIdentifier(requestShortener), \": \").concat(problem(requestShortener)));\n            }\n\n            var reason = getInnerBailoutReason(module, requestShortener);\n            var reasonWithPrefix = reason ? \": \".concat(reason) : \"\";\n\n            if (module === problem) {\n              return formatBailoutReason(\"Cannot concat with \".concat(module.readableIdentifier(requestShortener)).concat(reasonWithPrefix));\n            } else {\n              return formatBailoutReason(\"Cannot concat with \".concat(module.readableIdentifier(requestShortener), \" because of \").concat(problem.readableIdentifier(requestShortener)).concat(reasonWithPrefix));\n            }\n          };\n        };\n\n        compilation.hooks.optimizeChunkModules.tapAsync({\n          name: \"ModuleConcatenationPlugin\",\n          stage: STAGE_DEFAULT\n        }, function (allChunks, modules, callback) {\n          var logger = compilation.getLogger(\"webpack.ModuleConcatenationPlugin\");\n          var chunkGraph = compilation.chunkGraph,\n              moduleGraph = compilation.moduleGraph;\n          var relevantModules = [];\n          var possibleInners = new Set();\n          var context = {\n            chunkGraph: chunkGraph,\n            moduleGraph: moduleGraph\n          };\n          logger.time(\"select relevant modules\");\n\n          var _iterator = _createForOfIteratorHelper(modules),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _module2 = _step.value;\n              var canBeRoot = true;\n              var canBeInner = true;\n\n              var bailoutReason = _module2.getConcatenationBailoutReason(context);\n\n              if (bailoutReason) {\n                setBailoutReason(_module2, bailoutReason);\n                continue;\n              } // Must not be an async module\n\n\n              if (moduleGraph.isAsync(_module2)) {\n                setBailoutReason(_module2, \"Module is async\");\n                continue;\n              } // Must be in strict mode\n\n\n              if (!_module2.buildInfo.strict) {\n                setBailoutReason(_module2, \"Module is not in strict mode\");\n                continue;\n              } // Module must be in any chunk (we don't want to do useless work)\n\n\n              if (chunkGraph.getNumberOfModuleChunks(_module2) === 0) {\n                setBailoutReason(_module2, \"Module is not in any chunk\");\n                continue;\n              } // Exports must be known (and not dynamic)\n\n\n              var exportsInfo = moduleGraph.getExportsInfo(_module2);\n              var relevantExports = exportsInfo.getRelevantExports(undefined);\n              var unknownReexports = relevantExports.filter(function (exportInfo) {\n                return exportInfo.isReexport() && !exportInfo.getTarget(moduleGraph);\n              });\n\n              if (unknownReexports.length > 0) {\n                setBailoutReason(_module2, \"Reexports in this module do not have a static target (\".concat(Array.from(unknownReexports, function (exportInfo) {\n                  return \"\".concat(exportInfo.name || \"other exports\", \": \").concat(exportInfo.getUsedInfo());\n                }).join(\", \"), \")\"));\n                continue;\n              } // Root modules must have a static list of exports\n\n\n              var unknownProvidedExports = relevantExports.filter(function (exportInfo) {\n                return exportInfo.provided !== true;\n              });\n\n              if (unknownProvidedExports.length > 0) {\n                setBailoutReason(_module2, \"List of module exports is dynamic (\".concat(Array.from(unknownProvidedExports, function (exportInfo) {\n                  return \"\".concat(exportInfo.name || \"other exports\", \": \").concat(exportInfo.getProvidedInfo(), \" and \").concat(exportInfo.getUsedInfo());\n                }).join(\", \"), \")\"));\n                canBeRoot = false;\n              } // Module must not be an entry point\n\n\n              if (chunkGraph.isEntryModule(_module2)) {\n                setInnerBailoutReason(_module2, \"Module is an entry point\");\n                canBeInner = false;\n              }\n\n              if (canBeRoot) relevantModules.push(_module2);\n              if (canBeInner) possibleInners.add(_module2);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          logger.timeEnd(\"select relevant modules\");\n          logger.debug(\"\".concat(relevantModules.length, \" potential root modules, \").concat(possibleInners.size, \" potential inner modules\")); // sort by depth\n          // modules with lower depth are more likely suited as roots\n          // this improves performance, because modules already selected as inner are skipped\n\n          logger.time(\"sort relevant modules\");\n          relevantModules.sort(function (a, b) {\n            return moduleGraph.getDepth(a) - moduleGraph.getDepth(b);\n          });\n          logger.timeEnd(\"sort relevant modules\");\n          /** @type {Statistics} */\n\n          var stats = {\n            cached: 0,\n            alreadyInConfig: 0,\n            invalidModule: 0,\n            incorrectChunks: 0,\n            incorrectDependency: 0,\n            incorrectModuleDependency: 0,\n            incorrectChunksOfImporter: 0,\n            incorrectRuntimeCondition: 0,\n            importerFailed: 0,\n            added: 0\n          };\n          var statsCandidates = 0;\n          var statsSizeSum = 0;\n          var statsEmptyConfigurations = 0;\n          logger.time(\"find modules to concatenate\");\n          var concatConfigurations = [];\n          var usedAsInner = new Set();\n\n          var _loop = function _loop() {\n            var currentRoot = _relevantModules[_i];\n            // when used by another configuration as inner:\n            // the other configuration is better and we can skip this one\n            // TODO reconsider that when it's only used in a different runtime\n            if (usedAsInner.has(currentRoot)) return \"continue\";\n            var chunkRuntime = undefined;\n\n            var _iterator2 = _createForOfIteratorHelper(chunkGraph.getModuleRuntimes(currentRoot)),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var r = _step2.value;\n                chunkRuntime = mergeRuntimeOwned(chunkRuntime, r);\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n\n            var exportsInfo = moduleGraph.getExportsInfo(currentRoot);\n            var filteredRuntime = filterRuntime(chunkRuntime, function (r) {\n              return exportsInfo.isModuleUsed(r);\n            });\n            var activeRuntime = filteredRuntime === true ? chunkRuntime : filteredRuntime === false ? undefined : filteredRuntime; // create a configuration with the root\n\n            var currentConfiguration = new ConcatConfiguration(currentRoot, activeRuntime); // cache failures to add modules\n\n            var failureCache = new Map(); // potential optional import candidates\n\n            /** @type {Set<Module>} */\n\n            var candidates = new Set(); // try to add all imports\n\n            var _iterator3 = _createForOfIteratorHelper(_this._getImports(compilation, currentRoot, activeRuntime)),\n                _step3;\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var imp = _step3.value;\n                candidates.add(imp);\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n\n            var _iterator4 = _createForOfIteratorHelper(candidates),\n                _step4;\n\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var _imp = _step4.value;\n                var impCandidates = new Set();\n\n                var problem = _this._tryToAdd(compilation, currentConfiguration, _imp, chunkRuntime, activeRuntime, possibleInners, impCandidates, failureCache, chunkGraph, true, stats);\n\n                if (problem) {\n                  failureCache.set(_imp, problem);\n                  currentConfiguration.addWarning(_imp, problem);\n                } else {\n                  var _iterator7 = _createForOfIteratorHelper(impCandidates),\n                      _step7;\n\n                  try {\n                    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                      var c = _step7.value;\n                      candidates.add(c);\n                    }\n                  } catch (err) {\n                    _iterator7.e(err);\n                  } finally {\n                    _iterator7.f();\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n\n            statsCandidates += candidates.size;\n\n            if (!currentConfiguration.isEmpty()) {\n              var _modules = currentConfiguration.getModules();\n\n              statsSizeSum += _modules.size;\n              concatConfigurations.push(currentConfiguration);\n\n              var _iterator5 = _createForOfIteratorHelper(_modules),\n                  _step5;\n\n              try {\n                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                  var _module = _step5.value;\n\n                  if (_module !== currentConfiguration.rootModule) {\n                    usedAsInner.add(_module);\n                  }\n                }\n              } catch (err) {\n                _iterator5.e(err);\n              } finally {\n                _iterator5.f();\n              }\n            } else {\n              statsEmptyConfigurations++;\n              var optimizationBailouts = moduleGraph.getOptimizationBailout(currentRoot);\n\n              var _iterator6 = _createForOfIteratorHelper(currentConfiguration.getWarningsSorted()),\n                  _step6;\n\n              try {\n                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                  var warning = _step6.value;\n                  optimizationBailouts.push(formatBailoutWarning(warning[0], warning[1]));\n                }\n              } catch (err) {\n                _iterator6.e(err);\n              } finally {\n                _iterator6.f();\n              }\n            }\n          };\n\n          for (var _i = 0, _relevantModules = relevantModules; _i < _relevantModules.length; _i++) {\n            var _ret = _loop();\n\n            if (_ret === \"continue\") continue;\n          }\n\n          logger.timeEnd(\"find modules to concatenate\");\n          logger.debug(\"\".concat(concatConfigurations.length, \" successful concat configurations (avg size: \").concat(statsSizeSum / concatConfigurations.length, \"), \").concat(statsEmptyConfigurations, \" bailed out completely\"));\n          logger.debug(\"\".concat(statsCandidates, \" candidates were considered for adding (\").concat(stats.cached, \" cached failure, \").concat(stats.alreadyInConfig, \" already in config, \").concat(stats.invalidModule, \" invalid module, \").concat(stats.incorrectChunks, \" incorrect chunks, \").concat(stats.incorrectDependency, \" incorrect dependency, \").concat(stats.incorrectChunksOfImporter, \" incorrect chunks of importer, \").concat(stats.incorrectModuleDependency, \" incorrect module dependency, \").concat(stats.incorrectRuntimeCondition, \" incorrect runtime condition, \").concat(stats.importerFailed, \" importer failed, \").concat(stats.added, \" added)\")); // HACK: Sort configurations by length and start with the longest one\n          // to get the biggest groups possible. Used modules are marked with usedModules\n          // TODO: Allow to reuse existing configuration while trying to add dependencies.\n          // This would improve performance. O(n^2) -> O(n)\n\n          logger.time(\"sort concat configurations\");\n          concatConfigurations.sort(function (a, b) {\n            return b.modules.size - a.modules.size;\n          });\n          logger.timeEnd(\"sort concat configurations\");\n          var usedModules = new Set();\n          logger.time(\"create concatenated modules\");\n          asyncLib.each(concatConfigurations, function (concatConfiguration, callback) {\n            var rootModule = concatConfiguration.rootModule; // Avoid overlapping configurations\n            // TODO: remove this when todo above is fixed\n\n            if (usedModules.has(rootModule)) return callback();\n            var modules = concatConfiguration.getModules();\n\n            var _iterator8 = _createForOfIteratorHelper(modules),\n                _step8;\n\n            try {\n              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                var m = _step8.value;\n                usedModules.add(m);\n              } // Create a new ConcatenatedModule\n\n            } catch (err) {\n              _iterator8.e(err);\n            } finally {\n              _iterator8.f();\n            }\n\n            var newModule = ConcatenatedModule.create(rootModule, modules, concatConfiguration.runtime, compiler.root, compilation.outputOptions.hashFunction);\n\n            var build = function build() {\n              newModule.build(compiler.options, compilation, null, null, function (err) {\n                if (err) {\n                  if (!err.module) {\n                    err.module = newModule;\n                  }\n\n                  return callback(err);\n                }\n\n                integrate();\n              });\n            };\n\n            var integrate = function integrate() {\n              if (backCompat) {\n                ChunkGraph.setChunkGraphForModule(newModule, chunkGraph);\n                ModuleGraph.setModuleGraphForModule(newModule, moduleGraph);\n              }\n\n              var _iterator9 = _createForOfIteratorHelper(concatConfiguration.getWarningsSorted()),\n                  _step9;\n\n              try {\n                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                  var warning = _step9.value;\n                  moduleGraph.getOptimizationBailout(newModule).push(formatBailoutWarning(warning[0], warning[1]));\n                }\n              } catch (err) {\n                _iterator9.e(err);\n              } finally {\n                _iterator9.f();\n              }\n\n              moduleGraph.cloneModuleAttributes(rootModule, newModule);\n\n              var _iterator10 = _createForOfIteratorHelper(modules),\n                  _step10;\n\n              try {\n                var _loop2 = function _loop2() {\n                  var m = _step10.value;\n\n                  // add to builtModules when one of the included modules was built\n                  if (compilation.builtModules.has(m)) {\n                    compilation.builtModules.add(newModule);\n                  }\n\n                  if (m !== rootModule) {\n                    // attach external references to the concatenated module too\n                    moduleGraph.copyOutgoingModuleConnections(m, newModule, function (c) {\n                      return c.originModule === m && !(c.dependency instanceof HarmonyImportDependency && modules.has(c.module));\n                    }); // remove module from chunk\n\n                    var _iterator11 = _createForOfIteratorHelper(chunkGraph.getModuleChunksIterable(rootModule)),\n                        _step11;\n\n                    try {\n                      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                        var chunk = _step11.value;\n                        chunkGraph.disconnectChunkAndModule(chunk, m);\n                      }\n                    } catch (err) {\n                      _iterator11.e(err);\n                    } finally {\n                      _iterator11.f();\n                    }\n                  }\n                };\n\n                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                  _loop2();\n                }\n              } catch (err) {\n                _iterator10.e(err);\n              } finally {\n                _iterator10.f();\n              }\n\n              compilation.modules.delete(rootModule);\n              ChunkGraph.clearChunkGraphForModule(rootModule);\n              ModuleGraph.clearModuleGraphForModule(rootModule); // remove module from chunk\n\n              chunkGraph.replaceModule(rootModule, newModule); // replace module references with the concatenated module\n\n              moduleGraph.moveModuleConnections(rootModule, newModule, function (c) {\n                var otherModule = c.module === rootModule ? c.originModule : c.module;\n                var innerConnection = c.dependency instanceof HarmonyImportDependency && modules.has(otherModule);\n                return !innerConnection;\n              }); // add concatenated module to the compilation\n\n              compilation.modules.add(newModule);\n              callback();\n            };\n\n            build();\n          }, function (err) {\n            logger.timeEnd(\"create concatenated modules\");\n            process.nextTick(callback.bind(null, err));\n          });\n        });\n      });\n    }\n    /**\n     * @param {Compilation} compilation the compilation\n     * @param {Module} module the module to be added\n     * @param {RuntimeSpec} runtime the runtime scope\n     * @returns {Set<Module>} the imported modules\n     */\n\n  }, {\n    key: \"_getImports\",\n    value: function _getImports(compilation, module, runtime) {\n      var moduleGraph = compilation.moduleGraph;\n      var set = new Set();\n\n      var _iterator12 = _createForOfIteratorHelper(module.dependencies),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var dep = _step12.value;\n          // Get reference info only for harmony Dependencies\n          if (!(dep instanceof HarmonyImportDependency)) continue;\n          var connection = moduleGraph.getConnection(dep); // Reference is valid and has a module\n\n          if (!connection || !connection.module || !connection.isTargetActive(runtime)) {\n            continue;\n          }\n\n          var importedNames = compilation.getDependencyReferencedExports(dep, undefined);\n\n          if (importedNames.every(function (i) {\n            return Array.isArray(i) ? i.length > 0 : i.name.length > 0;\n          }) || Array.isArray(moduleGraph.getProvidedExports(module))) {\n            set.add(connection.module);\n          }\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n\n      return set;\n    }\n    /**\n     * @param {Compilation} compilation webpack compilation\n     * @param {ConcatConfiguration} config concat configuration (will be modified when added)\n     * @param {Module} module the module to be added\n     * @param {RuntimeSpec} runtime the runtime scope of the generated code\n     * @param {RuntimeSpec} activeRuntime the runtime scope of the root module\n     * @param {Set<Module>} possibleModules modules that are candidates\n     * @param {Set<Module>} candidates list of potential candidates (will be added to)\n     * @param {Map<Module, Module | function(RequestShortener): string>} failureCache cache for problematic modules to be more performant\n     * @param {ChunkGraph} chunkGraph the chunk graph\n     * @param {boolean} avoidMutateOnFailure avoid mutating the config when adding fails\n     * @param {Statistics} statistics gathering metrics\n     * @returns {Module | function(RequestShortener): string} the problematic module\n     */\n\n  }, {\n    key: \"_tryToAdd\",\n    value: function _tryToAdd(compilation, config, module, runtime, activeRuntime, possibleModules, candidates, failureCache, chunkGraph, avoidMutateOnFailure, statistics) {\n      var cacheEntry = failureCache.get(module);\n\n      if (cacheEntry) {\n        statistics.cached++;\n        return cacheEntry;\n      } // Already added?\n\n\n      if (config.has(module)) {\n        statistics.alreadyInConfig++;\n        return null;\n      } // Not possible to add?\n\n\n      if (!possibleModules.has(module)) {\n        statistics.invalidModule++;\n        failureCache.set(module, module); // cache failures for performance\n\n        return module;\n      } // Module must be in the correct chunks\n\n\n      var missingChunks = Array.from(chunkGraph.getModuleChunksIterable(config.rootModule)).filter(function (chunk) {\n        return !chunkGraph.isModuleInChunk(module, chunk);\n      });\n\n      if (missingChunks.length > 0) {\n        var problem = function problem(requestShortener) {\n          var missingChunksList = Array.from(new Set(missingChunks.map(function (chunk) {\n            return chunk.name || \"unnamed chunk(s)\";\n          }))).sort();\n          var chunks = Array.from(new Set(Array.from(chunkGraph.getModuleChunksIterable(module)).map(function (chunk) {\n            return chunk.name || \"unnamed chunk(s)\";\n          }))).sort();\n          return \"Module \".concat(module.readableIdentifier(requestShortener), \" is not in the same chunk(s) (expected in chunk(s) \").concat(missingChunksList.join(\", \"), \", module is in chunk(s) \").concat(chunks.join(\", \"), \")\");\n        };\n\n        statistics.incorrectChunks++;\n        failureCache.set(module, problem); // cache failures for performance\n\n        return problem;\n      }\n\n      var moduleGraph = compilation.moduleGraph;\n      var incomingConnections = moduleGraph.getIncomingConnectionsByOriginModule(module);\n      var incomingConnectionsFromNonModules = incomingConnections.get(null) || incomingConnections.get(undefined);\n\n      if (incomingConnectionsFromNonModules) {\n        var activeNonModulesConnections = incomingConnectionsFromNonModules.filter(function (connection) {\n          // We are not interested in inactive connections\n          // or connections without dependency\n          return connection.isActive(runtime) || connection.dependency;\n        });\n\n        if (activeNonModulesConnections.length > 0) {\n          var _problem = function _problem(requestShortener) {\n            var importingExplanations = new Set(activeNonModulesConnections.map(function (c) {\n              return c.explanation;\n            }).filter(Boolean));\n            var explanations = Array.from(importingExplanations).sort();\n            return \"Module \".concat(module.readableIdentifier(requestShortener), \" is referenced \").concat(explanations.length > 0 ? \"by: \".concat(explanations.join(\", \")) : \"in an unsupported way\");\n          };\n\n          statistics.incorrectDependency++;\n          failureCache.set(module, _problem); // cache failures for performance\n\n          return _problem;\n        }\n      }\n      /** @type {Map<Module, readonly ModuleGraph.ModuleGraphConnection[]>} */\n\n\n      var incomingConnectionsFromModules = new Map();\n\n      var _iterator13 = _createForOfIteratorHelper(incomingConnections),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var _step13$value = _slicedToArray(_step13.value, 2),\n              _originModule2 = _step13$value[0],\n              _connections = _step13$value[1];\n\n          if (_originModule2) {\n            // Ignore connection from orphan modules\n            if (chunkGraph.getNumberOfModuleChunks(_originModule2) === 0) continue; // We don't care for connections from other runtimes\n\n            var originRuntime = undefined;\n\n            var _iterator19 = _createForOfIteratorHelper(chunkGraph.getModuleRuntimes(_originModule2)),\n                _step19;\n\n            try {\n              for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                var r = _step19.value;\n                originRuntime = mergeRuntimeOwned(originRuntime, r);\n              }\n            } catch (err) {\n              _iterator19.e(err);\n            } finally {\n              _iterator19.f();\n            }\n\n            if (!intersectRuntime(runtime, originRuntime)) continue; // We are not interested in inactive connections\n\n            var activeConnections = _connections.filter(function (connection) {\n              return connection.isActive(runtime);\n            });\n\n            if (activeConnections.length > 0) incomingConnectionsFromModules.set(_originModule2, activeConnections);\n          }\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n\n      var incomingModules = Array.from(incomingConnectionsFromModules.keys()); // Module must be in the same chunks like the referencing module\n\n      var otherChunkModules = incomingModules.filter(function (originModule) {\n        var _iterator14 = _createForOfIteratorHelper(chunkGraph.getModuleChunksIterable(config.rootModule)),\n            _step14;\n\n        try {\n          for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n            var chunk = _step14.value;\n\n            if (!chunkGraph.isModuleInChunk(originModule, chunk)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator14.e(err);\n        } finally {\n          _iterator14.f();\n        }\n\n        return false;\n      });\n\n      if (otherChunkModules.length > 0) {\n        var _problem2 = function _problem2(requestShortener) {\n          var names = otherChunkModules.map(function (m) {\n            return m.readableIdentifier(requestShortener);\n          }).sort();\n          return \"Module \".concat(module.readableIdentifier(requestShortener), \" is referenced from different chunks by these modules: \").concat(names.join(\", \"));\n        };\n\n        statistics.incorrectChunksOfImporter++;\n        failureCache.set(module, _problem2); // cache failures for performance\n\n        return _problem2;\n      }\n      /** @type {Map<Module, readonly ModuleGraph.ModuleGraphConnection[]>} */\n\n\n      var nonHarmonyConnections = new Map();\n\n      var _iterator15 = _createForOfIteratorHelper(incomingConnectionsFromModules),\n          _step15;\n\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var _step15$value = _slicedToArray(_step15.value, 2),\n              _originModule3 = _step15$value[0],\n              _connections2 = _step15$value[1];\n\n          var selected = _connections2.filter(function (connection) {\n            return !connection.dependency || !(connection.dependency instanceof HarmonyImportDependency);\n          });\n\n          if (selected.length > 0) nonHarmonyConnections.set(_originModule3, _connections2);\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n\n      if (nonHarmonyConnections.size > 0) {\n        var _problem3 = function _problem3(requestShortener) {\n          var names = Array.from(nonHarmonyConnections).map(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                originModule = _ref2[0],\n                connections = _ref2[1];\n\n            return \"\".concat(originModule.readableIdentifier(requestShortener), \" (referenced with \").concat(Array.from(new Set(connections.map(function (c) {\n              return c.dependency && c.dependency.type;\n            }).filter(Boolean))).sort().join(\", \"), \")\");\n          }).sort();\n          return \"Module \".concat(module.readableIdentifier(requestShortener), \" is referenced from these modules with unsupported syntax: \").concat(names.join(\", \"));\n        };\n\n        statistics.incorrectModuleDependency++;\n        failureCache.set(module, _problem3); // cache failures for performance\n\n        return _problem3;\n      }\n\n      if (runtime !== undefined && typeof runtime !== \"string\") {\n        // Module must be consistently referenced in the same runtimes\n\n        /** @type {{ originModule: Module, runtimeCondition: RuntimeSpec }[]} */\n        var otherRuntimeConnections = [];\n\n        var _iterator16 = _createForOfIteratorHelper(incomingConnectionsFromModules),\n            _step16;\n\n        try {\n          outer: for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n            var _step16$value = _slicedToArray(_step16.value, 2),\n                originModule = _step16$value[0],\n                connections = _step16$value[1];\n\n            /** @type {false | RuntimeSpec} */\n            var currentRuntimeCondition = false;\n\n            var _iterator17 = _createForOfIteratorHelper(connections),\n                _step17;\n\n            try {\n              var _loop3 = function _loop3() {\n                var connection = _step17.value;\n                var runtimeCondition = filterRuntime(runtime, function (runtime) {\n                  return connection.isTargetActive(runtime);\n                });\n                if (runtimeCondition === false) return \"continue\";\n                if (runtimeCondition === true) return \"continue|outer\";\n\n                if (currentRuntimeCondition !== false) {\n                  currentRuntimeCondition = mergeRuntime(currentRuntimeCondition, runtimeCondition);\n                } else {\n                  currentRuntimeCondition = runtimeCondition;\n                }\n              };\n\n              for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n                var _ret2 = _loop3();\n\n                if (_ret2 === \"continue\") continue;\n                if (_ret2 === \"continue|outer\") continue outer;\n              }\n            } catch (err) {\n              _iterator17.e(err);\n            } finally {\n              _iterator17.f();\n            }\n\n            if (currentRuntimeCondition !== false) {\n              otherRuntimeConnections.push({\n                originModule: originModule,\n                runtimeCondition: currentRuntimeCondition\n              });\n            }\n          }\n        } catch (err) {\n          _iterator16.e(err);\n        } finally {\n          _iterator16.f();\n        }\n\n        if (otherRuntimeConnections.length > 0) {\n          var _problem4 = function _problem4(requestShortener) {\n            return \"Module \".concat(module.readableIdentifier(requestShortener), \" is runtime-dependent referenced by these modules: \").concat(Array.from(otherRuntimeConnections, function (_ref3) {\n              var originModule = _ref3.originModule,\n                  runtimeCondition = _ref3.runtimeCondition;\n              return \"\".concat(originModule.readableIdentifier(requestShortener), \" (expected runtime \").concat(runtimeToString(runtime), \", module is only referenced in \").concat(runtimeToString(\n              /** @type {RuntimeSpec} */\n              runtimeCondition), \")\");\n            }).join(\", \"));\n          };\n\n          statistics.incorrectRuntimeCondition++;\n          failureCache.set(module, _problem4); // cache failures for performance\n\n          return _problem4;\n        }\n      }\n\n      var backup;\n\n      if (avoidMutateOnFailure) {\n        backup = config.snapshot();\n      } // Add the module\n\n\n      config.add(module);\n      incomingModules.sort(compareModulesByIdentifier); // Every module which depends on the added module must be in the configuration too.\n\n      for (var _i2 = 0, _incomingModules = incomingModules; _i2 < _incomingModules.length; _i2++) {\n        var _originModule = _incomingModules[_i2];\n\n        var _problem5 = this._tryToAdd(compilation, config, _originModule, runtime, activeRuntime, possibleModules, candidates, failureCache, chunkGraph, false, statistics);\n\n        if (_problem5) {\n          if (backup !== undefined) config.rollback(backup);\n          statistics.importerFailed++;\n          failureCache.set(module, _problem5); // cache failures for performance\n\n          return _problem5;\n        }\n      } // Add imports to possible candidates list\n\n\n      var _iterator18 = _createForOfIteratorHelper(this._getImports(compilation, module, runtime)),\n          _step18;\n\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var imp = _step18.value;\n          candidates.add(imp);\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n\n      statistics.added++;\n      return null;\n    }\n  }]);\n\n  return ModuleConcatenationPlugin;\n}();\n\nvar ConcatConfiguration = /*#__PURE__*/function () {\n  /**\n   * @param {Module} rootModule the root module\n   * @param {RuntimeSpec} runtime the runtime\n   */\n  function ConcatConfiguration(rootModule, runtime) {\n    _classCallCheck(this, ConcatConfiguration);\n\n    this.rootModule = rootModule;\n    this.runtime = runtime;\n    /** @type {Set<Module>} */\n\n    this.modules = new Set();\n    this.modules.add(rootModule);\n    /** @type {Map<Module, Module | function(RequestShortener): string>} */\n\n    this.warnings = new Map();\n  }\n\n  _createClass(ConcatConfiguration, [{\n    key: \"add\",\n    value: function add(module) {\n      this.modules.add(module);\n    }\n  }, {\n    key: \"has\",\n    value: function has(module) {\n      return this.modules.has(module);\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.modules.size === 1;\n    }\n  }, {\n    key: \"addWarning\",\n    value: function addWarning(module, problem) {\n      this.warnings.set(module, problem);\n    }\n  }, {\n    key: \"getWarningsSorted\",\n    value: function getWarningsSorted() {\n      return new Map(Array.from(this.warnings).sort(function (a, b) {\n        var ai = a[0].identifier();\n        var bi = b[0].identifier();\n        if (ai < bi) return -1;\n        if (ai > bi) return 1;\n        return 0;\n      }));\n    }\n    /**\n     * @returns {Set<Module>} modules as set\n     */\n\n  }, {\n    key: \"getModules\",\n    value: function getModules() {\n      return this.modules;\n    }\n  }, {\n    key: \"snapshot\",\n    value: function snapshot() {\n      return this.modules.size;\n    }\n  }, {\n    key: \"rollback\",\n    value: function rollback(snapshot) {\n      var modules = this.modules;\n\n      var _iterator20 = _createForOfIteratorHelper(modules),\n          _step20;\n\n      try {\n        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n          var m = _step20.value;\n\n          if (snapshot === 0) {\n            modules.delete(m);\n          } else {\n            snapshot--;\n          }\n        }\n      } catch (err) {\n        _iterator20.e(err);\n      } finally {\n        _iterator20.f();\n      }\n    }\n  }]);\n\n  return ConcatConfiguration;\n}();\n\nmodule.exports = ModuleConcatenationPlugin;","map":{"version":3,"sources":["/home/john/tree-epidemic-sim-front-end/node_modules/webpack/lib/optimize/ModuleConcatenationPlugin.js"],"names":["asyncLib","require","ChunkGraph","ModuleGraph","STAGE_DEFAULT","HarmonyImportDependency","compareModulesByIdentifier","intersectRuntime","mergeRuntimeOwned","filterRuntime","runtimeToString","mergeRuntime","ConcatenatedModule","formatBailoutReason","msg","ModuleConcatenationPlugin","options","compiler","backCompat","_backCompat","hooks","compilation","tap","moduleGraph","bailoutReasonMap","Map","setBailoutReason","module","reason","setInnerBailoutReason","getOptimizationBailout","push","rs","set","getInnerBailoutReason","requestShortener","get","formatBailoutWarning","problem","readableIdentifier","reasonWithPrefix","optimizeChunkModules","tapAsync","name","stage","allChunks","modules","callback","logger","getLogger","chunkGraph","relevantModules","possibleInners","Set","context","time","canBeRoot","canBeInner","bailoutReason","getConcatenationBailoutReason","isAsync","buildInfo","strict","getNumberOfModuleChunks","exportsInfo","getExportsInfo","relevantExports","getRelevantExports","undefined","unknownReexports","filter","exportInfo","isReexport","getTarget","length","Array","from","getUsedInfo","join","unknownProvidedExports","provided","getProvidedInfo","isEntryModule","add","timeEnd","debug","size","sort","a","b","getDepth","stats","cached","alreadyInConfig","invalidModule","incorrectChunks","incorrectDependency","incorrectModuleDependency","incorrectChunksOfImporter","incorrectRuntimeCondition","importerFailed","added","statsCandidates","statsSizeSum","statsEmptyConfigurations","concatConfigurations","usedAsInner","currentRoot","has","chunkRuntime","getModuleRuntimes","r","filteredRuntime","isModuleUsed","activeRuntime","currentConfiguration","ConcatConfiguration","failureCache","candidates","_getImports","imp","impCandidates","_tryToAdd","addWarning","c","isEmpty","getModules","rootModule","optimizationBailouts","getWarningsSorted","warning","usedModules","each","concatConfiguration","m","newModule","create","runtime","root","outputOptions","hashFunction","build","err","integrate","setChunkGraphForModule","setModuleGraphForModule","cloneModuleAttributes","builtModules","copyOutgoingModuleConnections","originModule","dependency","getModuleChunksIterable","chunk","disconnectChunkAndModule","delete","clearChunkGraphForModule","clearModuleGraphForModule","replaceModule","moveModuleConnections","otherModule","innerConnection","process","nextTick","bind","dependencies","dep","connection","getConnection","isTargetActive","importedNames","getDependencyReferencedExports","every","i","isArray","getProvidedExports","config","possibleModules","avoidMutateOnFailure","statistics","cacheEntry","missingChunks","isModuleInChunk","missingChunksList","map","chunks","incomingConnections","getIncomingConnectionsByOriginModule","incomingConnectionsFromNonModules","activeNonModulesConnections","isActive","importingExplanations","explanation","Boolean","explanations","incomingConnectionsFromModules","connections","originRuntime","activeConnections","incomingModules","keys","otherChunkModules","names","nonHarmonyConnections","selected","type","otherRuntimeConnections","outer","currentRuntimeCondition","runtimeCondition","backup","snapshot","rollback","warnings","ai","identifier","bi","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst ChunkGraph = require(\"../ChunkGraph\");\nconst ModuleGraph = require(\"../ModuleGraph\");\nconst { STAGE_DEFAULT } = require(\"../OptimizationStages\");\nconst HarmonyImportDependency = require(\"../dependencies/HarmonyImportDependency\");\nconst { compareModulesByIdentifier } = require(\"../util/comparators\");\nconst {\n\tintersectRuntime,\n\tmergeRuntimeOwned,\n\tfilterRuntime,\n\truntimeToString,\n\tmergeRuntime\n} = require(\"../util/runtime\");\nconst ConcatenatedModule = require(\"./ConcatenatedModule\");\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../RequestShortener\")} RequestShortener */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {Object} Statistics\n * @property {number} cached\n * @property {number} alreadyInConfig\n * @property {number} invalidModule\n * @property {number} incorrectChunks\n * @property {number} incorrectDependency\n * @property {number} incorrectModuleDependency\n * @property {number} incorrectChunksOfImporter\n * @property {number} incorrectRuntimeCondition\n * @property {number} importerFailed\n * @property {number} added\n */\n\nconst formatBailoutReason = msg => {\n\treturn \"ModuleConcatenation bailout: \" + msg;\n};\n\nclass ModuleConcatenationPlugin {\n\tconstructor(options) {\n\t\tif (typeof options !== \"object\") options = {};\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst { _backCompat: backCompat } = compiler;\n\t\tcompiler.hooks.compilation.tap(\"ModuleConcatenationPlugin\", compilation => {\n\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\tconst bailoutReasonMap = new Map();\n\n\t\t\tconst setBailoutReason = (module, reason) => {\n\t\t\t\tsetInnerBailoutReason(module, reason);\n\t\t\t\tmoduleGraph\n\t\t\t\t\t.getOptimizationBailout(module)\n\t\t\t\t\t.push(\n\t\t\t\t\t\ttypeof reason === \"function\"\n\t\t\t\t\t\t\t? rs => formatBailoutReason(reason(rs))\n\t\t\t\t\t\t\t: formatBailoutReason(reason)\n\t\t\t\t\t);\n\t\t\t};\n\n\t\t\tconst setInnerBailoutReason = (module, reason) => {\n\t\t\t\tbailoutReasonMap.set(module, reason);\n\t\t\t};\n\n\t\t\tconst getInnerBailoutReason = (module, requestShortener) => {\n\t\t\t\tconst reason = bailoutReasonMap.get(module);\n\t\t\t\tif (typeof reason === \"function\") return reason(requestShortener);\n\t\t\t\treturn reason;\n\t\t\t};\n\n\t\t\tconst formatBailoutWarning = (module, problem) => requestShortener => {\n\t\t\t\tif (typeof problem === \"function\") {\n\t\t\t\t\treturn formatBailoutReason(\n\t\t\t\t\t\t`Cannot concat with ${module.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)}: ${problem(requestShortener)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst reason = getInnerBailoutReason(module, requestShortener);\n\t\t\t\tconst reasonWithPrefix = reason ? `: ${reason}` : \"\";\n\t\t\t\tif (module === problem) {\n\t\t\t\t\treturn formatBailoutReason(\n\t\t\t\t\t\t`Cannot concat with ${module.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)}${reasonWithPrefix}`\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\treturn formatBailoutReason(\n\t\t\t\t\t\t`Cannot concat with ${module.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)} because of ${problem.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)}${reasonWithPrefix}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tcompilation.hooks.optimizeChunkModules.tapAsync(\n\t\t\t\t{\n\t\t\t\t\tname: \"ModuleConcatenationPlugin\",\n\t\t\t\t\tstage: STAGE_DEFAULT\n\t\t\t\t},\n\t\t\t\t(allChunks, modules, callback) => {\n\t\t\t\t\tconst logger = compilation.getLogger(\n\t\t\t\t\t\t\"webpack.ModuleConcatenationPlugin\"\n\t\t\t\t\t);\n\t\t\t\t\tconst { chunkGraph, moduleGraph } = compilation;\n\t\t\t\t\tconst relevantModules = [];\n\t\t\t\t\tconst possibleInners = new Set();\n\t\t\t\t\tconst context = {\n\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\tmoduleGraph\n\t\t\t\t\t};\n\t\t\t\t\tlogger.time(\"select relevant modules\");\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\tlet canBeRoot = true;\n\t\t\t\t\t\tlet canBeInner = true;\n\n\t\t\t\t\t\tconst bailoutReason = module.getConcatenationBailoutReason(context);\n\t\t\t\t\t\tif (bailoutReason) {\n\t\t\t\t\t\t\tsetBailoutReason(module, bailoutReason);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Must not be an async module\n\t\t\t\t\t\tif (moduleGraph.isAsync(module)) {\n\t\t\t\t\t\t\tsetBailoutReason(module, `Module is async`);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Must be in strict mode\n\t\t\t\t\t\tif (!module.buildInfo.strict) {\n\t\t\t\t\t\t\tsetBailoutReason(module, `Module is not in strict mode`);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Module must be in any chunk (we don't want to do useless work)\n\t\t\t\t\t\tif (chunkGraph.getNumberOfModuleChunks(module) === 0) {\n\t\t\t\t\t\t\tsetBailoutReason(module, \"Module is not in any chunk\");\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Exports must be known (and not dynamic)\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\tconst relevantExports = exportsInfo.getRelevantExports(undefined);\n\t\t\t\t\t\tconst unknownReexports = relevantExports.filter(exportInfo => {\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\texportInfo.isReexport() && !exportInfo.getTarget(moduleGraph)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (unknownReexports.length > 0) {\n\t\t\t\t\t\t\tsetBailoutReason(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t`Reexports in this module do not have a static target (${Array.from(\n\t\t\t\t\t\t\t\t\tunknownReexports,\n\t\t\t\t\t\t\t\t\texportInfo =>\n\t\t\t\t\t\t\t\t\t\t`${\n\t\t\t\t\t\t\t\t\t\t\texportInfo.name || \"other exports\"\n\t\t\t\t\t\t\t\t\t\t}: ${exportInfo.getUsedInfo()}`\n\t\t\t\t\t\t\t\t).join(\", \")})`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Root modules must have a static list of exports\n\t\t\t\t\t\tconst unknownProvidedExports = relevantExports.filter(\n\t\t\t\t\t\t\texportInfo => {\n\t\t\t\t\t\t\t\treturn exportInfo.provided !== true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (unknownProvidedExports.length > 0) {\n\t\t\t\t\t\t\tsetBailoutReason(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t`List of module exports is dynamic (${Array.from(\n\t\t\t\t\t\t\t\t\tunknownProvidedExports,\n\t\t\t\t\t\t\t\t\texportInfo =>\n\t\t\t\t\t\t\t\t\t\t`${\n\t\t\t\t\t\t\t\t\t\t\texportInfo.name || \"other exports\"\n\t\t\t\t\t\t\t\t\t\t}: ${exportInfo.getProvidedInfo()} and ${exportInfo.getUsedInfo()}`\n\t\t\t\t\t\t\t\t).join(\", \")})`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcanBeRoot = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Module must not be an entry point\n\t\t\t\t\t\tif (chunkGraph.isEntryModule(module)) {\n\t\t\t\t\t\t\tsetInnerBailoutReason(module, \"Module is an entry point\");\n\t\t\t\t\t\t\tcanBeInner = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (canBeRoot) relevantModules.push(module);\n\t\t\t\t\t\tif (canBeInner) possibleInners.add(module);\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"select relevant modules\");\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t`${relevantModules.length} potential root modules, ${possibleInners.size} potential inner modules`\n\t\t\t\t\t);\n\t\t\t\t\t// sort by depth\n\t\t\t\t\t// modules with lower depth are more likely suited as roots\n\t\t\t\t\t// this improves performance, because modules already selected as inner are skipped\n\t\t\t\t\tlogger.time(\"sort relevant modules\");\n\t\t\t\t\trelevantModules.sort((a, b) => {\n\t\t\t\t\t\treturn moduleGraph.getDepth(a) - moduleGraph.getDepth(b);\n\t\t\t\t\t});\n\t\t\t\t\tlogger.timeEnd(\"sort relevant modules\");\n\n\t\t\t\t\t/** @type {Statistics} */\n\t\t\t\t\tconst stats = {\n\t\t\t\t\t\tcached: 0,\n\t\t\t\t\t\talreadyInConfig: 0,\n\t\t\t\t\t\tinvalidModule: 0,\n\t\t\t\t\t\tincorrectChunks: 0,\n\t\t\t\t\t\tincorrectDependency: 0,\n\t\t\t\t\t\tincorrectModuleDependency: 0,\n\t\t\t\t\t\tincorrectChunksOfImporter: 0,\n\t\t\t\t\t\tincorrectRuntimeCondition: 0,\n\t\t\t\t\t\timporterFailed: 0,\n\t\t\t\t\t\tadded: 0\n\t\t\t\t\t};\n\t\t\t\t\tlet statsCandidates = 0;\n\t\t\t\t\tlet statsSizeSum = 0;\n\t\t\t\t\tlet statsEmptyConfigurations = 0;\n\n\t\t\t\t\tlogger.time(\"find modules to concatenate\");\n\t\t\t\t\tconst concatConfigurations = [];\n\t\t\t\t\tconst usedAsInner = new Set();\n\t\t\t\t\tfor (const currentRoot of relevantModules) {\n\t\t\t\t\t\t// when used by another configuration as inner:\n\t\t\t\t\t\t// the other configuration is better and we can skip this one\n\t\t\t\t\t\t// TODO reconsider that when it's only used in a different runtime\n\t\t\t\t\t\tif (usedAsInner.has(currentRoot)) continue;\n\n\t\t\t\t\t\tlet chunkRuntime = undefined;\n\t\t\t\t\t\tfor (const r of chunkGraph.getModuleRuntimes(currentRoot)) {\n\t\t\t\t\t\t\tchunkRuntime = mergeRuntimeOwned(chunkRuntime, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(currentRoot);\n\t\t\t\t\t\tconst filteredRuntime = filterRuntime(chunkRuntime, r =>\n\t\t\t\t\t\t\texportsInfo.isModuleUsed(r)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst activeRuntime =\n\t\t\t\t\t\t\tfilteredRuntime === true\n\t\t\t\t\t\t\t\t? chunkRuntime\n\t\t\t\t\t\t\t\t: filteredRuntime === false\n\t\t\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t\t\t: filteredRuntime;\n\n\t\t\t\t\t\t// create a configuration with the root\n\t\t\t\t\t\tconst currentConfiguration = new ConcatConfiguration(\n\t\t\t\t\t\t\tcurrentRoot,\n\t\t\t\t\t\t\tactiveRuntime\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// cache failures to add modules\n\t\t\t\t\t\tconst failureCache = new Map();\n\n\t\t\t\t\t\t// potential optional import candidates\n\t\t\t\t\t\t/** @type {Set<Module>} */\n\t\t\t\t\t\tconst candidates = new Set();\n\n\t\t\t\t\t\t// try to add all imports\n\t\t\t\t\t\tfor (const imp of this._getImports(\n\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\tcurrentRoot,\n\t\t\t\t\t\t\tactiveRuntime\n\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\tcandidates.add(imp);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (const imp of candidates) {\n\t\t\t\t\t\t\tconst impCandidates = new Set();\n\t\t\t\t\t\t\tconst problem = this._tryToAdd(\n\t\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\t\tcurrentConfiguration,\n\t\t\t\t\t\t\t\timp,\n\t\t\t\t\t\t\t\tchunkRuntime,\n\t\t\t\t\t\t\t\tactiveRuntime,\n\t\t\t\t\t\t\t\tpossibleInners,\n\t\t\t\t\t\t\t\timpCandidates,\n\t\t\t\t\t\t\t\tfailureCache,\n\t\t\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tstats\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (problem) {\n\t\t\t\t\t\t\t\tfailureCache.set(imp, problem);\n\t\t\t\t\t\t\t\tcurrentConfiguration.addWarning(imp, problem);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const c of impCandidates) {\n\t\t\t\t\t\t\t\t\tcandidates.add(c);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstatsCandidates += candidates.size;\n\t\t\t\t\t\tif (!currentConfiguration.isEmpty()) {\n\t\t\t\t\t\t\tconst modules = currentConfiguration.getModules();\n\t\t\t\t\t\t\tstatsSizeSum += modules.size;\n\t\t\t\t\t\t\tconcatConfigurations.push(currentConfiguration);\n\t\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\t\tif (module !== currentConfiguration.rootModule) {\n\t\t\t\t\t\t\t\t\tusedAsInner.add(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstatsEmptyConfigurations++;\n\t\t\t\t\t\t\tconst optimizationBailouts =\n\t\t\t\t\t\t\t\tmoduleGraph.getOptimizationBailout(currentRoot);\n\t\t\t\t\t\t\tfor (const warning of currentConfiguration.getWarningsSorted()) {\n\t\t\t\t\t\t\t\toptimizationBailouts.push(\n\t\t\t\t\t\t\t\t\tformatBailoutWarning(warning[0], warning[1])\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"find modules to concatenate\");\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t`${\n\t\t\t\t\t\t\tconcatConfigurations.length\n\t\t\t\t\t\t} successful concat configurations (avg size: ${\n\t\t\t\t\t\t\tstatsSizeSum / concatConfigurations.length\n\t\t\t\t\t\t}), ${statsEmptyConfigurations} bailed out completely`\n\t\t\t\t\t);\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t`${statsCandidates} candidates were considered for adding (${stats.cached} cached failure, ${stats.alreadyInConfig} already in config, ${stats.invalidModule} invalid module, ${stats.incorrectChunks} incorrect chunks, ${stats.incorrectDependency} incorrect dependency, ${stats.incorrectChunksOfImporter} incorrect chunks of importer, ${stats.incorrectModuleDependency} incorrect module dependency, ${stats.incorrectRuntimeCondition} incorrect runtime condition, ${stats.importerFailed} importer failed, ${stats.added} added)`\n\t\t\t\t\t);\n\t\t\t\t\t// HACK: Sort configurations by length and start with the longest one\n\t\t\t\t\t// to get the biggest groups possible. Used modules are marked with usedModules\n\t\t\t\t\t// TODO: Allow to reuse existing configuration while trying to add dependencies.\n\t\t\t\t\t// This would improve performance. O(n^2) -> O(n)\n\t\t\t\t\tlogger.time(`sort concat configurations`);\n\t\t\t\t\tconcatConfigurations.sort((a, b) => {\n\t\t\t\t\t\treturn b.modules.size - a.modules.size;\n\t\t\t\t\t});\n\t\t\t\t\tlogger.timeEnd(`sort concat configurations`);\n\t\t\t\t\tconst usedModules = new Set();\n\n\t\t\t\t\tlogger.time(\"create concatenated modules\");\n\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\tconcatConfigurations,\n\t\t\t\t\t\t(concatConfiguration, callback) => {\n\t\t\t\t\t\t\tconst rootModule = concatConfiguration.rootModule;\n\n\t\t\t\t\t\t\t// Avoid overlapping configurations\n\t\t\t\t\t\t\t// TODO: remove this when todo above is fixed\n\t\t\t\t\t\t\tif (usedModules.has(rootModule)) return callback();\n\t\t\t\t\t\t\tconst modules = concatConfiguration.getModules();\n\t\t\t\t\t\t\tfor (const m of modules) {\n\t\t\t\t\t\t\t\tusedModules.add(m);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Create a new ConcatenatedModule\n\t\t\t\t\t\t\tlet newModule = ConcatenatedModule.create(\n\t\t\t\t\t\t\t\trootModule,\n\t\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t\tconcatConfiguration.runtime,\n\t\t\t\t\t\t\t\tcompiler.root,\n\t\t\t\t\t\t\t\tcompilation.outputOptions.hashFunction\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tconst build = () => {\n\t\t\t\t\t\t\t\tnewModule.build(\n\t\t\t\t\t\t\t\t\tcompiler.options,\n\t\t\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tif (!err.module) {\n\t\t\t\t\t\t\t\t\t\t\t\terr.module = newModule;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tintegrate();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tconst integrate = () => {\n\t\t\t\t\t\t\t\tif (backCompat) {\n\t\t\t\t\t\t\t\t\tChunkGraph.setChunkGraphForModule(newModule, chunkGraph);\n\t\t\t\t\t\t\t\t\tModuleGraph.setModuleGraphForModule(newModule, moduleGraph);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tfor (const warning of concatConfiguration.getWarningsSorted()) {\n\t\t\t\t\t\t\t\t\tmoduleGraph\n\t\t\t\t\t\t\t\t\t\t.getOptimizationBailout(newModule)\n\t\t\t\t\t\t\t\t\t\t.push(formatBailoutWarning(warning[0], warning[1]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmoduleGraph.cloneModuleAttributes(rootModule, newModule);\n\t\t\t\t\t\t\t\tfor (const m of modules) {\n\t\t\t\t\t\t\t\t\t// add to builtModules when one of the included modules was built\n\t\t\t\t\t\t\t\t\tif (compilation.builtModules.has(m)) {\n\t\t\t\t\t\t\t\t\t\tcompilation.builtModules.add(newModule);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (m !== rootModule) {\n\t\t\t\t\t\t\t\t\t\t// attach external references to the concatenated module too\n\t\t\t\t\t\t\t\t\t\tmoduleGraph.copyOutgoingModuleConnections(\n\t\t\t\t\t\t\t\t\t\t\tm,\n\t\t\t\t\t\t\t\t\t\t\tnewModule,\n\t\t\t\t\t\t\t\t\t\t\tc => {\n\t\t\t\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t\t\t\tc.originModule === m &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t!(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tc.dependency instanceof HarmonyImportDependency &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodules.has(c.module)\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t// remove module from chunk\n\t\t\t\t\t\t\t\t\t\tfor (const chunk of chunkGraph.getModuleChunksIterable(\n\t\t\t\t\t\t\t\t\t\t\trootModule\n\t\t\t\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, m);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcompilation.modules.delete(rootModule);\n\t\t\t\t\t\t\t\tChunkGraph.clearChunkGraphForModule(rootModule);\n\t\t\t\t\t\t\t\tModuleGraph.clearModuleGraphForModule(rootModule);\n\n\t\t\t\t\t\t\t\t// remove module from chunk\n\t\t\t\t\t\t\t\tchunkGraph.replaceModule(rootModule, newModule);\n\t\t\t\t\t\t\t\t// replace module references with the concatenated module\n\t\t\t\t\t\t\t\tmoduleGraph.moveModuleConnections(rootModule, newModule, c => {\n\t\t\t\t\t\t\t\t\tconst otherModule =\n\t\t\t\t\t\t\t\t\t\tc.module === rootModule ? c.originModule : c.module;\n\t\t\t\t\t\t\t\t\tconst innerConnection =\n\t\t\t\t\t\t\t\t\t\tc.dependency instanceof HarmonyImportDependency &&\n\t\t\t\t\t\t\t\t\t\tmodules.has(otherModule);\n\t\t\t\t\t\t\t\t\treturn !innerConnection;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t// add concatenated module to the compilation\n\t\t\t\t\t\t\t\tcompilation.modules.add(newModule);\n\n\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tbuild();\n\t\t\t\t\t\t},\n\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\tlogger.timeEnd(\"create concatenated modules\");\n\t\t\t\t\t\t\tprocess.nextTick(callback.bind(null, err));\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @param {Module} module the module to be added\n\t * @param {RuntimeSpec} runtime the runtime scope\n\t * @returns {Set<Module>} the imported modules\n\t */\n\t_getImports(compilation, module, runtime) {\n\t\tconst moduleGraph = compilation.moduleGraph;\n\t\tconst set = new Set();\n\t\tfor (const dep of module.dependencies) {\n\t\t\t// Get reference info only for harmony Dependencies\n\t\t\tif (!(dep instanceof HarmonyImportDependency)) continue;\n\n\t\t\tconst connection = moduleGraph.getConnection(dep);\n\t\t\t// Reference is valid and has a module\n\t\t\tif (\n\t\t\t\t!connection ||\n\t\t\t\t!connection.module ||\n\t\t\t\t!connection.isTargetActive(runtime)\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst importedNames = compilation.getDependencyReferencedExports(\n\t\t\t\tdep,\n\t\t\t\tundefined\n\t\t\t);\n\n\t\t\tif (\n\t\t\t\timportedNames.every(i =>\n\t\t\t\t\tArray.isArray(i) ? i.length > 0 : i.name.length > 0\n\t\t\t\t) ||\n\t\t\t\tArray.isArray(moduleGraph.getProvidedExports(module))\n\t\t\t) {\n\t\t\t\tset.add(connection.module);\n\t\t\t}\n\t\t}\n\t\treturn set;\n\t}\n\n\t/**\n\t * @param {Compilation} compilation webpack compilation\n\t * @param {ConcatConfiguration} config concat configuration (will be modified when added)\n\t * @param {Module} module the module to be added\n\t * @param {RuntimeSpec} runtime the runtime scope of the generated code\n\t * @param {RuntimeSpec} activeRuntime the runtime scope of the root module\n\t * @param {Set<Module>} possibleModules modules that are candidates\n\t * @param {Set<Module>} candidates list of potential candidates (will be added to)\n\t * @param {Map<Module, Module | function(RequestShortener): string>} failureCache cache for problematic modules to be more performant\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {boolean} avoidMutateOnFailure avoid mutating the config when adding fails\n\t * @param {Statistics} statistics gathering metrics\n\t * @returns {Module | function(RequestShortener): string} the problematic module\n\t */\n\t_tryToAdd(\n\t\tcompilation,\n\t\tconfig,\n\t\tmodule,\n\t\truntime,\n\t\tactiveRuntime,\n\t\tpossibleModules,\n\t\tcandidates,\n\t\tfailureCache,\n\t\tchunkGraph,\n\t\tavoidMutateOnFailure,\n\t\tstatistics\n\t) {\n\t\tconst cacheEntry = failureCache.get(module);\n\t\tif (cacheEntry) {\n\t\t\tstatistics.cached++;\n\t\t\treturn cacheEntry;\n\t\t}\n\n\t\t// Already added?\n\t\tif (config.has(module)) {\n\t\t\tstatistics.alreadyInConfig++;\n\t\t\treturn null;\n\t\t}\n\n\t\t// Not possible to add?\n\t\tif (!possibleModules.has(module)) {\n\t\t\tstatistics.invalidModule++;\n\t\t\tfailureCache.set(module, module); // cache failures for performance\n\t\t\treturn module;\n\t\t}\n\n\t\t// Module must be in the correct chunks\n\t\tconst missingChunks = Array.from(\n\t\t\tchunkGraph.getModuleChunksIterable(config.rootModule)\n\t\t).filter(chunk => !chunkGraph.isModuleInChunk(module, chunk));\n\t\tif (missingChunks.length > 0) {\n\t\t\tconst problem = requestShortener => {\n\t\t\t\tconst missingChunksList = Array.from(\n\t\t\t\t\tnew Set(missingChunks.map(chunk => chunk.name || \"unnamed chunk(s)\"))\n\t\t\t\t).sort();\n\t\t\t\tconst chunks = Array.from(\n\t\t\t\t\tnew Set(\n\t\t\t\t\t\tArray.from(chunkGraph.getModuleChunksIterable(module)).map(\n\t\t\t\t\t\t\tchunk => chunk.name || \"unnamed chunk(s)\"\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t).sort();\n\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\trequestShortener\n\t\t\t\t)} is not in the same chunk(s) (expected in chunk(s) ${missingChunksList.join(\n\t\t\t\t\t\", \"\n\t\t\t\t)}, module is in chunk(s) ${chunks.join(\", \")})`;\n\t\t\t};\n\t\t\tstatistics.incorrectChunks++;\n\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\treturn problem;\n\t\t}\n\n\t\tconst moduleGraph = compilation.moduleGraph;\n\n\t\tconst incomingConnections =\n\t\t\tmoduleGraph.getIncomingConnectionsByOriginModule(module);\n\n\t\tconst incomingConnectionsFromNonModules =\n\t\t\tincomingConnections.get(null) || incomingConnections.get(undefined);\n\t\tif (incomingConnectionsFromNonModules) {\n\t\t\tconst activeNonModulesConnections =\n\t\t\t\tincomingConnectionsFromNonModules.filter(connection => {\n\t\t\t\t\t// We are not interested in inactive connections\n\t\t\t\t\t// or connections without dependency\n\t\t\t\t\treturn connection.isActive(runtime) || connection.dependency;\n\t\t\t\t});\n\t\t\tif (activeNonModulesConnections.length > 0) {\n\t\t\t\tconst problem = requestShortener => {\n\t\t\t\t\tconst importingExplanations = new Set(\n\t\t\t\t\t\tactiveNonModulesConnections.map(c => c.explanation).filter(Boolean)\n\t\t\t\t\t);\n\t\t\t\t\tconst explanations = Array.from(importingExplanations).sort();\n\t\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\t\trequestShortener\n\t\t\t\t\t)} is referenced ${\n\t\t\t\t\t\texplanations.length > 0\n\t\t\t\t\t\t\t? `by: ${explanations.join(\", \")}`\n\t\t\t\t\t\t\t: \"in an unsupported way\"\n\t\t\t\t\t}`;\n\t\t\t\t};\n\t\t\t\tstatistics.incorrectDependency++;\n\t\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\t\treturn problem;\n\t\t\t}\n\t\t}\n\n\t\t/** @type {Map<Module, readonly ModuleGraph.ModuleGraphConnection[]>} */\n\t\tconst incomingConnectionsFromModules = new Map();\n\t\tfor (const [originModule, connections] of incomingConnections) {\n\t\t\tif (originModule) {\n\t\t\t\t// Ignore connection from orphan modules\n\t\t\t\tif (chunkGraph.getNumberOfModuleChunks(originModule) === 0) continue;\n\n\t\t\t\t// We don't care for connections from other runtimes\n\t\t\t\tlet originRuntime = undefined;\n\t\t\t\tfor (const r of chunkGraph.getModuleRuntimes(originModule)) {\n\t\t\t\t\toriginRuntime = mergeRuntimeOwned(originRuntime, r);\n\t\t\t\t}\n\n\t\t\t\tif (!intersectRuntime(runtime, originRuntime)) continue;\n\n\t\t\t\t// We are not interested in inactive connections\n\t\t\t\tconst activeConnections = connections.filter(connection =>\n\t\t\t\t\tconnection.isActive(runtime)\n\t\t\t\t);\n\t\t\t\tif (activeConnections.length > 0)\n\t\t\t\t\tincomingConnectionsFromModules.set(originModule, activeConnections);\n\t\t\t}\n\t\t}\n\n\t\tconst incomingModules = Array.from(incomingConnectionsFromModules.keys());\n\n\t\t// Module must be in the same chunks like the referencing module\n\t\tconst otherChunkModules = incomingModules.filter(originModule => {\n\t\t\tfor (const chunk of chunkGraph.getModuleChunksIterable(\n\t\t\t\tconfig.rootModule\n\t\t\t)) {\n\t\t\t\tif (!chunkGraph.isModuleInChunk(originModule, chunk)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t\tif (otherChunkModules.length > 0) {\n\t\t\tconst problem = requestShortener => {\n\t\t\t\tconst names = otherChunkModules\n\t\t\t\t\t.map(m => m.readableIdentifier(requestShortener))\n\t\t\t\t\t.sort();\n\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\trequestShortener\n\t\t\t\t)} is referenced from different chunks by these modules: ${names.join(\n\t\t\t\t\t\", \"\n\t\t\t\t)}`;\n\t\t\t};\n\t\t\tstatistics.incorrectChunksOfImporter++;\n\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\treturn problem;\n\t\t}\n\n\t\t/** @type {Map<Module, readonly ModuleGraph.ModuleGraphConnection[]>} */\n\t\tconst nonHarmonyConnections = new Map();\n\t\tfor (const [originModule, connections] of incomingConnectionsFromModules) {\n\t\t\tconst selected = connections.filter(\n\t\t\t\tconnection =>\n\t\t\t\t\t!connection.dependency ||\n\t\t\t\t\t!(connection.dependency instanceof HarmonyImportDependency)\n\t\t\t);\n\t\t\tif (selected.length > 0)\n\t\t\t\tnonHarmonyConnections.set(originModule, connections);\n\t\t}\n\t\tif (nonHarmonyConnections.size > 0) {\n\t\t\tconst problem = requestShortener => {\n\t\t\t\tconst names = Array.from(nonHarmonyConnections)\n\t\t\t\t\t.map(([originModule, connections]) => {\n\t\t\t\t\t\treturn `${originModule.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)} (referenced with ${Array.from(\n\t\t\t\t\t\t\tnew Set(\n\t\t\t\t\t\t\t\tconnections\n\t\t\t\t\t\t\t\t\t.map(c => c.dependency && c.dependency.type)\n\t\t\t\t\t\t\t\t\t.filter(Boolean)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.sort()\n\t\t\t\t\t\t\t.join(\", \")})`;\n\t\t\t\t\t})\n\t\t\t\t\t.sort();\n\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\trequestShortener\n\t\t\t\t)} is referenced from these modules with unsupported syntax: ${names.join(\n\t\t\t\t\t\", \"\n\t\t\t\t)}`;\n\t\t\t};\n\t\t\tstatistics.incorrectModuleDependency++;\n\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\treturn problem;\n\t\t}\n\n\t\tif (runtime !== undefined && typeof runtime !== \"string\") {\n\t\t\t// Module must be consistently referenced in the same runtimes\n\t\t\t/** @type {{ originModule: Module, runtimeCondition: RuntimeSpec }[]} */\n\t\t\tconst otherRuntimeConnections = [];\n\t\t\touter: for (const [\n\t\t\t\toriginModule,\n\t\t\t\tconnections\n\t\t\t] of incomingConnectionsFromModules) {\n\t\t\t\t/** @type {false | RuntimeSpec} */\n\t\t\t\tlet currentRuntimeCondition = false;\n\t\t\t\tfor (const connection of connections) {\n\t\t\t\t\tconst runtimeCondition = filterRuntime(runtime, runtime => {\n\t\t\t\t\t\treturn connection.isTargetActive(runtime);\n\t\t\t\t\t});\n\t\t\t\t\tif (runtimeCondition === false) continue;\n\t\t\t\t\tif (runtimeCondition === true) continue outer;\n\t\t\t\t\tif (currentRuntimeCondition !== false) {\n\t\t\t\t\t\tcurrentRuntimeCondition = mergeRuntime(\n\t\t\t\t\t\t\tcurrentRuntimeCondition,\n\t\t\t\t\t\t\truntimeCondition\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentRuntimeCondition = runtimeCondition;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentRuntimeCondition !== false) {\n\t\t\t\t\totherRuntimeConnections.push({\n\t\t\t\t\t\toriginModule,\n\t\t\t\t\t\truntimeCondition: currentRuntimeCondition\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (otherRuntimeConnections.length > 0) {\n\t\t\t\tconst problem = requestShortener => {\n\t\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\t\trequestShortener\n\t\t\t\t\t)} is runtime-dependent referenced by these modules: ${Array.from(\n\t\t\t\t\t\totherRuntimeConnections,\n\t\t\t\t\t\t({ originModule, runtimeCondition }) =>\n\t\t\t\t\t\t\t`${originModule.readableIdentifier(\n\t\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t\t)} (expected runtime ${runtimeToString(\n\t\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t\t)}, module is only referenced in ${runtimeToString(\n\t\t\t\t\t\t\t\t/** @type {RuntimeSpec} */ (runtimeCondition)\n\t\t\t\t\t\t\t)})`\n\t\t\t\t\t).join(\", \")}`;\n\t\t\t\t};\n\t\t\t\tstatistics.incorrectRuntimeCondition++;\n\t\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\t\treturn problem;\n\t\t\t}\n\t\t}\n\n\t\tlet backup;\n\t\tif (avoidMutateOnFailure) {\n\t\t\tbackup = config.snapshot();\n\t\t}\n\n\t\t// Add the module\n\t\tconfig.add(module);\n\n\t\tincomingModules.sort(compareModulesByIdentifier);\n\n\t\t// Every module which depends on the added module must be in the configuration too.\n\t\tfor (const originModule of incomingModules) {\n\t\t\tconst problem = this._tryToAdd(\n\t\t\t\tcompilation,\n\t\t\t\tconfig,\n\t\t\t\toriginModule,\n\t\t\t\truntime,\n\t\t\t\tactiveRuntime,\n\t\t\t\tpossibleModules,\n\t\t\t\tcandidates,\n\t\t\t\tfailureCache,\n\t\t\t\tchunkGraph,\n\t\t\t\tfalse,\n\t\t\t\tstatistics\n\t\t\t);\n\t\t\tif (problem) {\n\t\t\t\tif (backup !== undefined) config.rollback(backup);\n\t\t\t\tstatistics.importerFailed++;\n\t\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\t\treturn problem;\n\t\t\t}\n\t\t}\n\n\t\t// Add imports to possible candidates list\n\t\tfor (const imp of this._getImports(compilation, module, runtime)) {\n\t\t\tcandidates.add(imp);\n\t\t}\n\t\tstatistics.added++;\n\t\treturn null;\n\t}\n}\n\nclass ConcatConfiguration {\n\t/**\n\t * @param {Module} rootModule the root module\n\t * @param {RuntimeSpec} runtime the runtime\n\t */\n\tconstructor(rootModule, runtime) {\n\t\tthis.rootModule = rootModule;\n\t\tthis.runtime = runtime;\n\t\t/** @type {Set<Module>} */\n\t\tthis.modules = new Set();\n\t\tthis.modules.add(rootModule);\n\t\t/** @type {Map<Module, Module | function(RequestShortener): string>} */\n\t\tthis.warnings = new Map();\n\t}\n\n\tadd(module) {\n\t\tthis.modules.add(module);\n\t}\n\n\thas(module) {\n\t\treturn this.modules.has(module);\n\t}\n\n\tisEmpty() {\n\t\treturn this.modules.size === 1;\n\t}\n\n\taddWarning(module, problem) {\n\t\tthis.warnings.set(module, problem);\n\t}\n\n\tgetWarningsSorted() {\n\t\treturn new Map(\n\t\t\tArray.from(this.warnings).sort((a, b) => {\n\t\t\t\tconst ai = a[0].identifier();\n\t\t\t\tconst bi = b[0].identifier();\n\t\t\t\tif (ai < bi) return -1;\n\t\t\t\tif (ai > bi) return 1;\n\t\t\t\treturn 0;\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * @returns {Set<Module>} modules as set\n\t */\n\tgetModules() {\n\t\treturn this.modules;\n\t}\n\n\tsnapshot() {\n\t\treturn this.modules.size;\n\t}\n\n\trollback(snapshot) {\n\t\tconst modules = this.modules;\n\t\tfor (const m of modules) {\n\t\t\tif (snapshot === 0) {\n\t\t\t\tmodules.delete(m);\n\t\t\t} else {\n\t\t\t\tsnapshot--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nmodule.exports = ModuleConcatenationPlugin;\n"]},"metadata":{},"sourceType":"script"}